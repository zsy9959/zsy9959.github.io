<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/2/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/" itemprop="url">BGP-EVPN基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-10T21:21:55+08:00">
                2021-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•标准BGP-4仅支持IPv4单播地址，为了支持更多的网络层协议，MP-BGP（Multiprotocol Extensions for BGP-4）（RFC4760）被提出作为BGP-4的扩展允许不同类型的地址族在BGP中同时分发，例如IPv4组播、IPv6、L3VPN、EVPN等。</p>
<p>•随着SDN的发展和商用，EVPN（Ethernet VPN）在各解决方案中占据重要角色，应用覆盖全场景包括园区网络、数据中心网络、广域IP承载网络和SD-WAN。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述MP-BGP的基本概念</p>
<p>▫描述EVPN的起源</p>
<p>▫描述EVPN的常见路由类型</p>
<p>▫描述EVPN的典型应用场景</p>
<h1 id="MP-BGP"><a href="#MP-BGP" class="headerlink" title="MP-BGP"></a>MP-BGP</h1><h2 id="MP-BGP-1"><a href="#MP-BGP-1" class="headerlink" title="MP-BGP"></a>MP-BGP</h2><p>MP-BGP（Multiprotocol Extensions for BGP-4）在RFC4760中被定义，用于实现BGP-4的扩展以允许BGP携带多种网络层协议（例如IPv6、L3VPN、EVPN等）。这种扩展有很好的后向兼容性，即一个支持MP-BGP的路由器可以和一个仅支持BGP-4的路由器交互。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/1.png"></p>
<blockquote>
<p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc4760/">https://datatracker.ietf.org/doc/rfc4760/</a></p>
</blockquote>
<h2 id="BGP-4扩展"><a href="#BGP-4扩展" class="headerlink" title="BGP-4扩展"></a>BGP-4扩展</h2><p>•BGP-4中IPv4特有的三个信息是NEXT_HOP属性、AGGREGATOR和IPv4 NLRI。因此为了支持多种网络层协议，BGP-4需要增加两种能力：</p>
<p>​    ▫关联其他网络层协议下一跳信息的能力。</p>
<p>​    ▫关联其他网络层协议NLRI的能力。</p>
<p>•这种两种能力被互联网数字分配机构（IANA）统称为地址族（Address Family，AF）。</p>
<p>•为了实现后向兼容性，协议规定MP-BGP增加两种新的属性，MP_REACH_NLRI和MP_UNREACH_NLRI，分别用于表示可达的目的信息和不可达的目的信息。这两种属性都属于可选非过渡（optional and non-transitive）。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/2.png"></p>
<blockquote>
<p>•BGP-4规定IPv4的NEXT_HOP和AGGREGATOR属于Path attributes字段，IPv4的NLRI中携带IPv4的路由条目。</p>
<p>•MP-BGP新增Path attributes的字段，将对应的网络层协议的NEXT_HOP字段和NLRI归属于MP_REACH_NLRI。MP_REACH_NLRI为Path attributes的新增字段。</p>
</blockquote>
<h2 id="MP-REACH-NLRI"><a href="#MP-REACH-NLRI" class="headerlink" title="MP_REACH_NLRI"></a>MP_REACH_NLRI</h2><p>•MP_REACH_NLRI被携带于BGP Update报文中，有以下作用：</p>
<p>​    ▫通告可达的路由给BGP邻居</p>
<p>​    ▫通告可达路的路由的下一跳给BGP邻居</p>
<p>•其详细字段如下：</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/3.png"></p>
<blockquote>
<p>•SAFI字段中1表示单播，2表示组播。值由IANA分配，其分配原则被定义于RFC2434（Guidelines for Writing an IANA Considerations Section in RFCs）。</p>
<p>•本章节后续学习EVPN的AFI为25 (L2VPN) ，SAFI为70 (EVPN)。</p>
</blockquote>
<h2 id="MP-UNREACH-NLRI"><a href="#MP-UNREACH-NLRI" class="headerlink" title="MP_UNREACH_NLRI"></a>MP_UNREACH_NLRI</h2><p>•MP_UNREACH_NLRI被携带于BGP Update报文中，用于撤销不可达的路由。</p>
<p>•其详细字段如下：</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/4.png"></p>
<blockquote>
<p>•例如EVPN的AFI为25 (L2VPN) ，SAFI为70 (EVPN)。</p>
</blockquote>
<h1 id="EVPN"><a href="#EVPN" class="headerlink" title="EVPN"></a>EVPN</h1><h2 id="EVPN简介"><a href="#EVPN简介" class="headerlink" title="EVPN简介"></a>EVPN简介</h2><h3 id="MPLS简介"><a href="#MPLS简介" class="headerlink" title="MPLS简介"></a>MPLS简介</h3><p>•MPLS （Multiprotocol Label Switching，多协议标记交换）位于TCP/IP协议栈中的数据链路层和网络层之间，在两层之间增加了额外的MPLS头部。报文转发直接基于MPLS头部。MPLS头部又被称为MPLS标签（Label）。</p>
<p>•MPLS以标签交换替代IP转发，实现了基于标签的快速转发。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<p>•MPLS起源于IPv4（Internet Protocol version 4），其核心技术可扩展到多种网络协议，包括IPv6（Internet Protocol version 6）、IPX（Internet Packet Exchange）、Appletalk、DECnet、CLNP（Connectionless Network Protocol）等。MPLS中的“Multiprotocol”指的就是支持多种网络协议。</p>
<p>•MPLS以标签交换替代IP转发。标签是一个短而定长的、只具有本地意义的连接标识符，与ATM的VPI/VCI以及Frame Relay的DLCI类似。</p>
<p>•MPLS域（MPLS Domain）：一系列连续的运行MPLS的网络设备构成了一个MPLS域。</p>
</blockquote>
<h3 id="VPLS简介"><a href="#VPLS简介" class="headerlink" title="VPLS简介"></a>VPLS简介</h3><p>VPLS（Virtual Private LAN Service）是一种基于以太网的二层VPN技术，它在MPLS网络上提供了类似LAN的业务，允许用户可以从多个地址位置接入网络、相互访问。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/6.png"></p>
<h3 id="传统L2VPN"><a href="#传统L2VPN" class="headerlink" title="传统L2VPN"></a>传统L2VPN</h3><p>•传统的L2VPN业务例如VPLS（Virtual Private LAN Service），提供用户远程站点之间二层连接服务。它组建二层交换网，像二层交换机一样透传以太报文。本例中PE1和PE2组建的VPLS网络透传CE1和CE2之间的VLAN流量。</p>
<p>•因此在传统L2VPN中对于远端MAC地址的学习依靠ARP广播泛洪，PE设备将需要承载广播流量。广播占用较多的接口带宽，这是传统L2VPN的一个典型问题。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/7.png"></p>
<blockquote>
<p>•VPLS有更多的问题，例如不支持多活接入、故障收敛慢、不支持负载均衡等不在本课程介绍，请学习HCIE-HCIE-Datacom《Etherent VPN》和RFC 7209 - Requirements for Ethernet VPN (EVPN)。</p>
</blockquote>
<h3 id="EVPN的诞生"><a href="#EVPN的诞生" class="headerlink" title="EVPN的诞生"></a>EVPN的诞生</h3><p>•随着新技术和新场景对网络需求，VPLS被暴露出更多的问题无法满足二层VPN的需求。业界重新审视了对Ethernet VPN的需求（RFC 7209），提出新的解决方案EVPN（Ethernet VPN）。</p>
<p>•EVPN最初在RFC 7432中被定义，EVPN引入控制平面，用于更好的控制MAC地址学习过程。</p>
<p>•EVPN的控制平面采用MP-BGP，数据平面支持MPLS LSPs或者IP/GRE tunneling。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/8.png"></p>
<blockquote>
<p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc7209/">https://datatracker.ietf.org/doc/rfc7209/</a></p>
<p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc7432/">https://datatracker.ietf.org/doc/rfc7432/</a></p>
</blockquote>
<h3 id="EVPN的优势"><a href="#EVPN的优势" class="headerlink" title="EVPN的优势"></a>EVPN的优势</h3><p>•EVPN颠覆了传统L2 VPN数据面学习的方式，引入控制面学习MAC和IP指导数据转发，实现了转控分离。</p>
<p>•EVPN解决传统L2 VPN的典型问题，带来双活，快速收敛，简化运维等更多的价值。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/9.png"></p>
<blockquote>
<p>•更多详细EVPN原理，请参考HCIE-Datacom《Ethernet VPN》。</p>
</blockquote>
<h2 id="EVPN常见路由"><a href="#EVPN常见路由" class="headerlink" title="EVPN常见路由"></a>EVPN常见路由</h2><h3 id="EVPN-NLRI"><a href="#EVPN-NLRI" class="headerlink" title="EVPN NLRI"></a>EVPN NLRI</h3><p>•EVPN定义了一种新的BGP NLRI（Network Layer Reachable Information）来承载所有的EVPN路由，被称为EVPN NLRI。</p>
<p>•EVPN NLRI是MP-BGP的新型扩展，被包含于MP_REACH_NLRI中，定义了新的NLRI。它规定了EVPN的AFI（Address Family Identifier）是25，SAFI（Subsequent Address Family Identifier）是70。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/10.png"></p>
<h3 id="EVPN路由"><a href="#EVPN路由" class="headerlink" title="EVPN路由"></a>EVPN路由</h3><p>EVPN NLRI格式采用TLV（Type-Length-Value）三元组结构，使得报文具有很强的灵活性和扩展性：</p>
<p>▫Route Type定义了不同的EVPN路由。RFC 7432中首先定义了四类路由。</p>
<p>▫Length定义了字段的长度。</p>
<p>▫Route Type Specifc则表示不同的路由类型有不同的字段填充。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<p>•The NLRI field in the MP_REACH_NLRI/MP_UNREACH_NLRI attribute contains the EVPN NLRI (encoded as specified above). </p>
<p>•The EVPN NLRI is carried in BGP [<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4271">RFC4271</a>] using BGP Multiprotocol Extensions [<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4760">RFC4760</a>] with an Address Family Identifier (AFI) of 25 (L2VPN) and a Subsequent Address Family Identifier (SAFI) of 70 (EVPN). The NLRI field in the MP_REACH_NLRI/MP_UNREACH_NLRI attribute contains the EVPN NLRI (encoded as specified above). </p>
<p>•In order for two BGP speakers to exchange labeled EVPN NLRI, they must use BGP Capabilities Advertisements to ensure that they both are capable of properly processing such NLRI. This is done as specified in [<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4760">RFC4760</a>], by using capability code 1 (multiprotocol BGP) with an AFI of 25 (L2VPN) and a SAFI of 70 (EVPN).</p>
</blockquote>
<h3 id="EVPN更多类型路由及作用"><a href="#EVPN更多类型路由及作用" class="headerlink" title="EVPN更多类型路由及作用"></a>EVPN更多类型路由及作用</h3><p>EVPN不仅限于二层VPN的应用，随着其EVPN路由类型的增加，支持更多的应用例如L3 VPN功能。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/12.png"></p>
<blockquote>
<p>•Type5类路由IP Prefix Route在标准化进程中目前处于草案阶段，draft-ietf-bess-evpn-prefix-advertisement。</p>
</blockquote>
<h3 id="EVPN协议标准"><a href="#EVPN协议标准" class="headerlink" title="EVPN协议标准"></a>EVPN协议标准</h3><p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/13.png"></p>
<h2 id="EVPN典型应用场景"><a href="#EVPN典型应用场景" class="headerlink" title="EVPN典型应用场景"></a>EVPN典型应用场景</h2><h3 id="EVPN在广域IP承载网的应用"><a href="#EVPN在广域IP承载网的应用" class="headerlink" title="EVPN在广域IP承载网的应用"></a>EVPN在广域IP承载网的应用</h3><p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/14.png"></p>
<blockquote>
<p>•E-LINE、E-TREE、E-LAN是EVC定义的三种类型，具体请参考城域以太网标准。<a target="_blank" rel="noopener" href="https://wiki.mef.net/display/CESG/E-Line">https://wiki.mef.net/display/CESG/E-Line</a></p>
<p>•MEF中提到了三种EVC的服务种类，点到点EVC（Point-to-Point EVC）、多点到多点EVC（Mutlipoint-to-Multipoint EVC）和根到多点EVC（Rooted-Multipoint EVC）。</p>
<ul>
<li>E-LINE：一条点到点的EVC将两个UNI严格地关联。</li>
<li>E-LAN：一个多点到多点EVC可以将两个或者两个以上的UNI关联起来，而且用户/运营商可以在不影响其他UNI的前提下根据需要向这个EVC中添加任意个UNI，或者将这个EVC中的某些UNI剔除。</li>
<li>E-TREE：这种EVC类似于三层VPN中的Hub-Spoke模式，它包含一个或多个根UNI（Root）和若干叶子UNI（Leaf），其中根UNI可以和EVC中的所有UNI直接通信，而叶子UNI只能和EVC中的根UNI直接通信，两个叶子UNI之间不能直接通信。 </li>
</ul>
</blockquote>
<h3 id="EVPN在数据中心网络的应用"><a href="#EVPN在数据中心网络的应用" class="headerlink" title="EVPN在数据中心网络的应用"></a>EVPN在数据中心网络的应用</h3><p>•在云数据中心采用EVPN的NVO（Network Virtualization Overlay）解决方案（RFC 8365）。</p>
<p>•推荐数据平面使用VXLAN封装与控制平面EVPN结合，构建灵活的数据中心Overlay网络。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/15.png"></p>
<h3 id="EVPN在园区网的应用"><a href="#EVPN在园区网的应用" class="headerlink" title="EVPN在园区网的应用"></a>EVPN在园区网的应用</h3><p>•园区网虚拟化园区解决方案同在云数据中心相同，采用EVPN的NVO解决方案（RFC 8365）。</p>
<p>•在不同的底层组网上使用VXLAN封装与控制平面EVPN结合，构建灵活的数据中心Overlay网络。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/16.png"></p>
<h3 id="EVPN在SD-WAN的应用"><a href="#EVPN在SD-WAN的应用" class="headerlink" title="EVPN在SD-WAN的应用"></a>EVPN在SD-WAN的应用</h3><p>•SD-WAN是新一代的企业分支互联解决方案，支持智能动态选路、ZTP和可视化等特性。</p>
<p>•SD-WAN解决方案中，在RR与CPE之间部署EVPN用于在控制平面传播SD-WAN的Overlay VPN路由，数据平面采用IPSec VPN构建安全的转发通道。</p>
<p><img src="/2021/05/10/BGP-EVPN%E5%9F%BA%E7%A1%80/17.png"></p>
<blockquote>
<p>•Overlay VPN路由包括站点VPN路由前缀、下一跳TNP路由信息以及用于CPE之间数据通道的数据加密所需要的IPSec相关密钥等信息。详细内容请参考SD-WAN课程。</p>
<p>•CPE（Customer Premise Equipment，客户终端设备）。</p>
</blockquote>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>1.（简答题）请简述EVPN的原理和常见的路由类型。</p>
<p><strong>EVPN是MP-BGP的扩展，常见有五种路由类型，被用于作为L2或者L3隧道的控制平面。</strong></p>
<p>2.（简答题）请简述EVPN的应用场景。</p>
<p><strong>EVPN可以被广泛用于企业全场景，例如SD-WAN、园区网、数据中心和广域网。在数据中心和园区中，EVPN与VXLAN结合构建业务 Overlay。在SD-WAN场景中EVPN与IPSec结合构建企业分支互联网络。在广域网中EVPN可以与各种底层隧道/标签技术结合，例如MPLS/SR/VPLS/VPWS等。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•MP-BGP对BGP-4的扩展允许不同类型的地址族在BGP中同时分发，例如IPv4组播、IPv6、L3VPN、EVPN等。</p>
<p>•本章节简单介绍EVPN的提出用于解决Ethernet二层VPN的问题。随着应用场景的逐渐丰富和协议的扩展，EVPN可以被用于多场景包括广域IP承载网络、数据中心网络、园区网络和SD-WAN。</p>
<h1 id="拓展信息"><a href="#拓展信息" class="headerlink" title="拓展信息"></a>拓展信息</h1><p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc4760/">https://datatracker.ietf.org/doc/rfc4760/</a></p>
<p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc7209/">https://datatracker.ietf.org/doc/rfc7209/</a></p>
<p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc7432/">https://datatracker.ietf.org/doc/rfc7432/</a></p>
<p>•<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc8365/">https://datatracker.ietf.org/doc/rfc8365/</a></p>
<p>•<a target="_blank" rel="noopener" href="https://wiki.mef.net/display/CESG/MEF+6.3+-+EVC+Ethernet+Services+Definitions">https://wiki.mef.net/display/CESG/MEF+6.3+-+EVC+Ethernet+Services+Definitions</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/" itemprop="url">BGP路由优选</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-10T17:56:08+08:00">
                2021-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•BGP是一个应用非常广泛的边界网关路由协议，在全球范围内被大量部署。BGP定义了多种路径属性，并且拥有丰富的路由策略工具，这使得BGP在路由操控和路径决策上变得非常灵活。</p>
<p>•针对BGP路由的各种属性的操作都可能影响路由的优选，从而对网络的流量产生影响，因此掌握BGP路由的优选规则十分重要。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述BGP路由优选规则</p>
<p>▫实现BGP路由控制</p>
<h1 id="BGP路由优选"><a href="#BGP路由优选" class="headerlink" title="BGP路由优选"></a>BGP路由优选</h1><h2 id="BGP路由优选规则"><a href="#BGP路由优选规则" class="headerlink" title="BGP路由优选规则"></a>BGP路由优选规则</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p><strong>丢弃下一跳不可达的路由。</strong></p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<blockquote>
<p><strong>↑</strong>  <strong>取值越大越优</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>↓</strong>  <strong>取值越小越优</strong></p>
</blockquote>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<blockquote>
<p>当前8条属性全部相同时可以形成路由负载分担</p>
<p>•上述规则依序排列，BGP进行路由优选时，从第一条规则开始执行，如果根据第一条规则无法作出判断，例如路由的Preferred-Value属性值相同，则继续执行下一条规则，如果根据当前的规则，BGP能够决策出最优的路由，则不再继续往下执行。</p>
<p>•本文选取了BGP路由优选规则中最为关键的12条，接下来将逐一讲解并验证上述规则。</p>
<p>•在后续的内容中可能会提到诸如“第8条选路规则”之类的术语，则对应本页所罗列的第8条选路规则。</p>
<p>•AIGP（Accumulated Interior Gateway Protocol，累加IGP度量值）用于传递并累加IGP metric值，该属性值并不常用，在BGP路由优选规则中并不涉及。</p>
</blockquote>
<hr>
<h2 id="拓扑说明-1"><a href="#拓扑说明-1" class="headerlink" title="拓扑说明 (1)"></a>拓扑说明 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/2.png"></p>
<p>•AS、设备互联地址如图所示，所有设备均创建Loopback0接口，IP地址为10.0.x.x（x为设备编号），所有设备使用环回口地址作为Router ID。</p>
<p>•AS200内运行OSPF，在内部互联接口（不包含连接外部AS的接口）、Loopback接口上激活OSPF。</p>
<h2 id="拓扑说明-2"><a href="#拓扑说明-2" class="headerlink" title="拓扑说明 (2)"></a>拓扑说明 (2)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/3.png"></p>
<p>•AS内部基于Loopback0接口建立IBGP对等体关系，AS之间基于直连接口建立EBGP对等体关系。</p>
<p>•R4、R5上存在相同的网段：10.0.45.0/24，通过import-route命令将该网段的直连路由注入到BGP，用于验证BGP路由优选规则。</p>
<h2 id="BGP路由优选规则-1"><a href="#BGP路由优选规则-1" class="headerlink" title="BGP路由优选规则"></a>BGP路由优选规则</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   <strong>丢弃下一跳不可达的路由。</strong></p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h2 id="丢弃下一跳不可达的路由-1"><a href="#丢弃下一跳不可达的路由-1" class="headerlink" title="丢弃下一跳不可达的路由 (1)"></a>丢弃下一跳不可达的路由 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/4.png"></p>
<p>•R4、R5将BGP路由10.0.45.0/24通告给AS200时Next_Hop属性值为10.0.24.4、10.0.34.5。</p>
<p>•R2、R3将路由通告给R1时不修改Next_Hop属性值，R1学习到的两条BGP路由10.0.45.0/24下一跳为10.0.24.4、10.0.34.5。</p>
<p>•R1进行BGP路由下一跳迭代查询时，由于R2、R3未在连接外部AS的接口上激活OSPF，导致路由迭代失败，R1上的BGP路由10.0.45.0/24下一跳不可达。</p>
<p>•在R1上通过<strong>display bgp routing</strong>查看BGP路由表，此时BGP路由10.0.45.0/24为非有效路由条目。</p>
<h2 id="丢弃下一跳不可达的路由-2"><a href="#丢弃下一跳不可达的路由-2" class="headerlink" title="丢弃下一跳不可达的路由 (2)"></a>丢弃下一跳不可达的路由 (2)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/5.png"></p>
<p>在R2、R3上通过<strong>next-hop-local</strong>命令修改Next_Hop属性值为本地更新源地址。</p>
<p>R2、R3向R1通告BGP路由时Next_Hop属性值将会变为：10.0.2.2、10.0.3.3。</p>
<p>这两个下一跳地址在R1上能够成功进行路由迭代，BGP路由的下一跳地址将会变成可达。</p>
<h2 id="丢弃下一跳不可达的路由-3"><a href="#丢弃下一跳不可达的路由-3" class="headerlink" title="丢弃下一跳不可达的路由 (3)"></a>丢弃下一跳不可达的路由 (3)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/6.png"></p>
<h2 id="BGP路由优选规则1"><a href="#BGP路由优选规则1" class="headerlink" title="BGP路由优选规则1"></a>BGP路由优选规则1</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p><strong>1.优选Preferred-Value属性值最大的路由。</strong></p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="修改Preferred-Value"><a href="#修改Preferred-Value" class="headerlink" title="修改Preferred-Value"></a>修改Preferred-Value</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/7.png"></p>
<p>使用<strong>preferred-value</strong>命令修改R3通告的BGP路由其Preferred-Value为100 ，优于R2通告BGP路由的默认Preferred-Value ，R1将会优选R3通告的BGP路由10.0.45.0/24。</p>
<h3 id="查看R1-BGP路由表"><a href="#查看R1-BGP路由表" class="headerlink" title="查看R1 BGP路由表"></a>查看R1 BGP路由表</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/8.png"></p>
<p>R3（10.0.3.3）通告的BGP路由拥有更高的Preferred-Value（100），因此R1将会优选R3通告的BGP路由10.0.45.0/24。</p>
<h2 id="BGP路由优选规则2"><a href="#BGP路由优选规则2" class="headerlink" title="BGP路由优选规则2"></a>BGP路由优选规则2</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p><strong>2.优选Local_Preference属性值最大的路由。</strong></p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="修改Local-Preference-1"><a href="#修改Local-Preference-1" class="headerlink" title="修改Local_Preference (1)"></a>修改Local_Preference (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/9.png"></p>
<h3 id="修改Local-Preference-2"><a href="#修改Local-Preference-2" class="headerlink" title="修改Local_Preference (2)"></a>修改Local_Preference (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/10.png"></p>
<p>下一跳可达、相同Preferred-Value的情况下将会比较Local_Preference，R3通告的BGP路由Local_Preference值为200，高于R2通告的BGP路由，R1将会优选R3通告的BGP路由。</p>
<h2 id="BGP路由优选规则3"><a href="#BGP路由优选规则3" class="headerlink" title="BGP路由优选规则3"></a>BGP路由优选规则3</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p><strong>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</strong></p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="本地优先"><a href="#本地优先" class="headerlink" title="本地优先"></a>本地优先</h3><p>•本条规则可以概括为在相同条件下，优选本地生成的路由，从对等体学习到的路由条目为次优。</p>
<p>•同时本地生成的路由也可能存在多种途径，当本地存在多种途径学习到相同路由时，从高到低优先级如下：</p>
<ul>
<li>手动聚合：手动通过aggregate命令在BGP视图内聚合生成的聚合路由</li>
<li>自动聚合：Summary automatic命令生成的自动聚合路由</li>
<li>Network方式注入的路由</li>
<li>Import-route方式注入的路由</li>
</ul>
<blockquote>
<p>•本条规则我们验证了：</p>
<p>​    ▫本地产生的BGP路由优于从对等体学习的BGP路由</p>
<p>​    ▫手动聚合产生的BGP路由优于自动聚合产生的BGP路由</p>
</blockquote>
<h3 id="手动聚合-1"><a href="#手动聚合-1" class="headerlink" title="手动聚合 (1)"></a>手动聚合 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/11.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/12.png"></p>
<h3 id="手动聚合-2"><a href="#手动聚合-2" class="headerlink" title="手动聚合 (2)"></a>手动聚合 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/13.png"></p>
<blockquote>
<p>•BGP路由表中“s”标志代表该路由条目被抑制。</p>
</blockquote>
<h3 id="手动聚合-3"><a href="#手动聚合-3" class="headerlink" title="手动聚合 (3)"></a>手动聚合 (3)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/14.png"></p>
<p>•R3上通过<strong>display bgp routing-table</strong> <strong>10.0.45.0</strong> <strong>24</strong>查看BGP路由10.0.45.0/24的详细信息，存在两条有效路由，其中最优的为手动聚合产生的路由。</p>
<p>•在本案例中我们验证了本地产生的BGP路由优于从对等体学习的BGP路由。</p>
<h3 id="自动聚合-1"><a href="#自动聚合-1" class="headerlink" title="自动聚合 (1)"></a>自动聚合 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/15.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/16.png"></p>
<h3 id="自动聚合-2"><a href="#自动聚合-2" class="headerlink" title="自动聚合 (2)"></a>自动聚合 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/17.png"></p>
<h3 id="自动聚合-3"><a href="#自动聚合-3" class="headerlink" title="自动聚合 (3)"></a>自动聚合 (3)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/18.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/19.png"></p>
<h3 id="自动聚合-4"><a href="#自动聚合-4" class="headerlink" title="自动聚合 (4)"></a>自动聚合 (4)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/20.png"></p>
<p>•R3上通过<strong>display bgp routing-table</strong> <strong>10.0.0.0</strong> 查看BGP路由10.0.0.0/8的详细信息，存在三条有效路由，其中最优的条目由聚合产生，并且存在Atomic-aggregate属性，由此可以看出该聚合条目为手动聚合产生的条目。</p>
<p>•R3上相同的BGP聚合路由：手动聚合 &gt; 自动聚合。</p>
<p>•在该案例中我们验证了手动聚合产生的BGP路由优于自动聚合产生的BGP路由。</p>
<blockquote>
<p>•本地Network优于本地import，此案例不再展示。</p>
<p>•自动聚合产生的聚合路由并不会携带Atomic-aggregate属性。</p>
</blockquote>
<h2 id="BGP路由优选规则4"><a href="#BGP路由优选规则4" class="headerlink" title="BGP路由优选规则4"></a>BGP路由优选规则4</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p><strong>4.优选AS_Path属性值最短的路由。</strong></p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="优选AS-Path最短-1"><a href="#优选AS-Path最短-1" class="headerlink" title="优选AS_Path最短 (1)"></a>优选AS_Path最短 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/21.png"></p>
<h3 id="优选AS-Path最短-2"><a href="#优选AS-Path最短-2" class="headerlink" title="优选AS_Path最短 (2)"></a>优选AS_Path最短 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/22.png"></p>
<h2 id="BGP路由优选规则5"><a href="#BGP路由优选规则5" class="headerlink" title="BGP路由优选规则5"></a>BGP路由优选规则5</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p><strong>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</strong></p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="Origin属性验证-1"><a href="#Origin属性验证-1" class="headerlink" title="Origin属性验证 (1)"></a>Origin属性验证 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/23.png"></p>
<p>•R4、R5上默认采用import-route方式将路由10.0.45.0/24注入到BGP，R1的BGP路由表中两条BGP路由10.0.45.0/24其Origin属性都是“？”，此时R1优选R4注入的BGP路由。</p>
<p>•在R5上修改注入路由的方式为network</p>
<p>•之后在R1上再次查看BGP路由表。</p>
<h3 id="Origin属性验证-2"><a href="#Origin属性验证-2" class="headerlink" title="Origin属性验证 (2)"></a>Origin属性验证 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/24.png"></p>
<p>•此时R5注入的BGP路由10.0.45.0/24其Origin属性为“i”，在前几条优选规则相同情况下，起源类型为“i”的BGP路由成为优选路由。</p>
<h2 id="BGP路由优选规则6"><a href="#BGP路由优选规则6" class="headerlink" title="BGP路由优选规则6"></a>BGP路由优选规则6</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p><strong>6.优选MED属性值最小的路由。</strong></p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="优选MED最小-1"><a href="#优选MED最小-1" class="headerlink" title="优选MED最小 (1)"></a>优选MED最小 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/25.png"></p>
<h3 id="优选MED最小-2"><a href="#优选MED最小-2" class="headerlink" title="优选MED最小 (2)"></a>优选MED最小 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/26.png"></p>
<h2 id="BGP路由优选规则7"><a href="#BGP路由优选规则7" class="headerlink" title="BGP路由优选规则7"></a>BGP路由优选规则7</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p><strong>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</strong></p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="优选从EBGP对等体学来的路由-1"><a href="#优选从EBGP对等体学来的路由-1" class="headerlink" title="优选从EBGP对等体学来的路由 (1)"></a>优选从EBGP对等体学来的路由 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/27.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/28.png"></p>
<h3 id="优选从EBGP对等体学来的路由-2"><a href="#优选从EBGP对等体学来的路由-2" class="headerlink" title="优选从EBGP对等体学来的路由 (2)"></a>优选从EBGP对等体学来的路由 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/29.png"></p>
<h2 id="BGP路由优选规则8"><a href="#BGP路由优选规则8" class="headerlink" title="BGP路由优选规则8"></a>BGP路由优选规则8</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p><strong>8.优选到Next_Hop的IGP度量值最小的路由。</strong></p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="IGP-Cost"><a href="#IGP-Cost" class="headerlink" title="IGP Cost"></a>IGP Cost</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/30.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/31.png"></p>
<h3 id="优选IGP-Cost值最小-1"><a href="#优选IGP-Cost值最小-1" class="headerlink" title="优选IGP Cost值最小 (1)"></a>优选IGP Cost值最小 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/32.png"></p>
<h3 id="优选IGP-Cost值最小-2"><a href="#优选IGP-Cost值最小-2" class="headerlink" title="优选IGP Cost值最小 (2)"></a>优选IGP Cost值最小 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/33.png"></p>
<h3 id="优选IGP-Cost值最小-3"><a href="#优选IGP-Cost值最小-3" class="headerlink" title="优选IGP Cost值最小 (3)"></a>优选IGP Cost值最小 (3)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/34.png"></p>
<p>•R1上通过<strong>display bgp routing-table</strong> <strong>10.0.45.0 24</strong> 查看BGP路由的详细信息，下一跳10.0.2.2的BGP路由其IGP cost值变为了10，而下一跳为10.0.3.3的BGP路由其IGP cost为默认值1，所以R1优选下一跳为10.0.3.3的路由。</p>
<p>•在R1的路由详细信息中可以看到如下内容：</p>
<p>​    <strong>not preferred for IGP cost</strong></p>
<p>​    表明该路由因为IGP cost未被优选。</p>
<h3 id="BGP路由等价负载分担"><a href="#BGP路由等价负载分担" class="headerlink" title="BGP路由等价负载分担"></a>BGP路由等价负载分担</h3><p>•在大型网络中，到达同一目的地通常会存在多条有效BGP路由，设备只会优选一条最优的BGP路由，将该路由加载到路由表中使用，这一特点往往会造成很多流量负载不均衡的情况。</p>
<p>•通过配置BGP负载分担，可以使得设备同时将多条等代价的BGP路由加载到路由表，实现流量负载均衡，减少网络拥塞。</p>
<p>•值得注意的是，尽管配置了BGP负载分担，设备依然只会在多条到达同一目的地的BGP路由中优选一条路由，并只将这条路由通告给其他对等体。</p>
<p>•在设备上使能BGP负载分担功能后，只有满足条件的多条BGP路由才会成为等价路由，进行负载分担。</p>
<blockquote>
<p>•默认情况下设备只会对AS_Path完全相同的路由进行负载分担，可以使用<strong>load-balancing as-path-ignore</strong>忽略AS_Path路径不一致。</p>
<p>•在公网中到达同一目的地的路由形成负载分担时，系统会首先判断最优路由的类型。若最优路由为IBGP路由则只是IBGP路由参与负载分担，若最优路由为EBGP路由则只是EBGP路由参与负载分担，即公网中到达同一目的地的IBGP和EBGP路由不能形成负载分担。</p>
</blockquote>
<h3 id="形成BGP路由等价负载分担的条件"><a href="#形成BGP路由等价负载分担的条件" class="headerlink" title="形成BGP路由等价负载分担的条件"></a>形成BGP路由等价负载分担的条件</h3><p>•Preferred-Value属性值相同。</p>
<p>•Local_Preference属性值相同。</p>
<p>•都是聚合路由或者非聚合路由。</p>
<p>•AS_Path属性长度相同。</p>
<p>•Origin类型（IGP、EGP、Incomplete）相同。</p>
<p>•MED属性值相同。</p>
<p>•都是EBGP路由或都是IBGP路由。</p>
<p>•AS内部IGP的Metric相同。</p>
<p>•AS_Path属性完全相同。</p>
<h3 id="配置BGP路由负载分担"><a href="#配置BGP路由负载分担" class="headerlink" title="配置BGP路由负载分担"></a>配置BGP路由负载分担</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/35.png"></p>
<p>以左侧拓扑为例，R1上两条BGP路由在不做任何路由策略、配置的情况下，前8条优选规则无法比较出优选路由。因此可以配置IBGP路由的负载分担。</p>
<h3 id="配置BGP路由负载分担后"><a href="#配置BGP路由负载分担后" class="headerlink" title="配置BGP路由负载分担后"></a>配置BGP路由负载分担后</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/36.png"></p>
<h2 id="BGP路由优选规则9"><a href="#BGP路由优选规则9" class="headerlink" title="BGP路由优选规则9"></a>BGP路由优选规则9</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p><strong>9.优选Cluster_List最短的路由。</strong></p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="优选Cluster-List最短案例-1"><a href="#优选Cluster-List最短案例-1" class="headerlink" title="优选Cluster_List最短案例 (1)"></a>优选Cluster_List最短案例 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/37.png"></p>
<p>对拓扑做如下修改：</p>
<p>•只在R5上将10.0.45.0/24发布到BGP</p>
<p>•配置R1为RR，R3为R1的客户端。</p>
<p>•R2、R3之间基于环回口建立IBGP对等体关系</p>
<p>R2上将收到R3通告的BGP路由10.0.45.0/24、R1反射的BGP路由10.0.45.0/24。</p>
<p>默认配置下，前面介绍的规则无法比较出优选路由，此时将根据Cluster_List进行优选。</p>
<h3 id="优选Cluster-List最短案例-2"><a href="#优选Cluster-List最短案例-2" class="headerlink" title="优选Cluster_List最短案例 (2)"></a>优选Cluster_List最短案例 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/38.png"></p>
<p>从BGP路由表中无法看出优选的是R1反射的BGP路由还是R3通告的BGP路由，此时可以通过命令<strong>display</strong> <strong>bgp routing</strong> <strong>10.0.45.0</strong> <strong>24</strong>查看BGP路由详细信息。</p>
<h3 id="优选Cluster-List最短案例-3"><a href="#优选Cluster-List最短案例-3" class="headerlink" title="优选Cluster_List最短案例 (3)"></a>优选Cluster_List最短案例 (3)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/39.png"></p>
<p>•经由R1反射的路由不是最优路由，原因也被标出：</p>
<p><strong>not preferred for Cluster List</strong>*</p>
<p>•R3直接通告给R2的BGP路由因为没有经过路由反射器，不存在Cluster_List属性，即被认为Cluster_List长度为0，小于由R1反射的BGP路由其Cluster_List长度（1），所以R3通告的BGP路由为优选路由。</p>
<h2 id="BGP路由优选规则10"><a href="#BGP路由优选规则10" class="headerlink" title="BGP路由优选规则10"></a>BGP路由优选规则10</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p><strong>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</strong></p>
<p>11.优选具有最小IP地址的对等体通告的路由。</p>
<h3 id="优选Router-ID最小-1"><a href="#优选Router-ID最小-1" class="headerlink" title="优选Router ID最小 (1)"></a>优选Router ID最小 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/40.png"></p>
<p>在我们的讲解拓扑中，默认配置下R1从R2、R3都会收到BGP路由10.0.45.0/24，并且前面的优选规则无法比较出优选路由，最终将会根据本条规则，优选Router ID最小的对等体通告的BGP路由，在本案例中也就是R2通告的BGP路由。</p>
<h3 id="优选Router-ID最小-2"><a href="#优选Router-ID最小-2" class="headerlink" title="优选Router ID最小 (2)"></a>优选Router ID最小 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/41.png"></p>
<p>查看R1的BGP路由表详细信息，来自10.0.3.3的BGP路由因Router ID原因没有被优选：<br> <strong>not preferred for router ID</strong></p>
<h3 id="优选Orginator-ID最小-1"><a href="#优选Orginator-ID最小-1" class="headerlink" title="优选Orginator_ID最小 (1)"></a>优选Orginator_ID最小 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/42.png"></p>
<p>如果BGP路由携带Originator_ID属性，则在本条规则的优选过程中，将比较Originator_ID的大小，并优选Originator_ID最小的BGP路由。</p>
<h3 id="优选Orginator-ID最小-2"><a href="#优选Orginator-ID最小-2" class="headerlink" title="优选Orginator_ID最小 (2)"></a>优选Orginator_ID最小 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/43.png"></p>
<h2 id="BGP路由优选规则11"><a href="#BGP路由优选规则11" class="headerlink" title="BGP路由优选规则11"></a>BGP路由优选规则11</h2><p>当到达同一个目的网段存在多条路由时，BGP通过如下的次序进行路由优选：</p>
<p>   丢弃下一跳不可达的路由。</p>
<p>1.优选Preferred-Value属性值最大的路由。</p>
<p>2.优选Local_Preference属性值最大的路由。</p>
<p>3.本地始发的BGP路由优于从其他对等体学习到的路由，本地始发的路由优先级：优选手动聚合&gt;自动聚合&gt;network&gt;import&gt;从对等体学到的。</p>
<p>4.优选AS_Path属性值最短的路由。</p>
<p>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete。</p>
<p>6.优选MED属性值最小的路由。</p>
<p>7.优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。</p>
<p>8.优选到Next_Hop的IGP度量值最小的路由。</p>
<p>9.优选Cluster_List最短的路由。</p>
<p>10.优选Router ID（Orginator_ID）最小的设备通告的路由。</p>
<p><strong>11.优选具有最小IP地址的对等体通告的路由。</strong></p>
<h3 id="优选具有最小IP地址的对等体-1"><a href="#优选具有最小IP地址的对等体-1" class="headerlink" title="优选具有最小IP地址的对等体 (1)"></a>优选具有最小IP地址的对等体 (1)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/44.png"></p>
<p>•当前面所有规则都无法比较出优选路由时，此时会根据对等体地址大小来进行优选，对等体地址较小者发送的路由较优。</p>
<p>•修改前一条规则的验证拓扑，R2、R3都与R4相连，R4作为RR客户端，只在R4上将路由发布到BGP，此时R2、R3反射的BGP路由将拥有相同的Originator ID：10.0.4.4。</p>
<h3 id="优选具有最小IP地址的对等体-2"><a href="#优选具有最小IP地址的对等体-2" class="headerlink" title="优选具有最小IP地址的对等体 (2)"></a>优选具有最小IP地址的对等体 (2)</h3><p><img src="/2021/05/10/BGP%E8%B7%AF%E7%94%B1%E4%BC%98%E9%80%89/45.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（简答题）从EBGP对等体收到的BGP路由通告给IBGP对等体时如何修改next_hop属性值为自身更新源地址？</p>
<p><strong>使用peer next-hop-local命令指定next_hop属性为TCP连接源地址。</strong></p>
<p>2.（判断题）当前三条优选规则相同的情况下，BGP会比较AS_Path长度，当AS_Path长度相同时会比较AS号的大小。</p>
<p>A.对</p>
<p><strong>B.错</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•BGP采用路径属性进行路由优选，这让BGP拥有丰富的可选比较项，可以在不同的场景下根据不同的路径属性选择出最适合的路由。</p>
<p>•BGP定义了一套详细的最优路径选择算法，这使得路由器能够在任何复杂的、高冗余性的网络环境下选择出最优的路径，这套算法也被称作BGP路由优选规则，或者BGP选路原则。</p>
<p>•BGP选路原则在实际中频繁应用，需要熟练掌握。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/" itemprop="url">BGP路径属性与路由反射器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-10T17:55:55+08:00">
                2021-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•任何一条BGP路由都拥有多个路径属性（Path Attributes），当路由器通告BGP路由给它的对等体时，该路由将会携带多个路径属性，这些属性描述了BGP路由的各项特征，同时在某些场景下也会影响BGP路由优选的决策。</p>
<p>•IBGP水平分割规则用于防止AS内部产生环路，在很大程度上杜绝了IBGP路由产生环路的可能性，但是同时也带来了新的问题：BGP路由在AS内部只能传递一跳，如果建立IBGP对等体全互联模型又会加重设备的负担。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述BGP常见的路径属性及作用</p>
<p>▫描述BGP路由反射器的概念及应用场景</p>
<p>▫描述BGP路由反射器的规则及工作机制</p>
<h1 id="BGP路径属性"><a href="#BGP路径属性" class="headerlink" title="BGP路径属性"></a>BGP路径属性</h1><h2 id="路径属性"><a href="#路径属性" class="headerlink" title="路径属性"></a><strong>路径属性</strong></h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/1.png"></p>
<p>•任何一条BGP路由都拥有多个路径属性。</p>
<p>•当路由器将BGP路由通告给它的对等体时，一并被通告的还有路由所携带的各个路径属性。</p>
<p>•BGP的路径属性将影响路由优选</p>
<h2 id="路径属性分类"><a href="#路径属性分类" class="headerlink" title="路径属性分类"></a>路径属性分类</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/2.png"></p>
<p>•公认属性是所有BGP路由器都必须能够识别的属性</p>
<p>•公认属性可以分为两类：</p>
<p>​    ▫公认必遵（Well-known Mandatory）：必须包括在每个Update消    息里。</p>
<p>​    ▫公认任意（Well-known Discretionary）：可能包括在某些Update    消息里。</p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/3.png"></p>
<p>•可选属性不需要都被BGP路由器所识别</p>
<p>•可选属性可以分为两类：</p>
<p>​    ▫可选过渡（Optional Transitive）：BGP设备不识别此类属性依然会    接受该类属性并通告给其他对等体。</p>
<p>​    ▫可选非过渡（Optional Non-transitive）：BGP设备不识别此类属性    会忽略该属性，且不会通告给其他对等体。    </p>
<blockquote>
<p>•BGP属性很多，这里仅列出常用BGP属性。</p>
</blockquote>
<h2 id="BGP-Update报文举例"><a href="#BGP-Update报文举例" class="headerlink" title="BGP Update报文举例"></a>BGP Update报文举例</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/4.png"></p>
<h2 id="AS-Path"><a href="#AS-Path" class="headerlink" title="AS_Path"></a>AS_Path</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/5.png"></p>
<p>•该属性为公认必遵属性，是前往目标网络的路由经过的AS号列表；</p>
<p>•作用：确保路由在EBGP对等体之间传递无环；另外也作为路由优选的衡量标准之一；</p>
<p>•路由在被通告给EBGP对等体时，路由器会在该路由的AS_Path中追加上本地的AS号；路由被通告给IBGP对等体时，AS_Path不会发生改变。</p>
<h2 id="AS-Path防止环路"><a href="#AS-Path防止环路" class="headerlink" title="AS_Path防止环路"></a>AS_Path防止环路</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/6.png"></p>
<p>R1从R4收到的BGP路由更新中AS_Path属性数值为：400 300 200 100，存在自身AS号，不接收该路由，从而防止了路由环路的产生。</p>
<h2 id="AS-Path影响路由优选"><a href="#AS-Path影响路由优选" class="headerlink" title="AS_Path影响路由优选"></a>AS_Path影响路由优选</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/7.png"></p>
<h2 id="AS-Path类型"><a href="#AS-Path类型" class="headerlink" title="AS_Path类型"></a>AS_Path类型</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/8.png"></p>
<blockquote>
<p>•路由聚合解决了两类问题，一是减轻了设备的负担，二是隐藏了明细的路由信息，减少了路由震荡的影响。但是路由聚合后，AS_Path属性丢失，存在产生环路的风险，为此可以通过AS_SET类型的AS_Path属性携带聚合前的AS路径信息。</p>
<p>•当发生路由聚合后，如果需要聚合路由携带所有明细路由中AS_Path属性携带的AS号防止环路，则在配置聚合的命令中增加as-set参数。</p>
<p>•在AS_SET的示例中AS 300内发生了路由聚合并配置了as-set参数，则聚合路由会将明细路由的AS_Path信息用一个AS-Set集表示（放在中括号{}里的AS号信息，该集合内的AS号没有先后顺序），在聚合路由中携带用以防止环路。</p>
<p>•除了AS_SET、AS_AS_SEQENCE之外，AS_Path还存在另外两种类型：AS_Confed_Sequence、AS_Confed_Set，这两种类型应用于BGP联邦中，本课程不涉及。</p>
</blockquote>
<h2 id="修改AS-Path"><a href="#修改AS-Path" class="headerlink" title="修改AS_Path"></a>修改AS_Path</h2><p>使用Route-Policy修改BGP路由的AS_Path属性时，可以使用以下三种方式：</p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/9.png"></p>
<h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/10.png"></p>
<p>•该属性为公认必遵属性，它标识了BGP路由的起源。如上表所示，根据路由被引入BGP的方式不同，存在三种类型的Origin。</p>
<p>•当去往同一个目的地存在多条不同Origin属性的路由时，在其他条件都相同的情况下，BGP将按如Origin的下顺序优选路由：IGP &gt; EGP &gt; Incomplete。</p>
<h2 id="Origin在BGP表中的显示"><a href="#Origin在BGP表中的显示" class="headerlink" title="Origin在BGP表中的显示"></a>Origin在BGP表中的显示</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/11.png"></p>
<h2 id="Next-Hop"><a href="#Next-Hop" class="headerlink" title="Next_Hop"></a>Next_Hop</h2><p>•该属性是一个公认必遵属性，用于指定到达目标网络的下一跳地址。</p>
<p>•当路由器学习到BGP路由后，需对BGP路由的Next_Hop属性值进行检查，该属性值（IP地址）必须在本地路由可达，如果不可达，则这条BGP路由不可用。</p>
<p>•在不同的场景中，设备对BGP路由的缺省Next_Hop属性值的设置规则如下：</p>
<p>▫路由器将BGP路由通告给自己的EBGP对等体时，将该路由的Next_Hop设置为自己的更新源IP地址。</p>
<p>▫路由器在收到EBGP对等体所通告的BGP路由后，在将路由传递给自己的IBGP对等体时，会保持路由的Next_Hop属性值不变。</p>
<p>▫如果路由器收到某条BGP路由，该路由的Next_Hop属性值与EBGP对等体（更新对象）同属一个网段，那么该条路由的Next_Hop地址将保持不变并传递给它的BGP对等体。</p>
<h2 id="Next-Hop的缺省操作-1"><a href="#Next-Hop的缺省操作-1" class="headerlink" title="Next_Hop的缺省操作 (1)"></a>Next_Hop的缺省操作 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/12.png"></p>
<p>路由器将BGP路由通告给自己的EBGP对等体时，将该路由的Next_Hop设置为自己的TCP连接源地址。</p>
<h2 id="Next-Hop的缺省操作-2"><a href="#Next-Hop的缺省操作-2" class="headerlink" title="Next_Hop的缺省操作 (2)"></a>Next_Hop的缺省操作 (2)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/13.png"></p>
<p>路由器在收到EBGP对等体所通告的BGP路由后，在将路由传递给自己的IBGP对等体时，会保持路由的Next_Hop属性值不变。</p>
<h2 id="Next-Hop的缺省操作-3"><a href="#Next-Hop的缺省操作-3" class="headerlink" title="Next_Hop的缺省操作 (3)"></a>Next_Hop的缺省操作 (3)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/14.png"></p>
<p>如果路由器收到某条BGP路由，该路由的Next_Hop属性值与EBGP对等体（更新对象）同属一个网段，那么该条路由的Next_Hop地址将保持不变并传递给它的BGP对等体。</p>
<h2 id="修改Next-hop属性"><a href="#修改Next-hop属性" class="headerlink" title="修改Next_hop属性"></a>修改Next_hop属性</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/15.png"></p>
<p>使用<strong>peer next-hop-local</strong>命令可以在设置向IBGP对等体（组）通告路由时，把下一跳属性设为自身的TCP连接源地址。</p>
<blockquote>
<p>•缺省情况下，R2通告给R3的BGP路由10.0.1.0/24的NextHop属性值为10.0.12.1，若R2未将到达10.0.12.0/24的路由发布到AS200的IGP协议中，那么R3将无法获知到达10.0.12.1的路由，此时BGP路由10.0.1.0/24的NextHop不可达，该路由将被视为无效。</p>
</blockquote>
<h2 id="Local-Preference"><a href="#Local-Preference" class="headerlink" title="Local_Preference"></a>Local_Preference</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/16.png"></p>
<p>•Local_Preference即本地优先级属性，是公认任意属性，可以用于告诉AS中的路由器，哪条路径是离开本AS的首选路径。</p>
<p>•Local_Preference属性值越大则BGP路由越优。缺省的Local_Preference值为100。</p>
<p>•该属性只能被传递给IBGP对等体，而不能传递给EBGP对等体。</p>
<h2 id="在BGP路由表中查看Local-Preference"><a href="#在BGP路由表中查看Local-Preference" class="headerlink" title="在BGP路由表中查看Local_Preference"></a>在BGP路由表中查看Local_Preference</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/17.png"></p>
<p>Local_Preference为200的BGP路由优于Local_Preference为100的BGP路由，在BGP路由表中来自10.0.12.1的BGP路由为最优。</p>
<h2 id="Local-Preference注意事项"><a href="#Local-Preference注意事项" class="headerlink" title="Local_Preference注意事项"></a>Local_Preference注意事项</h2><p>•Local_Preference属性只能在IBGP对等体间传递（除非做了策略否则Local_Preference值在IBGP对等体间传递过程中不会丢失），而不能在EBGP对等体间传递，如果在EBGP对等体间收到的路由的路径属性中携带了Local_Preference，则会进行错误处理。</p>
<p>•但是可以在AS边界路由器上使用Import方向的策略来修改Local_Preference属性值。也就是在收到路由之后，在本地为路由赋予Local_Preference。</p>
<p>•使用<strong>bgp</strong> <strong>default local-preference</strong>命令修改缺省Local_Preference值，该值缺省为100。</p>
<p>•路由器在向其EBGP对等体发送路由更新时，不能携带Local_Preference属性，但是对方接收路由之后，会在本地为这条路由赋一个缺省Local_Preference值（100），然后再将路由传递给自己的IBGP对等体。</p>
<p>•本地使用<strong>network</strong>命令及<strong>import-route</strong>命令引入的路由， Local_Preference为缺省值100，并能在AS内向其他IBGP对等体传递，传递过程中除非受路由策略影响，否则Local_Preference不变。</p>
<h2 id="Community技术背景-1"><a href="#Community技术背景-1" class="headerlink" title="Community技术背景 (1)"></a>Community技术背景 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/18.png"></p>
<h2 id="Community技术背景-2"><a href="#Community技术背景-2" class="headerlink" title="Community技术背景 (2)"></a>Community技术背景 (2)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/19.png"></p>
<h2 id="Community属性"><a href="#Community属性" class="headerlink" title="Community属性"></a>Community属性</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/20.png"></p>
<p>•Community（团体）属性为可选过渡属性，是一种路由标记，用于简化路由策略的执行。</p>
<p>•可以将某些路由分配一个特定的Community属性值，之后就可以基于Community值而不是网络前缀/掩码信息来匹配路由并执行相应的策略了。</p>
<h2 id="Community属性格式"><a href="#Community属性格式" class="headerlink" title="Community属性格式"></a>Community属性格式</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/21.png"></p>
<p>Community属性值长度为32bit，也就是4Byte。可使用两种形式呈现：</p>
<p>​    ▫十进制整数格式。</p>
<p>​    ▫AA：NN格式，其中AA表示AS号，NN是自定义的编号。</p>
<blockquote>
<p>•团体（Community）属性分为自定义团体属性和公认团体属性。</p>
</blockquote>
<h2 id="公认Community属性"><a href="#公认Community属性" class="headerlink" title="公认Community属性"></a>公认Community属性</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/22.png"></p>
<p>RFC1997（BGP Communities Attribute）定义了几个公认的Community属性值，如上表所示。</p>
<blockquote>
<p>•No_Export_Subconfed团体属性涉及到BGP联邦的概念，本课程不涉及。</p>
</blockquote>
<h2 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/23.png"></p>
<p>•MED（Multi-Exit Discriminator，多出口鉴别器）是可选非过渡属性，是一种度量值，用于向外部对等体指出进入本AS的首选路径，即当进入本AS的入口有多个时，AS可以使用MED动态地影响其他AS选择进入的路径。</p>
<p>•MED属性值越小则BGP路由越优。</p>
<p>•MED主要用于在AS之间影响BGP的选路。MED被传递给EBGP对等体后，对等体在其AS内传递路由时，携带该MED值，但将路由再次传递给其EBGP对等体时，缺省不会携带MED属性。</p>
<h2 id="关于MED的一些注意事项"><a href="#关于MED的一些注意事项" class="headerlink" title="关于MED的一些注意事项"></a>关于MED的一些注意事项</h2><p>•缺省情况下，路由器只比较来自同一相邻AS的BGP路由的MED值，也就是说如果去往同一个目的地的两条路由来自不同的相邻AS，则不进行MED值的比较。</p>
<p>•一台BGP路由器将路由通告给EBGP对等体时，是否携带MED属性，需要根据以下条件进行判断（不对EBGP对等体使用策略的情况下）：</p>
<ul>
<li>如果该BGP路由是本地始发（本地通过network或import-route命令引入）的，则缺省携带MED属性发送给EBGP对等体。</li>
<li>如果该BGP路由为从BGP对等体学习到，那么该路由传递给EBGP对等体时缺省不会携带MED属性。</li>
<li>在IBGP对等体之间传递路由时，MED值会被保留并传递，除非部署了策略，否则MED值在传递过程中不发生改变也不会丢失。</li>
</ul>
<h2 id="MED的默认操作-1"><a href="#MED的默认操作-1" class="headerlink" title="MED的默认操作 (1)"></a>MED的默认操作 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/24.png"></p>
<p>•如果路由器通过IGP学习到一条路由，并通过<strong>network</strong>或<strong>import-route</strong>的方式将路由引入BGP，产生的BGP路由的MED值继承路由在IGP中的metric。例如上图中如果R2通过OSPF学习到了10.0.1.0/24路由，并且该路由在R2的全局路由表中OSPF Cost=100，那么当R2将路由network进BGP后，产生的BGP路由的MED值为100。</p>
<p>•如果路由器将本地直连、静态路由通过<strong>network</strong>或<strong>import-route</strong>的方式引入BGP，那么这条BGP路由的MED为0，因为直连、静态路由cost为0。</p>
<h2 id="MED的默认操作-2"><a href="#MED的默认操作-2" class="headerlink" title="MED的默认操作 (2)"></a>MED的默认操作 (2)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/25.png"></p>
<p>•如果路由器通过BGP学习到其他对等体传递过来的路由，那么将路由更新给自己的EBGP对等体时，默认是不携带MED的。这就是所谓的：“MED不会跨AS传递”。例如在上图中，如果R3从R2学习到一条携带了MED属性的BGP路由，则它将该路由通告给R4时，缺省是不会携带MED属性的。</p>
<p>•可以使用default med命令修改缺省的MED值，<strong>default med</strong>命令只对本设备上用<strong>import-route</strong>命令引入的路由和BGP的聚合路由生效。例如在R2上配置<strong>default med 999</strong>，那么R2通过<strong>import-route</strong>及<strong>aggregate</strong>命令产生的路由传递给R3时，路由携带的MED为999。</p>
<h2 id="Atomic-Aggregate及Aggregator"><a href="#Atomic-Aggregate及Aggregator" class="headerlink" title="Atomic_Aggregate及Aggregator"></a>Atomic_Aggregate及Aggregator</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/26.png"></p>
<p>Atomic_Aggregate属于公认任意属性，而Aggregator属性属于可选过渡属性。</p>
<blockquote>
<p>•R3上通过<strong>aggregate</strong>命令将BGP路由10.0.1.0/24、10.0.2.0/24、10.0.3.0/24、10.0.4.0/24聚合成了10.0.0.0/16，并使用<strong>detail-suppressed</strong>抑制了明细路由的对外发布，R3只会将聚合后的BGP路由传递给R4，而不传递聚合前的明细路由。</p>
<p>•Atomic_Aggregate是一个公认自由决定属性，它只相当于一种预警标记，而并不承载任何信息。当路由器收到一条BGP路由更新且发现该条路由携带Atomic_Aggregate属性时，它便知道该条路由可能出现了路径属性的丢失，此时该路由器把这条路由再通告给其他对等体时，需保留路由的Atomic_Aggregate属性。另外，收到该路由更新的路由器不能将这条路由再度明细化。</p>
<p>•另一个重要的属性是Aggregator，这是一个可选传递属性，当路由聚合被执行时，执行路由聚合操作的路由器可以为该聚合路由添加Aggregator属性，并在该属性中记录本地AS号及自己的Router-ID，因此Aggregator属性用于标记路由聚合行为发生在哪个AS及哪台BGP路由器上</p>
</blockquote>
<h2 id="查看聚合之后的路由"><a href="#查看聚合之后的路由" class="headerlink" title="查看聚合之后的路由"></a>查看聚合之后的路由</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/27.png"></p>
<p>在BGP路由详细信息中可与看到Aggregator属性记录了聚合设备的AS号、Router ID，同时通过Atomic-Aggregate属性标明该路由为聚合路由。</p>
<h2 id="Preferred-Value介绍"><a href="#Preferred-Value介绍" class="headerlink" title="Preferred-Value介绍"></a>Preferred-Value介绍</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/28.png"></p>
<p>•Preferred-Value（协议首选值）是华为设备的特有属性，该属性仅在本地有效。当BGP路由表中存在到相同目的地的路由时，将优先选择Preferred-Value值高的路由。</p>
<p>•取值范围：0~65535；该值越大，则路由越优先。</p>
<p>•Preferred-Value只能在路由器本地配置，而且只影响本设备的路由优选。该属性不会传递给任何BGP对等体。</p>
<h2 id="在BGP路由表中查看Preferred-Value"><a href="#在BGP路由表中查看Preferred-Value" class="headerlink" title="在BGP路由表中查看Preferred-Value"></a>在BGP路由表中查看Preferred-Value</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/29.png"></p>
<p>Preferred-Value为100的BGP路由优于Preferred-Value为0的路由，在BGP路由表中来自10.0.12.1的BGP路由为最优。</p>
<blockquote>
<p>•Preferred-value在路由表中简写为PrefVal。</p>
</blockquote>
<h1 id="BGP路由反射器"><a href="#BGP路由反射器" class="headerlink" title="BGP路由反射器"></a>BGP路由反射器</h1><h2 id="中转AS中的IBGP问题"><a href="#中转AS中的IBGP问题" class="headerlink" title="中转AS中的IBGP问题"></a>中转AS中的IBGP问题</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/30.png"></p>
<p>•由于水平分割的原因，为了保证中转AS200所有的BGP路由器都能学习到完整的BGP路由，就必须在AS内实现IBGP全互联。然而实现IBGP全互联存在诸多短板：</p>
<ul>
<li><p>路由器需维护大量的TCP及BGP连接，尤其在路由器数量较多时；</p>
</li>
<li><p>AS内BGP网络的可扩展性较差。</p>
</li>
</ul>
<p>•为此可以采用路由反射器技术。</p>
<h2 id="路由反射器角色"><a href="#路由反射器角色" class="headerlink" title="路由反射器角色"></a>路由反射器角色</h2><p>•引入路由反射器之后存在两种角色：</p>
<ul>
<li><p>RR（Route Reflector）：路由反射器</p>
</li>
<li><p>Client：RR客户端</p>
</li>
</ul>
<p>•RR会将学习的路由反射出去，从而使得IBGP路由在AS内传播无需建立IBGP全互联。</p>
<p>•将一台BGP路由器指定为RR的同时，还需要指定其Client。至于Client本身，无需做任何配置，它并不知晓网络中存在RR。</p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/31.png"></p>
<h2 id="路由反射规则"><a href="#路由反射规则" class="headerlink" title="路由反射规则"></a>路由反射规则</h2><p>RR在接收BGP路由时：</p>
<p>▫如果路由反射器从自己的非客户对等体学习到一条IBGP路由，则它会将该路由反射给所有客户</p>
<p>▫如果路由反射器从自己的客户学习到一条IBGP路由，则它会将该路由反射给所有非客户，以及除了该客户之外的其他所有客户</p>
<p>▫如果路由学习自EBGP对等体，则发送给所有客户、非客户IBGP对等体。</p>
<blockquote>
<p>•当路由反射器执行路由反射时，它只将自己使用的、最优的BGP路由进行反射</p>
</blockquote>
<h2 id="反射规则示例-1"><a href="#反射规则示例-1" class="headerlink" title="反射规则示例 (1)"></a>反射规则示例 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/32.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/33.png"></p>
<h2 id="反射规则示例-2"><a href="#反射规则示例-2" class="headerlink" title="反射规则示例 (2)"></a>反射规则示例 (2)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/34.png"></p>
<p>注意此处“反射”和“发送”的区别。“发送”指的是传统情况下（相当于RR不存在的场景下）的BGP路由传递行为，而“反射”指的是遵循路由反射规则的情况下，RR执行的路由传递动作，被反射出去的路由会被RR插入特殊的路径属性。</p>
<blockquote>
<p>•RR将路由反射时不会修改以下的BGP路径属性：Next_Hop、AS_Path、 Local_Preference、MED，如果反射器修改这几个路径属性的值则有可能产生路由环路。</p>
</blockquote>
<h2 id="RR场景下的路由防环"><a href="#RR场景下的路由防环" class="headerlink" title="RR场景下的路由防环"></a>RR场景下的路由防环</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/35.png"></p>
<p>•RR的设定使得IBGP水平分割原则失效，这就可能导致环路的产生，为此RR会为BGP路由添加两个特殊的路径属性来避免出现环路：</p>
<p>​    ▫Originator_ID</p>
<p>​    ▫Cluster_List</p>
<p>•Originator_ID、Cluster_List属性都属于可选过渡类型。</p>
<h2 id="Originator-ID"><a href="#Originator-ID" class="headerlink" title="Originator ID"></a>Originator ID</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/36.png"></p>
<p>•RR将一条BGP路由进行反射时会在反射出去的路由中增加Originator_ID，其值为本地AS中通告该路由的BGP路由器Router ID。</p>
<p>•若AS内存在多个RR，则Originator_ID属性由第一个RR创建，并且不被后续的RR（若有）所更改。</p>
<p>•当BGP路由器收到一条携带Originator_ID属性的IBGP路由，并且Originator_ID属性值与自身的Router ID相同，则它会忽略关于该条路由的更新。</p>
<h2 id="路由反射簇-Cluster"><a href="#路由反射簇-Cluster" class="headerlink" title="路由反射簇 (Cluster)"></a>路由反射簇 (Cluster)</h2><p>•路由反射簇包括反射器RR及其Client。一个AS内允许存在多个路由反射簇（如下图）。</p>
<p>•每一个簇都有唯一的簇ID（Cluster_ID，缺省时为RR的BGP Router ID ）。</p>
<p>•当一条路由被反射器反射后，该RR（该簇）的Cluster_ID就会被添加至路由的Cluster_list属性中。 </p>
<p>•当RR收到一条携带Cluster_list属性的BGP路由，且该属性值中包含该簇的Cluster_ID时，RR认为该条路由存在环路，因此将忽略关于该条路由的更新。</p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/37.png"></p>
<h2 id="Cluster-List"><a href="#Cluster-List" class="headerlink" title="Cluster_List"></a><strong>Cluster_List</strong></h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/38.png"></p>
<p>•R2发送给R1的路由，经过R1反射给R3时除了添加Originator_ID之外还会添加Cluster_List：10.0.1.1。R3再次反射给R4时， Cluster_List值为：10.0.3.3 10.0.1.1，R4再次反射给R1时Cluster_List值为：10.0.4.4 10.0.3.3 10.0.1.1。</p>
<p>•当R4将路由反射给R1时，R1发现Cluster_List包含了自身Cluster_ID，判断存在环路，从而忽略该路由更新。</p>
<h2 id="RR应用举例"><a href="#RR应用举例" class="headerlink" title="RR应用举例"></a>RR应用举例</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/39.png"></p>
<h2 id="配置介绍"><a href="#配置介绍" class="headerlink" title="配置介绍"></a><strong>配置介绍</strong></h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/40.png"></p>
<h2 id="配置案例-1"><a href="#配置案例-1" class="headerlink" title="配置案例 (1)"></a>配置案例 (1)</h2><p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/41.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/42.png"></p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/43.png"></p>
<h2 id="配置案例-2"><a href="#配置案例-2" class="headerlink" title="配置案例 (2)"></a>配置案例 (2)</h2><p>分别在R3、R1查看BGP路由10.4.4.0/24。</p>
<p><img src="/2021/05/10/BGP%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8/44.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选题）AS_Path属性属于哪种类型的BGP属性？(   )</p>
<p>A.可选过渡</p>
<p>B.可选非过渡</p>
<p><strong>C.公认必遵</strong></p>
<p>D.公认任意</p>
<p>2.（简答题）MED值的作用是什么？是否可以跨越AS传递该属性值？</p>
<p><strong>在本AS存在多个入口时通过MED值可影响其他AS选择进入本AS的路径，MED作为可选非过渡属性，不可以跨越AS传递。</strong></p>
<p>3.（简单题）为防止环路产生，路由反射器使用了何种路径属性？</p>
<p><strong>Originator_ID、Cluster_ID</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•BGP在通告路由时会携带丰富的路径属性，这些属性描述了路由的特征，同时在某些场景下也会影响BGP的路由优选。</p>
<p>•BGP的路径属性可以分为公认属性、可选属性。对于公认属性，所有BGP路由器都必须识别；对于可选属性，不需要所有BGP路由器都能识别。</p>
<p>•为解决IBGP水平分割问题可以采用全互联的IBGP连接，但是该方式需要维护大量的IBGP对等体关系，为此可以部署RR来减少IBGP对等体关系的数量。</p>
<p>•RR的设定打破了IBGP水平分割规则，为了防止路由环路产生，BGP增加了Originator_ID、Cluster_ID两个路径属性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/BGP%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/" itemprop="url">BGP基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-10T17:55:27+08:00">
                2021-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•为方便管理规模不断扩大的网络，网络被分成了不同的AS（Autonomous System，自治系统）。早期，EGP（Exterior Gateway Protocol，外部网关协议）被用于实现在AS之间动态交换路由信息。但是EGP设计得比较简单，只发布网络可达的路由信息，而不对路由信息进行优选，同时也没有考虑环路避免等问题，很快就无法满足网络管理的要求。</p>
<p>•BGP是为取代最初的EGP而设计的另一种外部网关协议。不同于最初的EGP，BGP能够进行路由优选、避免路由环路、更高效率的传递路由和维护大量的路由信息。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述BGP基本概念</p>
<p>▫描述BGP的对等体类型</p>
<p>▫阐明BGP对等体建立过程</p>
<p>▫阐明BGP状态机</p>
<p>▫实现BGP基本配置</p>
<h1 id="BGP概述"><a href="#BGP概述" class="headerlink" title="BGP概述"></a>BGP概述</h1><h2 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h2><p>OSPF、IS-IS等IGP路由协议在组织机构网络内部广泛应用，随着网络规模扩大，网络中路由数量不断增长，IGP已无法管理大规模网络，AS的概念由此诞生。</p>
<p>AS指的是在同一个组织管理下，使用统一选路策略的设备集合。</p>
<p>不同AS通过AS号区分，AS号存在16bit、32bit两种表示方式。IANA负责AS号的分发。</p>
<p>当不同AS之间需要进行通信时，在AS之间应使用何种路由协议进行路由的传递？</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/1.png"></p>
<blockquote>
<p>•IANA（Internet Assigned Numbers Authority，因特网地址分配组织）：IAB（Internet Architecture Board，因特网体系委员会）的下设组织。IANA授权NIC（ Network Information Center，网络信息中心）和其他组织负责IP地址和域名分配，同时，IANA负责维护TCP/IP协议族所采用的协议标识符数据库，包括自治系统号。</p>
<p>•在长度为16bit的AS号表示方式中：64512-65534为私有AS号，在长度为32bit的AS号表示方式中：4200000000-4294967294为私有AS号。</p>
</blockquote>
<h2 id="使用IGP传递路由"><a href="#使用IGP传递路由" class="headerlink" title="使用IGP传递路由"></a>使用IGP传递路由</h2><p>•AS之间需要直连链路，或通过VPN协议构造逻辑直连（例如GRE Tunnel）进行邻居建立。</p>
<p>•AS之间可能是不同的机构、公司，相互之间无法完全信任，使用IGP可能存在暴露AS内部的网络信息的风险。</p>
<p>•整个网络规模扩大，路由数量进一步增加，路由表规模变大，路由收敛变慢，设备性能消耗加大。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/2.png"></p>
<blockquote>
<p>•VPN（virtual private network，虚拟专用网）：使用虚拟专业网络技术可以从逻辑上建立一个直接连接的网络。</p>
</blockquote>
<h2 id="使用BGP传递路由"><a href="#使用BGP传递路由" class="headerlink" title="使用BGP传递路由"></a>使用BGP传递路由</h2><p>为此在AS之间专门使用BGP（Border Gateway Protocol，边界网关协议）协议进行路由传递，相较于传统的IGP协议：</p>
<ul>
<li><p>BGP基于TCP，只要能够建立TCP连接即可建立BGP。</p>
</li>
<li><p>只传递路由信息，不会暴露AS内的拓扑信息。</p>
</li>
<li><p>触发式更新，而不是进行周期性更新。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/3.png"></p>
<h2 id="BGP发展历史"><a href="#BGP发展历史" class="headerlink" title="BGP发展历史"></a>BGP发展历史</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/4.png"></p>
<blockquote>
<p>•目前关于BGP-4最新的RFC是4271，相比较于RFC1771，对于一些细节进行了进一步说明，如事件、状态机以及BGP路由决策流程等。</p>
</blockquote>
<h2 id="BGP在企业中的应用"><a href="#BGP在企业中的应用" class="headerlink" title="BGP在企业中的应用"></a>BGP在企业中的应用</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/5.png"></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/6.png"></p>
<h1 id="BGP的基本概念"><a href="#BGP的基本概念" class="headerlink" title="BGP的基本概念"></a>BGP的基本概念</h1><h2 id="BGP概述-1"><a href="#BGP概述-1" class="headerlink" title="BGP概述"></a>BGP概述</h2><p>•BGP是一种实现自治系统AS之间的路由可达，并选择最佳路由的矢量性协议。早期发布的三个版本分别是BGP-1（RFC1105）、BGP-2（RFC1163）和BGP-3（RFC1267），1994年开始使用BGP-4（RFC1771），2006年之后单播IPv4网络使用的版本是BGP-4（RFC4271），其他网络（如IPv6等）使用的版本是MP-BGP（RFC4760）。 </p>
<p>•BGP的特点：</p>
<ul>
<li>BGP使用TCP作为其传输层协议（端口号为179），使用触发式路由更新，而不是周期性路由更新。</li>
<li>BGP能够承载大批量的路由信息，能够支撑大规模网络。</li>
<li>BGP提供了丰富的路由策略，能够灵活的进行路由选路，并能指导对等体按策略发布路由。</li>
<li>BGP能够支撑MPLS/VPN的应用，传递客户VPN路由。</li>
<li>BGP提供了路由聚合和路由衰减功能用于防止路由振荡，通过这两项功能有效地提高了网络稳定性。</li>
</ul>
<h2 id="BGP特征-1"><a href="#BGP特征-1" class="headerlink" title="BGP特征 (1)"></a>BGP特征 (1)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/7.png"></p>
<p>•BGP使用TCP为传输层协议，TCP端口号179。路由器之间的BGP会话基于TCP连接而建立。</p>
<p>•运行BGP的路由器被称为BGP发言者（BGP Speaker），或BGP路由器。</p>
<p>•两个建立BGP会话的路由器互为对等体（Peer），BGP对等体之间交换BGP路由表。</p>
<p>•BGP路由器只发送增量的BGP路由更新，或进行触发式更新（不会周期性更新）。</p>
<p>•BGP能够承载大批量的路由前缀，可在大规模网络中应用。</p>
<h2 id="BGP特征-2"><a href="#BGP特征-2" class="headerlink" title="BGP特征 (2)"></a>BGP特征 (2)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/8.png"></p>
<p>•BGP通常被称为路径矢量路由协议（Path-Vector Routing Protocol）。</p>
<p>•每条BGP路由都携带多种路径属性（Path attribute），BGP可以通过这些路径属性控制路径选择，而不像IS-IS、OSPF只能通过Cost控制路径选择，因此在路径选择上，BGP具有丰富的可操作性，可以在不同场景下选择最合适的路径控制方式。</p>
<h2 id="BGP对等体关系"><a href="#BGP对等体关系" class="headerlink" title="BGP对等体关系"></a>BGP对等体关系</h2><p>•与OSPF、IS-IS等协议不同，BGP的会话是基于TCP建立的。建立BGP对等体关系的两台路由器并不要求必须直连。</p>
<p>•BGP存在两种对等体关系类型：EBGP及IBGP：</p>
<ul>
<li><p>EBGP（External BGP）：位于不同自治系统的BGP路由器之间的BGP对等体关系。两台路由器之间要建立EBGP对等体关系，必须满足两个条件：</p>
<ul>
<li>两个路由器所属AS不同（即AS号不同）。</li>
<li>在配置EBGP时，Peer命令所指定的对等体IP地址要求路由可达，并且TCP连接能够正确建立。</li>
</ul>
</li>
<li><p>IBGP（Internal BGP）：位于相同自治系统的BGP路由器之间的BGP邻接关系。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/9.png"></p>
<h2 id="BGP对等体关系建立-1"><a href="#BGP对等体关系建立-1" class="headerlink" title="BGP对等体关系建立 (1)"></a>BGP对等体关系建立 (1)</h2><p>先启动BGP的一端先发起TCP连接，如左图所示，R1先启动BGP，R1使用随机端口号向R2的179端口发起TCP连接，完成TCP连接的建立。</p>
<p>三次握手建立完成之后，R1、R2之间相互发送Open报文，携带参数用于对等体建立，参数协商正常之后双方相互发送Keepalive报文，收到对端发送的Keepalive报文之后对等体建立成功，同时双方定期发送Keepalive报文用于保持连接。</p>
<p>其中Open报文中携带：</p>
<ul>
<li><p>My Autonomous System：自身AS号</p>
</li>
<li><p>Hold Time：用于协商后续Keepalive报文发送时间</p>
</li>
<li><p>BGP Identifier：自身Router ID</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/10.png"></p>
<blockquote>
<p>•BGP建立对等体的对等体都会发起TCP三次握手，所以会建立两个TCP连接，但是实际BGP只会保留其中一个TCP连接，从Open报文中获取对端BGP Identifier之后BGP对等体会比较本端的Router ID和对端的Router ID大小，如果本端Router ID小于对端Router ID，则会关闭本地建立的TCP连接，使用由对端主动发起创建的TCP连接进行后续的BGP报文交互。</p>
</blockquote>
<h2 id="BGP对等体关系建立-2"><a href="#BGP对等体关系建立-2" class="headerlink" title="BGP对等体关系建立 (2)"></a>BGP对等体关系建立 (2)</h2><p>BGP对等体关系建立之后，BGP路由器发送BGP Update（更新）报文通告路由到对等体。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/11.png"></p>
<h2 id="TCP连接源地址"><a href="#TCP连接源地址" class="headerlink" title="TCP连接源地址"></a>TCP连接源地址</h2><p>缺省情况下，BGP使用报文出接口作为TCP连接的本地接口。</p>
<p>在部署IBGP对等体关系时，建议使用Loopback地址作为更新源地址。Loopback接口非常稳定，而且可以借助AS内的IGP和冗余拓扑来保证可靠性。</p>
<p>在部署EBGP对等体关系时，通常使用直连接口的IP地址作为源地址，如若使用Loopback接口建立EBGP对等体关系，则应注意EBGP多跳问题。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/12.png"></p>
<h2 id="BGP报文类型-1"><a href="#BGP报文类型-1" class="headerlink" title="BGP报文类型 (1)"></a>BGP报文类型 (1)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/13.png"></p>
<p>BGP存在5种类型的报文，不同类型的报文拥有相同的头部（header）。</p>
<blockquote>
<p>•不同于常见的IGP协议，BGP使用TCP作为传输层协议，端口号179，这使得BGP支持在非直连的路由器之间建立对等体关系。</p>
</blockquote>
<h2 id="BGP报文类型-2"><a href="#BGP报文类型-2" class="headerlink" title="BGP报文类型 (2)"></a>BGP报文类型 (2)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/14.png"></p>
<h2 id="BGP报文格式-报文头格式"><a href="#BGP报文格式-报文头格式" class="headerlink" title="BGP报文格式 - 报文头格式"></a>BGP报文格式 - 报文头格式</h2><p>BGP五种报文都拥有相同的报文头，格式如左侧所示，主要字段解释如下：</p>
<ul>
<li>pMarker：16Byte，用于标明BGP报文边界，所有bit均为“1”。</li>
<li>pLength：2Byte，BGP报文总长度（包括报文头在内），以Byte为单位。</li>
<li>pType：1Byte，BGP报文的类型。其取值从1到5，分别表示Open、Update、Notification、Keepalive和Route-refresh 报文。</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/15.png"></p>
<h2 id="BGP报文格式-Open"><a href="#BGP报文格式-Open" class="headerlink" title="BGP报文格式 - Open"></a>BGP报文格式 - Open</h2><p>Open报文是TCP连接建立之后发送的第一个报文，用于建立BGP对等体之间的连接关系，报文格式如左侧所示，主要字段解释如下：</p>
<ul>
<li><p>pVersion：BGP的版本号。对于BGP 4来说，其值为4。</p>
</li>
<li><p>pMy AS（autonomous system）：本地AS号。通过比较两端的AS号可以判断对端是否和本端处于相同AS。</p>
</li>
<li><p>pHold Time：保持时间。在建立对等体关系时两端要协商Hold Time，并保持一致。如果在这个时间内未收到对端发来的Keepalive报文或Update报文，则认为BGP连接中断。</p>
</li>
<li><p>pBGP Identifier：BGP标识符，以IP地址的形式表示，用来识别BGP路由器。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/16.png"></p>
<blockquote>
<p>•Opt Parm Len：Optional parameters的长度。</p>
<p>•Optional parameters：宣告自身对于一些可选功能的支持，比如认证、多协议支持。</p>
<p>•除了IPv4单播路由信息，BGP4+还支持多种网络层协议（如IPv6、组播），在协商时BGP对等体之间会通过Optional parameters字段协商对网络层协议的支持能力。</p>
</blockquote>
<h2 id="BGP报文格式-Update"><a href="#BGP报文格式-Update" class="headerlink" title="BGP报文格式 - Update"></a>BGP报文格式 - Update</h2><p>•Update报文用于在对等体之间传递路由信息，可以用于发布、撤销路由。</p>
<p>•一个Update报文可以通告具有相同路径属性的多条路由，这些路由保存在NLRI（Network Layer Reachable Information，网络层可达信息）中。同时Update还可以携带多条不可达路由，用于告知对方撤销路由，这些保存在Withdrawn Routes字段中。</p>
<p>•报文格式如左侧所示，主要字段解释如下：</p>
<ul>
<li><p>Withdrawn routes：不可达路由的列表。</p>
</li>
<li><p>Path attributes：与NLRI相关的所有路径属性列表，每个路径属性由一个TLV（Type-Length-Value）三元组构成。</p>
</li>
<li><p>NLRI：可达路由的前缀和前缀长度二元组。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/17.png"></p>
<blockquote>
<p>•Unfeasible routes length：不可达路由字段的长度，以Byte为单位。如果为0则说明没有Withdrawn Routes 字段。</p>
<p>•Withdrawn Routes Length：标明Withdrawn Routes部分的长度。其值为零时，表示没有撤销的路由。</p>
<p>•Total path attribute length：路径属性字段的长度，以Byte为单位。如果为0则说明没有Path Attributes 字段。</p>
</blockquote>
<h2 id="BGP报文格式-Notification"><a href="#BGP报文格式-Notification" class="headerlink" title="BGP报文格式 - Notification"></a>BGP报文格式 - Notification</h2><p>当BGP检测到错误状态时（对等体关系建立时、建立之后都可能发生），就会向对等体发送Notification，告知对端错误原因。之后BGP连接将会立即中断。</p>
<ul>
<li><p>pError Code、Error subcode：差错码、差错子码，用于告知对端具体的错误类型。</p>
</li>
<li><p>pData：用于辅助描述详细的错误内容，长度并不固定。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/18.png"></p>
<h2 id="BGP报文格式-Keepalive"><a href="#BGP报文格式-Keepalive" class="headerlink" title="BGP报文格式 - Keepalive"></a>BGP报文格式 - Keepalive</h2><p>•BGP路由器收到对端发送的Keepalive报文，将对等体状态置为已建立，同时后续定期发送keepalive报文用于保持连接。</p>
<p>•Keepalive报文格式中只包含报文头，没有附加其他任何字段。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/19.png"></p>
<h2 id="BGP报文格式-Route-refresh"><a href="#BGP报文格式-Route-refresh" class="headerlink" title="BGP报文格式 - Route-refresh"></a>BGP报文格式 - Route-refresh</h2><p>•Route-refresh报文用来要求对等体重新发送指定地址族的路由信息，一般为本端修改了相关路由策略之后让对方重新发送Update报文，本端执行新的路由策略重新计算BGP路由。</p>
<p>•相关字段内容如下：</p>
<ul>
<li><p>pAFI：Address Family Identifier，地址族标识，如IPv4。</p>
</li>
<li><p>pRes.：保留，8个bit必须置0。</p>
</li>
<li><p>pSAFI：Subsequent Address Family Identifier，子地址族标识。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/20.png"></p>
<blockquote>
<p>•在Open报文协商时会协商是否支持Route-refresh，如果对等体支持Route-refresh能力，则可以通过<strong>refresh</strong> <strong>bgp</strong>命令手工对BGP连接进行软复位，BGP软复位可以在不中断BGP连接的情况下重新刷新BGP路由表，并应用新的策略。</p>
<p>•对于不支持Route-Refresh能力的BGP对等体，可以配置<strong>keep-all-routes</strong>命令，保留该对等体的所有原始路由，这样不需要复位BGP连接即可完成路由表的刷新。</p>
<p>•缺省情况下未开启<strong>keep-all-routes</strong>。</p>
</blockquote>
<h2 id="BGP状态机-1"><a href="#BGP状态机-1" class="headerlink" title="BGP状态机 (1)"></a>BGP状态机 (1)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/21.png"></p>
<h2 id="BGP状态机-2"><a href="#BGP状态机-2" class="headerlink" title="BGP状态机 (2)"></a>BGP状态机 (2)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/22.png"></p>
<blockquote>
<p>•Idle状态是BGP初始状态。在Idle状态下，BGP拒绝对等体发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态。</p>
<ul>
<li>Start事件是由一个操作者配置一个BGP过程，或者重置一个已经存在的过程或者路由器软件重置BGP过程引起的。</li>
<li>任何状态中收到Notification报文或TCP拆链通知等Error事件后，BGP都会转至Idle状态。</li>
</ul>
<p>•在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。</p>
<ul>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态。</li>
<li>如果TCP连接失败，那么BGP转至Active状态。</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态。</li>
</ul>
<p>•在Active状态下，BGP总是在试图建立TCP连接。</p>
<ul>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态。</li>
<li>如果TCP连接失败，那么BGP停留在Active状态。</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。</li>
</ul>
<p>•在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。</p>
<ul>
<li><p>如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态。</p>
</li>
<li><p>如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。</p>
</li>
</ul>
<p>•在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。</p>
<p>•在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。</p>
<ul>
<li><p>如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。</p>
</li>
<li><p>如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。</p>
</li>
<li><p>Route-refresh报文不会改变BGP状态。</p>
</li>
<li><p>如果收到Notification报文，那么BGP转至Idle状态。</p>
</li>
<li><p>如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态。</p>
</li>
</ul>
</blockquote>
<h2 id="BGP状态机详解-1"><a href="#BGP状态机详解-1" class="headerlink" title="BGP状态机详解 (1)"></a>BGP状态机详解 (1)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/23.png"></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/24.png"></p>
<h2 id="BGP状态机详解-2"><a href="#BGP状态机详解-2" class="headerlink" title="BGP状态机详解 (2)"></a>BGP状态机详解 (2)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/25.png"></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/26.png"></p>
<h2 id="BGP对等体表"><a href="#BGP对等体表" class="headerlink" title="BGP对等体表"></a>BGP对等体表</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/27.png"></p>
<p>•在设备上通过<strong>display</strong> <strong>bgp</strong> <strong>peer</strong>命令查看BGP对等体表，其中主要参数含义：</p>
<ul>
<li><p>Peer：对等体地址</p>
</li>
<li><p>V：version，版本号</p>
</li>
<li><p>AS：对等体AS号</p>
</li>
<li><p>Up/Down：该对等体已经存在up或者down的时间</p>
</li>
<li><p>State：对等体状态，这里显示的为BGP状态机的状态</p>
</li>
<li><p>PrefRcv：prefix received，从该对等体收到的路由前缀数目</p>
</li>
</ul>
<blockquote>
<p>•BGP对等体表的作用为列出本设备的BGP对等体，以及对等体的状态等信息。</p>
<p>•MsgRcvd 、MsgSent：从对等体收到的报文个数，向对等体发送的报文个数。</p>
<p>•OutQ：out queue，对外发送报文队列中排队的个数，一般为0。</p>
</blockquote>
<h2 id="BGP路由表-1"><a href="#BGP路由表-1" class="headerlink" title="BGP路由表 (1)"></a>BGP路由表 (1)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/28.png"></p>
<p>•在设备上通过<strong>display bgp routing-table</strong>查看BGP路由表：</p>
<ul>
<li><p>Network：路由的目的网络地址以及网络掩码</p>
</li>
<li><p>NextHop：下一跳地址</p>
</li>
</ul>
<p>•如果想要查看某条路由更加详细的信息，可以通过<strong>display</strong> <strong>bgp</strong> <strong>routing-table</strong> <em>ipv4-address { mask |</em> <em>mask-length}</em> 查看，该命令会将匹配的BGP路由信息详细展示。</p>
<blockquote>
<p>•列出本设备发现的所有BGP路由，如果到达同一个目的地存在多条路由，则将路由都进行罗列，但每个目的地只会优选一条路由。</p>
</blockquote>
<h2 id="BGP路由表-2"><a href="#BGP路由表-2" class="headerlink" title="BGP路由表 (2)"></a>BGP路由表 (2)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/29.png"></p>
<blockquote>
<p>•通过<strong>display</strong> <strong>bgp</strong> <strong>routing-table</strong> <em>ipv4-address { mask | mask-length }</em> 可以显示指定IP地址/掩码长度的路由信息，在其中有关于该BGP路由的详细信息，如：路由始发者、下一跳地址、路由的路径属性等。</p>
</blockquote>
<h2 id="BGP路由的生成"><a href="#BGP路由的生成" class="headerlink" title="BGP路由的生成"></a>BGP路由的生成</h2><p>•不同于IGP路由协议，BGP自身并不会发现并计算产生路由，BGP将IGP路由表中的路由注入到BGP路由表中，并通过Update报文传递给BGP对等体。</p>
<p>•BGP注入路由的方式有两种：</p>
<ul>
<li><p>Network</p>
</li>
<li><p>import-route</p>
</li>
</ul>
<p>•与IGP协议相同，BGP支持根据已有的路由条目进行聚合，生成聚合路由。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/30.png"></p>
<h2 id="Network注入路由-1"><a href="#Network注入路由-1" class="headerlink" title="Network注入路由 (1)"></a>Network注入路由 (1)</h2><p>通过Network方式注入路由：</p>
<p><strong>1.AS200内的BGP路由器已经通过IGP协议OSPF学习到了两条路由：10.1.0.0/24和10.2.0.0/24，在BGP进程内通过network命令注入这两条路由，这两条路由将会出现在本地的BGP路由表中。</strong></p>
<p><em>2.AS200内的BGP路由器通过Update报文将路由传递给AS300内的BGP路由器。</em></p>
<p><em>3.AS300内的BGP路由器收到路由后，将这两条路由加入到本地的BGP路由表中。</em></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/31.png"></p>
<blockquote>
<p>•Network方式注入的路由必须是已经存在于IP路由表中的路由条目，否则不会被成功注入到BGP路由表中。</p>
</blockquote>
<h2 id="Network注入路由-2"><a href="#Network注入路由-2" class="headerlink" title="Network注入路由 (2)"></a>Network注入路由 (2)</h2><p>通过Network方式注入路由：</p>
<p><em>1.AS200内的BGP路由器已经通过IGP协议OSPF学习到了两条路由：10.1.0.0/24和10.2.0.0/24，在BGP进程内通过network命令注入这两条路由，这两条路由将会出现在本地的BGP路由表中。</em></p>
<p><strong>2.AS200内的BGP路由器通过Update报文将路由传递给AS300内的BGP路由器。</strong></p>
<p><strong>3.AS300内的BGP路由器收到路由后，将这两条路由加入到本地的BGP路由表中。</strong></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/32.png"></p>
<h2 id="import-route方式注入路由"><a href="#import-route方式注入路由" class="headerlink" title="import-route方式注入路由"></a>import-route方式注入路由</h2><p>•Network方式注入路由虽然是精确注入，但是只能一条条配置逐条注入IP路由表中的路由，如果注入的路由条目很多配置命令将会非常复杂，为此可以使用import-route方式，将：</p>
<ol>
<li><p>直连路由</p>
</li>
<li><p>静态路由</p>
</li>
<li><p>OSPF路由</p>
</li>
<li><p>IS-IS路由</p>
</li>
</ol>
<p>等协议的路由注入到BGP路由表中。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/33.png"></p>
<h2 id="BGP聚合路由"><a href="#BGP聚合路由" class="headerlink" title="BGP聚合路由"></a>BGP聚合路由</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/34.png"></p>
<p>与众多IGP协议相同，BGP同样支持路由的手工聚合，在BGP配置视图中使用<strong>aggregate</strong>命令可以执行BGP路由手工聚合，在BGP已经学习到相应的明细路由情况下，设备会向BGP注入指定的聚合路由。</p>
<blockquote>
<p>•执行聚合之后，在本地的BGP路由表中除了原本的明细路由条目之外，还会多出一条聚合的路由条目。</p>
<p>•如果在执行聚合时指定了<strong>detail-suppressed</strong>，则BGP只会向对等体通告聚合后的路由，而不通告聚合前的明细路由。</p>
<p>•在聚合时配置了抑制明细路由的参数，R3上查看路由表，将只能看到BGP路由：10.1.0.0/22，无法看到聚合前的明细路由。</p>
</blockquote>
<h2 id="通告原则"><a href="#通告原则" class="headerlink" title="通告原则"></a>通告原则</h2><p>•BGP通过network、import-route、aggregate聚合方式生成BGP路由后，通过Update报文将BGP路由传递给对等体。</p>
<p>•BGP通告遵循以下原则：</p>
<ul>
<li><p>只发布最优且有效路由。</p>
</li>
<li><p>从EBGP对等体获取的路由，会发布给所有对等体。</p>
</li>
<li><p>IBGP水平分割：从IBGP对等体获取的路由，不会发送给IBGP对等体。</p>
</li>
<li><p>BGP同步规则指的是：当一台路由器从自己的IBGP对等体学习到一条BGP路由时（这类路由被称为IBGP路由），它将不能使用该条路由或把这条路由通告给自己的EBGP对等体，除非它又从IGP协议（例如OSPF等，此处也包含静态路由）学习到这条路由，也就是要求IBGP路由与IGP路由同步。同步规则主要用于规避BGP路由黑洞问题。</p>
</li>
</ul>
<h3 id="BGP路由通告原则一"><a href="#BGP路由通告原则一" class="headerlink" title="BGP路由通告原则一"></a>BGP路由通告原则一</h3><p>•第一条原则：只发布最优且有效（即下一跳地址可达）路由。</p>
<p>•通过<strong>display</strong> <strong>bgp</strong> <strong>routing-table</strong>命令可以查看BGP路由表。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/35.png"></p>
<p>•在BGP路由表中同时存在以下两个标志的路由为最优、有效：</p>
<ul>
<li><p>* : 代表有效</p>
</li>
<li><p>&gt; : 代表最优</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/36.png"></p>
<h3 id="BGP路由通告原则二"><a href="#BGP路由通告原则二" class="headerlink" title="BGP路由通告原则二"></a>BGP路由通告原则二</h3><p>第二条原则：从EBGP对等体获取的路由，会发布给所有对等体。</p>
<p>R2从EBGP对等体获取的BGP路由，会发布给所有EBGP、IBGP对等体。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/37.png"></p>
<h3 id="BGP路由通告原则三-1"><a href="#BGP路由通告原则三-1" class="headerlink" title="BGP路由通告原则三 (1)"></a>BGP路由通告原则三 (1)</h3><p>•第三条原则：从IBGP对等体获取的BGP路由，不会再发送给其他IBGP对等体。</p>
<p>•该条原则也被称为“IBGP水平分割”。</p>
<p>•如图所示，如果IBGP对等体学习到的路由会继续传递给其他的IBGP对等体：</p>
<ul>
<li><p>R2将一条路由传递给了IBGP对等体R3</p>
</li>
<li><p>R3收到路由之后传递给IBGP对等体R1</p>
</li>
<li><p>R1继续传递给IBGP对等体R2</p>
<p>路由环路形成。</p>
</li>
</ul>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/38.png"></p>
<h3 id="BGP路由通告原则三-2"><a href="#BGP路由通告原则三-2" class="headerlink" title="BGP路由通告原则三 (2)"></a>BGP路由通告原则三 (2)</h3><p>•第三条原则可能会带来新的问题，如左侧所示，当BGP路由器R2将路由传递给BGP路由器R1时，由于第三条原则限制，R1无法将BGP路由传递给R3，R3将无法学习到路由。</p>
<p>•为解决该问题可以采用AS内IBGP全互联的方式，即：R2、R3之间建立非直连的IBGP对等体关系，以此让BGP路由器R2将路由传递给BGP路由器 R3。</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/39.png"></p>
<h3 id="BGP路由通告原则四-1"><a href="#BGP路由通告原则四-1" class="headerlink" title="BGP路由通告原则四 (1)"></a>BGP路由通告原则四 (1)</h3><p>•第四条原则：当一台路由器从自己的IBGP对等体学习到一条BGP路由时（这类路由被称为IBGP路由），它将不能使用该条路由或把这条路由通告给自己的EBGP对等体，除非它又从IGP协议（例如OSPF等，此处也包含静态路由）学习到这条路由，该条规则也被称为BGP同步原则。</p>
<p>•如图所示：</p>
<ol>
<li><p>BGP路由器R4上存在一条路由10.0.4.0/24，R4将其传递给了R2。</p>
</li>
<li><p>R2将路由传递给非直连IBGP对等体R3。</p>
</li>
<li><p>R3将路由传递给R5。</p>
</li>
<li><p>之后R5向10.0.4.4发起访问。</p>
</li>
</ol>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/40.png"></p>
<h3 id="BGP路由通告原则四-2"><a href="#BGP路由通告原则四-2" class="headerlink" title="BGP路由通告原则四 (2)"></a>BGP路由通告原则四 (2)</h3><p>•R5访问10.0.4.4：</p>
<ol>
<li><p>R5查找路由表，将报文发送给R3。</p>
</li>
<li><p>R3收到报文后查找路由表，匹配到一条BGP路由，其下一跳为R2，但是R2为非直连下一跳，需要进行路由迭代，通过IGP学习到的路由迭代出下一跳为R1。R3将报文发送给R1。</p>
</li>
<li><p>R1收到报文后查找路由表，因为R1并非BGP路由器，未与R2建立IBGP对等体关系，因此R1上并无BGP路由10.0.4.0/24，路由查找失败，R1将报文丢弃。</p>
</li>
</ol>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/41.png"></p>
<blockquote>
<p>•产生该问题根本原因为AS200域内未运行BGP的路由器并无从BGP学习到的路由条目，查找路由失败，导致R1丢弃报文。为此制定了BGP同步原则：</p>
<p>当BGP的路由条目也存在于IGP路由表时才对外发送，以图中场景为例，当R3查看IGP路由表，OSPF路由表中并无路由10.0.4.0/24，因此并不会向R5发送该路由，自然也不会产生后续的访问失败问题。</p>
<p>•解决该问题的方式有：</p>
<ul>
<li>将BGP路由重分发到IGP中，基本不会使用该方式。</li>
<li>建立全互联的IBGP对等体关系，让全网所有路由器都拥有BGP路由。</li>
</ul>
</blockquote>
<h1 id="BGP的基本配置"><a href="#BGP的基本配置" class="headerlink" title="BGP的基本配置"></a>BGP的基本配置</h1><h2 id="配置介绍"><a href="#配置介绍" class="headerlink" title="配置介绍"></a>配置介绍</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/42.png"></p>
<blockquote>
<p>•如果没有配置Router ID，则BGP会自动选取系统视图下的Router ID作为BGP协议的Router ID。系统视图下的Router ID选择规则，请参见命令router-id中的描述。</p>
</blockquote>
<h2 id="配置案例-1"><a href="#配置案例-1" class="headerlink" title="配置案例 (1)"></a>配置案例 (1)</h2><p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/43.png"></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/44.png"></p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/45.png"></p>
<h2 id="配置案例-2"><a href="#配置案例-2" class="headerlink" title="配置案例 (2)"></a>配置案例 (2)</h2><p>在R3上查看BGP对等体状态：</p>
<p><img src="/2021/05/10/BGP%E5%9F%BA%E7%A1%80/46.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（简答题）BGP使用的TCP目的端口号是多少？</p>
<p><strong>179</strong></p>
<p>2.（简答题）BGP对等体关系有哪几种？划分的依据是什么？</p>
<p><strong>IBGP、EBGP对等体关系，对等体是否和自身处于一个AS内。</strong></p>
<p>3.（多选题）BGP对等体关系建立、更新路由分别使用（  ）、（  ）报文。</p>
<p>A.Route-refresh</p>
<p><strong>B.Open</strong></p>
<p>C.Notification</p>
<p><strong>D.Update</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•本章节介绍了BGP基础知识，涵盖了：BGP产生的背景、AS的概念、BGP的特征等。</p>
<p>•本章节中我们详细地学习了BGP的对等体关系建立过程以及BGP状态机，学习时将对等体关系建立过程与状态机的转换相结合有助于理解记忆。</p>
<p>• 不同于IGP路由协议，BGP不能自己发现、计算路由条目，其路由条目由IGP协议路由表中的路由发布得到。</p>
<p>•BGP在进行路由通告时遵循四条原则，这些原则对BGP路由传递进行了限制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/IS-IS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/10/IS-IS/" itemprop="url">IS-IS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-10T16:36:30+08:00">
                2021-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•IS-IS（Intermediate System to Intermediate System，中间系统到中间系统）是ISO （International Organization for Standardization，国际标准化组织）为它的CLNP（ConnectionLessNetwork Protocol，无连接网络协议）设计的一种动态路由协议。</p>
<p>•随着TCP/IP协议的流行，为了提供对IP路由的支持，IETF在RFC1195中对IS-IS进行了扩充和修改，使它能够同时应用在TCP/IP和OSI（Open System Interconnect，开放式系统互联）环境中，我们将扩展后的IS-IS称为集成IS-IS。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述IS-IS的基本概念</p>
<p>▫描述IS-IS的工作原理</p>
<p>▫描述IS-IS与OSPF的差异</p>
<p>▫实现IS-IS的常用配置</p>
<h1 id="IS-IS的基本概念"><a href="#IS-IS的基本概念" class="headerlink" title="IS-IS的基本概念"></a>IS-IS的基本概念</h1><h2 id="IS-IS概述"><a href="#IS-IS概述" class="headerlink" title="IS-IS概述"></a>IS-IS概述</h2><p>IS-IS是ISO定义的OSI协议栈中的CLNS（ConnectionLess Network Service，无连接网络服务）的一部分。</p>
<p><img src="/2021/05/10/IS-IS/1.png"></p>
<blockquote>
<p>•IS-IS是一种链路状态路由协议，IS-IS与OSPF在许多方面非常相似，例如运行IS-IS协议的直连设备之间通过发送Hello报文发现彼此，然后建立邻接关系，并交互链路状态信息。</p>
<p>•CLNS由以下三个部分组成：</p>
<p>​    ▫CLNP：类似于TCP/IP中的IP协议。</p>
<p>​    ▫IS-IS：类似于TCP/IP中的OSPF。</p>
<p>​    ▫ES-IS：类似于TCP/IP中的ARP，ICMP等。</p>
<p>•ES：End System，终端系统，类似于IP网络环境中的主机。</p>
<p>•ES-IS：End System to Intermediate System，终端系统到中间系统。</p>
<p>•IP网络环境中不涉及CLNP以及ES-IS，因此本课程不做详细介绍。</p>
</blockquote>
<h2 id="NSAP"><a href="#NSAP" class="headerlink" title="NSAP"></a>NSAP</h2><p>•NSAP（Network Service Access Point，网络服务访问点）是OSI协议栈中用于定位资源的地址，主要用于提供网络层和上层应用之间的接口。NSAP包括IDP及DSP，如下图所示：</p>
<p><img src="/2021/05/10/IS-IS/2.png"></p>
<p>•IDP（Initial Domian Part）相当于IP地址中的主网络号。它是由ISO规定，并由AFI（Authority and Format Identifier）与IDI（Initial Domain Identifier）两部分组成。AFI表示地址分配机构和地址格式，IDI用来标识域。</p>
<p>•DSP（Domian Specific Part）相当于IP地址中的子网号和主机地址。它由High Order DSP、System ID和SEL三个部分组成。High Order DSP用来分割区域，System ID用来区分主机，SEL（NSAP Selector）用来指示服务类型。</p>
<h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>•NET（Network Entity Title，网络实体名称）是OSI协议栈中设备的网络层信息，主要用于路由计算，由区域地址（Area ID）和System ID组成，可以看作是特殊的NSAP（SEL为00的NSAP）。</p>
<p>•NET的长度与NSAP的相同，最长为20Byte，最短为8Byte。</p>
<p>•在IP网络中运行IS-IS时，只需配置NET，根据NET地址设备可以获取到Area ID以及System ID。</p>
<p><img src="/2021/05/10/IS-IS/3.png"></p>
<blockquote>
<p>•Area ID由IDP和DSP中的High Order DSP组成，既能够标识路由域，也能够标识路由域中的区域。因此，它们一起被称为区域地址，相当于OSPF中的区域编号。</p>
<p>​    ▫一般情况下，一个路由器只需要配置一个区域地址，且同一区域中所有节点的区域地址都要相同。为了支持区域的平滑合并、分割及转换，缺省情况下，一个IS-IS进程下最多可配置3个区域地址。</p>
<p>•System ID用来在区域内唯一标识主机或路由器。在设备的实现中，它的长度固定为6Byte。</p>
</blockquote>
<h2 id="NET的配置举例"><a href="#NET的配置举例" class="headerlink" title="NET的配置举例"></a>NET的配置举例</h2><p>•每台运行IS-IS的网络设备至少需拥有一个NET，当然，一台设备也可以同时配置多个NET，但是这些NET的System ID必须相同。</p>
<p>•在华为的网络设备上，System ID的长度总是固定的6Byte。在一个IS-IS路由域中，设备的System ID必须唯一，为了便于管理，一般根据Router ID配置System ID。</p>
<p><img src="/2021/05/10/IS-IS/4.png"></p>
<h2 id="IS-IS和OSPF区域划分的区别"><a href="#IS-IS和OSPF区域划分的区别" class="headerlink" title="IS-IS和OSPF区域划分的区别"></a>IS-IS和OSPF区域划分的区别</h2><p>•IS-IS在自治系统内采用骨干区域与非骨干区域两级的分层结构：</p>
<p>​    ▫Level-1路由器部署在非骨干区域。</p>
<p>​    ▫Level-2路由器和Level-1-2路由器部署在骨干区域。</p>
<p>•每一个非骨干区域都通过Level-1-2路由器与骨干区域相连。</p>
<p>如图所示，IS-IS整个骨干区域不仅包括Area49.0002中的所有路由器，还包括其它区域的Level2和Level-1-2路由器。</p>
<p><img src="/2021/05/10/IS-IS/5.png"></p>
<blockquote>
<p>•在学习OSPF过程中，我们已经体会到了多区域、层次化网络设计的好处。对于链路状态路由协议而言，运行了该协议的设备会向网络中通告链路状态信息，同时也收集网络中所泛洪的链路状态信息后加以存储，并最终以这些信息为基础进行计算，从而得到路由信息。如果不采用多区域部署的方式，那么随着网络的规模逐渐增大，网络中泛洪的链路状态信息势必会越来越多，所有设备都将承受更重的负担，路由计算机收敛将逐渐变得更加缓慢，这也使得网络的扩展性变差。</p>
<p>•以上拓扑结构图可以体现IS-IS与OSPF的不同点：</p>
<p>​    ▫在IS-IS中，每个路由器都只属于一个区域；而在OSPF中，一个路由器的不同接口可以属于不同的区域。</p>
<p>​    ▫在IS-IS中，单个区域没有骨干与非骨干区域的概念；而在OSPF中，Area0被定义为骨干区域。</p>
<p>​    ▫在IS-IS中，Level-1和Level-2级别的路由都采用SPF算法，分别生成最短路径树SPT（Shortest Path Tree）；而在OSPF中，只有在同一个区域内才使用SPF算法，区域之间的路由需要通过骨干区域来转发。</p>
</blockquote>
<h2 id="IS-IS路由器的分类-1"><a href="#IS-IS路由器的分类-1" class="headerlink" title="IS-IS路由器的分类 (1)"></a>IS-IS路由器的分类 (1)</h2><p><strong>Level-1路由器</strong></p>
<p>▫Level-1路由器（例如图中的R1）是一种IS-IS区域内部路由器，它只与属于同一区域的Level-1和Level-1-2路由器形成邻接关系，这种邻接关系称为Level-1邻接关系。Level-1路由器无法与Level-2路由器建立邻接关系。</p>
<p>▫Level-1路由器只负责维护Level-1的链路状态数据库LSDB，该LSDB只包含本区域的路由信息。值得一提的是，Level-1路由器必须通过Level-1-2路由器接入IS-IS骨干区域从而访问其他区域。</p>
<p><img src="/2021/05/10/IS-IS/6.png"></p>
<h2 id="IS-IS路由器的分类-2"><a href="#IS-IS路由器的分类-2" class="headerlink" title="IS-IS路由器的分类 (2)"></a>IS-IS路由器的分类 (2)</h2><p><strong>Level-2路由器</strong></p>
<p>▫Level-2路由器（例如图中的R4、R5、R6、R7）是IS-IS骨干路由器，它可以与同一或者不同区域的Level-2路由器或者Level-1-2路由器形成邻接关系。Level-2路由器维护一个Level-2的LSDB，该LSDB包含整个IS-IS域的所有路由信息。</p>
<p>▫所有Level-2级别（即形成Level-2邻接关系）的路由器组成路由域的骨干网，负责在不同区域间通信。路由域中Level-2级别的路由器必须是物理连续的，以保证骨干网的连续性。</p>
<p><img src="/2021/05/10/IS-IS/7.png"></p>
<h2 id="IS-IS路由器的分类-3"><a href="#IS-IS路由器的分类-3" class="headerlink" title="IS-IS路由器的分类 (3)"></a>IS-IS路由器的分类 (3)</h2><p><strong>Level-1-2路由器</strong></p>
<p>▫Level-1-2路由器与OSPF中的ABR非常相似，它也是IS-IS骨干网络的组成部分。</p>
<p>▫Level-1-2路由器维护两个LSDB，Level-1的LSDB用于区域内路由，Level-2的LSDB用于区域间路由。</p>
<p>▫同时属于Level-1和Level-2的路由器称为Level-1-2路由器（例如图中的R2和R3），它可以与同一区域的Level-1和Level-1-2路由器形成Level-1邻接关系，也可以与其他区域的Level-2和Level-1-2路由器形成Level-2的邻接关系。</p>
<p><img src="/2021/05/10/IS-IS/8.png"></p>
<blockquote>
<p>•在华为路由器上配置IS-IS时，缺省时，路由器全局Level为Level-1-2，当然，可以通过命令修改该设备的类型。</p>
</blockquote>
<h2 id="IS-IS支持的网络类型"><a href="#IS-IS支持的网络类型" class="headerlink" title="IS-IS支持的网络类型"></a>IS-IS支持的网络类型</h2><p>IS-IS会自动根据接口的数据链路层封装决定该接口的缺省网络类型， IS-IS支持两种类型的网络：</p>
<p>▫广播（Broadcast）： 如Ethernet。</p>
<p>▫点到点（P2P）： 如PPP、 HDLC等。</p>
<p><img src="/2021/05/10/IS-IS/9.png"></p>
<blockquote>
<p>•对于NBMA网络，需对其配置子接口，并注意子接口类型应配置为P2P。</p>
</blockquote>
<h2 id="IS-IS开销值"><a href="#IS-IS开销值" class="headerlink" title="IS-IS开销值"></a>IS-IS开销值</h2><p>•IS-IS使用Cost（开销）作为路由度量值，Cost值越小，则路径越优。IS-IS链路的Cost与设备的接口有关，与OSPF类似，每一个激活了IS-IS的接口都会维护接口Cost。然而与OSPF不同的是，IS-IS接口的Cost在缺省情况下并不与接口带宽相关（在实际部署时，IS-IS也支持根据带宽调整Cost值），无论接口带宽多大，缺省时Cost为10。</p>
<p>•一条IS-IS路径的Cost等于本路由器到达目标网段沿途的所有链路的Cost总和。</p>
<p>•IS-IS有三种方式来确定接口的开销，按照优先级由高到低分别是：</p>
<p>​    ▫接口开销：为单个接口设置开销。</p>
<p>​    ▫全局开销：为所有接口设置开销。</p>
<p>​    ▫自动计算开销：根据接口带宽自动计算开销。</p>
<p><img src="/2021/05/10/IS-IS/10.png"></p>
<blockquote>
<p>•在早期的ISO10589中，使能IS-IS的接口下最大只能配置值为63的开销值，此时IS-IS的开销类型为narrow。但是在大型网络设计中，较小的度量范围不能满足实际需求。RFC3784中规定，使能IS-IS的接口开销值可以扩展到16777215，此时IS-IS的开销类型为wide。</p>
<p>•缺省时，华为路由器采用的开销类型是narrow。</p>
<p>•narrow类型下使用的TLV：</p>
<p>​    ▫128号TLV（IP Internal Reachability TLV）：用来携带路由域    内的IS-IS路由信息。</p>
<p>​    ▫130号TLV（IP External Reachability TLV）：用来携带路由域    外的IS-IS路由信息。</p>
<p>​    ▫2号TLV(IS Neighbors TLV)：用来携带邻居信息。</p>
<p>•wide类型下使用的TLV：</p>
<p>​    ▫135号TLV(Extended IP Reachability TLV)：用来替换原有的IP     reachability TLV，携带IS-IS路由信息，它扩展了路由开销值的    范围，并可以携带sub TLV。</p>
<p>​    ▫22号TLV（IS Extended Neighbors TLV）：用来携带邻居信息</p>
</blockquote>
<h2 id="IS-IS报文格式"><a href="#IS-IS报文格式" class="headerlink" title="IS-IS报文格式"></a>IS-IS报文格式</h2><p>•IS-IS报文是直接封装在数据链路层的帧结构中的。</p>
<p>•PDU（Protocol Data Unit，协议数据单元）可以分为两个部分，报文头（IS-IS Header）和变长字段部分（Variable Length Fields ）。</p>
<p>•其中IS-IS Header又可分为通用头部（PDU Common Header）和专用头部（PDU Specific Header）。对于所有PDU来说，通用报头都是相同的，但专用报头根据PDU类型不同而有所差别。</p>
<p><img src="/2021/05/10/IS-IS/11.png"></p>
<h2 id="IS-IS通用头部详解"><a href="#IS-IS通用头部详解" class="headerlink" title="IS-IS通用头部详解"></a>IS-IS通用头部详解</h2><p><strong>重要字段解释：</strong></p>
<p>•Intradomain Routing Protocol Discriminator：域内路由选择协议鉴别符，固定为0x83。</p>
<p>•Length Indicator：IS-IS头部的长度（包括通用头部和专用头部），以Byte为单位。</p>
<p>•Version/Protocol ID Extension：版本/协议标识扩展，固定为0x01。</p>
<p>•System ID Length：NSAP地址或NET中System ID区域的长度。值为0时，表示System ID区域的长度为6Byte。</p>
<p>•R（Reserved）：保留，固定为0。</p>
<p>•Version：固定为0x01。</p>
<p>•Max.Areas：支持的最大区域个数。设置为1～254的整数，表示该IS-IS进程实际所允许的最大区域地址数；设置为0，表示该IS-IS进程最大只支持3个区域地址数。</p>
<p><img src="/2021/05/10/IS-IS/12.png"></p>
<h2 id="IS-IS报文类型概述"><a href="#IS-IS报文类型概述" class="headerlink" title="IS-IS报文类型概述"></a>IS-IS报文类型概述</h2><p>•IS-IS的PDU有4种类型：IIH(IS-IS Hello)，LSP（ Link State PDU，链路状态报文），CSNP（Complete Sequence Number PDU，全序列号报文），PSNP（Partial Sequence Number PDU，部分序列号报文）。</p>
<p>•IIH：用于建立和维持邻接关系， 广播网络中的Level-1 IS-IS路由器使用Level-1 LAN IIH； 广播网络中的Level-2 IS-IS路由器使用Level-2 LAN IIH； 点到点网络中则使用P2P IIH。</p>
<p>•LSP：用于交换链路状态信息。LSP分为两种，Level-1 LSP、Level-2 LSP。</p>
<p>•SNP：通过描述全部或部分链路数据库中的LSP来同步各LSDB，从而维护LSDB的完整与同步。SNP包括CSNP和PSNP，进一步又可分为Level-1 CSNP、 Level-2 CSNP、 Level-1 PSNP和Level-2 PSNP。</p>
<p><img src="/2021/05/10/IS-IS/13.png"></p>
<h2 id="IS-IS常见的TLV"><a href="#IS-IS常见的TLV" class="headerlink" title="IS-IS常见的TLV"></a>IS-IS常见的TLV</h2><p>•TLV的含义是：类型（TYPE），长度（LENGTH），值（VALUE）。实际上是一个数据结构，这个结构包含了这三个字段。</p>
<p>•使用TLV结构构建报文的好处是灵活性和扩展性好。采用TLV使得报文的整体结构固定，增加新特性只需要增加新TLV即可，不需要改变整个报文的整体结构。</p>
<p><img src="/2021/05/10/IS-IS/14.png"></p>
<blockquote>
<p>•TLV也称为CLV（Code-Length-Value）。</p>
</blockquote>
<h1 id="IS-IS工作原理"><a href="#IS-IS工作原理" class="headerlink" title="IS-IS工作原理"></a>IS-IS工作原理</h1><h2 id="邻接关系建立"><a href="#邻接关系建立" class="headerlink" title="邻接关系建立"></a>邻接关系建立</h2><h3 id="IS-IS邻接关系建立原则"><a href="#IS-IS邻接关系建立原则" class="headerlink" title="IS-IS邻接关系建立原则"></a>IS-IS邻接关系建立原则</h3><p>•IS-IS按如下原则建立邻接关系：</p>
<p>​    ▫只有同一层次的相邻路由器才有可能成为邻接。</p>
<p>​    ▫对于Level-1路由器来说，Area ID必须一致。</p>
<p>​    ▫链路两端IS-IS接口的网络类型必须一致。</p>
<p>​    ▫链路两端IS-IS接口的地址必须处于同一网段（默认情况下）。</p>
<p>•由于IS-IS是直接运行在数据链路层上的协议，并且最早设计是给CLNP使用的，IS-IS邻接关系的形成与IP地址无关。但在实际的部署中，在IP网络上运行IS-IS时，需要检查对方的IP地址的。如果接口配置了从IP，那么只要双方有某个IP（主IP或者从IP）在同一网段，就能建立邻接，不一定要主IP相同。</p>
<blockquote>
<p>•通过将以太网接口模拟成点到点接口，可以建立点到点链路邻接关系。</p>
<p>•当链路两端IS-IS接口的地址不在同一网段时，如果配置接口对接收的Hello报文不作IP地址检查，也可以建立邻接关系。</p>
<p>​    ▫对于点到点接口，可以配置接口忽略IP地址检查。</p>
<p>​    ▫对于以太网接口，需要将以太网接口模拟成点到点接口，然后    才可以配置接口忽略IP地址检查。</p>
<p>•一般情况下，一个接口只需配置一个主IP地址，但在有些特殊情况下需要配置从IP地址。比如，一台路由器通过一个接口连接了一个物理网络，但该物理网络的计算机分别属于2个不同的网络，为了使路由器与物理网络中的所有计算机通信，就需要在该接口上配置一个主IP地址和一个从IP地址。路由器的每个三层接口可以配置多个IP地址，其中一个为主IP地址，其余为从IP地址，每个三层接口最多可配置31个从IP地址。</p>
</blockquote>
<h3 id="IIH"><a href="#IIH" class="headerlink" title="IIH"></a>IIH</h3><p>IIH报文用于建立和维持邻接关系，广播网络中的Level-1 IS-IS路由器使用Level-1 LAN IIH；广播网络中的Level-2 IS-IS路由器使用Level-2 LAN IIH；点到点网络中则使用P2P IIH。</p>
<p><strong>Reserved/Circuit</strong> <strong>Type</strong>：表示路由器的类型（01表示L1，10表示L2，11表示L1/L2）。 </p>
<p>Source ID ：发出Hello报文的路由器的System ID。 </p>
<p><strong>Holding Time</strong> ： 保持时间。在此时间内如果没有收到邻接发来的Hello报文，则中止已建立的邻接关系。 </p>
<p><strong>Priority</strong> <strong>：</strong>选举DIS的优先级，取值范围为0～127。数值越大，优先级越高。该字段只在广播网中的Hello消息(LAN IIH消息)携带；点到点网络的Hello消息(P2P IIH消息)没有此字段，也没有此字段之前的R保留位。 </p>
<p><strong>LAN ID</strong> <strong>：</strong> 包括DIS的System ID和伪节点ID。该字段只在广播网中的Hello消息(LAN IIH消息)携带；点到点网络的Hello消息(P2P IIH消息)没有此字段。 </p>
<p><strong>Local Circuit ID</strong> ：本地链路ID。该字段只在点到点网络的Hello消息(P2P IIH消息)携带；广播网中的Hello消息(LAN IIH消息)没有此字段。 </p>
<p><img src="/2021/05/10/IS-IS/15.png"></p>
<h3 id="广播网络中的邻接关系建立过程"><a href="#广播网络中的邻接关系建立过程" class="headerlink" title="广播网络中的邻接关系建立过程"></a>广播网络中的邻接关系建立过程</h3><p>两台运行IS-IS的路由器在交互协议报文实现路由功能之前必须首先建立邻接关系。在不同类型的网络上，IS-IS的邻接建立方式并不相同。在广播网络中，使用三次握手建立邻接关系。</p>
<p>R1及R2通过千兆以太接口互联，这两台直连的Level-1路由器建立邻接关系的过程如下：</p>
<ol>
<li><p>在Down状态下，R1组播发送Level-1 LAN IIH，此报文中邻接列表为空。</p>
</li>
<li><p>R2收到此报文后，将邻接状态标识为Initial。然后，R2再向R1回复Level-1 LAN IIH ，此报文中标识R1为R2的邻接。</p>
</li>
<li><p>R1收到此报文后，将自己与R2的邻接状态标识为Up。然后R1再向R2发送一个标识R2为R1邻接的Level-1 LAN IIH 。</p>
</li>
<li><p>R2收到此报文后，将自己与R1的邻接状态标识为Up。这样，两个路由器成功建立了邻接关系。</p>
</li>
<li><p>广播网络中需要选举DIS，在邻接关系建立后，路由器会等待两个Hello报文间隔，再进行DIS的选举。</p>
</li>
</ol>
<p><img src="/2021/05/10/IS-IS/16.png"></p>
<blockquote>
<p>•Level-1 IIH和Level-2 IIH发送的组播地址分别为01-80-C2-00-00-14、01-80-C2-00-00-15。</p>
<p>•Down：邻接关系的初始状态。</p>
<p>•Initial：收到IIH，但是报文中的邻接列表未包含路由器自身的System ID。</p>
<p>•UP：收到IIS，且邻接列表中包含路由器自身的System ID。</p>
</blockquote>
<h3 id="DIS与伪节点"><a href="#DIS与伪节点" class="headerlink" title="DIS与伪节点"></a>DIS与伪节点</h3><p>•在广播网络中，IS-IS需要在所有的路由器中选举一个路由器作为DIS（Designated Intermediate System）。</p>
<p>•DIS用来创建和更新伪节点（Pseudonodes），并负责生成伪节点的LSP，用来描述这个网络上有哪些网络设备。伪节点是用来模拟广播网络的一个虚拟节点，并非真实的路由器。在IS-IS中，伪节点用DIS的System ID和Circuit ID（非0值）标识。</p>
<p><img src="/2021/05/10/IS-IS/17.png"></p>
<h3 id="IS-IS中的DIS与OSPF中的DR"><a href="#IS-IS中的DIS与OSPF中的DR" class="headerlink" title="IS-IS中的DIS与OSPF中的DR"></a>IS-IS中的DIS与OSPF中的DR</h3><p>•Level-1和Level-2的DIS是分别选举的，用户可以为不同级别的DIS选举设置不同的优先级。</p>
<p>•DIS的选举规则如下：</p>
<p>​    ▫DIS优先级数值最大的被选为DIS。</p>
<p>​    ▫如果优先级数值最大的路由器有多台，则其中MAC地址最大的路由    器会成为DIS。</p>
<p>•DIS发送Hello PDU的时间间隔是普通路由器的1/3，这样可以确保DIS出现故障时能够被更快速地被发现。</p>
<p>•IS-IS中DIS与OSPF协议中DR（Designated Router）的区别：</p>
<p>​    ▫在IS-IS广播网中，优先级为0的路由器也参与DIS的选举，在OSPF中优先级为0的路由器则不参与DR的选举。</p>
<p>​    ▫在IS-IS广播网中，当有新的路由器加入，并符合成为DIS的条件时，这个路由器会被选中成为新的DIS，原有的伪节点被删除。此更改会引起一组新的LSP泛洪。而在OSPF中，当一台新路由器加入后，即使它的DR优先级值最大，也不会立即成为该网段中的DR。</p>
<p>​    ▫在IS-IS广播网中，同一网段上的同一级别的路由器之间都会形成邻接关系，包括所有的非DIS路由器之间也会形成邻接关系。而在OSPF中，路由器只与DR和BDR建立邻接关系。</p>
<h3 id="点到点网络中的邻接关系建立过程"><a href="#点到点网络中的邻接关系建立过程" class="headerlink" title="点到点网络中的邻接关系建立过程"></a>点到点网络中的邻接关系建立过程</h3><p>•点到点网络中，邻接关系的建立使用两次握手方式：只要路由器收到对端发来的Hello报文，就单方面宣布邻接为Up状态，建立邻接关系。</p>
<p>•两次握手机制存在明显的缺陷，华为设备在点到点网络中使用IS-IS时，默认使用三次握手建立邻接关系。此方式通过三次发送P2P IIH最终建立起邻接关系。</p>
<p><img src="/2021/05/10/IS-IS/18.png"></p>
<h2 id="链路状态数据库同步"><a href="#链路状态数据库同步" class="headerlink" title="链路状态数据库同步"></a>链路状态数据库同步</h2><h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p>•IS-IS链路状态报文LSP用于交换链路状态信息。LSP分为两种：Level–1 LSP和Level–2 LSP。Level–1 LSP由Level-1路由器传送，Level–2 LSP由Level-2路由器传送，Level-1-2路由器则可传送以上两种LSP。</p>
<p>•两类LSP有相同的报文格式。</p>
<p><strong>Remaining Lifetime</strong> : LSP的生存时间，以秒为单位。 </p>
<p><strong>LSP ID</strong>:由三部分组成，System ID、伪节点ID和LSP分片后的编号。 </p>
<p><strong>Sequence Number</strong>: LSP的序列号。在路由器启动时所发送的第一个LSP报文中的序列号为1，以后当需要生成新的LSP时，新LSP的序列号在前一个LSP序列号的基础上加1。更高的序列号意味着更新的LSP。</p>
<p><strong>Checksum</strong>： LSP的校验和。 </p>
<p><strong>ATT（Attachment）</strong>：由Level-1-2路由器产生，用来指明始发路由器是否与其它区域相连。虽然此标志位也存在于Level-1和Level-2的LSP中，但实际上此字段只和Level-1-2路由器始发的L1 LSP有关。</p>
<p><strong>OL（LSDB Overload，1bit）</strong>：过载标志位。设置了过载标志位的LSP虽然还会在网络中扩散，但是在计算通过超载路由器的路由时不会被采用。即对路由器设置过载位后，其它路由器在进行SPF计算时不会考虑这台路由器。当路由器内存不足时，系统自动在发送的LSP报文中设置过载标志位。 </p>
<p>**IS Type(2bit)**：生成LSP的路由器的类型。用来指明是Level-1还是Level-2路由器（01表示Level-1，11表示Level-2）。 </p>
<p><img src="/2021/05/10/IS-IS/19.png"></p>
<h3 id="IS-IS的LSDB"><a href="#IS-IS的LSDB" class="headerlink" title="IS-IS的LSDB"></a>IS-IS的LSDB</h3><p><img src="/2021/05/10/IS-IS/20.png"></p>
<blockquote>
<p>•伪节点ID：当该参数不为零时，表示该LSP为伪节点生成。</p>
<p>•分片号：当IS-IS要发布的链路状态协议数据报文PDU（Protocol Data Unit）中的信息量太大时，IS-IS路由器将会生成多个LSP分片，用来携带更多的IS-IS信息。分片号用来区分不同的LSP分片。</p>
</blockquote>
<h3 id="查看非伪节点的LSP"><a href="#查看非伪节点的LSP" class="headerlink" title="查看非伪节点的LSP"></a>查看非伪节点的LSP</h3><p><img src="/2021/05/10/IS-IS/21.png"></p>
<blockquote>
<p>•AREA ADDR：该LSP来源的区域号</p>
<p>•INTF ADDR：该LSP中描述的接口地址</p>
<p>•NBR ID：该LSP中描述的邻接信息</p>
<p>•IP-Internal：该LSP中描述的网段信息</p>
</blockquote>
<h3 id="查看伪节点LSP"><a href="#查看伪节点LSP" class="headerlink" title="查看伪节点LSP"></a>查看伪节点LSP</h3><p><img src="/2021/05/10/IS-IS/22.png"></p>
<h3 id="CSNP"><a href="#CSNP" class="headerlink" title="CSNP"></a>CSNP</h3><p>CSNP包含该设备LSDB中所有的LSP摘要，路由器通过交互 CSNP来判断是否需要同步LSDB。</p>
<p>▫在广播网络上，CSNP由DIS定期发送（缺省的发送周期为10秒）。</p>
<p>▫在点到点网络上，CSNP只在第一次建立邻接关系时发送。</p>
<p><img src="/2021/05/10/IS-IS/23.png"></p>
<h3 id="PSNP"><a href="#PSNP" class="headerlink" title="PSNP"></a>PSNP</h3><p>PSNP只包含部分LSP的摘要信息（与CSNP不同）：</p>
<p>▫当发现LSDB不同步时，PSNP来请求邻居发送新的LSP。</p>
<p>▫在点到的网络中，当收到LSP时，使用PSNP对收到的LSP进行确认。</p>
<p><img src="/2021/05/10/IS-IS/24.png"></p>
<h3 id="广播网络中LSP的同步过程"><a href="#广播网络中LSP的同步过程" class="headerlink" title="广播网络中LSP的同步过程"></a>广播网络中LSP的同步过程</h3><p>广播网络中新加入路由器与DIS同步LSDB数据库的过程：</p>
<ol>
<li><p>新加入的路由器R3首先发送IIH报文，与该广播域中的路由器建立邻接关系。建立邻接关系之后，R3等待LSP刷新定时器超时，然后将自己的LSP发往组播地址（Level-1：01-80-C2-00-00-14；Level-2：01-80-C2-00-00-15）。这样网络上所有的邻接都将收到该LSP。</p>
</li>
<li><p>该网段中的DIS会把收到R3的LSP加入到LSDB中，并等待CSNP报文定时器超时并发送CSNP报文。</p>
</li>
<li><p>R3收到DIS发来的CSNP报文，对比自己的LSDB数据库，然后向DIS发送PSNP报文请求自己没有的LSP。</p>
</li>
<li><p>DIS收到该PSNP报文请求后向R3发送对应的LSP进行LSDB的同步。 </p>
</li>
</ol>
<p><img src="/2021/05/10/IS-IS/25.png"></p>
<h3 id="点到点网络中LSP的同步过程"><a href="#点到点网络中LSP的同步过程" class="headerlink" title="点到点网络中LSP的同步过程"></a>点到点网络中LSP的同步过程</h3><p>点到点网络上LSDB数据库的同步过程：</p>
<p>•R1先与R2建立邻接关系。</p>
<p>•建立邻接关系之后，R1与R2会先发送CSNP给对端设备。如果对端的LSDB与CSNP没有同步，则发送PSNP请求索取相应的LSP。</p>
<p>•假设R2向R1索取相应的LSP。</p>
<ol>
<li><p>R1发送R2请求的LSP的同时启动LSP重传定时器，并等待R2发送的PSNP作为收到LSP的确认。</p>
</li>
<li><p>如果在接口LSP重传定时器超时后，R1没有收到R2发送的PSNP报文作为应答。</p>
</li>
<li><p>则R1重新发送该LSP。</p>
</li>
<li><p>R2收到LSP后，发送PSNP进行确认。</p>
</li>
</ol>
<p><img src="/2021/05/10/IS-IS/26.png"></p>
<h3 id="LSP的处理机制"><a href="#LSP的处理机制" class="headerlink" title="LSP的处理机制"></a>LSP的处理机制</h3><p>IS-IS通过交互LSP实现链路状态数据库同步，路由器收到LSP后，按照以下原则处理：</p>
<p>•若收到的LSP比本地LSP的更优，或者本地没有收到的LSP：</p>
<p>​    ▫在广播网络中：将其加入数据库，并组播发送新的LSP。</p>
<p>​    ▫在点到点网络中：将其加入数据库，并发送PSNP报文来确认收到此    LSP，之后将这新的LSP发送给除了发送该LSP的邻居以外的邻居。</p>
<p>•若收到的LSP和本地LSP无法比较出优劣，则不处理该LSP。</p>
<p><img src="/2021/05/10/IS-IS/27.png"></p>
<blockquote>
<p>•LSP产生的原因，IS-IS路由域内的所有路由器都会产生LSP，以下事件会触发一个新的LSP：</p>
<p>​    ▫邻接Up或Down</p>
<p>​    ▫IS-IS相关接口Up或Down</p>
<p>​    ▫引入的IP路由发生变化</p>
<p>​    ▫区域间的IP路由发生变化</p>
<p>​    ▫接口被赋了新的metric值</p>
<p>​    ▫周期性更新（刷新间隔15min）</p>
</blockquote>
<h2 id="路由计算"><a href="#路由计算" class="headerlink" title="路由计算"></a>路由计算</h2><h3 id="Level-1路由器的路由计算"><a href="#Level-1路由器的路由计算" class="headerlink" title="Level-1路由器的路由计算"></a>Level-1路由器的路由计算</h3><p>•R1是Level-1路由器，只维护Level-1 LSDB，该LSDB中包含同属一个区域的R2及R3以及R1自己产生的Level-1 LSP。</p>
<p>•R1根据LSDB中的Level-1 LSP计算出Area 49.0001内的拓扑，以及到达区域内各个网段的路由信息。</p>
<p>•R2及R3作为Area 49.0001内的Level-1-2路由器，会在它们向该区域下发的Level-1 LSP中设置ATT标志位，用于向区域内的Level-1路由器宣布可以通过自己到达其他区域。 R1作为Level-1路由器，会根据该ATT标志位，计算出指向R2或R3的默认路由。</p>
<p><img src="/2021/05/10/IS-IS/28.png"></p>
<h3 id="Level-1路由器的次优路径的问题"><a href="#Level-1路由器的次优路径的问题" class="headerlink" title="Level-1路由器的次优路径的问题"></a>Level-1路由器的次优路径的问题</h3><p>缺省时， R1只能通过指向R2或R3的默认路由到达区域外部，但是R1距离R2和R3路由器的Cost值相等，那么当R1发送数据包到192.168.20.0/24时，就有可能选择路径2，导致出现次优路径。</p>
<p><img src="/2021/05/10/IS-IS/29.png"></p>
<h3 id="路由渗透"><a href="#路由渗透" class="headerlink" title="路由渗透"></a>路由渗透</h3><p>•缺省情况下，Level-1-2路由器不会将到达其他区域的路由通告本Level-1区域中。</p>
<p>•通过路由渗透，可以将区域间路由通过Leve-1-2路由器传递到Level-1区域，此时Leve-1路由器可以学习到其他区域的详细路由，从而计算出最优路径。</p>
<p><img src="/2021/05/10/IS-IS/31.png"></p>
<h3 id="Level-1-2路由器的路由计算"><a href="#Level-1-2路由器的路由计算" class="headerlink" title="Level-1-2路由器的路由计算"></a>Level-1-2路由器的路由计算</h3><p>•R2及R3都维护Level-1 LSDB，它们能够通过这些LSDB中的LSP计算出Area 49.0001的路由。</p>
<p>•R2及R3都维护Level-2 LSDB，它们能够通过这些LSDB中的LSP计算出Area 49.0002的路由。</p>
<p>•R2及R3将到达Area 49.0001的路由以Level-2 LSP的形式发送到Area 49.0002。</p>
<p><img src="/2021/05/10/IS-IS/32.png"></p>
<h3 id="Level-2路由器的路由计算"><a href="#Level-2路由器的路由计算" class="headerlink" title="Level-2路由器的路由计算"></a>Level-2路由器的路由计算</h3><p>R4及R5作为Level-2路由器，只会维护Level-2 LSDB，它们能够根据该LSDB计算出到达全网各个网段的路由。</p>
<p><img src="/2021/05/10/IS-IS/33.png"></p>
<h1 id="IS-IS的基本配置"><a href="#IS-IS的基本配置" class="headerlink" title="IS-IS的基本配置"></a>IS-IS的基本配置</h1><h2 id="IS-IS协议的基本配置-1"><a href="#IS-IS协议的基本配置-1" class="headerlink" title="IS-IS协议的基本配置 (1)"></a>IS-IS协议的基本配置 (1)</h2><p><img src="/2021/05/10/IS-IS/34.png"></p>
<h2 id="IS-IS协议的基本配置-2"><a href="#IS-IS协议的基本配置-2" class="headerlink" title="IS-IS协议的基本配置 (2)"></a>IS-IS协议的基本配置 (2)</h2><p><img src="/2021/05/10/IS-IS/35.png"></p>
<h2 id="IS-IS协议的基本配置-3"><a href="#IS-IS协议的基本配置-3" class="headerlink" title="IS-IS协议的基本配置 (3)"></a>IS-IS协议的基本配置 (3)</h2><p><img src="/2021/05/10/IS-IS/36.png"></p>
<h2 id="案例：IS-IS配置"><a href="#案例：IS-IS配置" class="headerlink" title="案例：IS-IS配置"></a>案例：IS-IS配置</h2><p><img src="/2021/05/10/IS-IS/37.png"></p>
<p><strong>组网需求</strong></p>
<p>如图所示，现网中有5台路由器。用户希望在这5台路由器实现网络互联，并且因为R1性能相对较低，所以还要使这台路由器处理相对较少的数据信息。同时用户希望R1可以选择最优路径访问192.168.10.0/24和192.168.20.0/24网段。</p>
<p><strong>配置思路</strong></p>
<p>在各路由器上配置IS-IS基本功能，实现网络互联。其中，配置R1为Level-1路由器，可以使这台路由器维护相对少量的数据信息。同时，配置R2和R3为Level-1/2路由器与R4和R5这两台Level-2路由器互联。</p>
<h3 id="案例：R1、R2及R3的配置"><a href="#案例：R1、R2及R3的配置" class="headerlink" title="案例：R1、R2及R3的配置"></a>案例：R1、R2及R3的配置</h3><p><img src="/2021/05/10/IS-IS/38.png"></p>
<h3 id="案例：R4和R5的配置"><a href="#案例：R4和R5的配置" class="headerlink" title="案例：R4和R5的配置"></a>案例：R4和R5的配置</h3><p><img src="/2021/05/10/IS-IS/39.png"></p>
<h3 id="案例：配置验证-查看设备的IS-IS邻接表"><a href="#案例：配置验证-查看设备的IS-IS邻接表" class="headerlink" title="案例：配置验证 (查看设备的IS-IS邻接表)"></a>案例：配置验证 (查看设备的IS-IS邻接表)</h3><p><img src="/2021/05/10/IS-IS/40.png"></p>
<blockquote>
<p>•System Id字段：描述邻接的系统ID</p>
<p>•Interface字段：描述通过该路由器哪个端口与邻接建立邻接关系</p>
<p>•Type：描述与该邻接的邻接关系类型</p>
<p>•PRI：描述该邻接对应端口的DIS优先级</p>
</blockquote>
<h3 id="案例：配置验证-查看设备的IS-IS路由表-1"><a href="#案例：配置验证-查看设备的IS-IS路由表-1" class="headerlink" title="案例：配置验证 (查看设备的IS-IS路由表) (1)"></a>案例：配置验证 (查看设备的IS-IS路由表) (1)</h3><p><img src="/2021/05/10/IS-IS/41.png"></p>
<h3 id="案例：配置验证-查看设备的IS-IS路由表-2"><a href="#案例：配置验证-查看设备的IS-IS路由表-2" class="headerlink" title="案例：配置验证 (查看设备的IS-IS路由表) (2)"></a>案例：配置验证 (查看设备的IS-IS路由表) (2)</h3><p><img src="/2021/05/10/IS-IS/42.png"></p>
<h2 id="路由渗透配置"><a href="#路由渗透配置" class="headerlink" title="路由渗透配置"></a>路由渗透配置</h2><p><img src="/2021/05/10/IS-IS/43.png"></p>
<h2 id="路由渗透验证"><a href="#路由渗透验证" class="headerlink" title="路由渗透验证"></a>路由渗透验证</h2><p>通过查看R1的路由表，我们可以看到新增了两条明细路由192.168.10.0/24以及192.168.20.0/24，两条路由的开销值均为30，当有数据包经由R1到达这两个网段时，不会产生次优路径。</p>
<p><img src="/2021/05/10/IS-IS/44.png"></p>
<h2 id="IS-IS认证的分类"><a href="#IS-IS认证的分类" class="headerlink" title="IS-IS认证的分类"></a>IS-IS认证的分类</h2><p>•IS-IS认证是基于网络安全性的要求而实现的一种认证手段，通过在IS-IS报文中增加认证字段对报文进行认证。当本地路由器接收到远端路由器发送过来的IS-IS报文，如果发现认证密码不匹配，则将收到的报文进行丢弃，达到自我保护的目的。</p>
<p>•根据报文的种类，认证可以分为以下三类：</p>
<p>▫接口认证：在接口视图下配置，对Level-1和Level-2的Hello报文进行认证。</p>
<p>▫区域认证：在IS-IS进程视图下配置，对Level-1的CSNP、PSNP和LSP报文进行认证。</p>
<p>▫路由域认证：在IS-IS进程视图下配置，对Level-2的CSNP、PSNP和LSP报文进行认证。</p>
<p>•根据报文的认证方式，可以分为以下四类：</p>
<p>▫简单认证：将配置的密码直接加入报文中，这种加密方式安全性较其他两种方式低。</p>
<p>▫MD5认证：通过将配置的密码进行MD5算法加密之后再加入报文中，提高密码的安全性。</p>
<p>▫Keychian认证：通过配置随时间变化的密码链表来进一步提升网络的安全性。</p>
<p>▫HMAC-SHA256认证：通过将配置的密码进行HMAC-SHA256算法加密之后再加入报文中，提高密码的安全性。</p>
<h2 id="IS-IS认证详解"><a href="#IS-IS认证详解" class="headerlink" title="IS-IS认证详解"></a>IS-IS认证详解</h2><p><strong>接口认证</strong></p>
<p>▫Hello报文使用的认证密码保存在接口下，发送带认证TLV的认证报文，互相连接的路由器接口必须配置相同的口令。</p>
<p><strong>区域认证</strong></p>
<p>▫区域内的每一台L1路由器都必须使用相同的认证模式和具有共同的钥匙串。</p>
<p><strong>路由域认证</strong></p>
<p>▫IS-IS域内的每一台L2和L1/L2类型的路由器都必须使用相同模式的认证，并使用共同的钥匙串。</p>
<p>▫对于区域和路由域认证，可以设置为SNP和LSP分开认证。</p>
<ul>
<li>本地发送的LSP报文和SNP报文都携带认证TLV，对收到的LSP报文和SNP报文都进行认证检查。</li>
<li>本地发送的LSP报文携带认证TLV，对收到的LSP报文进行认证检查；发送的SNP报文携带认证TLV，但不对收到的SNP报文进行检查。</li>
<li>本地发送的LSP报文携带认证TLV，对收到的LSP报文进行认证检查；发送的SNP报文不携带认证TLV，也不对收到的SNP报文进行认证检查。</li>
<li>本地发送的LSP报文和SNP报文都携带认证TLV，对收到的LSP报文和SNP报文都不进行认证检查。</li>
</ul>
<h2 id="IS-IS认证的配置-1"><a href="#IS-IS认证的配置-1" class="headerlink" title="IS-IS认证的配置 (1)"></a>IS-IS认证的配置 (1)</h2><p><img src="/2021/05/10/IS-IS/45.png"></p>
<h2 id="IS-IS认证的配置-2"><a href="#IS-IS认证的配置-2" class="headerlink" title="IS-IS认证的配置 (2)"></a>IS-IS认证的配置 (2)</h2><p><img src="/2021/05/10/IS-IS/46.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）关于OSPF与IS-IS，说法正确的有？ (   )</p>
<p><strong>A.OSPF及IS-IS都是链路状态路由协议。</strong></p>
<p><strong>B.OSPF仅仅支持IP网络，而集成IS-IS支持CLNP及IP网络。</strong></p>
<p><strong>C.OSPF使用区域号0标识骨干区域。</strong></p>
<p><strong>D.IS-IS骨干区域由Level-2及Level-1-2路由器组成。</strong></p>
<p>2.（多选题）关于Level-1路由器说法正确的有？(   )</p>
<p><strong>A.Level-1路由器只能和相同区域的IS-IS路由器建立邻接关系。</strong></p>
<p>B.Level-1路由器可以和同区域的Level-2路由器建立邻接关系。</p>
<p><strong>C.缺省情况下，Level-1路由器只能通过缺省路由到达区域外部。</strong></p>
<p><strong>D.Level-1路由器的LSDB中只存在Level-1 LSP。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•本课程介绍了IS-IS的基本概念。每一台运行IS-IS的路由器都至少有一个NET地址。IS-IS采用分层架构，所有Level-2和Level-1-2路由器共同构成了骨干区域，同一区域的Level-1路由器构成了普通区域。IS-IS协议有四种报文类型，分别是IIH、CSNP、PSNP、LSP。</p>
<p>•Level-1路由器只维护区域内的LSDB，Level-1路由通过离自己最近的Level-1-2路由器到达区域外部，为了避免次优路径，可以在Level-1-2路由器上部署路由渗透的特性。</p>
<p>•IS-IS支持三种认证类型，分别是接口认证、区域认证、路由域认证。</p>
<p>•IS-IS协议与OSPF协议都是链路路由状态协议，两者都需要维护LSDB，随着网络规模的不断扩大，巨大的LSDB会导致路由器整体性能下降，因此对于这两种路由协议而言，面对更大规模的组网时，需要进行多区域的网络设计。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/" itemprop="url">OSPF特殊区域及其它特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-09T19:04:41+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•在一个大型网络中，OSPF路由器通常需要同时维护由域内路由、域间路由、外部路由构成的数据库。当网络规模不断扩大时，LSDB规模也不断增长。如果某区域不需要为其他区域提供流量中转服务，那么该区域内的路由器就没有必要维护本区域外的链路状态信息。</p>
<p>•OSPF通过划分区域可以减小区域内路由器LSDB的规模，对于那些位于自治系统（AS）边界的非骨干区域的低端路由器来说仍然无法承受，通过OSPF的特殊区域特性可以进一步减少LSA数量和路由表规模。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述OSPF特殊区域类型及相关特征</p>
<p>▫阐明OSPF路由汇总的应用场景及功能优势</p>
<p>▫实现OSPF报文认证的配置</p>
<h1 id="Stub区域和Totally-Stub区域"><a href="#Stub区域和Totally-Stub区域" class="headerlink" title="Stub区域和Totally Stub区域"></a>Stub区域和Totally Stub区域</h1><h2 id="网络规模变大引发的问题"><a href="#网络规模变大引发的问题" class="headerlink" title="网络规模变大引发的问题"></a>网络规模变大引发的问题</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/1.png"></p>
<p>OSPF路由器计算区域内、区域间、外部路由都需要依靠网络中的LSA，当网络规模变大时，设备的LSDB规模也变大，设备的路由计算变得更加吃力，造成设备性能浪费。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/3.png"></p>
<h2 id="传输区域和末端区域"><a href="#传输区域和末端区域" class="headerlink" title="传输区域和末端区域"></a>传输区域和末端区域</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/4.png"></p>
<p>OSPF的区域可分为两种类型：</p>
<p>▫传输区域（Transit Area）：除了承载本区域发起的流量和访问本区域的流量外，还承载了源IP和目的IP都不属于本区域的流量，即“穿越型流量”，如本例中的Area 0。</p>
<p>▫末端区域（Stub Area）：只承载本区域发起的流量和访问本区域的流量，如本例中的Area 1和Area 2。</p>
<h2 id="Stub区域"><a href="#Stub区域" class="headerlink" title="Stub区域"></a>Stub区域</h2><p>•Stub区域的ABR不向Stub区域内传播它接收到的AS外部路由，Stub区域中路由器的LSDB、路由表规模都会大大减小。</p>
<p>•为保证Stub区域能够到达AS外部，Stub区域的ABR将生成一条缺省路由（使用3类LSA描述）。</p>
<p>•配置Stub区域时需要注意下列几点：</p>
<p>​    ▫骨干区域不能被配置为Stub区域。</p>
<p>​    ▫Stub区域中的所有路由器都必须将该区域配置为Stub。</p>
<p>​    ▫Stub区域内不能引入也不接收AS外部路由。</p>
<p>​    ▫虚连接不能穿越Stub区域。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/5.png"></p>
<h2 id="Stub区域的路由表及3类LSA"><a href="#Stub区域的路由表及3类LSA" class="headerlink" title="Stub区域的路由表及3类LSA"></a>Stub区域的路由表及3类LSA</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/6.png"></p>
<h2 id="Totally-Stub区域-1"><a href="#Totally-Stub区域-1" class="headerlink" title="Totally Stub区域 (1)"></a>Totally Stub区域 (1)</h2><p>•Totally Stub区域既不允许AS外部路由在本区域内传播，也不允许区域间路由在本区域内传播。</p>
<p>•Totally Stub区域内的路由器通过本区域ABR下发的缺省路由（使用3类LSA描述）到达其他区域，以及AS外部。</p>
<p>•配置Totally Stub区域时需要注意：</p>
<p>▫与Stub区域配置的区别在于，在ABR上需要追加no-summary关键字。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/7.png"></p>
<blockquote>
<p>•思考：为什么非ABR设备不需要追加no-summary参数呢？</p>
</blockquote>
<h2 id="Totally-Stub区域-2"><a href="#Totally-Stub区域-2" class="headerlink" title="Totally Stub区域 (2)"></a>Totally Stub区域 (2)</h2><p>•Totally Stub区域访问其他区域及AS外部是通过默认路由实现的。</p>
<p>•AS外部、其他OSPF区域的拓扑及路由变化不会导致Totally Stub区域内的路由器进行路由重计算，减少了设备性能浪费。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/8.png"></p>
<p>Stub区域、Totally Stub区域解决了末端区域维护过大LSDB带来的问题，但对于某些特定场景，它们并不是最佳解决方案。</p>
<h1 id="NSSA区域和Totally-NSSA区域"><a href="#NSSA区域和Totally-NSSA区域" class="headerlink" title="NSSA区域和Totally NSSA区域"></a>NSSA区域和Totally NSSA区域</h1><h2 id="Stub区域与Totally-Stub区域存在的问题"><a href="#Stub区域与Totally-Stub区域存在的问题" class="headerlink" title="Stub区域与Totally Stub区域存在的问题"></a>Stub区域与Totally Stub区域存在的问题</h2><p>•OSPF规定Stub区域是不能引入外部路由的，这样可以避免大量外部路由引入造成设备资源消耗。</p>
<p>•对于既需要引入外部路由又要避免外部路由带来的资源消耗的场景，Stub和Totally Stub区域就不能满足需求了。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/9.png"></p>
<h2 id="NSSA区域与Totally-NSSA区域"><a href="#NSSA区域与Totally-NSSA区域" class="headerlink" title="NSSA区域与Totally NSSA区域"></a>NSSA区域与Totally NSSA区域</h2><p>•NSSA区域能够引入外部路由，同时又不会学习来自OSPF网络其它区域引入的外部路由。</p>
<p>•Totally NSSA与NSSA区域的配置区别在于前者在ABR上需要追加no-summary关键字。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/10.png"></p>
<blockquote>
<p>NSSA区域能够引入外部路由，同时又不会学习来自OSPF网络其它区域的外部路由。</p>
<p>▫7类LSA是为了支持NSSA区域而新增的一种LSA类型，用于描述NSSA区域引入的外部路由信息。NSSA区域的ASBR将外部路由引入该区域后，使用7类LSA描述这些路由。</p>
<p>▫7类LSA的扩散范围仅限于始发NSSA区域，7类LSA不会被注入到普通区域。</p>
<p>▫NSSA区域的ABR会将7类LSA转化为5类LSA，并将该LSA注入到骨干区域，从而在整个OSPF域内泛洪。</p>
<p>▫NSSA区域的ABR会阻挡其他区域引入的外部路由引入本区域，即NSSA区域内不会存在4类及5类LSA，为了让NSSA区域内的路由器能够通过骨干区域到达AS外部，NSSA区域的ABR会自动向该区域注入一条缺省路由，该路由采用7类LSA描述。</p>
</blockquote>
<h2 id="NSSA区域与Totally-NSSA区域的LSDB"><a href="#NSSA区域与Totally-NSSA区域的LSDB" class="headerlink" title="NSSA区域与Totally NSSA区域的LSDB"></a>NSSA区域与Totally NSSA区域的LSDB</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/11.png"></p>
<blockquote>
<p>•场景1（将Area 2配置为NSSA区域）：当R5将外部路由192.168.3.0/24引入NSSA区域时，R5作为ASBR生成7类LSA在Area 2内泛洪；R3生成使用7类LSA描述的缺省路由注入Area 2，Area 2内的路由器依然会收到R3注入的3类LSA，并计算出到达其他区域的区域间路由。</p>
<p>•场景2（将Area2配置为Totally NSSA区域）：Totally NSSA区域和NSSA区域类似，只是Totally NSSA区域的ABR会阻挡3类LSA进入该区域，因此在场景2中，R3不会将区域间路由注入Area 2，故而在R5的LSDB中，仅会看到一条描述缺省路由的3类LSA。</p>
</blockquote>
<h2 id="OSPF-LSA回顾"><a href="#OSPF-LSA回顾" class="headerlink" title="OSPF LSA回顾"></a>OSPF LSA回顾</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/12.png"></p>
<h2 id="路由器对LSA的处理原则"><a href="#路由器对LSA的处理原则" class="headerlink" title="路由器对LSA的处理原则"></a>路由器对LSA的处理原则</h2><p>OSPF通过交互LSA实现链路状态数据库同步，路由器收到LSA后，按照以下原则处理：</p>
<p>▫如果收到的LSA本地没有，则更新LSDB并泛洪该LSA。</p>
<p>▫如果本地LSDB已存在该LSA，但是收到的更新，则更新LSDB并泛洪该LSA。</p>
<p>▫如果收到的LSA和LSDB中相同，则忽略，并终止泛洪。</p>
<p>▫如果收到的LSA损坏，例如Checksum错误，则不接收该LSA。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/13.png"></p>
<h1 id="区域间路由汇总和外部路由汇总"><a href="#区域间路由汇总和外部路由汇总" class="headerlink" title="区域间路由汇总和外部路由汇总"></a>区域间路由汇总和外部路由汇总</h1><h2 id="在ABR执行路由汇总"><a href="#在ABR执行路由汇总" class="headerlink" title="在ABR执行路由汇总"></a>在ABR执行路由汇总</h2><p>•路由汇总又被称为路由聚合，即是将一组前缀相同的路由汇聚成一条路由，从而达到减小路由表规模以及优化设备资源利用率的目的，我们把汇聚之前的这组路由称为精细路由或明细路由，把汇聚之后的这条路由称为汇总路由或聚合路由。</p>
<p>•OSPF路由汇总的类型：</p>
<p>​    ▫在ABR执行路由汇总：对区域间的路由执行路由汇总。</p>
<p>​    ▫在ASBR执行路由汇总：对引入的外部路由执行路由汇总。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/14.png"></p>
<h2 id="在ASBR执行路由汇总"><a href="#在ASBR执行路由汇总" class="headerlink" title="在ASBR执行路由汇总"></a>在ASBR执行路由汇总</h2><p>•在ASBR配置路由汇总后，ASBR将对自己所引入的外部路由进行汇总。</p>
<p>•NSSA区域的ASBR也可以对引入NSSA区域的外部路由进行汇总。</p>
<p>•在NSSA区域中，ABR执行7类LSA转化成5类LSA动作，此时它也是ASBR。若配置路由汇总，则对由7类LSA转化成的5类LSA进行汇总。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/15.png"></p>
<blockquote>
<p>•R1、R3、R5分别对引入的外部路由执行路由汇总。</p>
</blockquote>
<h1 id="OSPF协议特性"><a href="#OSPF协议特性" class="headerlink" title="OSPF协议特性"></a>OSPF协议特性</h1><h2 id="Silent-Interface"><a href="#Silent-Interface" class="headerlink" title="Silent-Interface"></a>Silent-Interface</h2><p>•通过Silent-Interface的配置，增强OSPF的组网适应能力，减少系统资源的消耗。</p>
<p>•Silent-Interface有以下特性：</p>
<p>​    ▫Silent-Interface不会接收和发送OSPF报文。</p>
<p>​    ▫Silent-Interface的直连路由仍可以发布出去。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/16.png"></p>
<h2 id="OSPF报文认证"><a href="#OSPF报文认证" class="headerlink" title="OSPF报文认证"></a>OSPF报文认证</h2><p>•OSPF支持报文认证功能，只有通过认证的OSPF报文才能被接收。</p>
<p>•路由器支持两种OSPF报文认证方式，当两种认证方式都存在时，优先使用接口认证方式：</p>
<p>​    ▫区域认证方式：一个OSPF区域中所有的路由器在该区域下的认证模式和口令必须一致。</p>
<p>​    ▫接口认证方式：相邻路由器直连接口下的认证模式和口令必须一致。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/17.png"></p>
<blockquote>
<p>区域视图下，配置OSPF区域的认证模式。</p>
<ul>
<li>执行命令<strong>authentication-mode simple</strong>  [ <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> ]，配置OSPF区域的认证模式。<ul>
<li>plain表示明文口令类型。</li>
<li>cipher表示密文口令类型。对于MD5/HMAC-MD5认证模式，当此参数缺省时，默认为cipher类型。</li>
</ul>
</li>
</ul>
<p>配置接口认证方式。</p>
<ul>
<li>执行命令<strong>ospf</strong> <strong>authentication-mode simple</strong> [ <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> ]，配置OSPF接口的认证模式。</li>
</ul>
</blockquote>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）OSPF定义了以下哪几种特殊区域？(   )</p>
<p><strong>A.Stub Area</strong></p>
<p><strong>B.Totally Stub Area</strong></p>
<p><strong>C.Not-So-Stubby Area（NSSA)</strong></p>
<p><strong>D.Totally NSSA</strong></p>
<p>2.（简答题）Stub区域与Totally Stub区域的主要差别是什么？</p>
<p><strong>Stub区域不允许4类和5类LSA进入，但允许3类LSA进入。Totally Stub区域不仅不允许4类和5类LSA进入，同时也不允许3类LSA进入，只允许表示缺省路由的3类LSA进入。</strong></p>
<p>3.（简答题）区域间路由汇总功能在什么路由器上配置？</p>
<p><strong>在ABR上配置</strong></p>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><p>•本章详细介绍了OSPF特殊区域，Stub区域内的路由器通过缺省路由到达外部网络、Totally Stub区域内的路由器通过缺省路由到达外部网络和OSPF区域间网络；NSSA、Totally NSSA区域内的路由器可引入外部路由。</p>
<p>•在本章还介绍了OSPF协议的特性。包括Silent-Interface、认证、以及OSPF路由器收到LSA时的处理方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/" itemprop="url">OSPF路由计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-09T19:04:13+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•同一区域内的OSPF路由器拥有完全一致的LSDB，在区域内部，OSPF采用SPF算法完成路由计算。</p>
<p>•随着网络规模不断扩大，路由器为了完成路由计算所消耗的内存、CPU资源也越来越多。通过区域划分可以在一定程度上缓解路由器的压力。</p>
<p>•在大规模网络中除了OSPF之外，还可能存在其它路由协议，OSPF支持外部路由引入，从而使得OSPF路由器知晓到达域外的路由。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫解释LSA关键字段的作用；</p>
<p>▫描述常见的LSA类型及其功能；</p>
<p>▫阐明SPF算法；</p>
<p>▫描述OSPF区域内路由、区域间路由计算原理；</p>
<p>▫描述OSPF区域间路由的防环机制；</p>
<p>▫描述OSPF外部路由计算原理。</p>
<h1 id="区域内路由计算"><a href="#区域内路由计算" class="headerlink" title="区域内路由计算"></a>区域内路由计算</h1><h2 id="LSA概述"><a href="#LSA概述" class="headerlink" title="LSA概述"></a>LSA概述</h2><h3 id="LSA的基本概念"><a href="#LSA的基本概念" class="headerlink" title="LSA的基本概念"></a>LSA的基本概念</h3><p>•LSA是OSPF进行路由计算的关键依据。</p>
<p>•OSPF的LSU报文可以携带多种不同类型的LSA。</p>
<p>•各种类型的LSA拥有相同的报文头部。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/1.png"></p>
<p><strong>重要字段解释</strong></p>
<p>•<strong>LS Age</strong>（链路状态老化时间）：此字段表示LSA已经生存的时间，单位是秒。</p>
<p>•<strong>Options</strong>（可选项）：每一个bit都对应了OSPF所支持的某种特性。</p>
<p>•<strong>LS Type</strong>（链路状态类型）<strong>：</strong>指示本LSA的类型。</p>
<p>•<strong>Link State ID</strong>（链路状态ID）<strong>：</strong>不同的LSA，对该字段的定义不同。</p>
<p>•<strong>Advertising Router</strong>（通告路由器）：产生该LSA的路由器的Router ID。</p>
<p>•<strong>LS</strong> <strong>Sequence</strong> <strong>Number</strong>（链路状态序列号）：当LSA每次有新的实例产生时，序列号就会增加。</p>
<p>•<strong>LS Checksum</strong>（校验和）：用于保证数据的完整性和准确性。</p>
<p>•<strong>Length</strong>：是一个包含LSA头部在内的LSA的总长度值。</p>
<blockquote>
<p>•链路状态类型、链路状态ID、通告路由器三元组唯一地标识了一个LSA。</p>
<p>•链路状态老化时间 、链路状态序列号 、校验和用于判断LSA的新旧</p>
<p>•LS Age：当LSA被始发时，该字段为0，随着LSA在网络中被泛洪，该时间逐渐累加，当到达MaxAge（缺省值为3600s）时，LSA不再用于路由计算。</p>
<p>•LS Sequence Number：该字段用于判断LSA的新旧或是否存在重复的实例。序列号范围是0x80000001-0x7FFFFFFF，路由器始发一个LSA，序列号为0x80000001，之后每次更新序列号加1，当LSA达到最大序列号时，重新产生该LSA，并且把序列号设置为0x80000001。</p>
</blockquote>
<h3 id="常见LSA的类型"><a href="#常见LSA的类型" class="headerlink" title="常见LSA的类型"></a>常见LSA的类型</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/2.png"></p>
<blockquote>
<p>•在许多场合中，我们习惯使用类型值来称呼对应的LSA，例如1类LSA等同于Router LSA，2类LSA等同于Network LSA，以此类推。</p>
</blockquote>
<h2 id="Router-LSA"><a href="#Router-LSA" class="headerlink" title="Router-LSA"></a>Router-LSA</h2><h3 id="Router-LSA详解-1"><a href="#Router-LSA详解-1" class="headerlink" title="Router LSA详解 (1)"></a>Router LSA详解 (1)</h3><p>•Router LSA（1类LSA）：每台OSPF路由器都会产生。它描述了该路由器直连接口的信息。</p>
<p>•Router LSA只能在所属的区域内泛洪。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/3.png"></p>
<p>•V (Virtual Link ) ：如果产生此LSA的路由器是虚连接的端点，则置为1。 </p>
<p>•E (External )： 如果产生此LSA的路由器是ASBR，则置为1。 </p>
<p>•B (Border )：如果产生此LSA的路由器是ABR，则置为1。 </p>
<p>•links ：LSA中的Link（链路）数量。Router LSA使用Link来承载路由器直连接口的信息。</p>
<h3 id="Router-LSA详解-2"><a href="#Router-LSA详解-2" class="headerlink" title="Router LSA详解 (2)"></a>Router LSA详解 (2)</h3><p>•Router LSA使用Link来承载路由器直连接口的信息。</p>
<p>•每条Link均包含“链路类型”、“链路ID”、“链路数据”以及“度量值”这几个关键信息。</p>
<p>•路由器可能会采用一个或者多个Link来描述某个接口。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/4.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/5.png"></p>
<blockquote>
<p>•度量值（Metric）：Cost值。</p>
</blockquote>
<h3 id="Router-LSA描述P2P网络"><a href="#Router-LSA描述P2P网络" class="headerlink" title="Router LSA描述P2P网络"></a>Router LSA描述P2P网络</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/6.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/7.png"></p>
<h3 id="Router-LSA描述TransNet"><a href="#Router-LSA描述TransNet" class="headerlink" title="Router LSA描述TransNet"></a>Router LSA描述TransNet</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/8.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/9.png"></p>
<h2 id="Network-LSA"><a href="#Network-LSA" class="headerlink" title="Network-LSA"></a>Network-LSA</h2><h3 id="Network-LSA详解"><a href="#Network-LSA详解" class="headerlink" title="Network LSA详解"></a>Network LSA详解</h3><p>•Network LSA（2类LSA） ：由DR产生，描述本网段的链路状态，在所属的区域内传播。</p>
<p>•Network LSA 记录了该网段内所有与DR建立了邻接关系的OSPF路由器，同时携带了该网段的网络掩码。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/10.png"></p>
<p>•<strong>Link State ID</strong> <strong>：</strong>DR的接口IP地址。</p>
<p>•<strong>Network Mask</strong>：MA网络的子网掩码。</p>
<p>•<strong>Attached Router</strong>：连接到该MA网络的路由器的Router-ID（与该DR建立了邻接关系的邻居的Router-ID，以及DR自己的Router-ID），如果有多台路由器接入该MA网络，则使用多个字段描述。</p>
<h3 id="Network-LSA描述MA网络"><a href="#Network-LSA描述MA网络" class="headerlink" title="Network LSA描述MA网络"></a>Network LSA描述MA网络</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/11.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/12.png"></p>
<h2 id="SPF计算过程"><a href="#SPF计算过程" class="headerlink" title="SPF计算过程"></a>SPF计算过程</h2><h3 id="SPF算法-1"><a href="#SPF算法-1" class="headerlink" title="SPF算法 (1)"></a>SPF算法 (1)</h3><p>Phase 1：构建SPF树。</p>
<p>▫路由器将自己作为最短路径树的树根，根据Router-LSA和Network-LSA中的拓扑信息，依次将Cost值最小的路由器添加到SPF树中。路由器以Router ID或者DR标识。</p>
<p>▫广播网络中DR和其所连接路由器的Cost值为0。</p>
<p>▫SPF树中只有单向的最短路径，保证了OSPF区域内路由计算不会出现环路。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/13.png"></p>
<h3 id="SPF算法-2"><a href="#SPF算法-2" class="headerlink" title="SPF算法 (2)"></a>SPF算法 (2)</h3><p>Phase 2：计算最优路由。</p>
<p>▫将Router-LSA、Network-LSA中的路由信息以叶子节点形式附加在对应的OSPF路由器上，计算最优路由。</p>
<p>▫已经出现的路由信息不会再添加到SPF树干上。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/14.png"></p>
<h3 id="SPF算法举例"><a href="#SPF算法举例" class="headerlink" title="SPF算法举例"></a>SPF算法举例</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/15.png"></p>
<h3 id="构建SPF树-1"><a href="#构建SPF树-1" class="headerlink" title="构建SPF树 (1)"></a>构建SPF树 (1)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/16.png"></p>
<h3 id="构建SPF树-2"><a href="#构建SPF树-2" class="headerlink" title="构建SPF树 (2)"></a>构建SPF树 (2)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/17.png"></p>
<h3 id="构建SPF树-3"><a href="#构建SPF树-3" class="headerlink" title="构建SPF树 (3)"></a>构建SPF树 (3)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/18.png"></p>
<h3 id="构建SPF树-4"><a href="#构建SPF树-4" class="headerlink" title="构建SPF树 (4)"></a>构建SPF树 (4)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/19.png"></p>
<blockquote>
<p>•R3在候选列表中存在两个不同的Cost值，分别为48和2，因此将Cost值较小的添加到最短路径树，并从候选列表中删除。</p>
</blockquote>
<h3 id="构建SPF树-5"><a href="#构建SPF树-5" class="headerlink" title="构建SPF树 (5)"></a>构建SPF树 (5)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/20.png"></p>
<h3 id="构建SPF树-6"><a href="#构建SPF树-6" class="headerlink" title="构建SPF树 (6)"></a>构建SPF树 (6)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/21.png"></p>
<h3 id="构建SPF树-7"><a href="#构建SPF树-7" class="headerlink" title="构建SPF树 (7)"></a>构建SPF树 (7)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/22.png"></p>
<h3 id="计算最优路由"><a href="#计算最优路由" class="headerlink" title="计算最优路由"></a>计算最优路由</h3><p>•从根节点开始依次添加各节点LSA中的路由信息。</p>
<p>•添加顺序为各节点加入SPF树的顺序，已经出现的忽略。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/23.png"></p>
<blockquote>
<p>•第二阶段根据Router LSA中的Stub、Network LSA中的路由信息，完成最优路由的计算。</p>
<p>•从根节点开始，依次添加LSA中的路由信息（添加顺序按照每个节点加入SPF树的顺序）：</p>
<p>▫10.0.1.1（R1）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.13.0/24，Metric=48；</p>
<p>▫10.0.12.2（DR）的Network LSA中，网络号/子网掩码10.0.12.0/24，Metric=1+0=1；</p>
<p>▫10.0.2.2（R2）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.24.0/24，Metric=1+0+48=49；</p>
<p>▫10.0.235.2（DR）的Network LSA中，网络号/子网掩码10.0.235.0/24，Metric=1+0+1=2；</p>
<p>▫10.0.3.3（R3）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.13.0/24，已在R1上，忽略；</p>
<p>▫10.0.5.5（R5）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.45.0/24，Metric=1+0+0+1+48=50；</p>
<p>▫10.0.4.4（R4）的Router LSA中，共2个Stub连接，网络号/子网掩码10.0.24.0/24，已在R2上，忽略；网络号/子网掩码10.0.45.0/24，已在R5上，忽略。</p>
</blockquote>
<h3 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/24.png"></p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1.（多选题）Router-LSA中主要包含哪几种链路类型？(   )</p>
<p><strong>A.P2P</strong></p>
<p><strong>B.TransNet</strong></p>
<p><strong>C.StubNet</strong></p>
<p><strong>D.Vlink</strong></p>
<p>2.（判断题）经过SPF算法计算后，被认为是最优的OSPF路由一定会被放入路由器的路由表。(  )</p>
<p>A.对</p>
<p><strong>B.错</strong></p>
<h2 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h2><p>•OSPF根据LSDB计算路由表，LSDB中可能存在多种类型的LSA，并且所有的LSA有相同的报文头部格式。</p>
<p>•同一区域的OSPF路由器拥有完全一致的LSDB。在只有一个区域的情况下，区域内部主要存在两种类型的LSA，即Router-LSA和Network-LSA。</p>
<p>•每台路由器都会产生Router-LSA，描述了路由器的直连接口信息。</p>
<p>•在MA网络中，DR会产生Network-LSA来描述接入该MA网络的所有路由器的Router-ID（其中包括DR自身），以及这个网络的掩码。</p>
<h1 id="区域间路由计算"><a href="#区域间路由计算" class="headerlink" title="区域间路由计算"></a>区域间路由计算</h1><h2 id="区域间路由计算过程"><a href="#区域间路由计算过程" class="headerlink" title="区域间路由计算过程"></a>区域间路由计算过程</h2><h3 id="大型网络中，单区域OSPF存在的问题"><a href="#大型网络中，单区域OSPF存在的问题" class="headerlink" title="大型网络中，单区域OSPF存在的问题"></a>大型网络中，单区域OSPF存在的问题</h3><p>•一系列连续的OSPF路由器构成的网络称为OSPF域（Domain）。</p>
<p>•OSPF要求网络内的路由器同步LSDB，实现对于网络的一致认知。</p>
<p>•当网络规模越来越大时，LSDB将变得非常臃肿，设备基于该LSDB进行路由计算，其负担也极大地增加了，此外路由器的路由表规模也变大了，这些无疑都将加大路由器的性能损耗。</p>
<p>•当网络拓扑发生变更时，这些变更需要被扩散到整个网络，并可能引发整网的路由重计算。</p>
<p>•单区域的设计，使得OSPF无法部署路由汇总。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/25.png"></p>
<h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>•Router LSA和Network LSA只在区域内泛洪，因此通过区域划分在一定程度上降低网络设备的内存及CPU的消耗。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/26.png"></p>
<p>划分区域后，路由器可以分为两种角色：</p>
<p>区域内部路由器（Internal Router）：该类设备的所有接口都属于同一个OSPF区域。如R1、R4、R5。</p>
<p>区域边界路由器（Area Border Router）：该类设备接口分别连接两个及两个以上的不同区域。如R2、R3。</p>
<h3 id="区域间路由信息传递"><a href="#区域间路由信息传递" class="headerlink" title="区域间路由信息传递"></a>区域间路由信息传递</h3><p>•OSPF区域间路由信息传递是通过ABR产生的Network Summary LSA（3类LSA）实现的。</p>
<p>•以192.168.1.0/24路由信息为例：</p>
<p>​    ▫R2依据Area 1内所泛洪的Router LSA及Network LSA计算得出192.168.1.0/24路由（区域内路由），并将该路由通过Network Summary LSA通告到Area 0。R3根据该LSA可计算出到达192.168.1.0/24的区域间路由。</p>
<p>​    ▫R3重新生成一份Network Summary LSA通告到Area 2中，至此所有OSPF区域都能学习到去往192.168.1.0/24的路由。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/27.png"></p>
<h3 id="Network-Summary-LSA详解"><a href="#Network-Summary-LSA详解" class="headerlink" title="Network Summary LSA详解"></a>Network Summary LSA详解</h3><p>Network Summary LSA（3类LSA）由ABR产生，用于向一个区域通告到达另一个区域的路由。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/28.png"></p>
<h3 id="Network-Summary-LSA示例"><a href="#Network-Summary-LSA示例" class="headerlink" title="Network Summary LSA示例"></a>Network Summary LSA示例</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/29.png"></p>
<h3 id="R1和R3的路由计算"><a href="#R1和R3的路由计算" class="headerlink" title="R1和R3的路由计算"></a>R1和R3的路由计算</h3><p>1.通过区域内SPF的计算，R1到达R2的Cost值为1，R3到达R2的Cost值为2。</p>
<p>2.R1和R3根据收到的Network Summary LSA进行路由计算：</p>
<p>▫R1将到达R2和Cost值和Network Summary LSA所携带的Cost值相加，因此R1到达192.168.1.0/24的Cost值为2。</p>
<p>▫R3将到达R2和Cost值和Network Summary LSA所携带的Cost值相加，因此R3到达192.168.1.0/24的Cost值为3。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/30.png"></p>
<h3 id="R5的路由计算"><a href="#R5的路由计算" class="headerlink" title="R5的路由计算"></a>R5的路由计算</h3><p>1.R3作为ABR，它通过Area 0内泛洪的Network Summary LSA计算出到达192.168.1.0/24的路由，然后重新向Area 2注入到达该网段的Network Summary LSA，其中包含自己到达该网段的Cost（值为3）。</p>
<p>2.R5在SPF中计算得知到达R3的Cost为1，因此R5到达192.168.1.0/24的Cost为4。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/31.png"></p>
<h3 id="区域间路由计算结果验证"><a href="#区域间路由计算结果验证" class="headerlink" title="区域间路由计算结果验证"></a>区域间路由计算结果验证</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/32.png"></p>
<h2 id="区域间路由防环机制"><a href="#区域间路由防环机制" class="headerlink" title="区域间路由防环机制"></a>区域间路由防环机制</h2><h3 id="域间路由环路的产生"><a href="#域间路由环路的产生" class="headerlink" title="域间路由环路的产生"></a>域间路由环路的产生</h3><p>•OSPF区域间路由的传播过程与距离矢量路由协议的路由传播过程非常相似。</p>
<p>•对于区域间路由的传递，OSPF也需要一定的防环机制。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/33.png"></p>
<h3 id="区域间路由的防环机制-1"><a href="#区域间路由的防环机制-1" class="headerlink" title="区域间路由的防环机制 (1)"></a>区域间路由的防环机制 (1)</h3><p>OSPF要求所有的非骨干区域必须与Area0直接相连，区域间路由需经由Area0中转。</p>
<p>区域间的路由传递不能发生在两个非骨干区域之间，这使得OSPF的区域架构在逻辑上形成了一个类似星型的拓扑。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/34.png"></p>
<h3 id="区域间路由的防环机制-2"><a href="#区域间路由的防环机制-2" class="headerlink" title="区域间路由的防环机制 (2)"></a>区域间路由的防环机制 (2)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/35.png"></p>
<h3 id="区域间路由的防环机制-3"><a href="#区域间路由的防环机制-3" class="headerlink" title="区域间路由的防环机制 (3)"></a>区域间路由的防环机制 (3)</h3><p>ABR从非骨干区域收到的3类LSA不能用于区域间路由的计算。</p>
<p>R1和R2、R3和R4之间的链路中断导致骨干区域不连续。</p>
<ul>
<li><p>R4将10.0.2.2/32路由以3类LSA的形式发送到Area 1。</p>
</li>
<li><p>R5和R6可以根据上述3类LSA计算出10.0.2.2/32路由。</p>
</li>
<li><p>R3从非骨干区域收到3类LSA，不进行路由计算，也不会将此3类LSA发送到其他区域。</p>
</li>
<li><p>此时，R1和R3都无法和10.0.2.2/32通信。</p>
</li>
</ul>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/36.png"></p>
<h2 id="虚连接的作用及配置"><a href="#虚连接的作用及配置" class="headerlink" title="虚连接的作用及配置"></a>虚连接的作用及配置</h2><p>•OSPF要求骨干区域必须是连续的，但是并不要求物理上连续，可以使用虚连接使骨干区域在逻辑上连续。</p>
<p>•虚连接可以在任意两个ABR上建立，但是要求这两个ABR都有端口连接到一个相同的非骨干区域。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/37.png"></p>
<blockquote>
<p>•注意：虚连接的创建使OSPF协议可以通过非骨干区域通信，违背了OSPF区域间的防环规则，在某些场景下会导致路由环路的产生，因此不建议部署OSPF虚连接。</p>
</blockquote>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>1.（判断题）一条Network Summary LSA只能描述一条路由信息。</p>
<p>A.错</p>
<p><strong>B.对</strong></p>
<p>2.（简答题）OSPF如何避免区域间的路由环路？</p>
<p><strong>OSPF划分了骨干区域和非骨干区域，所有非骨干区域均直接和骨干区域相连，且骨干区域只有一个；非骨干区域之间的通信都要通过骨干区域中转；并规定从骨干区域传来的三类LSA不再传回骨干区域。</strong></p>
<h2 id="本节小结-1"><a href="#本节小结-1" class="headerlink" title="本节小结"></a>本节小结</h2><p>•OSPF引入了多区域的概念，使得该协议能够支持更大规模的组网。</p>
<p>•OSPF使用3类LSA来描述区域间的路由信息。</p>
<p>•为了避免出现区域间路由环路，OSPF设计了多个规则。</p>
<p>•OSPF Virtual Link是一种虚拟的、逻辑的链路，被部署在两台OSPF路由器之间，它穿越某个非骨干区域，用于实现另一个非骨干区域与Area0的连接。Virtual Link应该始终作为一种临时的技术手段来解决非骨干区域没有与Area0直接相连的情况。</p>
<h1 id="外部路由计算"><a href="#外部路由计算" class="headerlink" title="外部路由计算"></a>外部路由计算</h1><h2 id="OSPF外部路由引入背景"><a href="#OSPF外部路由引入背景" class="headerlink" title="OSPF外部路由引入背景"></a>OSPF外部路由引入背景</h2><p>网络中存在部分链路未开启OSPF协议如：</p>
<p>▫路由器连接外部网络使用静态路由或者BGP协议；</p>
<p>▫服务器直连的链路未开启OSPF协议。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/38.png"></p>
<h2 id="外部路由引入的基本概念"><a href="#外部路由引入的基本概念" class="headerlink" title="外部路由引入的基本概念"></a>外部路由引入的基本概念</h2><p>•ASBR（AS Boundary Router）：自治系统边界路由器。只要一台OSPF设备引入了外部路由，它就成为了ASBR。如图中的R1。</p>
<p>•ASBR将外部路由信息以AS-external LSA（5类LSA）的形式在OSPF网络内泛洪。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/39.png"></p>
<blockquote>
<p>•<strong>在OSPF进程下，通过如下命令引入外部路由。设备支持引入BGP、ISIS、OSPF、直连以及静态路由。</strong></p>
<p>▫<strong>import-route</strong> { <strong>limit</strong> <em>limit-number</em> | { <strong>bgp</strong> [ <strong>permit-ibgp</strong> ] | <strong>direct</strong> | <strong>unr</strong> | <strong>rip</strong> [ <em>process-id-rip</em> ] | <strong>static</strong> | <strong>isis</strong> [ process-id-isis ] | <strong>ospf</strong> [ process-id-ospf ] } [ <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>tag</strong> <em>tag</em> | <strong>route-policy</strong> <em>route-policy-name</em> ]  }</p>
</blockquote>
<h2 id="AS-external-LSA详解"><a href="#AS-external-LSA详解" class="headerlink" title="AS-external LSA详解"></a>AS-external LSA详解</h2><p>AS-external LSA（5类LSA）：由ASBR产生，描述到达AS外部的路由，该LSA会被通告到所有的区域（除了Stub区域和NSSA区域）。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/40.png"></p>
<blockquote>
<p>•Forwarding Address：当FA为0.0.0.0时，则到达该外部网段的流量会被发往引入这条外部路由的ASBR。而如果FA不为0.0.0.0，则流量会被发往这个转发地址。FA这一概念的引入，使得OSPF在某些特殊的场景中得以规避次优路径问题。</p>
<p>•External Route Tag（外部路由标记）：这是一个只有外部路由才能够携带的标记，常被用于部署路由策略。</p>
</blockquote>
<h2 id="AS-external-LSA示例"><a href="#AS-external-LSA示例" class="headerlink" title="AS-external LSA示例"></a>AS-external LSA示例</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/41.png"></p>
<h2 id="R3的路由计算过程"><a href="#R3的路由计算过程" class="headerlink" title="R3的路由计算过程"></a>R3的路由计算过程</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/42.png"></p>
<h2 id="ASBR-Summary-LSA"><a href="#ASBR-Summary-LSA" class="headerlink" title="ASBR-Summary LSA"></a>ASBR-Summary LSA</h2><p>ASBR-Summary LSA（4类LSA）：由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/43.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/44.png"></p>
<h2 id="ASBR-Summary-LSA示例"><a href="#ASBR-Summary-LSA示例" class="headerlink" title="ASBR-Summary LSA示例"></a>ASBR-Summary LSA示例</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/45.png"></p>
<h2 id="R5的路由计算过程"><a href="#R5的路由计算过程" class="headerlink" title="R5的路由计算过程"></a>R5的路由计算过程</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/46.png"></p>
<h2 id="区分OSPF外部路由的2种度量值类型-1"><a href="#区分OSPF外部路由的2种度量值类型-1" class="headerlink" title="区分OSPF外部路由的2种度量值类型 (1)"></a>区分OSPF外部路由的2种度量值类型 (1)</h2><p>•<strong>Metric-Type-1</strong></p>
<p>▫当外部路由的开销与自治系统内部的路由开销相当，并且和OSPF自身路由的开销具有可比性时，可以认为这类路由的可信程度较高，将其配置成Metric-Type-1。</p>
<p>▫Metric-Type-1外部路由的开销为AS内部开销（路由器到ASBR的开销）与AS外部开销之和。</p>
<p>•<strong>Metric-Type-2</strong></p>
<p>▫当ASBR到AS之外的开销远远大于在AS之内到达ASBR的开销时，可以认为这类路由的可信程度较低，将其配置成Metric-Type-2。</p>
<p>▫Metric-Type-2外部路由的开销等于AS外部开销。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/47.png"></p>
<h2 id="区分OSPF外部路由的2种度量值类型-2"><a href="#区分OSPF外部路由的2种度量值类型-2" class="headerlink" title="区分OSPF外部路由的2种度量值类型 (2)"></a>区分OSPF外部路由的2种度量值类型 (2)</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/48.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/49.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/50.png"></p>
<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><p>1.（多选题）ABR可能会产生以下哪些类型的LSA？(   )</p>
<p><strong>A. ASBR-Summary LSA</strong></p>
<p><strong>B. AS-external-LSA</strong></p>
<p><strong>C. Router-LSA</strong></p>
<p><strong>D. Network Summary LSA</strong></p>
<p>2.（单选题）对于同一个路由前缀，以下哪种优先级最高？(   )</p>
<p><strong>A.区域内路由</strong></p>
<p>B.区域间路由</p>
<p>C.第一类外部路由</p>
<p>D.第二类外部路由</p>
<h2 id="本节小结-2"><a href="#本节小结-2" class="headerlink" title="本节小结"></a>本节小结</h2><p>•在一个大规模网络中，可能存在多种不同的路由协议，OSPF支持将AS外部路由引入本AS，使得AS内的路由器能够获知到达AS外部的路由。</p>
<p>•ASBR将外部路由引入OSPF后，使用5类LSA描述它们，与ASBR同属一个区域的路由器能够根据5类LSA以及区域内的1类、2类LSA完成外部路由计算；与ASBR不在同一个区域的路由器还需借助4类LSA才能完成外部路由计算。</p>
<p>•OSPF将外部路由引入OSPF后，可以设置路由的度量值类型：Metric-Type-1或Metric-Type-2，不同度量值类型的外部路由，其开销的计算方式不同，其路由的优先级也不相同，Metric-Type-1路由的优先级高于Metric-Type-2路由。</p>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><p>•本章知识点包括OSPF区域内路由计算、区域间路由计算、外部路由计算等。</p>
<p>•OSPF路由遵循以下优先级顺序，区域内路由&gt;区域间路由&gt;Metric-Type-1外部路由&gt;Metric-Type-2外部路由。</p>
<p>•LSA是OSPF链路状态信息的载体，随着网络规模逐渐变大，网络业务逐渐变得复杂，通过OSPF区域的划分以及大量外部路由的引入，路由器的LSDB中可能存在大量的1类、2类、3类、4类、5类LSA，容易造成设备性能的浪费。</p>
<p>•OSPF存在什么技术手段可以在保证网络可达性的前提下，减少设备性能损耗么？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/" itemprop="url">IP-OSPF基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:14:14+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•路由器根据路由表转发数据包，路由表项可通过手动配置和动态路由协议生成。</p>
<p>•静态路由比动态路由使用更少的带宽，并且不占用CPU资源来计算和分析路由更新。当网络结构比较简单时，只需配置静态路由就可以使网络正常工作。但是当网络发生故障或者拓扑发生变化后，静态路由不会自动更新，必须手动重新配置。</p>
<p>•相比较于静态路由，动态路由协议具有更强的可扩展性，具备更强的应变能力。</p>
<p>•OSPF（Open Shortest Path First，开放式最短路径优先）具有扩展性强，收敛速度快等特点，作为优秀的内部网关协议被广泛使用。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述OSPF路由计算的整体过程</p>
<p>▫阐明DR与BDR的作用</p>
<p>▫描述OSPF报文类型和作用</p>
<p>▫实现OSPF的基本配置</p>
<p>▫区分OSPF邻居关系和邻接关系</p>
<h1 id="动态路由协议简介"><a href="#动态路由协议简介" class="headerlink" title="动态路由协议简介"></a><strong>动态路由协议简介</strong></h1><h2 id="动态路由协议的分类"><a href="#动态路由协议的分类" class="headerlink" title="动态路由协议的分类"></a><strong>动态路由协议的分类</strong></h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/1.png"></p>
<blockquote>
<p>•BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector）算法。因此在某些场合下，BGP也被称为路径矢量路由协议。</p>
<p>•IGP（内部网关协议）在同一个自治系统内交换路由信息，IGP的主要目的是发现和计算自治域内的路由信息。</p>
<p>•EGP（外部网关协议）主要用于AS（自治系统）之间的互联。</p>
</blockquote>
<h2 id="距离矢量路由协议"><a href="#距离矢量路由协议" class="headerlink" title="距离矢量路由协议"></a><strong>距离矢量路由协议</strong></h2><p>•运行距离矢量路由协议的路由器周期性地泛洪自己的路由表。通过路由的交互，每台路由器都从相邻的路由器学习到路由，并且加载进自己的路由表中，然后再通告给其他相邻路由器。</p>
<p>•对于网络中的所有路由器而言，路由器并不清楚网络的拓扑，只是简单的知道要去往某个目的网段方向在哪里，开销有多大。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/2.png"> </p>
<h2 id="链路状态路由协议-LSA泛洪"><a href="#链路状态路由协议-LSA泛洪" class="headerlink" title="链路状态路由协议 - LSA泛洪"></a>链路状态路由协议 - LSA泛洪</h2><p>•链路状态路由协议通告的的是链路状态而不是路由信息。</p>
<p>•运行链路状态路由协议的路由器之间首先会建立邻居关系，然后彼此之间开始交互LSA（Link State Advertisement，链路状态通告）。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/3.png"></p>
<blockquote>
<p>•链路状态通告，可以简单的理解为每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居路由器之间的关系等）的通告。</p>
</blockquote>
<h2 id="链路状态路由协议-LSDB维护"><a href="#链路状态路由协议-LSDB维护" class="headerlink" title="链路状态路由协议 - LSDB维护"></a>链路状态路由协议 - LSDB维护</h2><p>每台路由器都会产生LSA，路由器将接收到的LSA放入自己的LSDB（Link State DataBase，链路状态数据库）。路由器通过对LSDB中所存储的LSA进行解析，进而了解全网拓扑。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/4.png"></p>
<h2 id="链路状态路由协议-SPF计算"><a href="#链路状态路由协议-SPF计算" class="headerlink" title="链路状态路由协议 - SPF计算"></a>链路状态路由协议 - SPF计算</h2><p>每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法进行计算。每台路由器都计算出一棵以自己为根的、无环的、拥有最短路径的“树”。有了这棵“树”，路由器就已经知道了到达所有网段的优选路径。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<p>•SPF是OSPF路由协议的一个核心算法，用来在一个复杂的网络中做出路由优选的决策。</p>
</blockquote>
<h2 id="链路状态路由协议-路由表生成"><a href="#链路状态路由协议-路由表生成" class="headerlink" title="链路状态路由协议 - 路由表生成"></a>链路状态路由协议 - 路由表生成</h2><p>路由器将计算出来的优选路径，加载进自己的路由表（Routing Table）。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/6.png"></p>
<h2 id="链路状态路由协议总结"><a href="#链路状态路由协议总结" class="headerlink" title="链路状态路由协议总结"></a>链路状态路由协议总结</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/7.png"></p>
<blockquote>
<p>链路状态路由协议有四个步骤：</p>
<p>▫第一步是建立相邻路由器之间的邻居关系。</p>
<p>▫第二步是邻居之间交互链路状态信息和同步LSDB。</p>
<p>▫第三步是进行优选路径计算。</p>
<p>▫第四步是根据最短路径树生成路由表项加载到路由表。</p>
</blockquote>
<h1 id="OSPF简介"><a href="#OSPF简介" class="headerlink" title="OSPF简介"></a>OSPF简介</h1><h2 id="OSPF概述"><a href="#OSPF概述" class="headerlink" title="OSPF概述"></a>OSPF概述</h2><p>•OSPF是IETF定义的一种基于链路状态的内部网关路由协议。目前针对IPv4协议使用的是OSPF Version 2（RFC2328）；针对IPv6协议使用OSPF Version 3（RFC2740）。</p>
<p>•OSPF有以下优点：</p>
<p>▫基于SPF算法，以“累计链路开销”作为选路参考值</p>
<p>▫采用组播形式收发部分协议报文</p>
<p>▫支持区域划分</p>
<p>▫支持对等价路由进行负载分担</p>
<p>▫支持报文认证</p>
<h2 id="OSPF应用场景"><a href="#OSPF应用场景" class="headerlink" title="OSPF应用场景"></a>OSPF应用场景</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/8.png"></p>
<p>•接入层：接入层利用光纤、双绞线、同轴电缆、无线接入技术等传输介质，实现与用户连接，并进行业务和带宽的分配。接入层目的是允许终端用户连接到网络，因此接入层交换机具有低成本和高端口密度特性。</p>
<p>•汇聚层：汇聚层为接入层提供基于策略的连接，如地址合并，协议过滤,路由服务，认证管理等。通过网段划分实现与网络隔离，可以防止网络故障蔓延和影响到核心层。汇聚层同时也可以提供接入层虚拟网之间的互连，控制和限制接入层对核心层的访问，保证核心层的安全和稳定。</p>
<p>•核心层：核心层的功能主要是实现骨干网络之间的优化传输，核心层任务的重点通常是冗余能力、可靠性和高速的传输。</p>
<h2 id="OSPF基础术语-Router-ID"><a href="#OSPF基础术语-Router-ID" class="headerlink" title="OSPF基础术语 - Router ID"></a>OSPF基础术语 - Router ID</h2><p>•Router ID用于在自治系统中唯一标识一台运行OSPF的路由器，它是一个32位的无符号整数。</p>
<p>•Router ID选举规则如下：</p>
<p>▫手动配置OSPF路由器的Router ID（建议手动配置）</p>
<p>▫如果没有手动配置Router ID，则路由器使用Loopback接口中最大的IP地址作为Router ID</p>
<p>▫如果没有配置Loopback接口，则路由器使用物理接口中最大的IP地址作为Router ID</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/9.png"></p>
<blockquote>
<p>•Router ID一旦选定，之后如果要更改的话就需要重启OSPF进程。</p>
<p>•在实际工程中，推荐手工指定OSPF路由设备的Router ID。首先规划出一个私有网段用于OSPF的Router ID选择，例如：192.168.1.0/24。在启用OSPF进程前在每个OSPF路由器上建立一个Loopback接口，使用一个32位掩码的私有地址作为其IP地址，这个32位的私有地址即作为该路由设备的Router ID。如果没有特殊要求，这个Loopback接口地址可以不发布在OSPF网络中。</p>
</blockquote>
<h2 id="OSPF基础术语-区域"><a href="#OSPF基础术语-区域" class="headerlink" title="OSPF基础术语 - 区域"></a>OSPF基础术语 - 区域</h2><p>•OSPF Area用于标识一个OSPF的区域。</p>
<p>•区域是从逻辑上将设备划分为不同的组，每个组用区域号（Area ID）来标识。</p>
<p>•OSPF的区域ID是一个32bit的非负整数，按点分十进制的形式（与IPv4地址的格式一样）呈现，例如Area0.0.0.1。为了简便起见，我们也会采用十进制的形式来表示。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/10.png"></p>
<blockquote>
<p>•几个例子：Area0.0.0.1等同于Area1，Area0.0.0.255等同于Area255，Area0.0.1.0等同于Area256。许多网络厂商的设备同时支持这两种区域ID配置及表示方式。</p>
</blockquote>
<h2 id="OSPF基础术语-度量值"><a href="#OSPF基础术语-度量值" class="headerlink" title="OSPF基础术语 - 度量值"></a>OSPF基础术语 - 度量值</h2><p>•OSPF使用Cost（开销）作为路由的度量值。每一个激活了OSPF的接口都会维护一个接口Cost值，缺省的接口Cost = “100 Mbit/s “ /“接口带宽” 。其中100 “Mbit/s”为OSPF指定的缺省参考值，该值是可配置的。</p>
<p>•OSPF以“累计cost”为开销值，也就是流量从源网络到目的网络所经过所有路由器的出接口的cost总和。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<p>•在实际应用中，推荐根据接口带宽大小手动配置Cost值，而不是修改OSPF参考带宽。</p>
</blockquote>
<h2 id="OSPF基础术语-度量值修改举例"><a href="#OSPF基础术语-度量值修改举例" class="headerlink" title="OSPF基础术语 - 度量值修改举例"></a>OSPF基础术语 - 度量值修改举例</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/12.png"></p>
<blockquote>
<p>•在规划流量路径时，推荐将汇聚层直连链路Cost值&gt;接入环所有链路Cost值之和，这样可以保证从接入层访问R1或R2时，流量可通过接入层路由器直达R1或R2。</p>
<p>•以上图为例。R1和R2位于企业网中的汇聚层，R1和R2的直连链路属于区域0，R1有一个直连网段10.0.1.1/32通过在区域0。</p>
<p>​    ▫在缺省情况下，R4到达10.0.1.1/32的路由存在两个下一跳。</p>
<p>​    ▫修改Cost之后，R4到达10.0.1.1的路由仅存在一个下一跳。</p>
</blockquote>
<h2 id="OSPF三大表项-邻居表"><a href="#OSPF三大表项-邻居表" class="headerlink" title="OSPF三大表项 - 邻居表"></a>OSPF三大表项 - 邻居表</h2><p>OSPF有三张重要的表项，OSPF邻居表、LSDB和OSPF路由表。对于OSPF的邻居表，需要了解：</p>
<p>▫OSPF在传递链路状态信息之前，需先建立OSPF邻居关系。</p>
<p>▫OSPF的邻居关系通过交互Hello报文建立。</p>
<p>▫OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/13.png"></p>
<h2 id="OSPF三大表项-LSDB"><a href="#OSPF三大表项-LSDB" class="headerlink" title="OSPF三大表项 - LSDB"></a>OSPF三大表项 - LSDB</h2><p>对于OSPF的LSDB，需要了解：</p>
<p>▫LSDB会保存自己产生的及从邻居收到的LSA信息，本例中R1的LSDB包含了三条LSA。</p>
<p>▫Type标识LSA的类型，AdvRouter标识发送LSA的路由器。</p>
<p>▫使用命令行display ospf lsdb查看LSDB表。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/14.png"></p>
<h2 id="OSPF三大表项-OSPF路由表"><a href="#OSPF三大表项-OSPF路由表" class="headerlink" title="OSPF三大表项 - OSPF路由表"></a>OSPF三大表项 - OSPF路由表</h2><p>对于OSPF的路由表，需要了解：</p>
<p>▫OSPF路由表和路由器路由表是两张不同的表。本例中OSPF路由表有三条路由。</p>
<p>▫OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。</p>
<p>▫使用命令display ospf routing查看OSPF路由表。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/15.png"></p>
<blockquote>
<p>•路由器路由表通常称为全局路由表，并非所有OSPF路由都可以放到路由器路由表。</p>
</blockquote>
<h2 id="OSPF报文格式和类型"><a href="#OSPF报文格式和类型" class="headerlink" title="OSPF报文格式和类型"></a>OSPF报文格式和类型</h2><p>•OSPF一共定义了5种类型的报文，不同类型的OSPF报文有相同的头部格式。</p>
<p>•OSPF报文直接采用IP封装，在报文的IP头部中，协议号为89。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/16.png"></p>
<blockquote>
<p>•重要字段解释</p>
<p>▫Version ：对于当前所使用的OSPFv2，该字段的值为2。</p>
<p>▫Router ID：表示生成此报文的路由器的Router ID。</p>
<p>▫Area ID：表示此报文需要被通告到的区域。</p>
<p>▫Type：类型字段。</p>
<p>▫Packet length：表示整个OSPF报文的长度，单位是字节。</p>
<p>▫Checksum：校验字段，其校验的范围是整个OSPF报文，包括OSPF报文头部。</p>
<p>▫Auth Type：为0时表示不认证；为1时表示简单的明文密码认证；为2时表示加密（MD5）认证。</p>
<p>▫Authentication：认证所需的信息。该字段的内容随AuType的值不同而不同。</p>
</blockquote>
<h1 id="OSPF工作过程"><a href="#OSPF工作过程" class="headerlink" title="OSPF工作过程"></a>OSPF工作过程</h1><h2 id="OSPF工作过程概览"><a href="#OSPF工作过程概览" class="headerlink" title="OSPF工作过程概览"></a>OSPF工作过程概览</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/17.png"></p>
<h2 id="建立邻居关系"><a href="#建立邻居关系" class="headerlink" title="建立邻居关系"></a>建立邻居关系</h2><p>•OSPF使用Hello报文发现和建立邻居关系。</p>
<p>•在以太网链路上，缺省时，OSPF采用组播的形式发送Hello报文（目的地址224.0.0.5）。</p>
<p>•OSPF Hello报文中包含了路由器的Router ID、邻居列表等信息。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/18.png"></p>
<blockquote>
<p>•R1和R2路由器相互发送Hello报文，第一个Hello报文包含的邻居列表为空。</p>
<p>•R2收到R1发送的Hello报文后，如果各项参数匹配，再次发送Hello报文时，将R1加入自己的邻居列表。</p>
<p>•在以太网链路上，通常以组播形式发送Hello报文：</p>
<p>​    ▫224.0.0.5的组播地址为OSPF设备的预留IP组播地址。</p>
<p>​    ▫224.0.0.6的组播地址为OSPF DR/BDR的预留IP组播地址。</p>
<p>•对于不支持组播的链路，OSPF支持采用单播的方式发送Hello报文。</p>
</blockquote>
<h3 id="影响邻居建立的因素"><a href="#影响邻居建立的因素" class="headerlink" title="影响邻居建立的因素"></a>影响邻居建立的因素</h3><ol>
<li><p><strong>Router ID</strong>：直连不能相同，非直连相同导致路由震荡</p>
</li>
<li><p><strong>认证</strong>：认证必须配置一直，否则不能建立邻居</p>
</li>
<li><p><strong>Area ID</strong>:必须一致，否则不能建立</p>
</li>
<li><p><strong>Hello间隔</strong>:必须一直否者不能建立</p>
<table>
<thead>
<tr>
<th></th>
<th>MA</th>
<th>P2P</th>
<th>NBMA</th>
<th>P2MP</th>
</tr>
</thead>
<tbody><tr>
<td>Hello time</td>
<td>10</td>
<td>10</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Hello dead time</td>
<td>30</td>
<td>30</td>
<td>120</td>
<td>120</td>
</tr>
</tbody></table>
</li>
<li><p><strong>接口网络类型</strong>：</p>
<p>NBMA与其它网络类型不能建立起邻居关系</p>
<p>MA与P2P可以建立起来，但不能进行路由计算</p>
</li>
<li><p><strong>接口MTU值</strong>:默认不开启，ospf mtu-enable，如果不相同会卡在exstart或exchang状态。</p>
</li>
<li><p><strong>静默接口 silent-interface</strong>：接口配置成静默接口不会发送hello报文</p>
</li>
<li><p><strong>hello报文中掩码信息不一致</strong>：MA网络 不一致不能建立 P2P可以建立因为此网络类型不检查掩码信息</p>
</li>
<li><p><strong>option字段</strong>：常规区域与特殊区域不能建立邻居关系</p>
</li>
<li><p><strong>DR priority 为 0</strong>：不建立<strong>邻接</strong>关系</p>
</li>
</ol>
<h2 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h2><p>•Hello报文的主要作用：</p>
<p>▫邻居发现：自动发现邻居路由器。</p>
<p>▫邻居建立：完成Hello报文中的参数协商，建立邻居关系。</p>
<p>▫邻居保持：通过周期性发送和接收，检测邻居运行状态。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/19.png"></p>
<p>•<strong>重要字段解释</strong></p>
<p>​    ▫<strong>Network</strong> <strong>Mask：</strong>发送Hello报文的接口的网络掩码。</p>
<p>​    ▫<strong>HelloInterval：</strong>发送Hello报文的时间间隔。通常为10s。</p>
<p>​    ▫<strong>RouterDeadInterval：</strong>失效时间。如果在此时间内未收到邻居发来的Hello报文，则认为邻居失效。通常为40s。</p>
<p>▫<strong>Neighbor：</strong>邻居，以Router ID标识。</p>
<p>•<strong>其它字段解释</strong></p>
<p>▫<strong>Options：</strong> </p>
<p>​    ▪E：是否支持外部路由</p>
<p>​    ▪MC：是否支持转发组播数据包</p>
<p>​    ▪N/P：是否为NSSA区域</p>
<p>▫<strong>Router Priority：DR优先级。默认为1。如果设置为0，则路由器不能参与DR或BDR的选举</strong>。</p>
<p>▫<strong>Designated</strong> <strong>Router：</strong>DR的接口地址。</p>
<p>▫<strong>Backup Designated</strong> <strong>Router</strong>：BDR的接口地址。</p>
<h2 id="邻接关系建立-1"><a href="#邻接关系建立-1" class="headerlink" title="邻接关系建立 (1)"></a>邻接关系建立 (1)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/20.png"></p>
<p>•<strong>DD报文部分字段解释</strong></p>
<p>▫<strong>I</strong>：当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。</p>
<p>▫**M (More)**：当发送连续多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。</p>
<p>▫**MS (Master/Slave)**：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。</p>
<p>▫<strong>DD sequence</strong> <strong>number</strong>：DD报文序列号。主从双方利用序列号来保证DD报文传输的可靠性和完整性。</p>
<blockquote>
<p>•R1和R2的Router ID分别为10.0.1.1和10.0.2.2并且二者已建立了邻居关系。当R1的邻居状态变为ExStart后，R1会发送第一个DD报文。此报文中，M-bit设置为1，表示后续还有DD报文要发送，MS-bit设置为1，表示R1宣告自己为Master。DD序列号被随机设置为X，I-bit设置为1，表示这是第一个DD报文。</p>
<p>•同样当R2的邻居状态变为ExStart后，R2也会发送第一个DD报文。此报文中，DD序列号被随机设置为Y（I-bit=1，M-bit=1，MS-bit=1，含义同上）。由于R2的Router ID较大，所以R2将成为真正的Master。收到此报文后，R1会产生一个Negotiation-Done事件，并将邻居状态从ExStart变为Exchange。</p>
<p>•当R1的邻居状态变为Exchange后，R1会发送一个新的DD报文，此报文中包含了LSDB的摘要信息，序列号设置为R2在步骤2中使用的序列号Y，I-bit=0，表示这不是第一个DD报文，M-bit=0，表示这是最后一个包含LSDB摘要信息的DD报文，MS-bit=0，表示R1宣告自己为Slave。收到此报文后，R2将邻居状态从ExStart变为Exchange。</p>
<p>•当R2的邻居状态变为Exchange后，R2会发送一个新的DD报文，此报文包含了LSDB的摘要信息。DD序列号设置为Y+1, MS-bit=1，表示R2宣告自己为Master。</p>
<p>•虽然R1不需要发送新的包含LSDB摘要信息的DD报文，但是作为Slave，R1需要对Master发送的每一个DD报文进行确认。所以，R1向R2发送一个新的DD报文，序列号为Y+1，该报文内容为空。发送完此报文后，RTA产生一个Exchange-Done事件，将邻居状态变为Loading。R2收到此报文后，会将邻居状态变为Full（假设R2的LSDB是最新最全的，不需要向R1请求更新）。</p>
</blockquote>
<h2 id="DD报文"><a href="#DD报文" class="headerlink" title="DD报文"></a>DD报文</h2><p>DD报文包含LSA头部信息，包括LS Type、LS ID、Advertising Router、LS Sequence Number、LS Checksum。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/21.png"></p>
<h2 id="邻接关系建立-2"><a href="#邻接关系建立-2" class="headerlink" title="邻接关系建立 (2)"></a>邻接关系建立 (2)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/23.png"></p>
<p>•R1开始向R2发送LSR报文，请求那些在Exchange状态下通过DD报文发现的、并且在本地LSDB中没有的链路状态信息。</p>
<p>•R2向R1发送LSU报文，LSU报文中包含了那些被请求的链路状态的详细信息。R1在完成LSU报文的接收之后，且没有其他待请求的LSA后，会将邻居状态从Loading变为Full。</p>
<p>•R1向R2发送LSAck报文，作为对LSU报文的确认。</p>
<h2 id="DR与BDR的作用"><a href="#DR与BDR的作用" class="headerlink" title="DR与BDR的作用"></a>DR与BDR的作用</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/24.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/25.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/26.png"></p>
<blockquote>
<p>•MA（ Multiple Access，多路访问 ）分为BMA（ Broadcast Multi-Access，广播多路访问）和NBMA（Non-Broadcast Multiple Access，非广播多路访问）。以太网链路组成的网络是典型的BMA网络。帧中继链路通过逻辑上的划分组成典型的NBMA网络（注：帧中继相关知识不再介绍）。</p>
<p>•DRother：既不是DR也不是BDR的路由器就是DRother路由器。</p>
</blockquote>
<h2 id="DR与BDR的选举规则"><a href="#DR与BDR的选举规则" class="headerlink" title="DR与BDR的选举规则"></a>DR与BDR的选举规则</h2><p>•DR/BDR的选举是非抢占式的。</p>
<p>•DR/BDR的选举是基于接口的。</p>
<p>​    ▫接口的DR优先级越大越优先。</p>
<p>​    ▫接口的DR优先级相等时，Router ID越大越优先。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/28.png"></p>
<p>•思考：</p>
<p>▫如果将上图中4台路由器的优先级全部设置为0，OSPF是否可以正常工作？</p>
<p>▫缺省情况下，哪些链路类型组成的网络是MA网络呢？</p>
<blockquote>
<p>广播链路或者NBMA链路上DR和BDR的选举过程如下：</p>
<p>▫接口UP后，发送Hello报文，同时进入到Waiting状态。在Waiting状态下会有一个WaitingTimer，该计时器的长度与DeadTimer是一样的。默认值为40秒，用户不可自行调整。</p>
<p>▫在WaitingTimer触发前，发送的Hello报文是没有DR和BDR字段的。在Waiting阶段，如果收到Hello报文中有DR和BDR，那么直接承认网络中的DR和BDR，而不会触发选举。直接离开Waiting状态，开始邻居同步。</p>
<p>▫假设网络中已经存在一个DR和一个BDR，这时新加入网络中的路由器，不论它的Router ID或者DR优先级有多大，都会承认现网中已有的DR和BDR。</p>
<p>▫当DR因为故障Down掉之后，BDR会继承DR的位置，剩下的优先级大于0的路由器会竞争成为新的BDR。</p>
<p>▫只有当不同Router ID，或者配置不同DR优先级的路由器同时起来，在同一时刻进行DR选举才会应用DR选举规则产生DR。</p>
</blockquote>
<h2 id="不同网络类型中DR与BDR的选举操作"><a href="#不同网络类型中DR与BDR的选举操作" class="headerlink" title="不同网络类型中DR与BDR的选举操作"></a>不同网络类型中DR与BDR的选举操作</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/29.png"></p>
<h2 id="可按需调整设备接口的OSPF网络类型"><a href="#可按需调整设备接口的OSPF网络类型" class="headerlink" title="可按需调整设备接口的OSPF网络类型"></a>可按需调整设备接口的OSPF网络类型</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/30.png"></p>
<p>•OSPF的网络类型是根据接口的数据链路层封装自动设置的。</p>
<p>•图中的路由器采用以太网接口互联，因此这些接口的网络类型缺省均为Broadcast。</p>
<p>•每段链路实际上都是点对点链路，因此在链路上选举DR与BDR是没有必要的。</p>
<p>•为了提高OSPF的工作效率，加快邻接关系的建立过程，可以把这些互联接口的网络类型都修改为P2P。</p>
<blockquote>
<p>•OSPF的网络类型是协议根据接口的数据链路层封装自动设置的，在图中，两台处于网络接入层的路由器AS-R1及AS-R2都通过双链路上联到核心层的路由器CO-R1及CO-R2。四台路由器都在各自接口上激活OSPF。由于这些路由器都是采用以太网接口互联，因此这些接口的网络类型缺省均为Broadcast，于是在邻居关系的建立过程中，OSPF会在每段以太网链路上选举DR及BDR。</p>
<p>•然而，这实际上是没有必要而且浪费时间的（DR及BDR的选举过程涉及一个等待计时器，这增加了直连路由器形成邻接关系的时间），因为这些链路其实从逻辑的角度看都是点对点的连接，选举DR或BDR实在是画蛇添足。因此为了提高OSPF的工作效率，加快邻接关系的建立过程，可以把这些互联接口的网络类型都修改为P2P。</p>
</blockquote>
<h1 id="OSPF的基本配置"><a href="#OSPF的基本配置" class="headerlink" title="OSPF的基本配置"></a>OSPF的基本配置</h1><h2 id="配置命令介绍-1"><a href="#配置命令介绍-1" class="headerlink" title="配置命令介绍 (1)"></a>配置命令介绍 (1)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/31.png"></p>
<blockquote>
<p>•缺省情况下，OSPF以32位主机路由的方式对外发布Loopback接口的IP地址，与Loopback接口上配置的掩码长度无关。如果要发布Loopback接口的实际网段，需要在接口下配置网络类型为NBMA或广播型。</p>
</blockquote>
<h2 id="配置命令介绍-2"><a href="#配置命令介绍-2" class="headerlink" title="配置命令介绍 (2)"></a>配置命令介绍 (2)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/32.png"></p>
<h2 id="OSPF配置举例"><a href="#OSPF配置举例" class="headerlink" title="OSPF配置举例"></a>OSPF配置举例</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/33.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/34.png"></p>
<h2 id="OSPF配置验证-1"><a href="#OSPF配置验证-1" class="headerlink" title="OSPF配置验证 (1)"></a>OSPF配置验证 (1)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/35.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/36.png"></p>
<h2 id="OSPF配置验证-2"><a href="#OSPF配置验证-2" class="headerlink" title="OSPF配置验证 (2)"></a>OSPF配置验证 (2)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/37.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/38.png"></p>
<h2 id="OSPF配置验证-3"><a href="#OSPF配置验证-3" class="headerlink" title="OSPF配置验证 (3)"></a>OSPF配置验证 (3)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/39.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/40.png"></p>
<h2 id="OSPF配置验证-4"><a href="#OSPF配置验证-4" class="headerlink" title="OSPF配置验证 (4)"></a>OSPF配置验证 (4)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/41.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/42.png"></p>
<h2 id="OSPF配置验证-5"><a href="#OSPF配置验证-5" class="headerlink" title="OSPF配置验证 (5)"></a>OSPF配置验证 (5)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/43.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/44.png"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>1.（单选题）OSPF使用以下哪种报文维护邻居关系？（   ）</p>
<p><strong>A.Hello</strong></p>
<p>B.Database Description</p>
<p>C.LSR</p>
<p>D.LSU</p>
<p>2.（多选题）OSPF支持以下哪些网络类型？（   ）</p>
<p><strong>A.P2P网络</strong></p>
<p><strong>B.P2MP网络</strong></p>
<p><strong>C.广播网络</strong></p>
<p><strong>D.NBMA网络</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•本文简单介绍了OSPF的基本概念，内容包括Router ID、区域、Cost。运行OSPF的路由器通过相互发送链路状态信息完成拓扑和路由计算。</p>
<p>•本文详细介绍了OSPF邻居和邻接关系建立的过程。在MA网络中，需要选举DR和BDR。OSPF有5种类型的报文，所有报文有相同的报文头部格式。运行OSPF的路由器通过周期性的发送Hello报文发现和维持邻居关系，通过DD、LSR、LSU、LSAck报文配合完成链路状态数据库的同步。最后介绍了OSPF单区域的简单配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/" itemprop="url">IP-IP路由基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:14:01+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫识别IP路由表和FIB表</p>
<p>▫分析路由转发流程</p>
<p>▫描述路由引入的原理</p>
<p>▫描述路由引入的使用场景</p>
<h1 id="IP路由基础"><a href="#IP路由基础" class="headerlink" title="IP路由基础"></a><strong>IP路由基础</strong></h1><h2 id="IP路由概述"><a href="#IP路由概述" class="headerlink" title="IP路由概述"></a><strong>IP路由概述</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/1.png"></p>
<p>当路由器收到一个IP报文时，路由器根据该IP报文的目的地址匹配路由条目（或路由表项）。</p>
<p>▫若有匹配的路由条目，则依据该条目中的出接口或下一跳等信息进行报文转发；</p>
<p>▫若无匹配的路由条目，则路由器没有相关路由信息用于指导报文转发，此时会丢弃该报文。</p>
<h2 id="RIB与FIB"><a href="#RIB与FIB" class="headerlink" title="RIB与FIB"></a><strong>RIB与FIB</strong></h2><p>具有路由功能的网络设备都维护两种重要的数据表：一是路由表RIB（Routing Information Base，路由信息库）；二是转发表FIB。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/2.png"></p>
<blockquote>
<p>•路由表：</p>
<p>​    ▫可以将路由表视为位于路由器的控制平面，实际上路由表并不直接指导数据转发。路由器在执行路由查询时，并不是在路由表中进行报文目的地址的查询，真正指导数据转发的是FIB表，路由器将路由表中的最优路由下载到FIB表，此后如果路由表中的相关表项发生变化，FIB表也将立即同步。</p>
<p>​    ▫由于两张表的一致性，且路由表阅读起来更直观，因此在绝大多数场合，在阐述路由器数据转发过程时，会用“路由表”这个说法，实际上，路由器查询的是FIB表，位于控制层面的路由表只是提供路由信息。</p>
<p>•FIB表：</p>
<p>​    ▫FIB表位于路由器的数据平面，亦被称为转发表项，每条转发表项都指定要到达某个目的地所需通过的出接口及下一跳IP地址等信息。</p>
<p>•注意：</p>
<p>​    ▫具有路由功能的华为数通产品包括路由器、三层交换机等，本课程以路由器为例进行讲解。</p>
<p>​    ▫OSPF（Open Shortest Path First，开放式最短路径优先）和IS-IS（Intermediate System to Intermediate System，中间系统到中间系统），均基于链路状态信息，使用最短路径优先算法进行路由计算。OSPF及IS-IS的详细内容，将在后续课程介绍。</p>
<p>​    ▫路由进程：路由器支持OSPF和IS-IS多进程，可以根据业务类型划分不同的进程，不同的进程之间相互独立。进程号是本地概念，不影响与其它路由器之间的报文交换。因此，不同的路由器之间，即使进程号不同也可以进行报文交换。</p>
</blockquote>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a><strong>路由表</strong></h2><p>每个路由器都有路由表，而路由表又分为本地核心路由表和协议路由表。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/3.png"></p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/4.png"></p>
<blockquote>
<p>•路由表中的关键字段：</p>
<ul>
<li><p>Destination：表示此路由的目的地址。用来标识IP包的目的地址或目的网络。</p>
</li>
<li><p>Mask：表示此目的地址的子网掩码长度。与目的地址一起来标识目的主机或路由器所在的网段的地址。</p>
</li>
<li><p>Proto（Protocol）：表示学习此路由的路由协议。</p>
</li>
<li><p>Pre（Preference）：表示此路由的路由协议优先级。</p>
<ul>
<li>路由器分别定义了外部优先级和内部优先级。外部优先级是指用户可以手工为各路由协议配置的优先级，内部优先级则不能被用户手工修改。</li>
<li>选择路由时先比较路由的外部优先级，当不同的路由协议配置了相同的优先级后，系统会通过内部优先级决定哪个路由协议发现的路由将成为最优路由。</li>
</ul>
</li>
<li><p>Cost：路由开销。</p>
</li>
<li><p>NextHop：表示转发到此目的网络的下一跳。指明数据转发的下一个设备。</p>
</li>
<li><p>Interface：表示转发到此目的网络的出接口。指明数据将从本地路由器哪个接口转发出去。</p>
</li>
<li><p>Preference用于不同路由协议间路由优先级的比较，Cost用于同一种路由协议内部不同路由的优先级的比较。</p>
</li>
<li><p>注意：正文内的路由表为截取版，非完整路由表。</p>
</li>
</ul>
</blockquote>
<h2 id="IP路由查找的最长匹配原则"><a href="#IP路由查找的最长匹配原则" class="headerlink" title="IP路由查找的最长匹配原则"></a><strong>IP路由查找的最长匹配原则</strong></h2><p>•路由器查找FIB表时，将报文的目的IP地址和FIB表中各表项的掩码进行按位“逻辑与”，得到的地址符合FIB表中的网络地址则匹配。</p>
<p>•最终选择一个掩码最长的FIB表项转发报文。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<p>•FIB表中每条转发项都指明到达某网段或某主机的报文应通过路由器的哪个物理接口或逻辑接口发送，然后就可到达该路径的下一个路由器，或者不再经过别的路由器而传送到直接相连的网络中的目的主机。</p>
<p>•FIB表信息查看命令：<strong>display fib</strong> [ <em>slot-id</em> ]</p>
<ul>
<li><em>slot-id</em>：显示指定槽位号的FIB表信息。整数形式，取值范围请根据设备实际配置选取。</li>
</ul>
<p>•FIB表中的字段说明：</p>
<ul>
<li><p>Total number of Routes：路由表总数。</p>
</li>
<li><p>Destination/Mask：目的地址/掩码长度。</p>
</li>
<li><p>Nexthop：下一跳。</p>
</li>
<li><p>Flag：当前标志，G、H、U、S、D、B的组合。</p>
<ul>
<li>G（Gateway）：网关路由，表示下一跳是网关。</li>
<li>H（Host）：主机路由，表示该路由为主机路由。</li>
<li>U（Up）：可用路由，表示该路由状态是Up。</li>
<li>S（Static）：静态路由。</li>
<li>D（Dynamic）：动态路由。</li>
<li>B（Black Hole）：黑洞路由，表示下一跳是空接口。</li>
</ul>
</li>
<li><p>TimeStamp：时间戳，表示该表项存在的时间，单位是秒。</p>
</li>
<li><p>Interface：到目的地址的出接口。</p>
</li>
<li><p>TunnelID：表示转发表项索引。该值不为0时，表示匹配该项的报文通过隧道转发（如：MPLS隧道转发）。该值为0时，表示报文不通过隧道转发。</p>
</li>
</ul>
</blockquote>
<h2 id="路由的来源"><a href="#路由的来源" class="headerlink" title="路由的来源"></a><strong>路由的来源</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/6.png"></p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/7.png"></p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/8.png"></p>
<blockquote>
<p>•直连路由：直连接口所在网段的路由，由设备自动生成。</p>
<p>•静态路由：由网络管理员手工配置的路由条目。</p>
<p>•动态路由：路由器通过动态路由协议（如OSPF、IS-IS、BGP等）学习到的路由。</p>
<p>​    ▫BGP（Border Gateway Protocol，边界网关协议）是一种实现AS（Autonomous System，自治系统）之间的路由可达，并选择最佳路由的距离矢量路由协议。</p>
<p>​    ▫AS是指在一个实体管辖下的拥有相同选路策略的IP网络。</p>
</blockquote>
<h2 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a><strong>动态路由协议</strong></h2><p>动态路由协议根据作用范围不同，可分为：</p>
<p>▫内部网关协议IGP（Interior Gateway Protocol）：在一个自治系统内部运行。常见的IGP协议包括OSPF和IS-IS。</p>
<p>▫外部网关协议EGP（Exterior Gateway Protocol）：运行于不同自治系统之间。BGP是目前最常用的EGP协议。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/9.png"></p>
<h2 id="路由迭代"><a href="#路由迭代" class="headerlink" title="路由迭代"></a><strong>路由迭代</strong></h2><p>路由必须有直连的下一跳才能够指导转发，静态路由或BGP路由的下一跳可能不是直连的邻居，因此需要计算出一个直连的下一跳，这个过程就叫做路由迭代。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/10.png"></p>
<h2 id="数据转发流程"><a href="#数据转发流程" class="headerlink" title="数据转发流程"></a><strong>数据转发流程</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<p>PC1发送数据包到PC2的流程如下：</p>
<p>1.PC1将报文发往网关设备R1。</p>
<p>2.R1查找路由表项，确定转发的下一跳、出接口，之后将报文转发给R2。</p>
<p>3.R2通过查找路由表项转发给R3。</p>
<p>4.R3收到后查找路由表项，发现IP报文的目的IP地址属于本地接口所在网段，则直接本地转发，最终该报文被发往目的主机PC2。</p>
</blockquote>
<h1 id="IP路由高级应用"><a href="#IP路由高级应用" class="headerlink" title="IP路由高级应用"></a><strong>IP路由高级应用</strong></h1><h2 id="IP路由高级应用场景分析-1"><a href="#IP路由高级应用场景分析-1" class="headerlink" title="IP路由高级应用场景分析 (1)"></a><strong>IP路由高级应用场景分析</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/12.png"></p>
<p>场景描述：</p>
<p>▫假设A公司和B公司各有自己的网络，这两个网络被独立管理及运维，A公司网络使用的路由协议为OSPF，B公司网络使用的路由协议为IS-IS。</p>
<p>▫现在两家公司合并成一家公司，导致原有的两张网络不得不进行整合，为了使合并后的新公司业务流量能够正常在整合后的网络上交互，最重要的就是实现路由互通。</p>
<blockquote>
<p>•OSPF与IS-IS是两种不同的动态路由协议，路由信息无法在路由协议之间直接交互。</p>
<p>•如图所示，A公司部署OSPF，边界设备为R1和R2；B公司部署IS-IS，边界设备为R3和R4。边界互联部分可以部署OSPF或IS-IS，例如：可以将R1与R3互联网段、R2与R4互联网段部署进A公司的OSPF，此时边界设备仅为R3和R4。</p>
</blockquote>
<h2 id="IP路由高级应用场景分析-2"><a href="#IP路由高级应用场景分析-2" class="headerlink" title="IP路由高级应用场景分析 (2)"></a>IP路由高级应用场景分析 (2)</h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/13.png"></p>
<p>场景描述：</p>
<p>▫在大型企业网络中，网络规模十分庞大，选用单一的路由协议无法满足网络的需求，因此多种路由协议共存的情况十分常见。</p>
<p>▫或者出于业务逻辑或行政管理的考虑，会在不同的网络结构中设计和部署不同的路由协议，使路由的层次结构更加清晰可控。</p>
<p>▫在这样的网络环境下，也需要实现全网路由互通。</p>
<h2 id="路由引入的基本概念"><a href="#路由引入的基本概念" class="headerlink" title="路由引入的基本概念"></a><strong>路由引入的基本概念</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/14.png"></p>
<p>路由引入指的是将路由信息从一种路由协议发布到另一种路由协议的操作。</p>
<p>▫通过路由引入，可以实现路由信息在不同路由协议间传递。</p>
<p>▫执行路由引入时，还可以部署路由控制，从而实现对业务流量的灵活把控。</p>
<blockquote>
<p>•如上图所示，OSPF和IS-IS网络中存在不同的网段，只有R1和R2同时知道所有路由条目。</p>
<p>•思考：如何让全部设备都能获取到所有的路由呢？</p>
</blockquote>
<h2 id="路由引入的方向性"><a href="#路由引入的方向性" class="headerlink" title="路由引入的方向性"></a><strong>路由引入的方向性</strong></h2><p>•路由引入是具有方向性的，将路由信息从路由协议A引入到路由协议B（A-to-B），则路由协议B可获知A中的路由信息，但是此时，A还并不知晓B路由协议中的路由信息，除非配置B-to-A的路由引入。</p>
<p>•路由引入时需要注意以下几点：</p>
<p>​    ▫路由优先级</p>
<p>​    ▫路由回灌</p>
<p>​    ▫路由度量值</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/15.png"></p>
<h2 id="路由引入：路由优先级"><a href="#路由引入：路由优先级" class="headerlink" title="路由引入：路由优先级"></a><strong>路由引入：路由优先级</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/16.png"></p>
<p>场景描述：</p>
<ol>
<li><p>R1将直连路由10.1.1.0/24引入到OSPF中。</p>
</li>
<li><p>R3通过OSPF学习到10.1.1.0/24网段路由（OSPF外部路由，路由优先级为150）。</p>
</li>
<li><p>R2在IS-IS进程中引入OSPF路由。</p>
</li>
<li><p>R3也会通过IS-IS学习到10.1.1.0/24网段路由（路由优先级为15）。</p>
</li>
<li><p>对R3而言，IS-IS路由优于OSPF外部路由，因此优选来自R4的IS-IS路由。</p>
</li>
</ol>
<p>后续R3访问10.1.1.0/24网段的路径为：R3-&gt;R4-&gt;R2-&gt;R1，这是次优路径。</p>
<blockquote>
<p>•华为定义的路由优先级：</p>
<p>▫Direct：0</p>
<p>▫OSPF：10</p>
<p>▫IS-IS：15</p>
<p>▫Static：60</p>
<p>▫OSPF ASE：150</p>
<p>▫OSPF NSSA：150</p>
<p>▫IBGP：255</p>
<p>▫EBGP：255</p>
<p>•注意：不同的厂商路由优先级的协定可能不同。</p>
</blockquote>
<h2 id="路由引入：路由回灌"><a href="#路由引入：路由回灌" class="headerlink" title="路由引入：路由回灌"></a><strong>路由引入：路由回灌</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/17.png"></p>
<p>场景描述：</p>
<ol>
<li><p>R1将直连路由10.1.1.0/24引入到OSPF中。</p>
</li>
<li><p>10.1.1.0/24网段路由全OSPF域内通告。</p>
</li>
<li><p>R2在IS-IS进程中引入OSPF路由。</p>
</li>
<li><p>10.1.1.0/24网段路由全IS-IS域内通告。</p>
</li>
<li><p>R3在OSPF进程中引入IS-IS路由。</p>
</li>
<li><p>10.1.1.0/24网段路由再次被通告进OSPF域内，形成路由回灌。</p>
</li>
</ol>
<h2 id="路由引入：路由度量值"><a href="#路由引入：路由度量值" class="headerlink" title="路由引入：路由度量值"></a><strong>路由引入：路由度量值</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/18.png"></p>
<p>场景描述：</p>
<ol>
<li><p>在IS-IS中引入OSPF路由。</p>
</li>
<li><p>在OSPF中引入IS-IS路由。</p>
</li>
</ol>
<p>不同的路由协议对路由度量值的定义不同，那么在路由协议之间进行路由引入时，被引入的路由的度量值该如何定义？定义成多少？</p>
<h2 id="路由引入场景"><a href="#路由引入场景" class="headerlink" title="路由引入场景"></a><strong>路由引入场景</strong></h2><p>路由引入主要涉及以下几种场景：</p>
<ol>
<li><p>动态路由协议之间的路由引入</p>
</li>
<li><p>引入直连路由到动态路由协议</p>
</li>
<li><p>引入静态路由到动态路由协议</p>
</li>
</ol>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/19.png"></p>
<h2 id="路由引入的基础配置命令"><a href="#路由引入的基础配置命令" class="headerlink" title="路由引入的基础配置命令"></a><strong>路由引入的基础配置命令</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/20.png"></p>
<blockquote>
<p>•说明：当OSPF网络中的设备需要访问运行其他协议的网络中的设备时，需要将其他协议的路由引入到OSPF网络中。</p>
</blockquote>
<h2 id="案例1：引入直连路由到OSPF"><a href="#案例1：引入直连路由到OSPF" class="headerlink" title="案例1：引入直连路由到OSPF"></a><strong>案例1：引入直连路由到OSPF</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/21.png"></p>
<p>•可以通过使用<strong>import-route direct</strong>命令，将路由表中所有直连路由引入到动态路由协议。</p>
<p>•引入后的路由会作为OSPF外部路由，在整个OSPF网络内通告。</p>
<blockquote>
<p>•在设备上部署动态路由协议，如果希望该设备的直连接口路由能够被发布到动态路由协议中，则需要激活该端口相应的动态路由协议。除此之外，也可以通过将直连路由引入到动态路由协议实现该目的。</p>
<p>•如图所示：</p>
<ul>
<li>R1、R2及R3运行OSPF，R1存在一个直连网段192.168.11.0/24，为了让R2和R3生成192.168.11.0/24的路由，可以在R1上将直连路由引入到OSPF。</li>
</ul>
<p>•说明：在OSPF网络中，若路由表的协议字段显示为O_ASE，表明该路由为OSPF的外部路由。</p>
</blockquote>
<h2 id="案例2：引入静态路由到OSPF"><a href="#案例2：引入静态路由到OSPF" class="headerlink" title="案例2：引入静态路由到OSPF"></a><strong>案例2：引入静态路由到OSPF</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/22.png"></p>
<p>•可以通过使用<strong>import-route</strong> <strong>static</strong>命令，将路由表中所有静态路由引入到动态路由协议。</p>
<p>•引入后的路由会作为OSPF外部路由，在整个OSPF网络内通告。</p>
<blockquote>
<p>•对于动态路由协议而言，静态路由被视为域外的路由信息，这些路由并不被动态路由协议直接感知。如果希望动态路由协议域内所有设备都能学习到该静态路由，则需要将静态路由引入到动态路由协议中。</p>
<p>•如图所示：</p>
<ul>
<li>R2及R3运行了OSPF，而R1不支持OSPF。在R2上添加静态路由指向192.168.11.0/24网段，并且在R2上将静态路由引入到OSPF，从而使R2和R3均能生成192.168.11.0/24的路由。</li>
</ul>
</blockquote>
<h2 id="案例3：将IS-IS路由引入到OSPF"><a href="#案例3：将IS-IS路由引入到OSPF" class="headerlink" title="案例3：将IS-IS路由引入到OSPF"></a><strong>案例3：将IS-IS路由引入到OSPF</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/23.png"></p>
<p>•可以通过使用<strong>import-route</strong> <strong>isis</strong> <strong>1</strong>命令，将路由表中所有IS-IS路由引入到动态路由协议。</p>
<p>•引入后的路由会作为OSPF外部路由，在整个OSPF网络内通告。</p>
<blockquote>
<p>•在两个动态路由协议域的边界执行路由引入操作，是最常见的场景之一，就是将路由信息从一个动态路由协议引入另一个动态路由协议中。</p>
<p>•如图所示：</p>
<ul>
<li>R1及R2运行了IS-IS，R2及R3运行了OSPF，两个协议维护的路由信息是完全隔离的。因此，此时R1有IS-IS网络内全部路由，但无法访问到OSPF网络；R3有OSPF网络内全部路由，但无法访问到IS-IS网络。在R2上执行路由引入，将IS-IS路由引入到OSPF中。</li>
</ul>
</blockquote>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.(单选题) 在某路由器的FIB表中存在以下4条路由转发表项，那么该路由器对于目的IP地址为10.0.1.1的IP报文将根据哪条路由进行转发？（  ）</p>
<p>A.0.0.0.0/0</p>
<p>B.10.0.0.0.0/16</p>
<p><strong>C.10.0.1.0/24</strong></p>
<p>D.10.0.2.0/24</p>
<p>2.(多选题) 以下关于路由引入的说法，<strong>错误</strong>的有（  ）。</p>
<p>A.在某路由器的OSPF进程中，执行<strong>import-route direct</strong>命令，则该路由器会把路由表中的所有直连路由都引入OSPF</p>
<p>B.在某路由器的OSPF进程中，执行<strong>import-route</strong> <strong>static</strong>命令，则该路由器会把路由表中的所有静态路由都引入OSPF</p>
<p><strong>C.在某路由器上，将路由表中来源于X路由协议的路由引入Y路由协议，需要在X路由协议视图下执行</strong>import-route<strong>命令</strong></p>
<p><strong>D.在某路由器上执行了</strong>import-route<strong>命令并成功将其GE0/0/1的直连路由引入OSPF，该接口也就激活了OSPF，并开始周期性地发送Hello报文</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•由于不同路由协议工作原理不同，因此到达同一目的网段可能会生成多个路由条目，路由器根据路由协议的优先级以及路由开销选择最优路由，并且把最优路由放入FIB表。路由器根据FIB表执行数据转发。</p>
<p>•当网络规模较大且使用多种路由协议时，路由协议间通过路由引入的方式实现路由的相互通告。由于路由引入可能会引入大量路由，并导致部分性能较低的设备无法承受，因此在进行路由引入时需要进行路由控制来实现路由的按需分发。</p>
<p>•本课程所列举的OSPF路由协议，IS-IS路由协议以及路由控制将在后续课程中详细介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/MSTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/MSTP/" itemprop="url">MSTP原理与配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:11:06+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•RSTP在STP基础上进行了改进，实现了网络拓扑快速收敛。但在划分VLAN的网络中运行RSTP/STP，局域网内所有的VLAN共享一棵生成树，被阻塞后的链路将不承载任何流量，无法在VLAN间实现数据流量的负载均衡，导致链路带宽利用率、设备资源利用率较低。</p>
<p>•为了弥补RSTP/STP的缺陷，IEEE于2002年发布的802.1S标准定义了MSTP（Multiple Spanning Tree Protocol，多生成树协议）。MSTP兼容STP和RSTP，通过建立多棵无环路的树，解决广播风暴并实现冗余备份。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述RSTP/STP技术的缺陷</p>
<p>▫描述MSTP对RSTP/STP技术的改进</p>
<p>▫描述MSTP的各种概念</p>
<p>▫描述MSTP的工作过程</p>
<p>▫实现MSTP的基本配置</p>
<h1 id="MSTP概述"><a href="#MSTP概述" class="headerlink" title="MSTP概述"></a>MSTP概述</h1><h2 id="RSTP-STP的不足-1"><a href="#RSTP-STP的不足-1" class="headerlink" title="RSTP/STP的不足 (1)"></a><strong>RSTP/STP的不足</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/MSTP/1.png"></p>
<h2 id="RSTP-STP的不足-2"><a href="#RSTP-STP的不足-2" class="headerlink" title="RSTP/STP的不足 (2)"></a><strong>RSTP/STP的不足</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/MSTP/2.png"></p>
<h2 id="多生成树协议概述"><a href="#多生成树协议概述" class="headerlink" title="多生成树协议概述"></a><strong>多生成树协议概述</strong></h2><p>•MSTP是IEEE 802.1S中定义的生成树协议，MSTP兼容STP和RSTP，既可以快速收敛，又提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</p>
<p>•MSTP可以将一个或多个VLAN映射到一个Instance（实例），再基于Instance计算生成树，映射到同一个Instance的VLAN共享同一棵生成树。</p>
<p><img src="/2021/05/06/MSTP/3.png"></p>
<blockquote>
<p>•如图中例子，经计算，最终生成两棵生成树：</p>
<ul>
<li><p>Instance1对应的生成树以SW1为根交换设备，转发VLAN1~VLAN10的报文。</p>
</li>
<li><p>Instance2对应的生成树以SW2为根交换设备，转发VLAN11~VLAN20的报文。</p>
</li>
<li><p>不同VLAN的报文沿不同的路径转发，实现了负载分担。</p>
</li>
</ul>
<p>•注意：生成树不是基于VLAN运行的，而是基于Instance运行的。</p>
</blockquote>
<h1 id="MSTP的基本概念"><a href="#MSTP的基本概念" class="headerlink" title="MSTP的基本概念"></a><strong>MSTP的基本概念</strong></h1><h2 id="MST-Region"><a href="#MST-Region" class="headerlink" title="MST Region"></a><strong>MST</strong> <strong>Region</strong></h2><p><img src="/2021/05/06/MSTP/5.png"></p>
<blockquote>
<p>•同一个MST域的设备具有下列特点：</p>
<ul>
<li><p>都启动了MSTP。</p>
</li>
<li><p>具有相同的域名。</p>
</li>
<li><p>具有相同的VLAN到生成树实例映射配置。</p>
</li>
<li><p>具有相同的MSTP修订级别配置。</p>
</li>
</ul>
</blockquote>
<h2 id="MSTI"><a href="#MSTI" class="headerlink" title="MSTI"></a><strong>MSTI</strong></h2><p><img src="/2021/05/06/MSTP/6.png"></p>
<blockquote>
<p>•Instance0是缺省存在的，而且缺省时，华为交换机上所有的VLAN都映射到了Instance0。</p>
<p>•通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。</p>
<ul>
<li>每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。</li>
</ul>
</blockquote>
<h2 id="CST"><a href="#CST" class="headerlink" title="CST"></a><strong>CST</strong></h2><p><img src="/2021/05/06/MSTP/7.png"></p>
<h2 id="IST"><a href="#IST" class="headerlink" title="IST"></a><strong>IST</strong></h2><p><img src="/2021/05/06/MSTP/8.png"></p>
<h2 id="CIST"><a href="#CIST" class="headerlink" title="CIST"></a><strong>CIST</strong></h2><p><img src="/2021/05/06/MSTP/9.png"></p>
<h2 id="SST"><a href="#SST" class="headerlink" title="SST"></a><strong>SST</strong></h2><p><img src="/2021/05/06/MSTP/10.png"></p>
<h2 id="总根，域根和主桥"><a href="#总根，域根和主桥" class="headerlink" title="总根，域根和主桥"></a><strong>总根，域根和主桥</strong></h2><p><img src="/2021/05/06/MSTP/11.png"></p>
<blockquote>
<p>•主桥包括总根和IST域根。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2021/05/06/MSTP/12.png"></p>
<h2 id="MSTP的端口角色-1"><a href="#MSTP的端口角色-1" class="headerlink" title="MSTP的端口角色 (1)"></a><strong>MSTP的端口角色 (1)</strong></h2><p>MSTP中定义的所有端口角色包括：</p>
<p>根端口、指定端口、Alternate端口、Backup端口、Master端口、域边缘端口和边缘端口。</p>
<p><img src="/2021/05/06/MSTP/15.png"></p>
<p><img src="/2021/05/06/MSTP/14.png"></p>
<p><img src="/2021/05/06/MSTP/16.png"></p>
<blockquote>
<p>•除边缘端口外，其他端口角色都参与MSTP的计算过程。</p>
<p>•同一端口在不同的生成树实例中可以担任不同的角色。</p>
</blockquote>
<h2 id="MSTP的端口状态"><a href="#MSTP的端口状态" class="headerlink" title="MSTP的端口状态"></a><strong>MSTP的端口状态</strong></h2><p>MSTP定义的端口状态与RSTP协议中定义相同:</p>
<ul>
<li><p>Forwarding状态：端口既转发用户流量，学习MAC地址，又接收/发送BPDU报文。</p>
</li>
<li><p>Learning状态：过渡状态，端口接收/发送BPDU报文，不转发用户流量但是学习MAC地址。</p>
</li>
<li><p>Discarding状态：端口只接收BPDU报文，不转发用户流量也不学习MAC地址。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>MSTP端口状态</strong></th>
<th><strong>端口在拓扑中的角色</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Forwarding</td>
<td>包括根端口、指定端口、Master端口、域边缘端口</td>
</tr>
<tr>
<td>Learning</td>
<td>包括根端口、指定端口、Master端口、域边缘端口</td>
</tr>
<tr>
<td>Discarding</td>
<td>包括根端口、指定端口、Master端口、域边缘端口、Alternate端口、Backup端口</td>
</tr>
</tbody></table>
<h2 id="MSTP报文"><a href="#MSTP报文" class="headerlink" title="MSTP报文"></a><strong>MSTP报文</strong></h2><p><img src="/2021/05/06/MSTP/18.png"></p>
<p><img src="/2021/05/06/MSTP/19.png"></p>
<p>•无论是域内的MST BPDU还是域间的，前36个字节和RST BPDU相同。从第37个字节开始是MSTP专有字段。最后的MSTI配置信息字段由若干MSTI配置信息组连缀而成。</p>
<p>•MST BPDU中主要信息说明：</p>
<ul>
<li><p>Protocol Identifier：2 Byte，协议标识符。</p>
</li>
<li><p>Protocol Version Identifier：1 Byte，协议版本标识符，STP为0，RSTP为2，MSTP为3。</p>
</li>
<li><p>BPDU Type：1 Byte，BPDU类型：</p>
<ul>
<li>0x00：STP的Configuration BPDU</li>
<li>0x80：STP的TCN BPDU（Topology Change Notification BPDU）</li>
<li>0x02：RST BPDU（Rapid Spanning-Tree BPDU）或者MST BPDU（Multiple Spanning-Tree BPDU）</li>
</ul>
</li>
<li><p>CIST Flags：1 Byte，CIST标志字段。</p>
</li>
<li><p>CIST Root Identifier：8 Byte，CIST的总根交换设备ID。</p>
</li>
<li><p>CIST External Path Cost：4 Byte，CIST外部路径开销指从本交换设备所属的MST域到CIST根交换设备所属的MST域的累计路径开销。CIST外部路径开销根据链路带宽计算。</p>
</li>
<li><p>CIST Regional Root Identifier：8 Byte，CIST的域根交换设备ID，即IST Master的ID。如果总根在这个域内，那么域根交换设备ID就是总根交换设备ID。</p>
</li>
<li><p>CIST Port Identifier：2 Byte，本端口在IST中的指定端口ID。</p>
</li>
<li><p>Message Age：2 Byte，BPDU报文的生存期。</p>
</li>
<li><p>Max Age：2 Byte，BPDU报文的最大生存期，超时则认为到根交换设备的链路故障。</p>
</li>
<li><p>Hello Time：2 Byte，Hello定时器，缺省为2秒。</p>
</li>
<li><p>Forward Delay：2 Byte，Forward Delay定时器，缺省为15秒。</p>
</li>
<li><p>Version 1 Length：1 Byte，Version1 BPDU的长度，值固定为0。</p>
</li>
<li><p>Version 3 Length：2 Byte，Version3 BPDU的长度。</p>
</li>
<li><p>MST Configuration Identifier：51 Byte，MST配置标识，表示MST域的标签信息，包含4个字段。</p>
</li>
<li><p>CIST Internal Root Path Cost：4 Byte，CIST内部路径开销指从本端口到IST Master交换设备的累计路径开销。CIST内部路径开销根据链路带宽计算。</p>
</li>
<li><p>CIST Bridge Identifier：8 Byte，CIST的指定交换设备ID。</p>
</li>
<li><p>CIST Remaining Hops：1 Byte，BPDU报文在CIST中的剩余跳数。</p>
</li>
<li><p>MSTI Configuration Messages：16 Byte，MSTI配置信息。每个MSTI的配置信息占16 Byte，如果有n个MSTI就占用n×16 Byte。</p>
</li>
</ul>
<h1 id="MSTP的工作原理"><a href="#MSTP的工作原理" class="headerlink" title="MSTP的工作原理"></a>MSTP的工作原理</h1><h2 id="MSTP拓扑计算"><a href="#MSTP拓扑计算" class="headerlink" title="MSTP拓扑计算"></a><strong>MSTP拓扑计算</strong></h2><p>•MSTP拓扑计算：</p>
<ul>
<li><p>MSTP可以将整个二层网络划分为多个MST域，各个域之间通过计算生成CST，域内生成IST，CST和IST构成了整个交换设备网络的CIST。</p>
</li>
<li><p>域内还可以基于实例计算生成多棵生成树，每棵生成树都被称为是一个MSTI。</p>
</li>
</ul>
<p>•CIST和MSTI都是根据优先级向量来计算的，这些优先级向量信息都包含在MST BPDU中。各交换设备互相交换MST BPDU来生成CIST和MSTI 。</p>
<ul>
<li><p>参与CIST计算的优先级向量为：</p>
<p>▪{ 根交换设备ID，外部路径开销，域根ID，内部路径开销，指定交换设备ID，指定端口ID，接收端口ID }</p>
</li>
<li><p>参与MSTI计算的优先级向量为：</p>
<p>▪{ 域根ID，内部路径开销，指定交换设备ID，指定端口ID，接收端口ID }</p>
</li>
<li><p>注意：括号中的向量的优先级从左到右依次递减。</p>
</li>
</ul>
<blockquote>
<p>•优先级向量说明：</p>
<ul>
<li><p>根交换设备ID：根交换设备ID用于选择CIST中的根交换设备。</p>
<ul>
<li><p>根交换设备ID = Priority(16 bit) + MAC(48 bit)。</p>
</li>
<li><p>其中Priority为MSTI0的优先级。</p>
</li>
</ul>
</li>
<li><p>外部路径开销（External Root Path Cost，ERPC）：从CIST的域根到达总根的路径开销。</p>
<ul>
<li>MST域内所有交换设备上保存的外部路径开销相同。</li>
<li>若CIST根交换设备在域中，则域内所有交换设备上保存的外部路径开销为0。</li>
</ul>
</li>
<li><p>域根ID：域根ID用于选择MSTI中的域根。</p>
<ul>
<li>域根ID = Priority(16 bit) + MAC(48 bit)。</li>
<li>其中Priority为MSTI0的优先级。</li>
</ul>
</li>
<li><p>内部路径开销（Internal Root Path Cost，IRPC）：本桥到达域根的路径开销。</p>
<ul>
<li>域边缘端口保存的内部路径开销大于非域边缘端口保存的内部路径开销。</li>
</ul>
</li>
<li><p>指定交换设备ID：CIST或MSTI实例的指定交换设备是本桥通往域根的最邻近的上游桥。</p>
<ul>
<li>如果本桥就是总根或域根，则指定交换设备为自己。</li>
</ul>
</li>
<li><p>指定端口ID：指定交换设备上同本设备上根端口相连的端口。</p>
<ul>
<li>Port ID = Priority(4 bit) + 端口号（12 bit）。</li>
<li>端口优先级必须是16的整数倍。</li>
</ul>
</li>
<li><p>接收端口ID：接收到BPDU报文的端口。</p>
<ul>
<li>Port ID = Priority(4 bit) + 端口号（12 bit）。</li>
<li>端口优先级必须是16的整数倍。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>•优先级向量比较原则：</p>
<ul>
<li><p>同一向量比较，值最小的向量具有最高优先级。</p>
</li>
<li><p>优先级向量比较原则如下</p>
<p>1.首先，比较根交换设备ID。</p>
<p>2.如果根交换设备ID相同，再比较外部路径开销。</p>
<p>3.如果外部路径开销相同，再比较域根ID。</p>
<p>4.如果域根ID仍然相同，再比较内部路径开销。</p>
<p>5.如果内部路径仍然相同，再比较指定交换设备ID。</p>
<p>6.如果指定交换设备ID仍然相同，再比较指定端口ID。</p>
<p>7.如果指定端口ID还相同，再比较接收端口ID。</p>
</li>
<li><p>如果端口接收到的BPDU内包含的配置消息优于端口上保存的配置消息，则端口上原来保存的配置消息被新收到的配置消息替代。端口同时更新交换设备保存的全局配置消息。反之，新收到的BPDU被丢弃。</p>
</li>
</ul>
</blockquote>
<h2 id="CIST计算"><a href="#CIST计算" class="headerlink" title="CIST计算"></a><strong>CIST计算</strong></h2><p>•经过比较MST BPDU消息后，在整个网络中选择一个优先级最高的交换设备作为CIST的树根，即总根。</p>
<p>•在每个MST域内，MSTP通过计算生成IST；同时MSTP将每个MST域作为单台交换设备对待，通过计算在MST域间生成CST。CST和IST构成了整个交换设备网络的CIST。</p>
<p><img src="/2021/05/06/MSTP/20.png"></p>
<h2 id="MSTI计算"><a href="#MSTI计算" class="headerlink" title="MSTI计算"></a>MSTI计算</h2><p>•在MST域内，MSTP根据VLAN和生成树实例的映射关系，针对不同的VLAN生成不同的生成树实例。</p>
<p>•每棵生成树独立进行计算，计算过程与STP计算生成树的过程类似。</p>
<p><img src="/2021/05/06/MSTP/21.png"></p>
<blockquote>
<p>•MSTI的特点：</p>
<p>​    ▫每个MSTI独立计算自己的生成树，互不干扰。</p>
<p>​    ▫每个MSTI的生成树计算方法与STP基本相同。</p>
<p>​    ▫每个MSTI的生成树可以有不同的根，不同的拓扑。</p>
<p>​    ▫每个MSTI在自己的生成树内发送BPDU。</p>
<p>​    ▫每个MSTI的拓扑通过命令配置决定。</p>
<p>​    ▫每个端口在不同MSTI上的生成树参数可以不同。</p>
<p>​    ▫每个端口在不同MSTI上的角色、状态可以不同。</p>
<p>•根桥和备份根桥：可以通过计算来自动确定生成树的根桥，用户也可以手动配置设备为指定生成树的根桥或备份根桥。</p>
<p>​    ▫设备在各生成树中的角色互相独立，在作为一棵生成树的根    桥或备份根桥的同时，也可以作为其它生成树的根桥或备份    根桥；但在同一棵生成树中，一台设备不能既作为根桥，又    作为备份根桥。</p>
<p>​    ▫在一棵生成树中，生效的根桥只有一个；当两台或两台以上    的设备被指定为同一棵生成树的根桥时，系统将选择MAC地    址最小的设备作为根桥。</p>
<p>​    ▫可以在每棵生成树中指定多个备份根桥。当根桥出现故障或    被关机时，备份根桥可以取代根桥成为指定生成树的根桥；    但此时若配置了新的根桥，则备份根桥将不会成为根桥。如    果配置了多个备份根桥，则MAC地址最小的备份根桥将成为    指定生成树的根桥。</p>
</blockquote>
<h2 id="MSTP网络数据转发"><a href="#MSTP网络数据转发" class="headerlink" title="MSTP网络数据转发"></a><strong>MSTP网络数据转发</strong></h2><p>在运行MSTP协议的网络中，一个VLAN报文将沿着如下路径进行转发：</p>
<ul>
<li><p>在MST域内，沿着其对应的MSTI转发。</p>
</li>
<li><p>在MST域间，沿着CST转发。</p>
</li>
</ul>
<p><img src="/2021/05/06/MSTP/22.png"></p>
<blockquote>
<p>•如图所示，以VLAN2的数据发送为例。</p>
</blockquote>
<h1 id="MSTP的基本配置"><a href="#MSTP的基本配置" class="headerlink" title="MSTP的基本配置"></a>MSTP的基本配置</h1><h2 id="MSTP的基础配置命令"><a href="#MSTP的基础配置命令" class="headerlink" title="MSTP的基础配置命令"></a><strong>MSTP的基础配置命令</strong></h2><p><img src="/2021/05/06/MSTP/23.png"></p>
<blockquote>
<p>•命令：<strong>stp mode</strong> <strong>mstp</strong></p>
<p>▫STP和MSTP不能互相识别报文，而MSTP和RSTP可以互相识别报文，所以若工作在MSTP工作模式下，交换设备会设置所有和运行STP的交换设备直接相连的端口工作在STP模式下，其他端口工作在MSTP模式下，实现运行不同生成树协议的设备之间的互通。</p>
</blockquote>
<h2 id="配置MST域并激活"><a href="#配置MST域并激活" class="headerlink" title="配置MST域并激活"></a><strong>配置MST域并激活</strong></h2><p><img src="/2021/05/06/MSTP/24.png"></p>
<p><img src="/2021/05/06/MSTP/25.png"></p>
<blockquote>
<p>•命令：<strong>stp region-configuration</strong></p>
<ul>
<li>缺省情况下，MST域的三个参数均取缺省值。</li>
</ul>
<p>•命令：<strong>region-name</strong> <em>name</em></p>
<ul>
<li><em>name</em>：指定交换设备的MST域名。字符串形式，不支持空格，区分大小写，长度为1～32个字符。</li>
</ul>
<p>•命令：<strong>instance</strong> <em>instance-id</em> <strong>vlan</strong> { <em>vlan-id1</em> [ <strong>to</strong> <em>vlan-id2</em> ] }</p>
<ul>
<li><em>instance-id</em>：指定生成树实例的编号。整数形式，取值范围是0～4094，取值为0表示的是CIST。</li>
</ul>
<p>•命令：<strong>revision-level</strong> <em>level</em></p>
<ul>
<li><p><em>level</em>：指定MST域的修订级别。整数形式，取值范围是0～65535。</p>
</li>
<li><p>MSTP是标准协议，各厂商设备的MSTP修订级别一般都默认为0。如果某厂商的设备不为0，为保持MST域内计算，在部署MSTP时，需要将各设备的MSTP修订级别修改为一致。</p>
</li>
</ul>
</blockquote>
<h2 id="MSTP的可选配置命令"><a href="#MSTP的可选配置命令" class="headerlink" title="MSTP的可选配置命令"></a>MSTP的可选配置命令</h2><p><img src="/2021/05/06/MSTP/26.png"></p>
<blockquote>
<p>•命令：<strong>stp</strong> [ <strong>instance</strong> <em>instance-id</em> ] <strong>root</strong> { <strong>primary</strong> | <strong>secondary</strong> }</p>
<ul>
<li><p><strong>instance</strong> <em>instance-id</em>：指定生成树实例的编号。如果不指定instance，则配置设备在实例0上为根桥/备份根桥设备。</p>
</li>
<li><p><strong>primary</strong>：指定配置为生成树的根桥设备。配置后该设备优先级值自动为0，将不能更改设备优先级。</p>
</li>
<li><p><strong>secondary</strong>：指定配置为生成树的备份根桥设备。配置后该设备优先级值自动为4096，将不能更改设备优先级。</p>
</li>
</ul>
<p>•命令：<strong>stp</strong> [ <strong>instance</strong> <em>instance-id</em> ] <strong>priority</strong> <em>priority</em></p>
<ul>
<li><em>priority</em>：指定交换设备的优先级数值。优先级值越小，则交换设备的优先级越高。整数形式，取值范围是0～61440，步长为4096，如0、4096、8192等。缺省值是32768。</li>
</ul>
<p>•命令：<strong>stp</strong> <strong>pathcost-standard</strong> { <strong>dot1d-1998</strong> | <strong>dot1t</strong> | <strong>legacy</strong> }</p>
<ul>
<li><p><strong>dot1d-1998</strong>：指定路径开销值的计算方法是IEEE 802.1D-1998标准方法，取值范围为1~65535。</p>
</li>
<li><p><strong>dot1t</strong>：指定路径开销值的计算方法是IEEE 802.1T标准方法，取值范围为1~200,000,000。</p>
</li>
<li><p><strong>legacy</strong>：指定路径开销值的计算方法是华为计算方法，取值范围为1~200,000。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/05/06/MSTP/27.png"></p>
<blockquote>
<p>•命令：<strong>stp</strong> [ <strong>instance</strong> <em>instance-id</em> ] <strong>port priority</strong> <em>priority</em></p>
<ul>
<li><em>priority</em>：指定端口在生成树计算时的优先级。整数形式，取值范围是0～240，步长为16，如0、16、32等。</li>
</ul>
</blockquote>
<h2 id="案例：单域多实例场景配置-1"><a href="#案例：单域多实例场景配置-1" class="headerlink" title="案例：单域多实例场景配置 (1)"></a><strong>案例：单域多实例场景配置</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/MSTP/28.png"></p>
<p><img src="/2021/05/06/MSTP/29.png"></p>
<blockquote>
<p>可以配置SW1为VLAN2的网关（VLANIF2：192.168.1.254/24），SW2为VLAN3的网关（VLANIF3:192.168.2.254/24），最终实现PC1能Ping通SW1的VLANIF2接口，PC2能Ping通SW2的VLANIF3接口。</p>
</blockquote>
<h2 id="案例：单域多实例场景配置-2"><a href="#案例：单域多实例场景配置-2" class="headerlink" title="案例：单域多实例场景配置 (2)"></a><strong>案例：单域多实例场景配置</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/MSTP/28.png"></p>
<p><img src="/2021/05/06/MSTP/30.png"></p>
<p><img src="/2021/05/06/MSTP/31.png"></p>
<h2 id="案例：单域多实例场景配置-3"><a href="#案例：单域多实例场景配置-3" class="headerlink" title="案例：单域多实例场景配置 (3)"></a><strong>案例：单域多实例场景配置</strong> <strong>(3)</strong></h2><p><img src="/2021/05/06/MSTP/28.png"></p>
<p><img src="/2021/05/06/MSTP/32.png"></p>
<p><img src="/2021/05/06/MSTP/33.png"></p>
<p><img src="/2021/05/06/MSTP/34.png"></p>
<h2 id="验证配置结果-1"><a href="#验证配置结果-1" class="headerlink" title="验证配置结果 (1)"></a><strong>验证配置结果</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/MSTP/35.png"></p>
<p><img src="/2021/05/06/MSTP/36.png"></p>
<h2 id="验证配置结果-2"><a href="#验证配置结果-2" class="headerlink" title="验证配置结果 (2)"></a><strong>验证配置结果</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/MSTP/37.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.(单选题) 某运行MSTP协议的交换机的端口角色如下图所示，请问GigabitEthernet0/0/1端口在Instance1中的端口状态应该是？</p>
<p>A.Blocking</p>
<p><strong>B.Discarding</strong></p>
<p>C.Forwarding</p>
<p>D.Learning</p>
<p><img src="/2021/05/06/MSTP/4.png"></p>
<p>2.(判断题) CIST是由内部生成树和公共生成树构成的一棵树。（  ）</p>
<p><strong>A.正确</strong></p>
<p>B.错误</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•在MSTP网络中，可以将一个或多个VLAN映射到一个Instance，然后MSTP基于该Instance计算生成树。基于Instance的生成树被称为MSTI，MSTP为每个Instance维护独立的MSTI，映射到同一个Instance的VLAN将共享同一棵生成树。</p>
<p>•在以太网中部署MSTP协议后可实现如下功能：</p>
<ul>
<li><p>形成多棵无环路的树，解决广播风暴并实现冗余备份。</p>
</li>
<li><p>多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
