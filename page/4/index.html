<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/4/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/" itemprop="url">OSPF特殊区域及其它特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-09T19:04:41+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•在一个大型网络中，OSPF路由器通常需要同时维护由域内路由、域间路由、外部路由构成的数据库。当网络规模不断扩大时，LSDB规模也不断增长。如果某区域不需要为其他区域提供流量中转服务，那么该区域内的路由器就没有必要维护本区域外的链路状态信息。</p>
<p>•OSPF通过划分区域可以减小区域内路由器LSDB的规模，对于那些位于自治系统（AS）边界的非骨干区域的低端路由器来说仍然无法承受，通过OSPF的特殊区域特性可以进一步减少LSA数量和路由表规模。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述OSPF特殊区域类型及相关特征</p>
<p>▫阐明OSPF路由汇总的应用场景及功能优势</p>
<p>▫实现OSPF报文认证的配置</p>
<h1 id="Stub区域和Totally-Stub区域"><a href="#Stub区域和Totally-Stub区域" class="headerlink" title="Stub区域和Totally Stub区域"></a>Stub区域和Totally Stub区域</h1><h2 id="网络规模变大引发的问题"><a href="#网络规模变大引发的问题" class="headerlink" title="网络规模变大引发的问题"></a>网络规模变大引发的问题</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/1.png"></p>
<p>OSPF路由器计算区域内、区域间、外部路由都需要依靠网络中的LSA，当网络规模变大时，设备的LSDB规模也变大，设备的路由计算变得更加吃力，造成设备性能浪费。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/3.png"></p>
<h2 id="传输区域和末端区域"><a href="#传输区域和末端区域" class="headerlink" title="传输区域和末端区域"></a>传输区域和末端区域</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/4.png"></p>
<p>OSPF的区域可分为两种类型：</p>
<p>▫传输区域（Transit Area）：除了承载本区域发起的流量和访问本区域的流量外，还承载了源IP和目的IP都不属于本区域的流量，即“穿越型流量”，如本例中的Area 0。</p>
<p>▫末端区域（Stub Area）：只承载本区域发起的流量和访问本区域的流量，如本例中的Area 1和Area 2。</p>
<h2 id="Stub区域"><a href="#Stub区域" class="headerlink" title="Stub区域"></a>Stub区域</h2><p>•Stub区域的ABR不向Stub区域内传播它接收到的AS外部路由，Stub区域中路由器的LSDB、路由表规模都会大大减小。</p>
<p>•为保证Stub区域能够到达AS外部，Stub区域的ABR将生成一条缺省路由（使用3类LSA描述）。</p>
<p>•配置Stub区域时需要注意下列几点：</p>
<p>​    ▫骨干区域不能被配置为Stub区域。</p>
<p>​    ▫Stub区域中的所有路由器都必须将该区域配置为Stub。</p>
<p>​    ▫Stub区域内不能引入也不接收AS外部路由。</p>
<p>​    ▫虚连接不能穿越Stub区域。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/5.png"></p>
<h2 id="Stub区域的路由表及3类LSA"><a href="#Stub区域的路由表及3类LSA" class="headerlink" title="Stub区域的路由表及3类LSA"></a>Stub区域的路由表及3类LSA</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/6.png"></p>
<h2 id="Totally-Stub区域-1"><a href="#Totally-Stub区域-1" class="headerlink" title="Totally Stub区域 (1)"></a>Totally Stub区域 (1)</h2><p>•Totally Stub区域既不允许AS外部路由在本区域内传播，也不允许区域间路由在本区域内传播。</p>
<p>•Totally Stub区域内的路由器通过本区域ABR下发的缺省路由（使用3类LSA描述）到达其他区域，以及AS外部。</p>
<p>•配置Totally Stub区域时需要注意：</p>
<p>▫与Stub区域配置的区别在于，在ABR上需要追加no-summary关键字。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/7.png"></p>
<blockquote>
<p>•思考：为什么非ABR设备不需要追加no-summary参数呢？</p>
</blockquote>
<h2 id="Totally-Stub区域-2"><a href="#Totally-Stub区域-2" class="headerlink" title="Totally Stub区域 (2)"></a>Totally Stub区域 (2)</h2><p>•Totally Stub区域访问其他区域及AS外部是通过默认路由实现的。</p>
<p>•AS外部、其他OSPF区域的拓扑及路由变化不会导致Totally Stub区域内的路由器进行路由重计算，减少了设备性能浪费。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/8.png"></p>
<p>Stub区域、Totally Stub区域解决了末端区域维护过大LSDB带来的问题，但对于某些特定场景，它们并不是最佳解决方案。</p>
<h1 id="NSSA区域和Totally-NSSA区域"><a href="#NSSA区域和Totally-NSSA区域" class="headerlink" title="NSSA区域和Totally NSSA区域"></a>NSSA区域和Totally NSSA区域</h1><h2 id="Stub区域与Totally-Stub区域存在的问题"><a href="#Stub区域与Totally-Stub区域存在的问题" class="headerlink" title="Stub区域与Totally Stub区域存在的问题"></a>Stub区域与Totally Stub区域存在的问题</h2><p>•OSPF规定Stub区域是不能引入外部路由的，这样可以避免大量外部路由引入造成设备资源消耗。</p>
<p>•对于既需要引入外部路由又要避免外部路由带来的资源消耗的场景，Stub和Totally Stub区域就不能满足需求了。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/9.png"></p>
<h2 id="NSSA区域与Totally-NSSA区域"><a href="#NSSA区域与Totally-NSSA区域" class="headerlink" title="NSSA区域与Totally NSSA区域"></a>NSSA区域与Totally NSSA区域</h2><p>•NSSA区域能够引入外部路由，同时又不会学习来自OSPF网络其它区域引入的外部路由。</p>
<p>•Totally NSSA与NSSA区域的配置区别在于前者在ABR上需要追加no-summary关键字。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/10.png"></p>
<blockquote>
<p>NSSA区域能够引入外部路由，同时又不会学习来自OSPF网络其它区域的外部路由。</p>
<p>▫7类LSA是为了支持NSSA区域而新增的一种LSA类型，用于描述NSSA区域引入的外部路由信息。NSSA区域的ASBR将外部路由引入该区域后，使用7类LSA描述这些路由。</p>
<p>▫7类LSA的扩散范围仅限于始发NSSA区域，7类LSA不会被注入到普通区域。</p>
<p>▫NSSA区域的ABR会将7类LSA转化为5类LSA，并将该LSA注入到骨干区域，从而在整个OSPF域内泛洪。</p>
<p>▫NSSA区域的ABR会阻挡其他区域引入的外部路由引入本区域，即NSSA区域内不会存在4类及5类LSA，为了让NSSA区域内的路由器能够通过骨干区域到达AS外部，NSSA区域的ABR会自动向该区域注入一条缺省路由，该路由采用7类LSA描述。</p>
</blockquote>
<h2 id="NSSA区域与Totally-NSSA区域的LSDB"><a href="#NSSA区域与Totally-NSSA区域的LSDB" class="headerlink" title="NSSA区域与Totally NSSA区域的LSDB"></a>NSSA区域与Totally NSSA区域的LSDB</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/11.png"></p>
<blockquote>
<p>•场景1（将Area 2配置为NSSA区域）：当R5将外部路由192.168.3.0/24引入NSSA区域时，R5作为ASBR生成7类LSA在Area 2内泛洪；R3生成使用7类LSA描述的缺省路由注入Area 2，Area 2内的路由器依然会收到R3注入的3类LSA，并计算出到达其他区域的区域间路由。</p>
<p>•场景2（将Area2配置为Totally NSSA区域）：Totally NSSA区域和NSSA区域类似，只是Totally NSSA区域的ABR会阻挡3类LSA进入该区域，因此在场景2中，R3不会将区域间路由注入Area 2，故而在R5的LSDB中，仅会看到一条描述缺省路由的3类LSA。</p>
</blockquote>
<h2 id="OSPF-LSA回顾"><a href="#OSPF-LSA回顾" class="headerlink" title="OSPF LSA回顾"></a>OSPF LSA回顾</h2><p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/12.png"></p>
<h2 id="路由器对LSA的处理原则"><a href="#路由器对LSA的处理原则" class="headerlink" title="路由器对LSA的处理原则"></a>路由器对LSA的处理原则</h2><p>OSPF通过交互LSA实现链路状态数据库同步，路由器收到LSA后，按照以下原则处理：</p>
<p>▫如果收到的LSA本地没有，则更新LSDB并泛洪该LSA。</p>
<p>▫如果本地LSDB已存在该LSA，但是收到的更新，则更新LSDB并泛洪该LSA。</p>
<p>▫如果收到的LSA和LSDB中相同，则忽略，并终止泛洪。</p>
<p>▫如果收到的LSA损坏，例如Checksum错误，则不接收该LSA。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/13.png"></p>
<h1 id="区域间路由汇总和外部路由汇总"><a href="#区域间路由汇总和外部路由汇总" class="headerlink" title="区域间路由汇总和外部路由汇总"></a>区域间路由汇总和外部路由汇总</h1><h2 id="在ABR执行路由汇总"><a href="#在ABR执行路由汇总" class="headerlink" title="在ABR执行路由汇总"></a>在ABR执行路由汇总</h2><p>•路由汇总又被称为路由聚合，即是将一组前缀相同的路由汇聚成一条路由，从而达到减小路由表规模以及优化设备资源利用率的目的，我们把汇聚之前的这组路由称为精细路由或明细路由，把汇聚之后的这条路由称为汇总路由或聚合路由。</p>
<p>•OSPF路由汇总的类型：</p>
<p>​    ▫在ABR执行路由汇总：对区域间的路由执行路由汇总。</p>
<p>​    ▫在ASBR执行路由汇总：对引入的外部路由执行路由汇总。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/14.png"></p>
<h2 id="在ASBR执行路由汇总"><a href="#在ASBR执行路由汇总" class="headerlink" title="在ASBR执行路由汇总"></a>在ASBR执行路由汇总</h2><p>•在ASBR配置路由汇总后，ASBR将对自己所引入的外部路由进行汇总。</p>
<p>•NSSA区域的ASBR也可以对引入NSSA区域的外部路由进行汇总。</p>
<p>•在NSSA区域中，ABR执行7类LSA转化成5类LSA动作，此时它也是ASBR。若配置路由汇总，则对由7类LSA转化成的5类LSA进行汇总。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/15.png"></p>
<blockquote>
<p>•R1、R3、R5分别对引入的外部路由执行路由汇总。</p>
</blockquote>
<h1 id="OSPF协议特性"><a href="#OSPF协议特性" class="headerlink" title="OSPF协议特性"></a>OSPF协议特性</h1><h2 id="Silent-Interface"><a href="#Silent-Interface" class="headerlink" title="Silent-Interface"></a>Silent-Interface</h2><p>•通过Silent-Interface的配置，增强OSPF的组网适应能力，减少系统资源的消耗。</p>
<p>•Silent-Interface有以下特性：</p>
<p>​    ▫Silent-Interface不会接收和发送OSPF报文。</p>
<p>​    ▫Silent-Interface的直连路由仍可以发布出去。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/16.png"></p>
<h2 id="OSPF报文认证"><a href="#OSPF报文认证" class="headerlink" title="OSPF报文认证"></a>OSPF报文认证</h2><p>•OSPF支持报文认证功能，只有通过认证的OSPF报文才能被接收。</p>
<p>•路由器支持两种OSPF报文认证方式，当两种认证方式都存在时，优先使用接口认证方式：</p>
<p>​    ▫区域认证方式：一个OSPF区域中所有的路由器在该区域下的认证模式和口令必须一致。</p>
<p>​    ▫接口认证方式：相邻路由器直连接口下的认证模式和口令必须一致。</p>
<p><img src="/2021/05/09/OSPF%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F%E5%8F%8A%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/17.png"></p>
<blockquote>
<p>区域视图下，配置OSPF区域的认证模式。</p>
<ul>
<li>执行命令<strong>authentication-mode simple</strong>  [ <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> ]，配置OSPF区域的认证模式。<ul>
<li>plain表示明文口令类型。</li>
<li>cipher表示密文口令类型。对于MD5/HMAC-MD5认证模式，当此参数缺省时，默认为cipher类型。</li>
</ul>
</li>
</ul>
<p>配置接口认证方式。</p>
<ul>
<li>执行命令<strong>ospf</strong> <strong>authentication-mode simple</strong> [ <strong>plain</strong> <em>plain-text</em> | [ <strong>cipher</strong> ] <em>cipher-text</em> ]，配置OSPF接口的认证模式。</li>
</ul>
</blockquote>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）OSPF定义了以下哪几种特殊区域？(   )</p>
<p><strong>A.Stub Area</strong></p>
<p><strong>B.Totally Stub Area</strong></p>
<p><strong>C.Not-So-Stubby Area（NSSA)</strong></p>
<p><strong>D.Totally NSSA</strong></p>
<p>2.（简答题）Stub区域与Totally Stub区域的主要差别是什么？</p>
<p><strong>Stub区域不允许4类和5类LSA进入，但允许3类LSA进入。Totally Stub区域不仅不允许4类和5类LSA进入，同时也不允许3类LSA进入，只允许表示缺省路由的3类LSA进入。</strong></p>
<p>3.（简答题）区域间路由汇总功能在什么路由器上配置？</p>
<p><strong>在ABR上配置</strong></p>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><p>•本章详细介绍了OSPF特殊区域，Stub区域内的路由器通过缺省路由到达外部网络、Totally Stub区域内的路由器通过缺省路由到达外部网络和OSPF区域间网络；NSSA、Totally NSSA区域内的路由器可引入外部路由。</p>
<p>•在本章还介绍了OSPF协议的特性。包括Silent-Interface、认证、以及OSPF路由器收到LSA时的处理方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/" itemprop="url">OSPF路由计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-09T19:04:13+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•同一区域内的OSPF路由器拥有完全一致的LSDB，在区域内部，OSPF采用SPF算法完成路由计算。</p>
<p>•随着网络规模不断扩大，路由器为了完成路由计算所消耗的内存、CPU资源也越来越多。通过区域划分可以在一定程度上缓解路由器的压力。</p>
<p>•在大规模网络中除了OSPF之外，还可能存在其它路由协议，OSPF支持外部路由引入，从而使得OSPF路由器知晓到达域外的路由。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫解释LSA关键字段的作用；</p>
<p>▫描述常见的LSA类型及其功能；</p>
<p>▫阐明SPF算法；</p>
<p>▫描述OSPF区域内路由、区域间路由计算原理；</p>
<p>▫描述OSPF区域间路由的防环机制；</p>
<p>▫描述OSPF外部路由计算原理。</p>
<h1 id="区域内路由计算"><a href="#区域内路由计算" class="headerlink" title="区域内路由计算"></a>区域内路由计算</h1><h2 id="LSA概述"><a href="#LSA概述" class="headerlink" title="LSA概述"></a>LSA概述</h2><h3 id="LSA的基本概念"><a href="#LSA的基本概念" class="headerlink" title="LSA的基本概念"></a>LSA的基本概念</h3><p>•LSA是OSPF进行路由计算的关键依据。</p>
<p>•OSPF的LSU报文可以携带多种不同类型的LSA。</p>
<p>•各种类型的LSA拥有相同的报文头部。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/1.png"></p>
<p><strong>重要字段解释</strong></p>
<p>•<strong>LS Age</strong>（链路状态老化时间）：此字段表示LSA已经生存的时间，单位是秒。</p>
<p>•<strong>Options</strong>（可选项）：每一个bit都对应了OSPF所支持的某种特性。</p>
<p>•<strong>LS Type</strong>（链路状态类型）<strong>：</strong>指示本LSA的类型。</p>
<p>•<strong>Link State ID</strong>（链路状态ID）<strong>：</strong>不同的LSA，对该字段的定义不同。</p>
<p>•<strong>Advertising Router</strong>（通告路由器）：产生该LSA的路由器的Router ID。</p>
<p>•<strong>LS</strong> <strong>Sequence</strong> <strong>Number</strong>（链路状态序列号）：当LSA每次有新的实例产生时，序列号就会增加。</p>
<p>•<strong>LS Checksum</strong>（校验和）：用于保证数据的完整性和准确性。</p>
<p>•<strong>Length</strong>：是一个包含LSA头部在内的LSA的总长度值。</p>
<blockquote>
<p>•链路状态类型、链路状态ID、通告路由器三元组唯一地标识了一个LSA。</p>
<p>•链路状态老化时间 、链路状态序列号 、校验和用于判断LSA的新旧</p>
<p>•LS Age：当LSA被始发时，该字段为0，随着LSA在网络中被泛洪，该时间逐渐累加，当到达MaxAge（缺省值为3600s）时，LSA不再用于路由计算。</p>
<p>•LS Sequence Number：该字段用于判断LSA的新旧或是否存在重复的实例。序列号范围是0x80000001-0x7FFFFFFF，路由器始发一个LSA，序列号为0x80000001，之后每次更新序列号加1，当LSA达到最大序列号时，重新产生该LSA，并且把序列号设置为0x80000001。</p>
</blockquote>
<h3 id="常见LSA的类型"><a href="#常见LSA的类型" class="headerlink" title="常见LSA的类型"></a>常见LSA的类型</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/2.png"></p>
<blockquote>
<p>•在许多场合中，我们习惯使用类型值来称呼对应的LSA，例如1类LSA等同于Router LSA，2类LSA等同于Network LSA，以此类推。</p>
</blockquote>
<h2 id="Router-LSA"><a href="#Router-LSA" class="headerlink" title="Router-LSA"></a>Router-LSA</h2><h3 id="Router-LSA详解-1"><a href="#Router-LSA详解-1" class="headerlink" title="Router LSA详解 (1)"></a>Router LSA详解 (1)</h3><p>•Router LSA（1类LSA）：每台OSPF路由器都会产生。它描述了该路由器直连接口的信息。</p>
<p>•Router LSA只能在所属的区域内泛洪。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/3.png"></p>
<p>•V (Virtual Link ) ：如果产生此LSA的路由器是虚连接的端点，则置为1。 </p>
<p>•E (External )： 如果产生此LSA的路由器是ASBR，则置为1。 </p>
<p>•B (Border )：如果产生此LSA的路由器是ABR，则置为1。 </p>
<p>•links ：LSA中的Link（链路）数量。Router LSA使用Link来承载路由器直连接口的信息。</p>
<h3 id="Router-LSA详解-2"><a href="#Router-LSA详解-2" class="headerlink" title="Router LSA详解 (2)"></a>Router LSA详解 (2)</h3><p>•Router LSA使用Link来承载路由器直连接口的信息。</p>
<p>•每条Link均包含“链路类型”、“链路ID”、“链路数据”以及“度量值”这几个关键信息。</p>
<p>•路由器可能会采用一个或者多个Link来描述某个接口。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/4.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/5.png"></p>
<blockquote>
<p>•度量值（Metric）：Cost值。</p>
</blockquote>
<h3 id="Router-LSA描述P2P网络"><a href="#Router-LSA描述P2P网络" class="headerlink" title="Router LSA描述P2P网络"></a>Router LSA描述P2P网络</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/6.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/7.png"></p>
<h3 id="Router-LSA描述TransNet"><a href="#Router-LSA描述TransNet" class="headerlink" title="Router LSA描述TransNet"></a>Router LSA描述TransNet</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/8.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/9.png"></p>
<h2 id="Network-LSA"><a href="#Network-LSA" class="headerlink" title="Network-LSA"></a>Network-LSA</h2><h3 id="Network-LSA详解"><a href="#Network-LSA详解" class="headerlink" title="Network LSA详解"></a>Network LSA详解</h3><p>•Network LSA（2类LSA） ：由DR产生，描述本网段的链路状态，在所属的区域内传播。</p>
<p>•Network LSA 记录了该网段内所有与DR建立了邻接关系的OSPF路由器，同时携带了该网段的网络掩码。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/10.png"></p>
<p>•<strong>Link State ID</strong> <strong>：</strong>DR的接口IP地址。</p>
<p>•<strong>Network Mask</strong>：MA网络的子网掩码。</p>
<p>•<strong>Attached Router</strong>：连接到该MA网络的路由器的Router-ID（与该DR建立了邻接关系的邻居的Router-ID，以及DR自己的Router-ID），如果有多台路由器接入该MA网络，则使用多个字段描述。</p>
<h3 id="Network-LSA描述MA网络"><a href="#Network-LSA描述MA网络" class="headerlink" title="Network LSA描述MA网络"></a>Network LSA描述MA网络</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/11.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/12.png"></p>
<h2 id="SPF计算过程"><a href="#SPF计算过程" class="headerlink" title="SPF计算过程"></a>SPF计算过程</h2><h3 id="SPF算法-1"><a href="#SPF算法-1" class="headerlink" title="SPF算法 (1)"></a>SPF算法 (1)</h3><p>Phase 1：构建SPF树。</p>
<p>▫路由器将自己作为最短路径树的树根，根据Router-LSA和Network-LSA中的拓扑信息，依次将Cost值最小的路由器添加到SPF树中。路由器以Router ID或者DR标识。</p>
<p>▫广播网络中DR和其所连接路由器的Cost值为0。</p>
<p>▫SPF树中只有单向的最短路径，保证了OSPF区域内路由计算不会出现环路。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/13.png"></p>
<h3 id="SPF算法-2"><a href="#SPF算法-2" class="headerlink" title="SPF算法 (2)"></a>SPF算法 (2)</h3><p>Phase 2：计算最优路由。</p>
<p>▫将Router-LSA、Network-LSA中的路由信息以叶子节点形式附加在对应的OSPF路由器上，计算最优路由。</p>
<p>▫已经出现的路由信息不会再添加到SPF树干上。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/14.png"></p>
<h3 id="SPF算法举例"><a href="#SPF算法举例" class="headerlink" title="SPF算法举例"></a>SPF算法举例</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/15.png"></p>
<h3 id="构建SPF树-1"><a href="#构建SPF树-1" class="headerlink" title="构建SPF树 (1)"></a>构建SPF树 (1)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/16.png"></p>
<h3 id="构建SPF树-2"><a href="#构建SPF树-2" class="headerlink" title="构建SPF树 (2)"></a>构建SPF树 (2)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/17.png"></p>
<h3 id="构建SPF树-3"><a href="#构建SPF树-3" class="headerlink" title="构建SPF树 (3)"></a>构建SPF树 (3)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/18.png"></p>
<h3 id="构建SPF树-4"><a href="#构建SPF树-4" class="headerlink" title="构建SPF树 (4)"></a>构建SPF树 (4)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/19.png"></p>
<blockquote>
<p>•R3在候选列表中存在两个不同的Cost值，分别为48和2，因此将Cost值较小的添加到最短路径树，并从候选列表中删除。</p>
</blockquote>
<h3 id="构建SPF树-5"><a href="#构建SPF树-5" class="headerlink" title="构建SPF树 (5)"></a>构建SPF树 (5)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/20.png"></p>
<h3 id="构建SPF树-6"><a href="#构建SPF树-6" class="headerlink" title="构建SPF树 (6)"></a>构建SPF树 (6)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/21.png"></p>
<h3 id="构建SPF树-7"><a href="#构建SPF树-7" class="headerlink" title="构建SPF树 (7)"></a>构建SPF树 (7)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/22.png"></p>
<h3 id="计算最优路由"><a href="#计算最优路由" class="headerlink" title="计算最优路由"></a>计算最优路由</h3><p>•从根节点开始依次添加各节点LSA中的路由信息。</p>
<p>•添加顺序为各节点加入SPF树的顺序，已经出现的忽略。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/23.png"></p>
<blockquote>
<p>•第二阶段根据Router LSA中的Stub、Network LSA中的路由信息，完成最优路由的计算。</p>
<p>•从根节点开始，依次添加LSA中的路由信息（添加顺序按照每个节点加入SPF树的顺序）：</p>
<p>▫10.0.1.1（R1）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.13.0/24，Metric=48；</p>
<p>▫10.0.12.2（DR）的Network LSA中，网络号/子网掩码10.0.12.0/24，Metric=1+0=1；</p>
<p>▫10.0.2.2（R2）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.24.0/24，Metric=1+0+48=49；</p>
<p>▫10.0.235.2（DR）的Network LSA中，网络号/子网掩码10.0.235.0/24，Metric=1+0+1=2；</p>
<p>▫10.0.3.3（R3）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.13.0/24，已在R1上，忽略；</p>
<p>▫10.0.5.5（R5）的Router LSA中，共1个Stub连接，网络号/子网掩码10.0.45.0/24，Metric=1+0+0+1+48=50；</p>
<p>▫10.0.4.4（R4）的Router LSA中，共2个Stub连接，网络号/子网掩码10.0.24.0/24，已在R2上，忽略；网络号/子网掩码10.0.45.0/24，已在R5上，忽略。</p>
</blockquote>
<h3 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/24.png"></p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1.（多选题）Router-LSA中主要包含哪几种链路类型？(   )</p>
<p><strong>A.P2P</strong></p>
<p><strong>B.TransNet</strong></p>
<p><strong>C.StubNet</strong></p>
<p><strong>D.Vlink</strong></p>
<p>2.（判断题）经过SPF算法计算后，被认为是最优的OSPF路由一定会被放入路由器的路由表。(  )</p>
<p>A.对</p>
<p><strong>B.错</strong></p>
<h2 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h2><p>•OSPF根据LSDB计算路由表，LSDB中可能存在多种类型的LSA，并且所有的LSA有相同的报文头部格式。</p>
<p>•同一区域的OSPF路由器拥有完全一致的LSDB。在只有一个区域的情况下，区域内部主要存在两种类型的LSA，即Router-LSA和Network-LSA。</p>
<p>•每台路由器都会产生Router-LSA，描述了路由器的直连接口信息。</p>
<p>•在MA网络中，DR会产生Network-LSA来描述接入该MA网络的所有路由器的Router-ID（其中包括DR自身），以及这个网络的掩码。</p>
<h1 id="区域间路由计算"><a href="#区域间路由计算" class="headerlink" title="区域间路由计算"></a>区域间路由计算</h1><h2 id="区域间路由计算过程"><a href="#区域间路由计算过程" class="headerlink" title="区域间路由计算过程"></a>区域间路由计算过程</h2><h3 id="大型网络中，单区域OSPF存在的问题"><a href="#大型网络中，单区域OSPF存在的问题" class="headerlink" title="大型网络中，单区域OSPF存在的问题"></a>大型网络中，单区域OSPF存在的问题</h3><p>•一系列连续的OSPF路由器构成的网络称为OSPF域（Domain）。</p>
<p>•OSPF要求网络内的路由器同步LSDB，实现对于网络的一致认知。</p>
<p>•当网络规模越来越大时，LSDB将变得非常臃肿，设备基于该LSDB进行路由计算，其负担也极大地增加了，此外路由器的路由表规模也变大了，这些无疑都将加大路由器的性能损耗。</p>
<p>•当网络拓扑发生变更时，这些变更需要被扩散到整个网络，并可能引发整网的路由重计算。</p>
<p>•单区域的设计，使得OSPF无法部署路由汇总。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/25.png"></p>
<h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>•Router LSA和Network LSA只在区域内泛洪，因此通过区域划分在一定程度上降低网络设备的内存及CPU的消耗。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/26.png"></p>
<p>划分区域后，路由器可以分为两种角色：</p>
<p>区域内部路由器（Internal Router）：该类设备的所有接口都属于同一个OSPF区域。如R1、R4、R5。</p>
<p>区域边界路由器（Area Border Router）：该类设备接口分别连接两个及两个以上的不同区域。如R2、R3。</p>
<h3 id="区域间路由信息传递"><a href="#区域间路由信息传递" class="headerlink" title="区域间路由信息传递"></a>区域间路由信息传递</h3><p>•OSPF区域间路由信息传递是通过ABR产生的Network Summary LSA（3类LSA）实现的。</p>
<p>•以192.168.1.0/24路由信息为例：</p>
<p>​    ▫R2依据Area 1内所泛洪的Router LSA及Network LSA计算得出192.168.1.0/24路由（区域内路由），并将该路由通过Network Summary LSA通告到Area 0。R3根据该LSA可计算出到达192.168.1.0/24的区域间路由。</p>
<p>​    ▫R3重新生成一份Network Summary LSA通告到Area 2中，至此所有OSPF区域都能学习到去往192.168.1.0/24的路由。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/27.png"></p>
<h3 id="Network-Summary-LSA详解"><a href="#Network-Summary-LSA详解" class="headerlink" title="Network Summary LSA详解"></a>Network Summary LSA详解</h3><p>Network Summary LSA（3类LSA）由ABR产生，用于向一个区域通告到达另一个区域的路由。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/28.png"></p>
<h3 id="Network-Summary-LSA示例"><a href="#Network-Summary-LSA示例" class="headerlink" title="Network Summary LSA示例"></a>Network Summary LSA示例</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/29.png"></p>
<h3 id="R1和R3的路由计算"><a href="#R1和R3的路由计算" class="headerlink" title="R1和R3的路由计算"></a>R1和R3的路由计算</h3><p>1.通过区域内SPF的计算，R1到达R2的Cost值为1，R3到达R2的Cost值为2。</p>
<p>2.R1和R3根据收到的Network Summary LSA进行路由计算：</p>
<p>▫R1将到达R2和Cost值和Network Summary LSA所携带的Cost值相加，因此R1到达192.168.1.0/24的Cost值为2。</p>
<p>▫R3将到达R2和Cost值和Network Summary LSA所携带的Cost值相加，因此R3到达192.168.1.0/24的Cost值为3。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/30.png"></p>
<h3 id="R5的路由计算"><a href="#R5的路由计算" class="headerlink" title="R5的路由计算"></a>R5的路由计算</h3><p>1.R3作为ABR，它通过Area 0内泛洪的Network Summary LSA计算出到达192.168.1.0/24的路由，然后重新向Area 2注入到达该网段的Network Summary LSA，其中包含自己到达该网段的Cost（值为3）。</p>
<p>2.R5在SPF中计算得知到达R3的Cost为1，因此R5到达192.168.1.0/24的Cost为4。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/31.png"></p>
<h3 id="区域间路由计算结果验证"><a href="#区域间路由计算结果验证" class="headerlink" title="区域间路由计算结果验证"></a>区域间路由计算结果验证</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/32.png"></p>
<h2 id="区域间路由防环机制"><a href="#区域间路由防环机制" class="headerlink" title="区域间路由防环机制"></a>区域间路由防环机制</h2><h3 id="域间路由环路的产生"><a href="#域间路由环路的产生" class="headerlink" title="域间路由环路的产生"></a>域间路由环路的产生</h3><p>•OSPF区域间路由的传播过程与距离矢量路由协议的路由传播过程非常相似。</p>
<p>•对于区域间路由的传递，OSPF也需要一定的防环机制。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/33.png"></p>
<h3 id="区域间路由的防环机制-1"><a href="#区域间路由的防环机制-1" class="headerlink" title="区域间路由的防环机制 (1)"></a>区域间路由的防环机制 (1)</h3><p>OSPF要求所有的非骨干区域必须与Area0直接相连，区域间路由需经由Area0中转。</p>
<p>区域间的路由传递不能发生在两个非骨干区域之间，这使得OSPF的区域架构在逻辑上形成了一个类似星型的拓扑。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/34.png"></p>
<h3 id="区域间路由的防环机制-2"><a href="#区域间路由的防环机制-2" class="headerlink" title="区域间路由的防环机制 (2)"></a>区域间路由的防环机制 (2)</h3><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/35.png"></p>
<h3 id="区域间路由的防环机制-3"><a href="#区域间路由的防环机制-3" class="headerlink" title="区域间路由的防环机制 (3)"></a>区域间路由的防环机制 (3)</h3><p>ABR从非骨干区域收到的3类LSA不能用于区域间路由的计算。</p>
<p>R1和R2、R3和R4之间的链路中断导致骨干区域不连续。</p>
<ul>
<li><p>R4将10.0.2.2/32路由以3类LSA的形式发送到Area 1。</p>
</li>
<li><p>R5和R6可以根据上述3类LSA计算出10.0.2.2/32路由。</p>
</li>
<li><p>R3从非骨干区域收到3类LSA，不进行路由计算，也不会将此3类LSA发送到其他区域。</p>
</li>
<li><p>此时，R1和R3都无法和10.0.2.2/32通信。</p>
</li>
</ul>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/36.png"></p>
<h2 id="虚连接的作用及配置"><a href="#虚连接的作用及配置" class="headerlink" title="虚连接的作用及配置"></a>虚连接的作用及配置</h2><p>•OSPF要求骨干区域必须是连续的，但是并不要求物理上连续，可以使用虚连接使骨干区域在逻辑上连续。</p>
<p>•虚连接可以在任意两个ABR上建立，但是要求这两个ABR都有端口连接到一个相同的非骨干区域。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/37.png"></p>
<blockquote>
<p>•注意：虚连接的创建使OSPF协议可以通过非骨干区域通信，违背了OSPF区域间的防环规则，在某些场景下会导致路由环路的产生，因此不建议部署OSPF虚连接。</p>
</blockquote>
<h3 id="虚连接的优缺点"><a href="#虚连接的优缺点" class="headerlink" title="虚连接的优缺点"></a>虚连接的优缺点</h3><p><strong>优点</strong></p>
<ol>
<li>解决骨干区域被分割的问题</li>
<li>解决骨干区域到非骨干区域不相连</li>
<li>增强冗余性和可靠性</li>
<li>解决次优路径</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>配置不当时可能会导致环路</li>
<li>虚连接不能路由汇总</li>
</ol>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>1.（判断题）一条Network Summary LSA只能描述一条路由信息。</p>
<p>A.错</p>
<p><strong>B.对</strong></p>
<p>2.（简答题）OSPF如何避免区域间的路由环路？</p>
<p><strong>OSPF划分了骨干区域和非骨干区域，所有非骨干区域均直接和骨干区域相连，且骨干区域只有一个；非骨干区域之间的通信都要通过骨干区域中转；并规定从骨干区域传来的三类LSA不再传回骨干区域。</strong></p>
<h2 id="本节小结-1"><a href="#本节小结-1" class="headerlink" title="本节小结"></a>本节小结</h2><p>•OSPF引入了多区域的概念，使得该协议能够支持更大规模的组网。</p>
<p>•OSPF使用3类LSA来描述区域间的路由信息。</p>
<p>•为了避免出现区域间路由环路，OSPF设计了多个规则。</p>
<p>•OSPF Virtual Link是一种虚拟的、逻辑的链路，被部署在两台OSPF路由器之间，它穿越某个非骨干区域，用于实现另一个非骨干区域与Area0的连接。Virtual Link应该始终作为一种临时的技术手段来解决非骨干区域没有与Area0直接相连的情况。</p>
<h1 id="外部路由计算"><a href="#外部路由计算" class="headerlink" title="外部路由计算"></a>外部路由计算</h1><h2 id="OSPF外部路由引入背景"><a href="#OSPF外部路由引入背景" class="headerlink" title="OSPF外部路由引入背景"></a>OSPF外部路由引入背景</h2><p>网络中存在部分链路未开启OSPF协议如：</p>
<p>▫路由器连接外部网络使用静态路由或者BGP协议；</p>
<p>▫服务器直连的链路未开启OSPF协议。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/38.png"></p>
<h2 id="外部路由引入的基本概念"><a href="#外部路由引入的基本概念" class="headerlink" title="外部路由引入的基本概念"></a>外部路由引入的基本概念</h2><p>•ASBR（AS Boundary Router）：自治系统边界路由器。只要一台OSPF设备引入了外部路由，它就成为了ASBR。如图中的R1。</p>
<p>•ASBR将外部路由信息以AS-external LSA（5类LSA）的形式在OSPF网络内泛洪。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/39.png"></p>
<blockquote>
<p>•<strong>在OSPF进程下，通过如下命令引入外部路由。设备支持引入BGP、ISIS、OSPF、直连以及静态路由。</strong></p>
<p>▫<strong>import-route</strong> { <strong>limit</strong> <em>limit-number</em> | { <strong>bgp</strong> [ <strong>permit-ibgp</strong> ] | <strong>direct</strong> | <strong>unr</strong> | <strong>rip</strong> [ <em>process-id-rip</em> ] | <strong>static</strong> | <strong>isis</strong> [ process-id-isis ] | <strong>ospf</strong> [ process-id-ospf ] } [ <strong>cost</strong> <em>cost</em> | <strong>type</strong> <em>type</em> | <strong>tag</strong> <em>tag</em> | <strong>route-policy</strong> <em>route-policy-name</em> ]  }</p>
</blockquote>
<h2 id="AS-external-LSA详解"><a href="#AS-external-LSA详解" class="headerlink" title="AS-external LSA详解"></a>AS-external LSA详解</h2><p>AS-external LSA（5类LSA）：由ASBR产生，描述到达AS外部的路由，该LSA会被通告到所有的区域（除了Stub区域和NSSA区域）。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/40.png"></p>
<blockquote>
<p>•Forwarding Address：当FA为0.0.0.0时，则到达该外部网段的流量会被发往引入这条外部路由的ASBR。而如果FA不为0.0.0.0，则流量会被发往这个转发地址。FA这一概念的引入，使得OSPF在某些特殊的场景中得以规避次优路径问题。</p>
<p>•External Route Tag（外部路由标记）：这是一个只有外部路由才能够携带的标记，常被用于部署路由策略。</p>
</blockquote>
<h2 id="AS-external-LSA示例"><a href="#AS-external-LSA示例" class="headerlink" title="AS-external LSA示例"></a>AS-external LSA示例</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/41.png"></p>
<h2 id="R3的路由计算过程"><a href="#R3的路由计算过程" class="headerlink" title="R3的路由计算过程"></a>R3的路由计算过程</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/42.png"></p>
<h2 id="ASBR-Summary-LSA"><a href="#ASBR-Summary-LSA" class="headerlink" title="ASBR-Summary LSA"></a>ASBR-Summary LSA</h2><p>ASBR-Summary LSA（4类LSA）：由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/43.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/44.png"></p>
<h2 id="ASBR-Summary-LSA示例"><a href="#ASBR-Summary-LSA示例" class="headerlink" title="ASBR-Summary LSA示例"></a>ASBR-Summary LSA示例</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/45.png"></p>
<h2 id="R5的路由计算过程"><a href="#R5的路由计算过程" class="headerlink" title="R5的路由计算过程"></a>R5的路由计算过程</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/46.png"></p>
<h2 id="区分OSPF外部路由的2种度量值类型-1"><a href="#区分OSPF外部路由的2种度量值类型-1" class="headerlink" title="区分OSPF外部路由的2种度量值类型 (1)"></a>区分OSPF外部路由的2种度量值类型 (1)</h2><p>•<strong>Metric-Type-1</strong></p>
<p>▫当外部路由的开销与自治系统内部的路由开销相当，并且和OSPF自身路由的开销具有可比性时，可以认为这类路由的可信程度较高，将其配置成Metric-Type-1。</p>
<p>▫Metric-Type-1外部路由的开销为AS内部开销（路由器到ASBR的开销）与AS外部开销之和。</p>
<p>•<strong>Metric-Type-2</strong></p>
<p>▫当ASBR到AS之外的开销远远大于在AS之内到达ASBR的开销时，可以认为这类路由的可信程度较低，将其配置成Metric-Type-2。</p>
<p>▫Metric-Type-2外部路由的开销等于AS外部开销。</p>
<p><strong>•相同的路由时路由路径的选择方法</strong></p>
<p>▫先比外部cost (Type 1&gt;Type2)</p>
<p>▫当外部cost相同时，比较内部cost值</p>
<p>▫若内部cost也相同，则负载均衡</p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/47.png"></p>
<h2 id="区分OSPF外部路由的2种度量值类型-2"><a href="#区分OSPF外部路由的2种度量值类型-2" class="headerlink" title="区分OSPF外部路由的2种度量值类型 (2)"></a>区分OSPF外部路由的2种度量值类型 (2)</h2><p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/48.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/49.png"></p>
<p><img src="/2021/05/09/OSPF%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97/50.png"></p>
<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><p>1.（多选题）ABR可能会产生以下哪些类型的LSA？(   )</p>
<p><strong>A. ASBR-Summary LSA</strong></p>
<p><strong>B. AS-external-LSA</strong></p>
<p><strong>C. Router-LSA</strong></p>
<p><strong>D. Network Summary LSA</strong></p>
<p>2.（单选题）对于同一个路由前缀，以下哪种优先级最高？(   )</p>
<p><strong>A.区域内路由</strong></p>
<p>B.区域间路由</p>
<p>C.第一类外部路由</p>
<p>D.第二类外部路由</p>
<h2 id="本节小结-2"><a href="#本节小结-2" class="headerlink" title="本节小结"></a>本节小结</h2><p>•在一个大规模网络中，可能存在多种不同的路由协议，OSPF支持将AS外部路由引入本AS，使得AS内的路由器能够获知到达AS外部的路由。</p>
<p>•ASBR将外部路由引入OSPF后，使用5类LSA描述它们，与ASBR同属一个区域的路由器能够根据5类LSA以及区域内的1类、2类LSA完成外部路由计算；与ASBR不在同一个区域的路由器还需借助4类LSA才能完成外部路由计算。</p>
<p>•OSPF将外部路由引入OSPF后，可以设置路由的度量值类型：Metric-Type-1或Metric-Type-2，不同度量值类型的外部路由，其开销的计算方式不同，其路由的优先级也不相同，Metric-Type-1路由的优先级高于Metric-Type-2路由。</p>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><p>•本章知识点包括OSPF区域内路由计算、区域间路由计算、外部路由计算等。</p>
<p>•OSPF路由遵循以下优先级顺序，区域内路由&gt;区域间路由&gt;Metric-Type-1外部路由&gt;Metric-Type-2外部路由。</p>
<p>•LSA是OSPF链路状态信息的载体，随着网络规模逐渐变大，网络业务逐渐变得复杂，通过OSPF区域的划分以及大量外部路由的引入，路由器的LSDB中可能存在大量的1类、2类、3类、4类、5类LSA，容易造成设备性能的浪费。</p>
<p>•OSPF存在什么技术手段可以在保证网络可达性的前提下，减少设备性能损耗么？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/" itemprop="url">IP-OSPF基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:14:14+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•路由器根据路由表转发数据包，路由表项可通过手动配置和动态路由协议生成。</p>
<p>•静态路由比动态路由使用更少的带宽，并且不占用CPU资源来计算和分析路由更新。当网络结构比较简单时，只需配置静态路由就可以使网络正常工作。但是当网络发生故障或者拓扑发生变化后，静态路由不会自动更新，必须手动重新配置。</p>
<p>•相比较于静态路由，动态路由协议具有更强的可扩展性，具备更强的应变能力。</p>
<p>•OSPF（Open Shortest Path First，开放式最短路径优先）具有扩展性强，收敛速度快等特点，作为优秀的内部网关协议被广泛使用。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述OSPF路由计算的整体过程</p>
<p>▫阐明DR与BDR的作用</p>
<p>▫描述OSPF报文类型和作用</p>
<p>▫实现OSPF的基本配置</p>
<p>▫区分OSPF邻居关系和邻接关系</p>
<h1 id="动态路由协议简介"><a href="#动态路由协议简介" class="headerlink" title="动态路由协议简介"></a><strong>动态路由协议简介</strong></h1><h2 id="动态路由协议的分类"><a href="#动态路由协议的分类" class="headerlink" title="动态路由协议的分类"></a><strong>动态路由协议的分类</strong></h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/1.png"></p>
<blockquote>
<p>•BGP使用一种基于距离矢量算法修改后的算法，该算法被称为路径矢量（Path Vector）算法。因此在某些场合下，BGP也被称为路径矢量路由协议。</p>
<p>•IGP（内部网关协议）在同一个自治系统内交换路由信息，IGP的主要目的是发现和计算自治域内的路由信息。</p>
<p>•EGP（外部网关协议）主要用于AS（自治系统）之间的互联。</p>
</blockquote>
<h2 id="距离矢量路由协议"><a href="#距离矢量路由协议" class="headerlink" title="距离矢量路由协议"></a><strong>距离矢量路由协议</strong></h2><p>•运行距离矢量路由协议的路由器周期性地泛洪自己的路由表。通过路由的交互，每台路由器都从相邻的路由器学习到路由，并且加载进自己的路由表中，然后再通告给其他相邻路由器。</p>
<p>•对于网络中的所有路由器而言，路由器并不清楚网络的拓扑，只是简单的知道要去往某个目的网段方向在哪里，开销有多大。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/2.png"> </p>
<h2 id="链路状态路由协议-LSA泛洪"><a href="#链路状态路由协议-LSA泛洪" class="headerlink" title="链路状态路由协议 - LSA泛洪"></a>链路状态路由协议 - LSA泛洪</h2><p>•链路状态路由协议通告的的是链路状态而不是路由信息。</p>
<p>•运行链路状态路由协议的路由器之间首先会建立邻居关系，然后彼此之间开始交互LSA（Link State Advertisement，链路状态通告）。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/3.png"></p>
<blockquote>
<p>•链路状态通告，可以简单的理解为每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居路由器之间的关系等）的通告。</p>
</blockquote>
<h2 id="链路状态路由协议-LSDB维护"><a href="#链路状态路由协议-LSDB维护" class="headerlink" title="链路状态路由协议 - LSDB维护"></a>链路状态路由协议 - LSDB维护</h2><p>每台路由器都会产生LSA，路由器将接收到的LSA放入自己的LSDB（Link State DataBase，链路状态数据库）。路由器通过对LSDB中所存储的LSA进行解析，进而了解全网拓扑。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/4.png"></p>
<h2 id="链路状态路由协议-SPF计算"><a href="#链路状态路由协议-SPF计算" class="headerlink" title="链路状态路由协议 - SPF计算"></a>链路状态路由协议 - SPF计算</h2><p>每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法进行计算。每台路由器都计算出一棵以自己为根的、无环的、拥有最短路径的“树”。有了这棵“树”，路由器就已经知道了到达所有网段的优选路径。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<p>•SPF是OSPF路由协议的一个核心算法，用来在一个复杂的网络中做出路由优选的决策。</p>
</blockquote>
<h2 id="链路状态路由协议-路由表生成"><a href="#链路状态路由协议-路由表生成" class="headerlink" title="链路状态路由协议 - 路由表生成"></a>链路状态路由协议 - 路由表生成</h2><p>路由器将计算出来的优选路径，加载进自己的路由表（Routing Table）。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/6.png"></p>
<h2 id="链路状态路由协议总结"><a href="#链路状态路由协议总结" class="headerlink" title="链路状态路由协议总结"></a>链路状态路由协议总结</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/7.png"></p>
<blockquote>
<p>链路状态路由协议有四个步骤：</p>
<p>▫第一步是建立相邻路由器之间的邻居关系。</p>
<p>▫第二步是邻居之间交互链路状态信息和同步LSDB。</p>
<p>▫第三步是进行优选路径计算。</p>
<p>▫第四步是根据最短路径树生成路由表项加载到路由表。</p>
</blockquote>
<h1 id="OSPF简介"><a href="#OSPF简介" class="headerlink" title="OSPF简介"></a>OSPF简介</h1><h2 id="OSPF概述"><a href="#OSPF概述" class="headerlink" title="OSPF概述"></a>OSPF概述</h2><p>•OSPF是IETF定义的一种基于链路状态的内部网关路由协议。目前针对IPv4协议使用的是OSPF Version 2（RFC2328）；针对IPv6协议使用OSPF Version 3（RFC2740）。</p>
<p>•OSPF有以下优点：</p>
<p>▫基于SPF算法，以“累计链路开销”作为选路参考值</p>
<p>▫采用组播形式收发部分协议报文</p>
<p>▫支持区域划分</p>
<p>▫支持对等价路由进行负载分担</p>
<p>▫支持报文认证</p>
<h2 id="OSPF应用场景"><a href="#OSPF应用场景" class="headerlink" title="OSPF应用场景"></a>OSPF应用场景</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/8.png"></p>
<p>•接入层：接入层利用光纤、双绞线、同轴电缆、无线接入技术等传输介质，实现与用户连接，并进行业务和带宽的分配。接入层目的是允许终端用户连接到网络，因此接入层交换机具有低成本和高端口密度特性。</p>
<p>•汇聚层：汇聚层为接入层提供基于策略的连接，如地址合并，协议过滤,路由服务，认证管理等。通过网段划分实现与网络隔离，可以防止网络故障蔓延和影响到核心层。汇聚层同时也可以提供接入层虚拟网之间的互连，控制和限制接入层对核心层的访问，保证核心层的安全和稳定。</p>
<p>•核心层：核心层的功能主要是实现骨干网络之间的优化传输，核心层任务的重点通常是冗余能力、可靠性和高速的传输。</p>
<h2 id="OSPF基础术语-Router-ID"><a href="#OSPF基础术语-Router-ID" class="headerlink" title="OSPF基础术语 - Router ID"></a>OSPF基础术语 - Router ID</h2><p>•Router ID用于在自治系统中唯一标识一台运行OSPF的路由器，它是一个32位的无符号整数。</p>
<p>•Router ID选举规则如下：</p>
<p>▫手动配置OSPF路由器的Router ID（建议手动配置）</p>
<p>▫如果没有手动配置Router ID，则路由器使用Loopback接口中最大的IP地址作为Router ID</p>
<p>▫如果没有配置Loopback接口，则路由器使用物理接口中最大的IP地址作为Router ID</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/9.png"></p>
<blockquote>
<p>•Router ID一旦选定，之后如果要更改的话就需要重启OSPF进程。</p>
<p>•在实际工程中，推荐手工指定OSPF路由设备的Router ID。首先规划出一个私有网段用于OSPF的Router ID选择，例如：192.168.1.0/24。在启用OSPF进程前在每个OSPF路由器上建立一个Loopback接口，使用一个32位掩码的私有地址作为其IP地址，这个32位的私有地址即作为该路由设备的Router ID。如果没有特殊要求，这个Loopback接口地址可以不发布在OSPF网络中。</p>
</blockquote>
<h2 id="OSPF基础术语-区域"><a href="#OSPF基础术语-区域" class="headerlink" title="OSPF基础术语 - 区域"></a>OSPF基础术语 - 区域</h2><p>•OSPF Area用于标识一个OSPF的区域。</p>
<p>•区域是从逻辑上将设备划分为不同的组，每个组用区域号（Area ID）来标识。</p>
<p>•OSPF的区域ID是一个32bit的非负整数，按点分十进制的形式（与IPv4地址的格式一样）呈现，例如Area0.0.0.1。为了简便起见，我们也会采用十进制的形式来表示。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/10.png"></p>
<blockquote>
<p>•几个例子：Area0.0.0.1等同于Area1，Area0.0.0.255等同于Area255，Area0.0.1.0等同于Area256。许多网络厂商的设备同时支持这两种区域ID配置及表示方式。</p>
</blockquote>
<h2 id="OSPF基础术语-度量值"><a href="#OSPF基础术语-度量值" class="headerlink" title="OSPF基础术语 - 度量值"></a>OSPF基础术语 - 度量值</h2><p>•OSPF使用Cost（开销）作为路由的度量值。每一个激活了OSPF的接口都会维护一个接口Cost值，缺省的接口Cost = “100 Mbit/s “ /“接口带宽” 。其中100 “Mbit/s”为OSPF指定的缺省参考值，该值是可配置的。</p>
<p>•OSPF以“累计cost”为开销值，也就是流量从源网络到目的网络所经过所有路由器的出接口的cost总和。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<p>•在实际应用中，推荐根据接口带宽大小手动配置Cost值，而不是修改OSPF参考带宽。</p>
</blockquote>
<h2 id="OSPF基础术语-度量值修改举例"><a href="#OSPF基础术语-度量值修改举例" class="headerlink" title="OSPF基础术语 - 度量值修改举例"></a>OSPF基础术语 - 度量值修改举例</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/12.png"></p>
<blockquote>
<p>•在规划流量路径时，推荐将汇聚层直连链路Cost值&gt;接入环所有链路Cost值之和，这样可以保证从接入层访问R1或R2时，流量可通过接入层路由器直达R1或R2。</p>
<p>•以上图为例。R1和R2位于企业网中的汇聚层，R1和R2的直连链路属于区域0，R1有一个直连网段10.0.1.1/32通过在区域0。</p>
<p>​    ▫在缺省情况下，R4到达10.0.1.1/32的路由存在两个下一跳。</p>
<p>​    ▫修改Cost之后，R4到达10.0.1.1的路由仅存在一个下一跳。</p>
</blockquote>
<h2 id="OSPF三大表项-邻居表"><a href="#OSPF三大表项-邻居表" class="headerlink" title="OSPF三大表项 - 邻居表"></a>OSPF三大表项 - 邻居表</h2><p>OSPF有三张重要的表项，OSPF邻居表、LSDB和OSPF路由表。对于OSPF的邻居表，需要了解：</p>
<p>▫OSPF在传递链路状态信息之前，需先建立OSPF邻居关系。</p>
<p>▫OSPF的邻居关系通过交互Hello报文建立。</p>
<p>▫OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/13.png"></p>
<h2 id="OSPF三大表项-LSDB"><a href="#OSPF三大表项-LSDB" class="headerlink" title="OSPF三大表项 - LSDB"></a>OSPF三大表项 - LSDB</h2><p>对于OSPF的LSDB，需要了解：</p>
<p>▫LSDB会保存自己产生的及从邻居收到的LSA信息，本例中R1的LSDB包含了三条LSA。</p>
<p>▫Type标识LSA的类型，AdvRouter标识发送LSA的路由器。</p>
<p>▫使用命令行display ospf lsdb查看LSDB表。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/14.png"></p>
<h2 id="OSPF三大表项-OSPF路由表"><a href="#OSPF三大表项-OSPF路由表" class="headerlink" title="OSPF三大表项 - OSPF路由表"></a>OSPF三大表项 - OSPF路由表</h2><p>对于OSPF的路由表，需要了解：</p>
<p>▫OSPF路由表和路由器路由表是两张不同的表。本例中OSPF路由表有三条路由。</p>
<p>▫OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。</p>
<p>▫使用命令display ospf routing查看OSPF路由表。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/15.png"></p>
<blockquote>
<p>•路由器路由表通常称为全局路由表，并非所有OSPF路由都可以放到路由器路由表。</p>
</blockquote>
<h2 id="OSPF报文格式和类型"><a href="#OSPF报文格式和类型" class="headerlink" title="OSPF报文格式和类型"></a>OSPF报文格式和类型</h2><p>•OSPF一共定义了5种类型的报文，不同类型的OSPF报文有相同的头部格式。</p>
<p>•OSPF报文直接采用IP封装，在报文的IP头部中，协议号为89。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/16.png"></p>
<blockquote>
<p>•重要字段解释</p>
<p>▫Version ：对于当前所使用的OSPFv2，该字段的值为2。</p>
<p>▫Router ID：表示生成此报文的路由器的Router ID。</p>
<p>▫Area ID：表示此报文需要被通告到的区域。</p>
<p>▫Type：类型字段。</p>
<p>▫Packet length：表示整个OSPF报文的长度，单位是字节。</p>
<p>▫Checksum：校验字段，其校验的范围是整个OSPF报文，包括OSPF报文头部。</p>
<p>▫Auth Type：为0时表示不认证；为1时表示简单的明文密码认证；为2时表示加密（MD5）认证。</p>
<p>▫Authentication：认证所需的信息。该字段的内容随AuType的值不同而不同。</p>
</blockquote>
<h1 id="OSPF工作过程"><a href="#OSPF工作过程" class="headerlink" title="OSPF工作过程"></a>OSPF工作过程</h1><h2 id="OSPF工作过程概览"><a href="#OSPF工作过程概览" class="headerlink" title="OSPF工作过程概览"></a>OSPF工作过程概览</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/17.png"></p>
<h2 id="建立邻居关系"><a href="#建立邻居关系" class="headerlink" title="建立邻居关系"></a>建立邻居关系</h2><p>•OSPF使用Hello报文发现和建立邻居关系。</p>
<p>•在以太网链路上，缺省时，OSPF采用组播的形式发送Hello报文（目的地址224.0.0.5）。</p>
<p>•OSPF Hello报文中包含了路由器的Router ID、邻居列表等信息。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/18.png"></p>
<blockquote>
<p>•R1和R2路由器相互发送Hello报文，第一个Hello报文包含的邻居列表为空。</p>
<p>•R2收到R1发送的Hello报文后，如果各项参数匹配，再次发送Hello报文时，将R1加入自己的邻居列表。</p>
<p>•在以太网链路上，通常以组播形式发送Hello报文：</p>
<p>​    ▫224.0.0.5的组播地址为OSPF设备的预留IP组播地址。</p>
<p>​    ▫224.0.0.6的组播地址为OSPF DR/BDR的预留IP组播地址。</p>
<p>•对于不支持组播的链路，OSPF支持采用单播的方式发送Hello报文。</p>
</blockquote>
<h3 id="影响邻居建立的因素"><a href="#影响邻居建立的因素" class="headerlink" title="影响邻居建立的因素"></a>影响邻居建立的因素</h3><ol>
<li><p><strong>Router ID</strong>：直连不能相同，非直连相同导致路由震荡</p>
</li>
<li><p><strong>认证</strong>：认证必须配置一致，否则不能建立邻居</p>
</li>
<li><p><strong>Area ID</strong>:必须一致，否则不能建立</p>
</li>
<li><p><strong>Hello间隔</strong>:必须一致否则不能建立</p>
<table>
<thead>
<tr>
<th></th>
<th>MA</th>
<th>P2P</th>
<th>NBMA</th>
<th>P2MP</th>
</tr>
</thead>
<tbody><tr>
<td>Hello time</td>
<td>10</td>
<td>10</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Hello dead time</td>
<td>40</td>
<td>40</td>
<td>120</td>
<td>120</td>
</tr>
</tbody></table>
</li>
<li><p><strong>接口网络类型</strong>：</p>
<p>NBMA与其它网络类型不能建立起邻居关系</p>
<p>MA与P2P可以建立起来，但不能进行路由计算</p>
</li>
<li><p><strong>接口MTU值</strong>:默认不开启，ospf mtu-enable，如果不相同会卡在exstart或exchang状态。</p>
</li>
<li><p><strong>静默接口 silent-interface</strong>：接口配置成静默接口不会发送hello报文</p>
</li>
<li><p><strong>hello报文中掩码信息不一致</strong>：MA网络 不一致不能建立 P2P可以建立因为此网络类型不检查掩码信息</p>
</li>
<li><p><strong>option字段</strong>：常规区域与特殊区域不能建立邻居关系</p>
</li>
<li><p><strong>DR priority 为 0</strong>：不建立<strong>邻接</strong>关系</p>
</li>
</ol>
<h2 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h2><p>•Hello报文的主要作用：</p>
<p>▫邻居发现：自动发现邻居路由器。</p>
<p>▫邻居建立：完成Hello报文中的参数协商，建立邻居关系。</p>
<p>▫邻居保持：通过周期性发送和接收，检测邻居运行状态。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/19.png"></p>
<p>•<strong>重要字段解释</strong></p>
<p>​    ▫<strong>Network</strong> <strong>Mask：</strong>发送Hello报文的接口的网络掩码。</p>
<p>​    ▫<strong>HelloInterval：</strong>发送Hello报文的时间间隔。通常为10s。</p>
<p>​    ▫<strong>RouterDeadInterval：</strong>失效时间。如果在此时间内未收到邻居发来的Hello报文，则认为邻居失效。通常为40s。</p>
<p>▫<strong>Neighbor：</strong>邻居，以Router ID标识。</p>
<p>•<strong>其它字段解释</strong></p>
<p>▫<strong>Options：</strong> </p>
<p>​    ▪E：是否支持外部路由</p>
<p>​    ▪MC：是否支持转发组播数据包</p>
<p>​    ▪N/P：是否为NSSA区域</p>
<p>▫<strong>Router Priority：DR优先级。默认为1。如果设置为0，则路由器不能参与DR或BDR的选举</strong>。</p>
<p>▫<strong>Designated</strong> <strong>Router：</strong>DR的接口地址。</p>
<p>▫<strong>Backup Designated</strong> <strong>Router</strong>：BDR的接口地址。</p>
<h2 id="邻接关系建立-1"><a href="#邻接关系建立-1" class="headerlink" title="邻接关系建立 (1)"></a>邻接关系建立 (1)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/20.png"></p>
<p>•<strong>DD报文部分字段解释</strong></p>
<p>▫<strong>I</strong>：当发送连续多个DD报文时，如果这是第一个DD报文，则置为1，否则置为0。</p>
<p>▫**M (More)**：当发送连续多个DD报文时，如果这是最后一个DD报文，则置为0。否则置为1，表示后面还有其他的DD报文。</p>
<p>▫**MS (Master/Slave)**：当两台OSPF路由器交换DD报文时，首先需要确定双方的主从关系，Router ID大的一方会成为Master。当值为1时表示发送方为Master。</p>
<p>▫<strong>DD sequence</strong> <strong>number</strong>：DD报文序列号。主从双方利用序列号来保证DD报文传输的可靠性和完整性。</p>
<blockquote>
<p>•R1和R2的Router ID分别为10.0.1.1和10.0.2.2并且二者已建立了邻居关系。当R1的邻居状态变为ExStart后，R1会发送第一个DD报文。此报文中，M-bit设置为1，表示后续还有DD报文要发送，MS-bit设置为1，表示R1宣告自己为Master。DD序列号被随机设置为X，I-bit设置为1，表示这是第一个DD报文。</p>
<p>•同样当R2的邻居状态变为ExStart后，R2也会发送第一个DD报文。此报文中，DD序列号被随机设置为Y（I-bit=1，M-bit=1，MS-bit=1，含义同上）。由于R2的Router ID较大，所以R2将成为真正的Master。收到此报文后，R1会产生一个Negotiation-Done事件，并将邻居状态从ExStart变为Exchange。</p>
<p>•当R1的邻居状态变为Exchange后，R1会发送一个新的DD报文，此报文中包含了LSDB的摘要信息，序列号设置为R2在步骤2中使用的序列号Y，I-bit=0，表示这不是第一个DD报文，M-bit=0，表示这是最后一个包含LSDB摘要信息的DD报文，MS-bit=0，表示R1宣告自己为Slave。收到此报文后，R2将邻居状态从ExStart变为Exchange。</p>
<p>•当R2的邻居状态变为Exchange后，R2会发送一个新的DD报文，此报文包含了LSDB的摘要信息。DD序列号设置为Y+1, MS-bit=1，表示R2宣告自己为Master。</p>
<p>•虽然R1不需要发送新的包含LSDB摘要信息的DD报文，但是作为Slave，R1需要对Master发送的每一个DD报文进行确认。所以，R1向R2发送一个新的DD报文，序列号为Y+1，该报文内容为空。发送完此报文后，RTA产生一个Exchange-Done事件，将邻居状态变为Loading。R2收到此报文后，会将邻居状态变为Full（假设R2的LSDB是最新最全的，不需要向R1请求更新）。</p>
</blockquote>
<h2 id="DD报文"><a href="#DD报文" class="headerlink" title="DD报文"></a>DD报文</h2><p>DD报文包含LSA头部信息，包括LS Type、LS ID、Advertising Router、LS Sequence Number、LS Checksum。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/21.png"></p>
<h2 id="邻接关系建立-2"><a href="#邻接关系建立-2" class="headerlink" title="邻接关系建立 (2)"></a>邻接关系建立 (2)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/23.png"></p>
<p>•R1开始向R2发送LSR报文，请求那些在Exchange状态下通过DD报文发现的、并且在本地LSDB中没有的链路状态信息。</p>
<p>•R2向R1发送LSU报文，LSU报文中包含了那些被请求的链路状态的详细信息。R1在完成LSU报文的接收之后，且没有其他待请求的LSA后，会将邻居状态从Loading变为Full。</p>
<p>•R1向R2发送LSAck报文，作为对LSU报文的确认。</p>
<h2 id="DR与BDR的作用"><a href="#DR与BDR的作用" class="headerlink" title="DR与BDR的作用"></a>DR与BDR的作用</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/24.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/25.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/26.png"></p>
<blockquote>
<p>•MA（ Multiple Access，多路访问 ）分为BMA（ Broadcast Multi-Access，广播多路访问）和NBMA（Non-Broadcast Multiple Access，非广播多路访问）。以太网链路组成的网络是典型的BMA网络。帧中继链路通过逻辑上的划分组成典型的NBMA网络（注：帧中继相关知识不再介绍）。</p>
<p>•DRother：既不是DR也不是BDR的路由器就是DRother路由器。</p>
</blockquote>
<h2 id="DR与BDR的选举规则"><a href="#DR与BDR的选举规则" class="headerlink" title="DR与BDR的选举规则"></a>DR与BDR的选举规则</h2><p>•DR/BDR的选举是非抢占式的。</p>
<p>•DR/BDR的选举是基于接口的。</p>
<p>​    ▫接口的DR优先级越大越优先。</p>
<p>​    ▫接口的DR优先级相等时，Router ID越大越优先。</p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/28.png"></p>
<p>•思考：</p>
<p>▫如果将上图中4台路由器的优先级全部设置为0，OSPF是否可以正常工作？</p>
<p>▫缺省情况下，哪些链路类型组成的网络是MA网络呢？</p>
<blockquote>
<p>广播链路或者NBMA链路上DR和BDR的选举过程如下：</p>
<p>▫接口UP后，发送Hello报文，同时进入到Waiting状态。在Waiting状态下会有一个WaitingTimer，该计时器的长度与DeadTimer是一样的。默认值为40秒，用户不可自行调整。</p>
<p>▫在WaitingTimer触发前，发送的Hello报文是没有DR和BDR字段的。在Waiting阶段，如果收到Hello报文中有DR和BDR，那么直接承认网络中的DR和BDR，而不会触发选举。直接离开Waiting状态，开始邻居同步。</p>
<p>▫假设网络中已经存在一个DR和一个BDR，这时新加入网络中的路由器，不论它的Router ID或者DR优先级有多大，都会承认现网中已有的DR和BDR。</p>
<p>▫当DR因为故障Down掉之后，BDR会继承DR的位置，剩下的优先级大于0的路由器会竞争成为新的BDR。</p>
<p>▫只有当不同Router ID，或者配置不同DR优先级的路由器同时起来，在同一时刻进行DR选举才会应用DR选举规则产生DR。</p>
</blockquote>
<h2 id="不同网络类型中DR与BDR的选举操作"><a href="#不同网络类型中DR与BDR的选举操作" class="headerlink" title="不同网络类型中DR与BDR的选举操作"></a>不同网络类型中DR与BDR的选举操作</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/29.png"></p>
<h2 id="可按需调整设备接口的OSPF网络类型"><a href="#可按需调整设备接口的OSPF网络类型" class="headerlink" title="可按需调整设备接口的OSPF网络类型"></a>可按需调整设备接口的OSPF网络类型</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/30.png"></p>
<p>•OSPF的网络类型是根据接口的数据链路层封装自动设置的。</p>
<p>•图中的路由器采用以太网接口互联，因此这些接口的网络类型缺省均为Broadcast。</p>
<p>•每段链路实际上都是点对点链路，因此在链路上选举DR与BDR是没有必要的。</p>
<p>•为了提高OSPF的工作效率，加快邻接关系的建立过程，可以把这些互联接口的网络类型都修改为P2P。</p>
<blockquote>
<p>•OSPF的网络类型是协议根据接口的数据链路层封装自动设置的，在图中，两台处于网络接入层的路由器AS-R1及AS-R2都通过双链路上联到核心层的路由器CO-R1及CO-R2。四台路由器都在各自接口上激活OSPF。由于这些路由器都是采用以太网接口互联，因此这些接口的网络类型缺省均为Broadcast，于是在邻居关系的建立过程中，OSPF会在每段以太网链路上选举DR及BDR。</p>
<p>•然而，这实际上是没有必要而且浪费时间的（DR及BDR的选举过程涉及一个等待计时器，这增加了直连路由器形成邻接关系的时间），因为这些链路其实从逻辑的角度看都是点对点的连接，选举DR或BDR实在是画蛇添足。因此为了提高OSPF的工作效率，加快邻接关系的建立过程，可以把这些互联接口的网络类型都修改为P2P。</p>
</blockquote>
<h1 id="OSPF的基本配置"><a href="#OSPF的基本配置" class="headerlink" title="OSPF的基本配置"></a>OSPF的基本配置</h1><h2 id="配置命令介绍-1"><a href="#配置命令介绍-1" class="headerlink" title="配置命令介绍 (1)"></a>配置命令介绍 (1)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/31.png"></p>
<blockquote>
<p>•缺省情况下，OSPF以32位主机路由的方式对外发布Loopback接口的IP地址，与Loopback接口上配置的掩码长度无关。如果要发布Loopback接口的实际网段，需要在接口下配置网络类型为NBMA或广播型。</p>
</blockquote>
<h2 id="配置命令介绍-2"><a href="#配置命令介绍-2" class="headerlink" title="配置命令介绍 (2)"></a>配置命令介绍 (2)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/32.png"></p>
<h2 id="OSPF配置举例"><a href="#OSPF配置举例" class="headerlink" title="OSPF配置举例"></a>OSPF配置举例</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/33.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/34.png"></p>
<h2 id="OSPF配置验证-1"><a href="#OSPF配置验证-1" class="headerlink" title="OSPF配置验证 (1)"></a>OSPF配置验证 (1)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/35.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/36.png"></p>
<h2 id="OSPF配置验证-2"><a href="#OSPF配置验证-2" class="headerlink" title="OSPF配置验证 (2)"></a>OSPF配置验证 (2)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/37.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/38.png"></p>
<h2 id="OSPF配置验证-3"><a href="#OSPF配置验证-3" class="headerlink" title="OSPF配置验证 (3)"></a>OSPF配置验证 (3)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/39.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/40.png"></p>
<h2 id="OSPF配置验证-4"><a href="#OSPF配置验证-4" class="headerlink" title="OSPF配置验证 (4)"></a>OSPF配置验证 (4)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/41.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/42.png"></p>
<h2 id="OSPF配置验证-5"><a href="#OSPF配置验证-5" class="headerlink" title="OSPF配置验证 (5)"></a>OSPF配置验证 (5)</h2><p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/43.png"></p>
<p><img src="/2021/05/06/OSPF%E5%9F%BA%E7%A1%80/44.png"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>1.（单选题）OSPF使用以下哪种报文维护邻居关系？（   ）</p>
<p><strong>A.Hello</strong></p>
<p>B.Database Description</p>
<p>C.LSR</p>
<p>D.LSU</p>
<p>2.（多选题）OSPF支持以下哪些网络类型？（   ）</p>
<p><strong>A.P2P网络</strong></p>
<p><strong>B.P2MP网络</strong></p>
<p><strong>C.广播网络</strong></p>
<p><strong>D.NBMA网络</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•本文简单介绍了OSPF的基本概念，内容包括Router ID、区域、Cost。运行OSPF的路由器通过相互发送链路状态信息完成拓扑和路由计算。</p>
<p>•本文详细介绍了OSPF邻居和邻接关系建立的过程。在MA网络中，需要选举DR和BDR。OSPF有5种类型的报文，所有报文有相同的报文头部格式。运行OSPF的路由器通过周期性的发送Hello报文发现和维持邻居关系，通过DD、LSR、LSU、LSAck报文配合完成链路状态数据库的同步。最后介绍了OSPF单区域的简单配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/" itemprop="url">IP-IP路由基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:14:01+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫识别IP路由表和FIB表</p>
<p>▫分析路由转发流程</p>
<p>▫描述路由引入的原理</p>
<p>▫描述路由引入的使用场景</p>
<h1 id="IP路由基础"><a href="#IP路由基础" class="headerlink" title="IP路由基础"></a><strong>IP路由基础</strong></h1><h2 id="IP路由概述"><a href="#IP路由概述" class="headerlink" title="IP路由概述"></a><strong>IP路由概述</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/1.png"></p>
<p>当路由器收到一个IP报文时，路由器根据该IP报文的目的地址匹配路由条目（或路由表项）。</p>
<p>▫若有匹配的路由条目，则依据该条目中的出接口或下一跳等信息进行报文转发；</p>
<p>▫若无匹配的路由条目，则路由器没有相关路由信息用于指导报文转发，此时会丢弃该报文。</p>
<h2 id="RIB与FIB"><a href="#RIB与FIB" class="headerlink" title="RIB与FIB"></a><strong>RIB与FIB</strong></h2><p>具有路由功能的网络设备都维护两种重要的数据表：一是路由表RIB（Routing Information Base，路由信息库）；二是转发表FIB。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/2.png"></p>
<blockquote>
<p>•路由表：</p>
<p>​    ▫可以将路由表视为位于路由器的控制平面，实际上路由表并不直接指导数据转发。路由器在执行路由查询时，并不是在路由表中进行报文目的地址的查询，真正指导数据转发的是FIB表，路由器将路由表中的最优路由下载到FIB表，此后如果路由表中的相关表项发生变化，FIB表也将立即同步。</p>
<p>​    ▫由于两张表的一致性，且路由表阅读起来更直观，因此在绝大多数场合，在阐述路由器数据转发过程时，会用“路由表”这个说法，实际上，路由器查询的是FIB表，位于控制层面的路由表只是提供路由信息。</p>
<p>•FIB表：</p>
<p>​    ▫FIB表位于路由器的数据平面，亦被称为转发表项，每条转发表项都指定要到达某个目的地所需通过的出接口及下一跳IP地址等信息。</p>
<p>•注意：</p>
<p>​    ▫具有路由功能的华为数通产品包括路由器、三层交换机等，本课程以路由器为例进行讲解。</p>
<p>​    ▫OSPF（Open Shortest Path First，开放式最短路径优先）和IS-IS（Intermediate System to Intermediate System，中间系统到中间系统），均基于链路状态信息，使用最短路径优先算法进行路由计算。OSPF及IS-IS的详细内容，将在后续课程介绍。</p>
<p>​    ▫路由进程：路由器支持OSPF和IS-IS多进程，可以根据业务类型划分不同的进程，不同的进程之间相互独立。进程号是本地概念，不影响与其它路由器之间的报文交换。因此，不同的路由器之间，即使进程号不同也可以进行报文交换。</p>
</blockquote>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a><strong>路由表</strong></h2><p>每个路由器都有路由表，而路由表又分为本地核心路由表和协议路由表。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/3.png"></p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/4.png"></p>
<blockquote>
<p>•路由表中的关键字段：</p>
<ul>
<li><p>Destination：表示此路由的目的地址。用来标识IP包的目的地址或目的网络。</p>
</li>
<li><p>Mask：表示此目的地址的子网掩码长度。与目的地址一起来标识目的主机或路由器所在的网段的地址。</p>
</li>
<li><p>Proto（Protocol）：表示学习此路由的路由协议。</p>
</li>
<li><p>Pre（Preference）：表示此路由的路由协议优先级。</p>
<ul>
<li>路由器分别定义了外部优先级和内部优先级。外部优先级是指用户可以手工为各路由协议配置的优先级，内部优先级则不能被用户手工修改。</li>
<li>选择路由时先比较路由的外部优先级，当不同的路由协议配置了相同的优先级后，系统会通过内部优先级决定哪个路由协议发现的路由将成为最优路由。</li>
</ul>
</li>
<li><p>Cost：路由开销。</p>
</li>
<li><p>NextHop：表示转发到此目的网络的下一跳。指明数据转发的下一个设备。</p>
</li>
<li><p>Interface：表示转发到此目的网络的出接口。指明数据将从本地路由器哪个接口转发出去。</p>
</li>
<li><p>Preference用于不同路由协议间路由优先级的比较，Cost用于同一种路由协议内部不同路由的优先级的比较。</p>
</li>
<li><p>注意：正文内的路由表为截取版，非完整路由表。</p>
</li>
</ul>
</blockquote>
<h2 id="IP路由查找的最长匹配原则"><a href="#IP路由查找的最长匹配原则" class="headerlink" title="IP路由查找的最长匹配原则"></a><strong>IP路由查找的最长匹配原则</strong></h2><p>•路由器查找FIB表时，将报文的目的IP地址和FIB表中各表项的掩码进行按位“逻辑与”，得到的地址符合FIB表中的网络地址则匹配。</p>
<p>•最终选择一个掩码最长的FIB表项转发报文。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<p>•FIB表中每条转发项都指明到达某网段或某主机的报文应通过路由器的哪个物理接口或逻辑接口发送，然后就可到达该路径的下一个路由器，或者不再经过别的路由器而传送到直接相连的网络中的目的主机。</p>
<p>•FIB表信息查看命令：<strong>display fib</strong> [ <em>slot-id</em> ]</p>
<ul>
<li><em>slot-id</em>：显示指定槽位号的FIB表信息。整数形式，取值范围请根据设备实际配置选取。</li>
</ul>
<p>•FIB表中的字段说明：</p>
<ul>
<li><p>Total number of Routes：路由表总数。</p>
</li>
<li><p>Destination/Mask：目的地址/掩码长度。</p>
</li>
<li><p>Nexthop：下一跳。</p>
</li>
<li><p>Flag：当前标志，G、H、U、S、D、B的组合。</p>
<ul>
<li>G（Gateway）：网关路由，表示下一跳是网关。</li>
<li>H（Host）：主机路由，表示该路由为主机路由。</li>
<li>U（Up）：可用路由，表示该路由状态是Up。</li>
<li>S（Static）：静态路由。</li>
<li>D（Dynamic）：动态路由。</li>
<li>B（Black Hole）：黑洞路由，表示下一跳是空接口。</li>
</ul>
</li>
<li><p>TimeStamp：时间戳，表示该表项存在的时间，单位是秒。</p>
</li>
<li><p>Interface：到目的地址的出接口。</p>
</li>
<li><p>TunnelID：表示转发表项索引。该值不为0时，表示匹配该项的报文通过隧道转发（如：MPLS隧道转发）。该值为0时，表示报文不通过隧道转发。</p>
</li>
</ul>
</blockquote>
<h2 id="路由的来源"><a href="#路由的来源" class="headerlink" title="路由的来源"></a><strong>路由的来源</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/6.png"></p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/7.png"></p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/8.png"></p>
<blockquote>
<p>•直连路由：直连接口所在网段的路由，由设备自动生成。</p>
<p>•静态路由：由网络管理员手工配置的路由条目。</p>
<p>•动态路由：路由器通过动态路由协议（如OSPF、IS-IS、BGP等）学习到的路由。</p>
<p>​    ▫BGP（Border Gateway Protocol，边界网关协议）是一种实现AS（Autonomous System，自治系统）之间的路由可达，并选择最佳路由的距离矢量路由协议。</p>
<p>​    ▫AS是指在一个实体管辖下的拥有相同选路策略的IP网络。</p>
</blockquote>
<h2 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a><strong>动态路由协议</strong></h2><p>动态路由协议根据作用范围不同，可分为：</p>
<p>▫内部网关协议IGP（Interior Gateway Protocol）：在一个自治系统内部运行。常见的IGP协议包括OSPF和IS-IS。</p>
<p>▫外部网关协议EGP（Exterior Gateway Protocol）：运行于不同自治系统之间。BGP是目前最常用的EGP协议。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/9.png"></p>
<h2 id="路由迭代"><a href="#路由迭代" class="headerlink" title="路由迭代"></a><strong>路由迭代</strong></h2><p>路由必须有直连的下一跳才能够指导转发，静态路由或BGP路由的下一跳可能不是直连的邻居，因此需要计算出一个直连的下一跳，这个过程就叫做路由迭代。</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/10.png"></p>
<h2 id="数据转发流程"><a href="#数据转发流程" class="headerlink" title="数据转发流程"></a><strong>数据转发流程</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<p>PC1发送数据包到PC2的流程如下：</p>
<p>1.PC1将报文发往网关设备R1。</p>
<p>2.R1查找路由表项，确定转发的下一跳、出接口，之后将报文转发给R2。</p>
<p>3.R2通过查找路由表项转发给R3。</p>
<p>4.R3收到后查找路由表项，发现IP报文的目的IP地址属于本地接口所在网段，则直接本地转发，最终该报文被发往目的主机PC2。</p>
</blockquote>
<h1 id="IP路由高级应用"><a href="#IP路由高级应用" class="headerlink" title="IP路由高级应用"></a><strong>IP路由高级应用</strong></h1><h2 id="IP路由高级应用场景分析-1"><a href="#IP路由高级应用场景分析-1" class="headerlink" title="IP路由高级应用场景分析 (1)"></a><strong>IP路由高级应用场景分析</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/12.png"></p>
<p>场景描述：</p>
<p>▫假设A公司和B公司各有自己的网络，这两个网络被独立管理及运维，A公司网络使用的路由协议为OSPF，B公司网络使用的路由协议为IS-IS。</p>
<p>▫现在两家公司合并成一家公司，导致原有的两张网络不得不进行整合，为了使合并后的新公司业务流量能够正常在整合后的网络上交互，最重要的就是实现路由互通。</p>
<blockquote>
<p>•OSPF与IS-IS是两种不同的动态路由协议，路由信息无法在路由协议之间直接交互。</p>
<p>•如图所示，A公司部署OSPF，边界设备为R1和R2；B公司部署IS-IS，边界设备为R3和R4。边界互联部分可以部署OSPF或IS-IS，例如：可以将R1与R3互联网段、R2与R4互联网段部署进A公司的OSPF，此时边界设备仅为R3和R4。</p>
</blockquote>
<h2 id="IP路由高级应用场景分析-2"><a href="#IP路由高级应用场景分析-2" class="headerlink" title="IP路由高级应用场景分析 (2)"></a>IP路由高级应用场景分析 (2)</h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/13.png"></p>
<p>场景描述：</p>
<p>▫在大型企业网络中，网络规模十分庞大，选用单一的路由协议无法满足网络的需求，因此多种路由协议共存的情况十分常见。</p>
<p>▫或者出于业务逻辑或行政管理的考虑，会在不同的网络结构中设计和部署不同的路由协议，使路由的层次结构更加清晰可控。</p>
<p>▫在这样的网络环境下，也需要实现全网路由互通。</p>
<h2 id="路由引入的基本概念"><a href="#路由引入的基本概念" class="headerlink" title="路由引入的基本概念"></a><strong>路由引入的基本概念</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/14.png"></p>
<p>路由引入指的是将路由信息从一种路由协议发布到另一种路由协议的操作。</p>
<p>▫通过路由引入，可以实现路由信息在不同路由协议间传递。</p>
<p>▫执行路由引入时，还可以部署路由控制，从而实现对业务流量的灵活把控。</p>
<blockquote>
<p>•如上图所示，OSPF和IS-IS网络中存在不同的网段，只有R1和R2同时知道所有路由条目。</p>
<p>•思考：如何让全部设备都能获取到所有的路由呢？</p>
</blockquote>
<h2 id="路由引入的方向性"><a href="#路由引入的方向性" class="headerlink" title="路由引入的方向性"></a><strong>路由引入的方向性</strong></h2><p>•路由引入是具有方向性的，将路由信息从路由协议A引入到路由协议B（A-to-B），则路由协议B可获知A中的路由信息，但是此时，A还并不知晓B路由协议中的路由信息，除非配置B-to-A的路由引入。</p>
<p>•路由引入时需要注意以下几点：</p>
<p>​    ▫路由优先级</p>
<p>​    ▫路由回灌</p>
<p>​    ▫路由度量值</p>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/15.png"></p>
<h2 id="路由引入：路由优先级"><a href="#路由引入：路由优先级" class="headerlink" title="路由引入：路由优先级"></a><strong>路由引入：路由优先级</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/16.png"></p>
<p>场景描述：</p>
<ol>
<li><p>R1将直连路由10.1.1.0/24引入到OSPF中。</p>
</li>
<li><p>R3通过OSPF学习到10.1.1.0/24网段路由（OSPF外部路由，路由优先级为150）。</p>
</li>
<li><p>R2在IS-IS进程中引入OSPF路由。</p>
</li>
<li><p>R3也会通过IS-IS学习到10.1.1.0/24网段路由（路由优先级为15）。</p>
</li>
<li><p>对R3而言，IS-IS路由优于OSPF外部路由，因此优选来自R4的IS-IS路由。</p>
</li>
</ol>
<p>后续R3访问10.1.1.0/24网段的路径为：R3-&gt;R4-&gt;R2-&gt;R1，这是次优路径。</p>
<blockquote>
<p>•华为定义的路由优先级：</p>
<p>▫Direct：0</p>
<p>▫OSPF：10</p>
<p>▫IS-IS：15</p>
<p>▫Static：60</p>
<p>▫OSPF ASE：150</p>
<p>▫OSPF NSSA：150</p>
<p>▫IBGP：255</p>
<p>▫EBGP：255</p>
<p>•注意：不同的厂商路由优先级的协定可能不同。</p>
</blockquote>
<h2 id="路由引入：路由回灌"><a href="#路由引入：路由回灌" class="headerlink" title="路由引入：路由回灌"></a><strong>路由引入：路由回灌</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/17.png"></p>
<p>场景描述：</p>
<ol>
<li><p>R1将直连路由10.1.1.0/24引入到OSPF中。</p>
</li>
<li><p>10.1.1.0/24网段路由全OSPF域内通告。</p>
</li>
<li><p>R2在IS-IS进程中引入OSPF路由。</p>
</li>
<li><p>10.1.1.0/24网段路由全IS-IS域内通告。</p>
</li>
<li><p>R3在OSPF进程中引入IS-IS路由。</p>
</li>
<li><p>10.1.1.0/24网段路由再次被通告进OSPF域内，形成路由回灌。</p>
</li>
</ol>
<h2 id="路由引入：路由度量值"><a href="#路由引入：路由度量值" class="headerlink" title="路由引入：路由度量值"></a><strong>路由引入：路由度量值</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/18.png"></p>
<p>场景描述：</p>
<ol>
<li><p>在IS-IS中引入OSPF路由。</p>
</li>
<li><p>在OSPF中引入IS-IS路由。</p>
</li>
</ol>
<p>不同的路由协议对路由度量值的定义不同，那么在路由协议之间进行路由引入时，被引入的路由的度量值该如何定义？定义成多少？</p>
<h2 id="路由引入场景"><a href="#路由引入场景" class="headerlink" title="路由引入场景"></a><strong>路由引入场景</strong></h2><p>路由引入主要涉及以下几种场景：</p>
<ol>
<li><p>动态路由协议之间的路由引入</p>
</li>
<li><p>引入直连路由到动态路由协议</p>
</li>
<li><p>引入静态路由到动态路由协议</p>
</li>
</ol>
<p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/19.png"></p>
<h2 id="路由引入的基础配置命令"><a href="#路由引入的基础配置命令" class="headerlink" title="路由引入的基础配置命令"></a><strong>路由引入的基础配置命令</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/20.png"></p>
<blockquote>
<p>•说明：当OSPF网络中的设备需要访问运行其他协议的网络中的设备时，需要将其他协议的路由引入到OSPF网络中。</p>
</blockquote>
<h2 id="案例1：引入直连路由到OSPF"><a href="#案例1：引入直连路由到OSPF" class="headerlink" title="案例1：引入直连路由到OSPF"></a><strong>案例1：引入直连路由到OSPF</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/21.png"></p>
<p>•可以通过使用<strong>import-route direct</strong>命令，将路由表中所有直连路由引入到动态路由协议。</p>
<p>•引入后的路由会作为OSPF外部路由，在整个OSPF网络内通告。</p>
<blockquote>
<p>•在设备上部署动态路由协议，如果希望该设备的直连接口路由能够被发布到动态路由协议中，则需要激活该端口相应的动态路由协议。除此之外，也可以通过将直连路由引入到动态路由协议实现该目的。</p>
<p>•如图所示：</p>
<ul>
<li>R1、R2及R3运行OSPF，R1存在一个直连网段192.168.11.0/24，为了让R2和R3生成192.168.11.0/24的路由，可以在R1上将直连路由引入到OSPF。</li>
</ul>
<p>•说明：在OSPF网络中，若路由表的协议字段显示为O_ASE，表明该路由为OSPF的外部路由。</p>
</blockquote>
<h2 id="案例2：引入静态路由到OSPF"><a href="#案例2：引入静态路由到OSPF" class="headerlink" title="案例2：引入静态路由到OSPF"></a><strong>案例2：引入静态路由到OSPF</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/22.png"></p>
<p>•可以通过使用<strong>import-route</strong> <strong>static</strong>命令，将路由表中所有静态路由引入到动态路由协议。</p>
<p>•引入后的路由会作为OSPF外部路由，在整个OSPF网络内通告。</p>
<blockquote>
<p>•对于动态路由协议而言，静态路由被视为域外的路由信息，这些路由并不被动态路由协议直接感知。如果希望动态路由协议域内所有设备都能学习到该静态路由，则需要将静态路由引入到动态路由协议中。</p>
<p>•如图所示：</p>
<ul>
<li>R2及R3运行了OSPF，而R1不支持OSPF。在R2上添加静态路由指向192.168.11.0/24网段，并且在R2上将静态路由引入到OSPF，从而使R2和R3均能生成192.168.11.0/24的路由。</li>
</ul>
</blockquote>
<h2 id="案例3：将IS-IS路由引入到OSPF"><a href="#案例3：将IS-IS路由引入到OSPF" class="headerlink" title="案例3：将IS-IS路由引入到OSPF"></a><strong>案例3：将IS-IS路由引入到OSPF</strong></h2><p><img src="/2021/05/06/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/23.png"></p>
<p>•可以通过使用<strong>import-route</strong> <strong>isis</strong> <strong>1</strong>命令，将路由表中所有IS-IS路由引入到动态路由协议。</p>
<p>•引入后的路由会作为OSPF外部路由，在整个OSPF网络内通告。</p>
<blockquote>
<p>•在两个动态路由协议域的边界执行路由引入操作，是最常见的场景之一，就是将路由信息从一个动态路由协议引入另一个动态路由协议中。</p>
<p>•如图所示：</p>
<ul>
<li>R1及R2运行了IS-IS，R2及R3运行了OSPF，两个协议维护的路由信息是完全隔离的。因此，此时R1有IS-IS网络内全部路由，但无法访问到OSPF网络；R3有OSPF网络内全部路由，但无法访问到IS-IS网络。在R2上执行路由引入，将IS-IS路由引入到OSPF中。</li>
</ul>
</blockquote>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.(单选题) 在某路由器的FIB表中存在以下4条路由转发表项，那么该路由器对于目的IP地址为10.0.1.1的IP报文将根据哪条路由进行转发？（  ）</p>
<p>A.0.0.0.0/0</p>
<p>B.10.0.0.0.0/16</p>
<p><strong>C.10.0.1.0/24</strong></p>
<p>D.10.0.2.0/24</p>
<p>2.(多选题) 以下关于路由引入的说法，<strong>错误</strong>的有（  ）。</p>
<p>A.在某路由器的OSPF进程中，执行<strong>import-route direct</strong>命令，则该路由器会把路由表中的所有直连路由都引入OSPF</p>
<p>B.在某路由器的OSPF进程中，执行<strong>import-route</strong> <strong>static</strong>命令，则该路由器会把路由表中的所有静态路由都引入OSPF</p>
<p><strong>C.在某路由器上，将路由表中来源于X路由协议的路由引入Y路由协议，需要在X路由协议视图下执行</strong>import-route<strong>命令</strong></p>
<p><strong>D.在某路由器上执行了</strong>import-route<strong>命令并成功将其GE0/0/1的直连路由引入OSPF，该接口也就激活了OSPF，并开始周期性地发送Hello报文</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•由于不同路由协议工作原理不同，因此到达同一目的网段可能会生成多个路由条目，路由器根据路由协议的优先级以及路由开销选择最优路由，并且把最优路由放入FIB表。路由器根据FIB表执行数据转发。</p>
<p>•当网络规模较大且使用多种路由协议时，路由协议间通过路由引入的方式实现路由的相互通告。由于路由引入可能会引入大量路由，并导致部分性能较低的设备无法承受，因此在进行路由引入时需要进行路由控制来实现路由的按需分发。</p>
<p>•本课程所列举的OSPF路由协议，IS-IS路由协议以及路由控制将在后续课程中详细介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/MSTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/MSTP/" itemprop="url">MSTP原理与配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:11:06+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•RSTP在STP基础上进行了改进，实现了网络拓扑快速收敛。但在划分VLAN的网络中运行RSTP/STP，局域网内所有的VLAN共享一棵生成树，被阻塞后的链路将不承载任何流量，无法在VLAN间实现数据流量的负载均衡，导致链路带宽利用率、设备资源利用率较低。</p>
<p>•为了弥补RSTP/STP的缺陷，IEEE于2002年发布的802.1S标准定义了MSTP（Multiple Spanning Tree Protocol，多生成树协议）。MSTP兼容STP和RSTP，通过建立多棵无环路的树，解决广播风暴并实现冗余备份。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述RSTP/STP技术的缺陷</p>
<p>▫描述MSTP对RSTP/STP技术的改进</p>
<p>▫描述MSTP的各种概念</p>
<p>▫描述MSTP的工作过程</p>
<p>▫实现MSTP的基本配置</p>
<h1 id="MSTP概述"><a href="#MSTP概述" class="headerlink" title="MSTP概述"></a>MSTP概述</h1><h2 id="RSTP-STP的不足-1"><a href="#RSTP-STP的不足-1" class="headerlink" title="RSTP/STP的不足 (1)"></a><strong>RSTP/STP的不足</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/MSTP/1.png"></p>
<h2 id="RSTP-STP的不足-2"><a href="#RSTP-STP的不足-2" class="headerlink" title="RSTP/STP的不足 (2)"></a><strong>RSTP/STP的不足</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/MSTP/2.png"></p>
<h2 id="多生成树协议概述"><a href="#多生成树协议概述" class="headerlink" title="多生成树协议概述"></a><strong>多生成树协议概述</strong></h2><p>•MSTP是IEEE 802.1S中定义的生成树协议，MSTP兼容STP和RSTP，既可以快速收敛，又提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</p>
<p>•MSTP可以将一个或多个VLAN映射到一个Instance（实例），再基于Instance计算生成树，映射到同一个Instance的VLAN共享同一棵生成树。</p>
<p><img src="/2021/05/06/MSTP/3.png"></p>
<blockquote>
<p>•如图中例子，经计算，最终生成两棵生成树：</p>
<ul>
<li><p>Instance1对应的生成树以SW1为根交换设备，转发VLAN1~VLAN10的报文。</p>
</li>
<li><p>Instance2对应的生成树以SW2为根交换设备，转发VLAN11~VLAN20的报文。</p>
</li>
<li><p>不同VLAN的报文沿不同的路径转发，实现了负载分担。</p>
</li>
</ul>
<p>•注意：生成树不是基于VLAN运行的，而是基于Instance运行的。</p>
</blockquote>
<h1 id="MSTP的基本概念"><a href="#MSTP的基本概念" class="headerlink" title="MSTP的基本概念"></a><strong>MSTP的基本概念</strong></h1><h2 id="MST-Region"><a href="#MST-Region" class="headerlink" title="MST Region"></a><strong>MST</strong> <strong>Region</strong></h2><p><img src="/2021/05/06/MSTP/5.png"></p>
<blockquote>
<p>•同一个MST域的设备具有下列特点：</p>
<ul>
<li><p>都启动了MSTP。</p>
</li>
<li><p>具有相同的域名。</p>
</li>
<li><p>具有相同的VLAN到生成树实例映射配置。</p>
</li>
<li><p>具有相同的MSTP修订级别配置。</p>
</li>
</ul>
</blockquote>
<h2 id="MSTI"><a href="#MSTI" class="headerlink" title="MSTI"></a><strong>MSTI</strong></h2><p><img src="/2021/05/06/MSTP/6.png"></p>
<blockquote>
<p>•Instance0是缺省存在的，而且缺省时，华为交换机上所有的VLAN都映射到了Instance0。</p>
<p>•通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。</p>
<ul>
<li>每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。</li>
</ul>
</blockquote>
<h2 id="CST"><a href="#CST" class="headerlink" title="CST"></a><strong>CST</strong></h2><p><img src="/2021/05/06/MSTP/7.png"></p>
<h2 id="IST"><a href="#IST" class="headerlink" title="IST"></a><strong>IST</strong></h2><p><img src="/2021/05/06/MSTP/8.png"></p>
<h2 id="CIST"><a href="#CIST" class="headerlink" title="CIST"></a><strong>CIST</strong></h2><p><img src="/2021/05/06/MSTP/9.png"></p>
<h2 id="SST"><a href="#SST" class="headerlink" title="SST"></a><strong>SST</strong></h2><p><img src="/2021/05/06/MSTP/10.png"></p>
<h2 id="总根，域根和主桥"><a href="#总根，域根和主桥" class="headerlink" title="总根，域根和主桥"></a><strong>总根，域根和主桥</strong></h2><p><img src="/2021/05/06/MSTP/11.png"></p>
<blockquote>
<p>•主桥包括总根和IST域根。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2021/05/06/MSTP/12.png"></p>
<h2 id="MSTP的端口角色-1"><a href="#MSTP的端口角色-1" class="headerlink" title="MSTP的端口角色 (1)"></a><strong>MSTP的端口角色 (1)</strong></h2><p>MSTP中定义的所有端口角色包括：</p>
<p>根端口、指定端口、Alternate端口、Backup端口、Master端口、域边缘端口和边缘端口。</p>
<p><img src="/2021/05/06/MSTP/15.png"></p>
<p><img src="/2021/05/06/MSTP/14.png"></p>
<p><img src="/2021/05/06/MSTP/16.png"></p>
<blockquote>
<p>•除边缘端口外，其他端口角色都参与MSTP的计算过程。</p>
<p>•同一端口在不同的生成树实例中可以担任不同的角色。</p>
</blockquote>
<h2 id="MSTP的端口状态"><a href="#MSTP的端口状态" class="headerlink" title="MSTP的端口状态"></a><strong>MSTP的端口状态</strong></h2><p>MSTP定义的端口状态与RSTP协议中定义相同:</p>
<ul>
<li><p>Forwarding状态：端口既转发用户流量，学习MAC地址，又接收/发送BPDU报文。</p>
</li>
<li><p>Learning状态：过渡状态，端口接收/发送BPDU报文，不转发用户流量但是学习MAC地址。</p>
</li>
<li><p>Discarding状态：端口只接收BPDU报文，不转发用户流量也不学习MAC地址。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>MSTP端口状态</strong></th>
<th><strong>端口在拓扑中的角色</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Forwarding</td>
<td>包括根端口、指定端口、Master端口、域边缘端口</td>
</tr>
<tr>
<td>Learning</td>
<td>包括根端口、指定端口、Master端口、域边缘端口</td>
</tr>
<tr>
<td>Discarding</td>
<td>包括根端口、指定端口、Master端口、域边缘端口、Alternate端口、Backup端口</td>
</tr>
</tbody></table>
<h2 id="MSTP报文"><a href="#MSTP报文" class="headerlink" title="MSTP报文"></a><strong>MSTP报文</strong></h2><p><img src="/2021/05/06/MSTP/18.png"></p>
<p><img src="/2021/05/06/MSTP/19.png"></p>
<p>•无论是域内的MST BPDU还是域间的，前36个字节和RST BPDU相同。从第37个字节开始是MSTP专有字段。最后的MSTI配置信息字段由若干MSTI配置信息组连缀而成。</p>
<p>•MST BPDU中主要信息说明：</p>
<ul>
<li><p>Protocol Identifier：2 Byte，协议标识符。</p>
</li>
<li><p>Protocol Version Identifier：1 Byte，协议版本标识符，STP为0，RSTP为2，MSTP为3。</p>
</li>
<li><p>BPDU Type：1 Byte，BPDU类型：</p>
<ul>
<li>0x00：STP的Configuration BPDU</li>
<li>0x80：STP的TCN BPDU（Topology Change Notification BPDU）</li>
<li>0x02：RST BPDU（Rapid Spanning-Tree BPDU）或者MST BPDU（Multiple Spanning-Tree BPDU）</li>
</ul>
</li>
<li><p>CIST Flags：1 Byte，CIST标志字段。</p>
</li>
<li><p>CIST Root Identifier：8 Byte，CIST的总根交换设备ID。</p>
</li>
<li><p>CIST External Path Cost：4 Byte，CIST外部路径开销指从本交换设备所属的MST域到CIST根交换设备所属的MST域的累计路径开销。CIST外部路径开销根据链路带宽计算。</p>
</li>
<li><p>CIST Regional Root Identifier：8 Byte，CIST的域根交换设备ID，即IST Master的ID。如果总根在这个域内，那么域根交换设备ID就是总根交换设备ID。</p>
</li>
<li><p>CIST Port Identifier：2 Byte，本端口在IST中的指定端口ID。</p>
</li>
<li><p>Message Age：2 Byte，BPDU报文的生存期。</p>
</li>
<li><p>Max Age：2 Byte，BPDU报文的最大生存期，超时则认为到根交换设备的链路故障。</p>
</li>
<li><p>Hello Time：2 Byte，Hello定时器，缺省为2秒。</p>
</li>
<li><p>Forward Delay：2 Byte，Forward Delay定时器，缺省为15秒。</p>
</li>
<li><p>Version 1 Length：1 Byte，Version1 BPDU的长度，值固定为0。</p>
</li>
<li><p>Version 3 Length：2 Byte，Version3 BPDU的长度。</p>
</li>
<li><p>MST Configuration Identifier：51 Byte，MST配置标识，表示MST域的标签信息，包含4个字段。</p>
</li>
<li><p>CIST Internal Root Path Cost：4 Byte，CIST内部路径开销指从本端口到IST Master交换设备的累计路径开销。CIST内部路径开销根据链路带宽计算。</p>
</li>
<li><p>CIST Bridge Identifier：8 Byte，CIST的指定交换设备ID。</p>
</li>
<li><p>CIST Remaining Hops：1 Byte，BPDU报文在CIST中的剩余跳数。</p>
</li>
<li><p>MSTI Configuration Messages：16 Byte，MSTI配置信息。每个MSTI的配置信息占16 Byte，如果有n个MSTI就占用n×16 Byte。</p>
</li>
</ul>
<h1 id="MSTP的工作原理"><a href="#MSTP的工作原理" class="headerlink" title="MSTP的工作原理"></a>MSTP的工作原理</h1><h2 id="MSTP拓扑计算"><a href="#MSTP拓扑计算" class="headerlink" title="MSTP拓扑计算"></a><strong>MSTP拓扑计算</strong></h2><p>•MSTP拓扑计算：</p>
<ul>
<li><p>MSTP可以将整个二层网络划分为多个MST域，各个域之间通过计算生成CST，域内生成IST，CST和IST构成了整个交换设备网络的CIST。</p>
</li>
<li><p>域内还可以基于实例计算生成多棵生成树，每棵生成树都被称为是一个MSTI。</p>
</li>
</ul>
<p>•CIST和MSTI都是根据优先级向量来计算的，这些优先级向量信息都包含在MST BPDU中。各交换设备互相交换MST BPDU来生成CIST和MSTI 。</p>
<ul>
<li><p>参与CIST计算的优先级向量为：</p>
<p>▪{ 根交换设备ID，外部路径开销，域根ID，内部路径开销，指定交换设备ID，指定端口ID，接收端口ID }</p>
</li>
<li><p>参与MSTI计算的优先级向量为：</p>
<p>▪{ 域根ID，内部路径开销，指定交换设备ID，指定端口ID，接收端口ID }</p>
</li>
<li><p>注意：括号中的向量的优先级从左到右依次递减。</p>
</li>
</ul>
<blockquote>
<p>•优先级向量说明：</p>
<ul>
<li><p>根交换设备ID：根交换设备ID用于选择CIST中的根交换设备。</p>
<ul>
<li><p>根交换设备ID = Priority(16 bit) + MAC(48 bit)。</p>
</li>
<li><p>其中Priority为MSTI0的优先级。</p>
</li>
</ul>
</li>
<li><p>外部路径开销（External Root Path Cost，ERPC）：从CIST的域根到达总根的路径开销。</p>
<ul>
<li>MST域内所有交换设备上保存的外部路径开销相同。</li>
<li>若CIST根交换设备在域中，则域内所有交换设备上保存的外部路径开销为0。</li>
</ul>
</li>
<li><p>域根ID：域根ID用于选择MSTI中的域根。</p>
<ul>
<li>域根ID = Priority(16 bit) + MAC(48 bit)。</li>
<li>其中Priority为MSTI0的优先级。</li>
</ul>
</li>
<li><p>内部路径开销（Internal Root Path Cost，IRPC）：本桥到达域根的路径开销。</p>
<ul>
<li>域边缘端口保存的内部路径开销大于非域边缘端口保存的内部路径开销。</li>
</ul>
</li>
<li><p>指定交换设备ID：CIST或MSTI实例的指定交换设备是本桥通往域根的最邻近的上游桥。</p>
<ul>
<li>如果本桥就是总根或域根，则指定交换设备为自己。</li>
</ul>
</li>
<li><p>指定端口ID：指定交换设备上同本设备上根端口相连的端口。</p>
<ul>
<li>Port ID = Priority(4 bit) + 端口号（12 bit）。</li>
<li>端口优先级必须是16的整数倍。</li>
</ul>
</li>
<li><p>接收端口ID：接收到BPDU报文的端口。</p>
<ul>
<li>Port ID = Priority(4 bit) + 端口号（12 bit）。</li>
<li>端口优先级必须是16的整数倍。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>•优先级向量比较原则：</p>
<ul>
<li><p>同一向量比较，值最小的向量具有最高优先级。</p>
</li>
<li><p>优先级向量比较原则如下</p>
<p>1.首先，比较根交换设备ID。</p>
<p>2.如果根交换设备ID相同，再比较外部路径开销。</p>
<p>3.如果外部路径开销相同，再比较域根ID。</p>
<p>4.如果域根ID仍然相同，再比较内部路径开销。</p>
<p>5.如果内部路径仍然相同，再比较指定交换设备ID。</p>
<p>6.如果指定交换设备ID仍然相同，再比较指定端口ID。</p>
<p>7.如果指定端口ID还相同，再比较接收端口ID。</p>
</li>
<li><p>如果端口接收到的BPDU内包含的配置消息优于端口上保存的配置消息，则端口上原来保存的配置消息被新收到的配置消息替代。端口同时更新交换设备保存的全局配置消息。反之，新收到的BPDU被丢弃。</p>
</li>
</ul>
</blockquote>
<h2 id="CIST计算"><a href="#CIST计算" class="headerlink" title="CIST计算"></a><strong>CIST计算</strong></h2><p>•经过比较MST BPDU消息后，在整个网络中选择一个优先级最高的交换设备作为CIST的树根，即总根。</p>
<p>•在每个MST域内，MSTP通过计算生成IST；同时MSTP将每个MST域作为单台交换设备对待，通过计算在MST域间生成CST。CST和IST构成了整个交换设备网络的CIST。</p>
<p><img src="/2021/05/06/MSTP/20.png"></p>
<h2 id="MSTI计算"><a href="#MSTI计算" class="headerlink" title="MSTI计算"></a>MSTI计算</h2><p>•在MST域内，MSTP根据VLAN和生成树实例的映射关系，针对不同的VLAN生成不同的生成树实例。</p>
<p>•每棵生成树独立进行计算，计算过程与STP计算生成树的过程类似。</p>
<p><img src="/2021/05/06/MSTP/21.png"></p>
<blockquote>
<p>•MSTI的特点：</p>
<p>​    ▫每个MSTI独立计算自己的生成树，互不干扰。</p>
<p>​    ▫每个MSTI的生成树计算方法与STP基本相同。</p>
<p>​    ▫每个MSTI的生成树可以有不同的根，不同的拓扑。</p>
<p>​    ▫每个MSTI在自己的生成树内发送BPDU。</p>
<p>​    ▫每个MSTI的拓扑通过命令配置决定。</p>
<p>​    ▫每个端口在不同MSTI上的生成树参数可以不同。</p>
<p>​    ▫每个端口在不同MSTI上的角色、状态可以不同。</p>
<p>•根桥和备份根桥：可以通过计算来自动确定生成树的根桥，用户也可以手动配置设备为指定生成树的根桥或备份根桥。</p>
<p>​    ▫设备在各生成树中的角色互相独立，在作为一棵生成树的根    桥或备份根桥的同时，也可以作为其它生成树的根桥或备份    根桥；但在同一棵生成树中，一台设备不能既作为根桥，又    作为备份根桥。</p>
<p>​    ▫在一棵生成树中，生效的根桥只有一个；当两台或两台以上    的设备被指定为同一棵生成树的根桥时，系统将选择MAC地    址最小的设备作为根桥。</p>
<p>​    ▫可以在每棵生成树中指定多个备份根桥。当根桥出现故障或    被关机时，备份根桥可以取代根桥成为指定生成树的根桥；    但此时若配置了新的根桥，则备份根桥将不会成为根桥。如    果配置了多个备份根桥，则MAC地址最小的备份根桥将成为    指定生成树的根桥。</p>
</blockquote>
<h2 id="MSTP网络数据转发"><a href="#MSTP网络数据转发" class="headerlink" title="MSTP网络数据转发"></a><strong>MSTP网络数据转发</strong></h2><p>在运行MSTP协议的网络中，一个VLAN报文将沿着如下路径进行转发：</p>
<ul>
<li><p>在MST域内，沿着其对应的MSTI转发。</p>
</li>
<li><p>在MST域间，沿着CST转发。</p>
</li>
</ul>
<p><img src="/2021/05/06/MSTP/22.png"></p>
<blockquote>
<p>•如图所示，以VLAN2的数据发送为例。</p>
</blockquote>
<h1 id="MSTP的基本配置"><a href="#MSTP的基本配置" class="headerlink" title="MSTP的基本配置"></a>MSTP的基本配置</h1><h2 id="MSTP的基础配置命令"><a href="#MSTP的基础配置命令" class="headerlink" title="MSTP的基础配置命令"></a><strong>MSTP的基础配置命令</strong></h2><p><img src="/2021/05/06/MSTP/23.png"></p>
<blockquote>
<p>•命令：<strong>stp mode</strong> <strong>mstp</strong></p>
<p>▫STP和MSTP不能互相识别报文，而MSTP和RSTP可以互相识别报文，所以若工作在MSTP工作模式下，交换设备会设置所有和运行STP的交换设备直接相连的端口工作在STP模式下，其他端口工作在MSTP模式下，实现运行不同生成树协议的设备之间的互通。</p>
</blockquote>
<h2 id="配置MST域并激活"><a href="#配置MST域并激活" class="headerlink" title="配置MST域并激活"></a><strong>配置MST域并激活</strong></h2><p><img src="/2021/05/06/MSTP/24.png"></p>
<p><img src="/2021/05/06/MSTP/25.png"></p>
<blockquote>
<p>•命令：<strong>stp region-configuration</strong></p>
<ul>
<li>缺省情况下，MST域的三个参数均取缺省值。</li>
</ul>
<p>•命令：<strong>region-name</strong> <em>name</em></p>
<ul>
<li><em>name</em>：指定交换设备的MST域名。字符串形式，不支持空格，区分大小写，长度为1～32个字符。</li>
</ul>
<p>•命令：<strong>instance</strong> <em>instance-id</em> <strong>vlan</strong> { <em>vlan-id1</em> [ <strong>to</strong> <em>vlan-id2</em> ] }</p>
<ul>
<li><em>instance-id</em>：指定生成树实例的编号。整数形式，取值范围是0～4094，取值为0表示的是CIST。</li>
</ul>
<p>•命令：<strong>revision-level</strong> <em>level</em></p>
<ul>
<li><p><em>level</em>：指定MST域的修订级别。整数形式，取值范围是0～65535。</p>
</li>
<li><p>MSTP是标准协议，各厂商设备的MSTP修订级别一般都默认为0。如果某厂商的设备不为0，为保持MST域内计算，在部署MSTP时，需要将各设备的MSTP修订级别修改为一致。</p>
</li>
</ul>
</blockquote>
<h2 id="MSTP的可选配置命令"><a href="#MSTP的可选配置命令" class="headerlink" title="MSTP的可选配置命令"></a>MSTP的可选配置命令</h2><p><img src="/2021/05/06/MSTP/26.png"></p>
<blockquote>
<p>•命令：<strong>stp</strong> [ <strong>instance</strong> <em>instance-id</em> ] <strong>root</strong> { <strong>primary</strong> | <strong>secondary</strong> }</p>
<ul>
<li><p><strong>instance</strong> <em>instance-id</em>：指定生成树实例的编号。如果不指定instance，则配置设备在实例0上为根桥/备份根桥设备。</p>
</li>
<li><p><strong>primary</strong>：指定配置为生成树的根桥设备。配置后该设备优先级值自动为0，将不能更改设备优先级。</p>
</li>
<li><p><strong>secondary</strong>：指定配置为生成树的备份根桥设备。配置后该设备优先级值自动为4096，将不能更改设备优先级。</p>
</li>
</ul>
<p>•命令：<strong>stp</strong> [ <strong>instance</strong> <em>instance-id</em> ] <strong>priority</strong> <em>priority</em></p>
<ul>
<li><em>priority</em>：指定交换设备的优先级数值。优先级值越小，则交换设备的优先级越高。整数形式，取值范围是0～61440，步长为4096，如0、4096、8192等。缺省值是32768。</li>
</ul>
<p>•命令：<strong>stp</strong> <strong>pathcost-standard</strong> { <strong>dot1d-1998</strong> | <strong>dot1t</strong> | <strong>legacy</strong> }</p>
<ul>
<li><p><strong>dot1d-1998</strong>：指定路径开销值的计算方法是IEEE 802.1D-1998标准方法，取值范围为1~65535。</p>
</li>
<li><p><strong>dot1t</strong>：指定路径开销值的计算方法是IEEE 802.1T标准方法，取值范围为1~200,000,000。</p>
</li>
<li><p><strong>legacy</strong>：指定路径开销值的计算方法是华为计算方法，取值范围为1~200,000。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/05/06/MSTP/27.png"></p>
<blockquote>
<p>•命令：<strong>stp</strong> [ <strong>instance</strong> <em>instance-id</em> ] <strong>port priority</strong> <em>priority</em></p>
<ul>
<li><em>priority</em>：指定端口在生成树计算时的优先级。整数形式，取值范围是0～240，步长为16，如0、16、32等。</li>
</ul>
</blockquote>
<h2 id="案例：单域多实例场景配置-1"><a href="#案例：单域多实例场景配置-1" class="headerlink" title="案例：单域多实例场景配置 (1)"></a><strong>案例：单域多实例场景配置</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/MSTP/28.png"></p>
<p><img src="/2021/05/06/MSTP/29.png"></p>
<blockquote>
<p>可以配置SW1为VLAN2的网关（VLANIF2：192.168.1.254/24），SW2为VLAN3的网关（VLANIF3:192.168.2.254/24），最终实现PC1能Ping通SW1的VLANIF2接口，PC2能Ping通SW2的VLANIF3接口。</p>
</blockquote>
<h2 id="案例：单域多实例场景配置-2"><a href="#案例：单域多实例场景配置-2" class="headerlink" title="案例：单域多实例场景配置 (2)"></a><strong>案例：单域多实例场景配置</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/MSTP/28.png"></p>
<p><img src="/2021/05/06/MSTP/30.png"></p>
<p><img src="/2021/05/06/MSTP/31.png"></p>
<h2 id="案例：单域多实例场景配置-3"><a href="#案例：单域多实例场景配置-3" class="headerlink" title="案例：单域多实例场景配置 (3)"></a><strong>案例：单域多实例场景配置</strong> <strong>(3)</strong></h2><p><img src="/2021/05/06/MSTP/28.png"></p>
<p><img src="/2021/05/06/MSTP/32.png"></p>
<p><img src="/2021/05/06/MSTP/33.png"></p>
<p><img src="/2021/05/06/MSTP/34.png"></p>
<h2 id="验证配置结果-1"><a href="#验证配置结果-1" class="headerlink" title="验证配置结果 (1)"></a><strong>验证配置结果</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/MSTP/35.png"></p>
<p><img src="/2021/05/06/MSTP/36.png"></p>
<h2 id="验证配置结果-2"><a href="#验证配置结果-2" class="headerlink" title="验证配置结果 (2)"></a><strong>验证配置结果</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/MSTP/37.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.(单选题) 某运行MSTP协议的交换机的端口角色如下图所示，请问GigabitEthernet0/0/1端口在Instance1中的端口状态应该是？</p>
<p>A.Blocking</p>
<p><strong>B.Discarding</strong></p>
<p>C.Forwarding</p>
<p>D.Learning</p>
<p><img src="/2021/05/06/MSTP/4.png"></p>
<p>2.(判断题) CIST是由内部生成树和公共生成树构成的一棵树。（  ）</p>
<p><strong>A.正确</strong></p>
<p>B.错误</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•在MSTP网络中，可以将一个或多个VLAN映射到一个Instance，然后MSTP基于该Instance计算生成树。基于Instance的生成树被称为MSTI，MSTP为每个Instance维护独立的MSTI，映射到同一个Instance的VLAN将共享同一棵生成树。</p>
<p>•在以太网中部署MSTP协议后可实现如下功能：</p>
<ul>
<li><p>形成多棵无环路的树，解决广播风暴并实现冗余备份。</p>
</li>
<li><p>多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/RSTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/RSTP/" itemprop="url">RSTP原理与配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T17:10:54+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路，但是这也带来了网络环路的问题。网络环路会引发广播风暴和MAC地址表震荡等问题，导致用户通信质量差，甚至通信中断。为了解决交换网络中的环路问题，IEEE提出了基于802.1D标准的STP（Spanning Tree Protocol，生成树协议）。</p>
<p>•随着局域网规模的不断增长，STP拓扑收敛速度慢的问题逐渐凸显，因此，IEEE在2001年发布了802.1W标准，定义了RSTP（Rapid Spanning Tree Protocol，快速生成树协议），RSTP在STP的基础上进行了改进，可实现网络拓扑的快速收敛。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li><p>描述STP技术的缺陷</p>
</li>
<li><p>描述RSTP对STP技术的改进</p>
</li>
<li><p>描述RSTP的基本工作原理</p>
</li>
<li><p>完成RSTP的基本配置</p>
</li>
</ul>
<h1 id="STP回顾与STP不足"><a href="#STP回顾与STP不足" class="headerlink" title="STP回顾与STP不足"></a><strong>STP回顾与STP不足</strong></h1><h2 id="回顾：STP的工作原理"><a href="#回顾：STP的工作原理" class="headerlink" title="回顾：STP的工作原理"></a><strong>回顾：STP的工作原理</strong></h2><p>•STP通过在交换机之间传递配置BPDU来选举根交换机 (或根桥)，以及确定每个交换机端口的角色和状态。</p>
<p>​    ▫在初始化过程中，每个交换机都主动发送配置BPDU。</p>
<p>​    ▫在网络拓扑稳定以后，只有根桥周期性发送配置BPDU，其他交    换机在收到上游传来的配置BPDU后，才会发送自己的配BPDU。</p>
<p>•配置BPDU包含了桥ID、路径开销和端口ID等参数。</p>
<p><img src="/2021/05/06/RSTP/1.png"></p>
<blockquote>
<p>•配置BPDU泛洪：</p>
<ul>
<li><p>在初始形成STP树的过程中，所有STP交换机会周期性地（Hello Time，缺省为2s）主动产生并发送配置BPDU，大家都认为自己是根桥。</p>
</li>
<li><p>随着BPDU的泛洪和收集，各交换机根据BPDU包含的信息进行比较，并选举出根桥。</p>
</li>
<li><p>在此之后（即STP树形成后的稳定期），只有根桥会周期性地（缺省为2s）主动产生并发送配置BPDU。相应的，非根桥交换机会从自己的根端口周期性地接收到配置BPDU，并立即触发产生自己的配置BPDU，然后从自己的指定端口发出。——这一过程看起来就像是，根桥发出的配置BPDU逐跳地“经过”了其他的交换机。也可以理解为：从根桥倒一盆水下来，水顺着这棵无环的树从上往下不断地往下流。因此如图所示，可以理解为SW1与SW2间的链路是SW2的上游链路，SW2与SW3间的链路是SW2的下游链路。</p>
</li>
</ul>
<p>•报文格式：</p>
<ul>
<li><p>配置BPDU携带的参数可以分为3类：</p>
</li>
<li><p>第一类，BPDU对自身的标识，包括：协议标识、协议版本号、BPDU类型和标志。</p>
<ul>
<li>协议标识（Protocol ID，PID），2 Byte，总是0x000。</li>
<li>协议版本号（Protocol Version ID，PVI），1 Byte，总是0x00。</li>
<li>BPDU类型（BPDU Type），1 Byte，配置BPDU的类型值为0x00。</li>
<li>标志（Flag），1 Byte，网络拓扑变化标志，仅使用了最低位和最高位。</li>
</ul>
</li>
<li><p>第二类，用于进行STP计算的参数，包括：当前根桥的BID、根路径开销、发送该BPDU的交换机的BID和发送该BPDU的端口的PID。</p>
<ul>
<li>根桥ID（Root ID），8 Byte，当前根桥的BID。</li>
<li>根路径开销（Root Path Cost，RPC），4 Byte，发送该BPDU的端口累计到根桥的开销。</li>
<li>网桥ID（Bridge ID，BID），8 Byte，发送该BPDU的交换机的BID。</li>
<li>接口ID（Port ID，PDID），2 Byte，发送该BPDU的端口ID。</li>
</ul>
</li>
<li><p>第三类，时间参数，包括：消息寿命、最大寿命、Hello时间和转发延迟。</p>
<ul>
<li>消息寿命（Message Age），2 Byte，该BPDU消息的年龄。从根桥发出的配置BPDU，Message Age为0。在实际的实现中，配置BPDU每“经过”一个桥，Message Age增加1。</li>
<li>最大寿命（Max Age），2 Byte，BPDU的最大生命周期，缺省为20s。</li>
<li>Hello时间（Hello Time），2 Byte，根桥发送配置BPDU的周期，缺省为2s。</li>
<li>转发延迟（Forward Delay），2 Byte，端口在侦听和学习状态（后续会讲）所停留的时间间隔，缺省为15s。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="回顾：STP树的生成过程"><a href="#回顾：STP树的生成过程" class="headerlink" title="回顾：STP树的生成过程"></a><strong>回顾：STP树的生成过程</strong></h2><p><img src="/2021/05/06/RSTP/2.png"></p>
<blockquote>
<p>•STP基本原理：</p>
<ul>
<li>在一个具有物理环路的交换网络中，交换机通过运行STP，自动生成一个没有环路的工作拓扑，也被称为STP树。树节点为某些特定的交换机，树枝为某些特定的链路。</li>
</ul>
<p>•STP采用四个步骤来解决二层环路问题（生成一棵STP树）：</p>
<ul>
<li>在一个交换网络中选举一个根桥；在每个非根桥上选举一个根端口；为每个网段选举一个指定端口；阻塞交换机上所有剩余的非根、非指定端口（备用端口）。</li>
</ul>
<p>•如何生成STP树？</p>
<ul>
<li>主要通过比较4个参数：根桥ID、根路径开销、网桥ID和端口ID，值越小，越优先。而这些参数，都是报文BPDU中的字段。<ul>
<li>根桥选举：比较根桥ID，最小胜出。</li>
<li>根端口选举：依次比较RPC、对端BID、对端PID和本端PID，最小胜出。</li>
<li>指定端口选举：依次比较RPC、本端BID和本端PID，最小胜出。</li>
<li>在确定了根端口和指定端口之后，交换机上所有剩余的非根端口和非指定端口被阻塞。</li>
</ul>
</li>
</ul>
<p>•在华为产品的实现中，被阻塞的非指定端口表现为Alternate Port。</p>
</blockquote>
<h2 id="回顾：STP的端口状态迁移"><a href="#回顾：STP的端口状态迁移" class="headerlink" title="回顾：STP的端口状态迁移"></a><strong>回顾：STP的端口状态迁移</strong></h2><p><img src="/2021/05/06/RSTP/3.png"></p>
<blockquote>
<p>•根据端口是否接收和发送STP协议帧，以及端口是否能转发用户数据帧，STP定义了五种端口状态：Disabled、Blocking、Listening、Learning和Forwarding。</p>
<ul>
<li>Disabled状态：端口无法接收和发出任何帧（即：端口不仅不处理BPDU报文，也不转发用户流量），端口处于关闭（down）状态。</li>
<li>Blocking状态：端口只能接收并处理BPDU，不能发送BPDU，也不能转发用户数据帧（用户流量），是阻塞端口的最终状态。</li>
<li>Listening状态：端口可以接收并发送BPDU，但不进行MAC地址学习，也不能转发用户数据帧。这是过渡状态，用于确定端口角色，将选举出根桥、根端口和指定端口，同时用于防止临时环路。</li>
<li>Learning状态：端口可以接收并发送BPDU，也可以进行MAC地址学习，根据收到的用户流量构建MAC地址表，但不能转发用户数据帧（用户流量）。这也是过渡状态，用于防止MAC地址表未建立，网络中出现大量数据帧泛洪。</li>
<li>Forwarding状态：端口可以接收并发送BPDU，也可以进行MAC地址学习，同时能够转发用户数据帧（用户流量）。只有根端口或指定端口才能进入Forwarding状态。</li>
</ul>
<p>•端口状态迁移：</p>
<ol>
<li><p>STP交换机的端口在初始启动时，会从Disabled状态进入到Blocking状态。在Blocking状态，端口只接收和分析BPDU，但不发送。</p>
</li>
<li><p>在整个过程中，端口一但被关闭或发生了链路故障，就会进入Disabled状态。</p>
</li>
<li><p>如果端口被选为根端口或指定端口，则会进入Listening状态，此时端口接收并发送BPDU，这种状态会持续一个Forward Delay的时间长度，缺省为15s，是为了防止临时环路：因为此时网络中可能还存在因STP树的计算过程不同步而产生的临时环路。</p>
</li>
<li><p>在端口状态迁移过程中，如果端口的角色被判定为非根端口或非指定端口，则其端口状态就会立即退回到Blocking状态。</p>
</li>
<li><p>如果没有因“意外情况”回到Disabled状态，那么端口会进入Learning状态，此时端口不但可以接收并发送BPDU，还会开始构建MAC地址表，为用户流量的转发做好准备。这个状态也会持续一个Forward Delay的时间长度，缺省为15s，是为了防止此时交换机的MAC地址表还未建立，导致大量的数据帧被泛洪<strong>。</strong></p>
</li>
<li><p>最后，端口进入Forwarding状态，开始转发用户流量。</p>
</li>
</ol>
</blockquote>
<h2 id="STP的不足"><a href="#STP的不足" class="headerlink" title="STP的不足"></a>STP的不足</h2><p>STP虽然能够解决环路问题，但是由于网络拓扑收敛慢，影响了用户通信质量。如果网络中的拓扑结构频繁变化，网络也会随之频繁失去连通性，从而导致用户通信频繁中断，这是用户无法忍受的。</p>
<p>STP的不足：</p>
<ul>
<li><p>STP没有细致区分端口状态和端口角色，不利于初学者学习及部署。</p>
<ul>
<li>从用户角度来讲，Listening、Learning和Blocking状态并没有区别，都同样不转发用户流量。</li>
<li>从使用和配置角度来讲，端口之间最本质的区别并不在于端口状态，而是在于端口扮演的角色。</li>
</ul>
</li>
<li><p>STP算法是被动的算法，依赖定时器等待的方式判断拓扑变化，收敛速度慢。</p>
</li>
<li><p>STP算法要求在稳定的拓扑中，根桥主动发出配置BPDU报文，而其他设备再进行处理，最终传遍整个STP网络。</p>
</li>
</ul>
<h2 id="STP对计时器的依赖"><a href="#STP对计时器的依赖" class="headerlink" title="STP对计时器的依赖"></a><strong>STP对计时器的依赖</strong></h2><p><img src="/2021/05/06/RSTP/4.png"></p>
<p><img src="/2021/05/06/RSTP/5.png"></p>
<h2 id="STP重收敛过程慢"><a href="#STP重收敛过程慢" class="headerlink" title="STP重收敛过程慢"></a><strong>STP重收敛过程慢</strong></h2><p><img src="/2021/05/06/RSTP/6.png"></p>
<p><img src="/2021/05/06/RSTP/7.png"></p>
<blockquote>
<p>•直连故障：</p>
<ul>
<li><p>两台交换机间有两条链路，其中一条是主用链路，另一条为备用链路。</p>
</li>
<li><p>当网络稳定时，交换机SW2检测到根端口的链路发生故障，则被阻塞的端口会开始端口状态迁移，最终进入用户流量转发状态。</p>
</li>
</ul>
<p>•非直连故障：</p>
<ul>
<li><p>当网络正常时，SW3的被阻塞端口会定期收到来自根桥的BPDU。</p>
</li>
<li><p>当SW1与SW2之间的链路发生故障时，SW2能够第一时间检测到故障发生，此时它认为自己成为新的根桥，于是向SW3发送自己的配置BPDU（根桥ID为自己的桥ID）。</p>
</li>
<li><p>SW3的被阻塞端口将收到上述配置BPDU，但该BPDU并不比当前端口所缓存的配置BPDU更优，因此SW3忽略该配置BPDU。</p>
</li>
<li><p>当Max Age计时器超时后，SW3端口上缓存的配置BPDU老化，SW3开始向SW2发送配置BPDU，该配置BPDU由根桥SW1发送的配置BPDU触发，其中的根桥ID字段值为SW1的桥ID。</p>
</li>
<li><p>SW2收到上述配置BPDU后，解析该报文并认定SW1为根桥，于是将其连接SW3的端口切换为根端口。</p>
</li>
</ul>
</blockquote>
<h2 id="STP拓扑变更机制"><a href="#STP拓扑变更机制" class="headerlink" title="STP拓扑变更机制"></a><strong>STP拓扑变更机制</strong></h2><p>STP的拓扑变更机制，需要先将拓扑变化信息传递给根桥，再由根桥向下游泛洪拓扑变化信息。</p>
<p><img src="/2021/05/06/RSTP/8.png"></p>
<blockquote>
<p>•拓扑变更，STP处理过程：</p>
<p>当交换机检测到拓扑更改时，会通知生成树的根桥，然后根桥将该拓扑更改信息泛洪到整个网络。</p>
<p>拓扑变化过程，如图：</p>
<ul>
<li>如果网络中新增一台交换机，导致工作拓扑发生了变化，则位于变化点的交换机可以通过端口状态直接感知到这种变化，但是其他的交换机是无法直接感知到的。</li>
<li>位于变化点的交换机会以Hello Time（缺省2s）为周期通过其根端口不断向上游发送TCN BPDU，直到接收到从上游交换机发来的、TCA位置1的配置BPDU。TCA位置1是为了通知下游设备停止发送TCN BPDU报文。</li>
<li>上游交换机收到TCN BPDU后，一方面会通过其指定端口回复TCA位置1的配置BPDU，另一方面会以Hello Time为周期通过其根端口不断向它的上游发送TCN BPDU。</li>
<li>这个过程一直重复，直到根桥收到TCN BPDU。</li>
<li>根桥收到TCN BPDU后，会发送TC位置1的配置BPDU，通告所有交换机网络拓扑发生了变化，通知下游设备直接删除桥MAC地址表项。</li>
</ul>
</blockquote>
<h1 id="RSTP概述"><a href="#RSTP概述" class="headerlink" title="RSTP概述"></a><strong>RSTP概述</strong></h1><h2 id="RSTP概述-1"><a href="#RSTP概述-1" class="headerlink" title="RSTP概述"></a><strong>RSTP概述</strong></h2><p>•IEEE 802.1W中定义的RSTP可以视为STP的改进版本，RSTP在许多方面对STP进行了优化，它的收敛速度更快，而且能够兼容STP。</p>
<p>•RSTP对STP的改进：</p>
<ul>
<li>通过端口角色的增补，简化了生成树协议的理解及部署；</li>
<li>端口状态的重新划分；</li>
<li>配置BPDU格式的改变，充分利用了STP协议报文中的Flag字段，明确了端口角色；</li>
<li>配置BPDU的处理发生变化；</li>
<li>快速收敛；</li>
<li>增加保护功能。</li>
</ul>
<blockquote>
<p>•RSTP可以兼容STP：RSTP可以和STP互操作，但是此时会丧失快速收敛等RSTP优势。</p>
<ul>
<li><p>当一个网段里既有运行STP的交换设备又有运行RSTP的交换设备，STP交换设备会忽略RSTP的BPDU。运行RSTP的交换设备在某端口上接收到运行STP的交换设备发出的配置BPDU，在两个Hello Time时间之后，便把自己的端口转换到STP工作模式，发送配置BPDU，从而实现了互操作。</p>
</li>
<li><p>在华为技术有限公司的数据通信设备上可以配置运行STP的交换设备被撤离网络后，运行RSTP的交换设备可迁移回到RSTP工作模式。</p>
</li>
</ul>
</blockquote>
<h2 id="RSTP在园区网络中的应用位置"><a href="#RSTP在园区网络中的应用位置" class="headerlink" title="RSTP在园区网络中的应用位置"></a><strong>RSTP在园区网络中的应用位置</strong></h2><p><img src="/2021/05/06/RSTP/9.png"></p>
<h1 id="RSTP对STP的改进"><a href="#RSTP对STP的改进" class="headerlink" title="RSTP对STP的改进"></a><strong>RSTP对STP的改进</strong></h1><h2 id="改进点1：端口角色"><a href="#改进点1：端口角色" class="headerlink" title="改进点1：端口角色"></a><strong>改进点1：端口角色</strong></h2><p>通过端口角色的增补，简化了生成树协议的理解与部署。</p>
<p><img src="/2021/05/06/RSTP/10.png"></p>
<p><img src="/2021/05/06/RSTP/11.png"></p>
<blockquote>
<p>•RSTP的端口角色共有4种：根端口、指定端口、Alternate端口和Backup端口。</p>
<p>•根端口和指定端口的作用同STP中定义，Alternate端口和Backup端口的描述如下：</p>
<ul>
<li><p>从配置BPDU报文发送角度来看：</p>
<ul>
<li>Alternate端口就是由于学习到其它网桥发送的配置BPDU报文而阻塞的端口。</li>
<li>Backup端口就是由于学习到自己发送的配置BPDU报文而阻塞的端口。</li>
</ul>
</li>
<li><p>从用户流量角度来看：</p>
<ul>
<li>Alternate端口提供了从指定桥到根的另一条可切换路径，作为根端口的备份端口。</li>
<li>Backup端口作为指定端口的备份，提供了另一条从根桥到相应网段的备份通路。</li>
</ul>
</li>
</ul>
<p>•给一个RSTP域内所有端口分配角色的过程就是整个拓扑收敛的过程。</p>
</blockquote>
<h2 id="改进点2：端口状态"><a href="#改进点2：端口状态" class="headerlink" title="改进点2：端口状态"></a><strong>改进点2：端口状态</strong></h2><p>RSTP的状态规范缩减为3种，根据端口是否转发用户流量和学习MAC地址来划分:</p>
<p>▫Discarding状态：不转发用户流量也不学习MAC地址；</p>
<p>▫Learning状态：不转发用户流量但是学习MAC地址；</p>
<p>▫Forwarding状：既转发用户流量又学习MAC地址。</p>
<table>
<thead>
<tr>
<th align="center">STP端口状态</th>
<th align="center"><strong>RSTP端口状态</strong></th>
<th align="center"><strong>端口在拓扑中的角色</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Forwarding</td>
<td align="center">Forwarding</td>
<td align="center">包括根端口、指定端口</td>
</tr>
<tr>
<td align="center">Learning</td>
<td align="center">Learning</td>
<td align="center">包括根端口、指定端口</td>
</tr>
<tr>
<td align="center">Listening</td>
<td align="center">Discarding</td>
<td align="center">包括根端口、指定端口</td>
</tr>
<tr>
<td align="center">Blocking</td>
<td align="center">Discarding</td>
<td align="center">包括Alternate端口、Backup端口</td>
</tr>
<tr>
<td align="center">Disabled</td>
<td align="center">Discarding</td>
<td align="center">包括Disable端口</td>
</tr>
</tbody></table>
<h2 id="改进点3：配置BPDU-RST-BPDU"><a href="#改进点3：配置BPDU-RST-BPDU" class="headerlink" title="改进点3：配置BPDU - RST BPDU"></a><strong>改进点3：配置BPDU - RST BPDU</strong></h2><p>•RSTP的配置BPDU充分利用了STP报文中的Flag字段，明确了端口角色。</p>
<p>•除了保证和STP格式基本一致之外，RSTP作了如下变化：</p>
<ul>
<li><p>Type字段：配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃。</p>
</li>
<li><p>Flag字段：使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU。</p>
</li>
</ul>
<p>•<strong>RST BPDU报文格式：</strong></p>
<p><img src="/2021/05/06/RSTP/12.png"></p>
<blockquote>
<p>•RST BPDU与STP配置BPDU报文格式不同点，包括：BPDU类型和Flag字段。</p>
<ul>
<li><p>BPDU类型，1 Byte，RST BPDU的类型值为0x02。</p>
</li>
<li><p>标志，1 Byte，包括：</p>
<p>▪bit 7：TCA，表示拓扑变化确认；</p>
<p>▪bit 6：Agreement，表示同意，用于P/A机制；</p>
<p>▪bit 5：Forwarding，表示转发状态；</p>
<p>▪bit 4：Learning，表示学习状态；</p>
<p>▪bit 3和bit 2：表示端口角色，00表示未知端口，01表示替代或备份端口，10表示根端口，11表示指定端口；</p>
<p>▪bit 1：Proposal，表示提议，用于P/A机制；</p>
<p>▪bit 0：TC，表示拓扑变化。</p>
</li>
</ul>
</blockquote>
<h2 id="改进点4：配置BPDU的处理-1"><a href="#改进点4：配置BPDU的处理-1" class="headerlink" title="改进点4：配置BPDU的处理 (1)"></a><strong>改进点4：配置BPDU的处理</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/RSTP/13.png"></p>
<h2 id="改进点4：配置BPDU的处理-2"><a href="#改进点4：配置BPDU的处理-2" class="headerlink" title="改进点4：配置BPDU的处理 (2)"></a><strong>改进点4：配置BPDU的处理</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/RSTP/14.png"></p>
<h2 id="改进点4：配置BPDU的处理-3"><a href="#改进点4：配置BPDU的处理-3" class="headerlink" title="改进点4：配置BPDU的处理 (3)"></a><strong>改进点4：配置BPDU的处理 (3)</strong></h2><p><img src="/2021/05/06/RSTP/15.png"></p>
<blockquote>
<p>•STP：</p>
<ul>
<li>STP只有指定端口会立即处理次优BPDU，其他端口会忽略次优BPDU，等到Max Age计时器超时后，缓存的次优BPDU才会老化，然后发送自身更优的BPDU，进行新一轮的拓扑收敛。</li>
</ul>
<p>•RSTP：</p>
<ul>
<li>RSTP处理次优BPDU报文不再依赖于任何定时器（即不再依赖于BPDU老化）解决拓扑收敛，同时RSTP的任何端口角色都会处理次优BPDU，从而加快了拓扑收敛。</li>
</ul>
</blockquote>
<h2 id="改进点5：快速收敛机制-1"><a href="#改进点5：快速收敛机制-1" class="headerlink" title="改进点5：快速收敛机制 (1)"></a><strong>改进点5：快速收敛机制 (1)</strong></h2><p><img src="/2021/05/06/RSTP/16.png"></p>
<p><img src="/2021/05/06/RSTP/17.png"></p>
<h2 id="改进点5：快速收敛机制-2"><a href="#改进点5：快速收敛机制-2" class="headerlink" title="改进点5：快速收敛机制 (2)"></a><strong>改进点5：快速收敛机制</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/RSTP/18.png"></p>
<blockquote>
<p>•边缘端口的UP和Down，不会引起网络拓扑的变动。</p>
</blockquote>
<h2 id="改进点5：快速收敛机制-3"><a href="#改进点5：快速收敛机制-3" class="headerlink" title="改进点5：快速收敛机制 (3)"></a>改进点5：快速收敛机制 (3)</h2><p><img src="/2021/05/06/RSTP/19.png"></p>
<blockquote>
<p>•事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。</p>
<p>•而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P/A机制加快了上游端口进入Forwarding状态的速度。</p>
</blockquote>
<h3 id="P-A机制详解-1"><a href="#P-A机制详解-1" class="headerlink" title="P/A机制详解(1)"></a><strong>P/A机制详解(1)</strong></h3><p><img src="/2021/05/06/RSTP/20.png"></p>
<h3 id="P-A机制详解-2"><a href="#P-A机制详解-2" class="headerlink" title="P/A机制详解(2)"></a><strong>P/A机制详解(2)</strong></h3><p><img src="/2021/05/06/RSTP/21.png"></p>
<blockquote>
<p>•SW2的下游端口同步过程：替代端口，状态不变；边缘端口，不参与计算；阻塞非边缘指定端口。</p>
</blockquote>
<h3 id="P-A机制详解-3"><a href="#P-A机制详解-3" class="headerlink" title="P/A机制详解(3)"></a><strong>P/A机制详解(3)</strong></h3><p><img src="/2021/05/06/RSTP/22.png"></p>
<h2 id="改进点6：拓扑变更机制"><a href="#改进点6：拓扑变更机制" class="headerlink" title="改进点6：拓扑变更机制"></a><strong>改进点6：拓扑变更机制</strong></h2><p>在RSTP中检测拓扑是否发生变化只有一个标准：一个非边缘端口迁移到Forwarding状态。</p>
<p><img src="/2021/05/06/RSTP/23.png"></p>
<blockquote>
<p>•在STP中，如果拓扑发生了变化，需要先向根桥传递TCN BPDU，再由根桥来通知拓扑变更，泛洪TC置位的配置BPDU。</p>
<p>•在RSTP中，通过新的拓扑变更机制，TC置位的RST BPDU会快速的在网络中泛洪。</p>
<p>•如上图所示：</p>
<ul>
<li><p>SW3的根端口收不到从根桥发来的RST BPDU后，Alternate端口会快速切换为新的根端口，启动TC While Timer，并清空所有端口学习到的MAC地址。然后向外发出TC置位的RST BPDU。</p>
</li>
<li><p>SW2接收到RST BPDU后，会清空接收口以外所有端口学习到的MAC地址，同时开启计时器，并向外发送TC置位的RST BPDU。</p>
</li>
<li><p>最终，RST BPDU会在全网泛洪。</p>
</li>
</ul>
</blockquote>
<h2 id="改进点7：保护功能-1"><a href="#改进点7：保护功能-1" class="headerlink" title="改进点7：保护功能 (1)"></a><strong>改进点7：保护功能</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/RSTP/24.png"></p>
<blockquote>
<p>•在交换设备上，通常将直接与用户终端（如PC机）或文件服务器等非交换设备相连的端口配置为边缘端口。</p>
<p>•如上图所示：</p>
<ul>
<li><p>SW3与某主机互联，并设置该互联端口为边缘端口。</p>
</li>
<li><p>后来该主机被恶意用户侵占，并伪造RST BPDU攻击SW3，因此边缘端口会收到RST BPDU，失去边缘端口特性，并进行生成树计算。</p>
</li>
</ul>
</blockquote>
<h2 id="改进点7：保护功能-2"><a href="#改进点7：保护功能-2" class="headerlink" title="改进点7：保护功能 (2)"></a><strong>改进点7：保护功能</strong> <strong>(2)</strong></h2><p><img src="/2021/05/06/RSTP/25.png"></p>
<blockquote>
<p>•由于维护人员的错误配置或网络中的恶意攻击，根桥有可能会收到优先级更高的RST BPDU，使得根桥失去根地位，从而引起网络拓扑结构的错误变动。这种拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。</p>
<p>•如上图所示：</p>
<ul>
<li><p>网络稳定时，SW1为根桥，向下游设备发送最优RST BPDU。</p>
</li>
<li><p>如果SW2被恶意用户侵占，例如恶意修改SW2的桥优先级，使得SW2的桥优先级优于SW1，此时SW2会主动发送自己的RST BPDU。</p>
</li>
<li><p>当SW1的指定端口收到该RST BPDU后，会重新进行生成树计算，而SW1也会失去根桥的地位，引起拓扑变动。</p>
</li>
</ul>
</blockquote>
<h2 id="改进点7：保护功能-3"><a href="#改进点7：保护功能-3" class="headerlink" title="改进点7：保护功能 (3)"></a><strong>改进点7：保护功能</strong> <strong>(3)</strong></h2><p><img src="/2021/05/06/RSTP/26.png"></p>
<blockquote>
<p>•在运行RSTP的网络中，根端口状态是依靠不断接收来自上游交换设备的RST BPDU维持。当由于链路拥塞或者单向链路故障导致根端口收不到来自上游交换设备的RST BPDU时，此时交换设备会重新选择根端口。</p>
<p>•如图所示，当SW1和SW3之间的链路发生单向链路故障时，SW3由于根端口在超时时间内收不到来自上游设备的BPDU报文，Alternate端口切换成根端口，根端口切换成指定端口，从而形成了环路。</p>
</blockquote>
<h2 id="改进点7：保护功能-4"><a href="#改进点7：保护功能-4" class="headerlink" title="改进点7：保护功能 (4)"></a><strong>改进点7：保护功能</strong> <strong>(4)</strong></h2><p><img src="/2021/05/06/RSTP/27.png"></p>
<blockquote>
<p>•交换设备在接收到TC置位的RST BPDU报文后，会执行MAC地址表项的删除操作。如果有人伪造TC置位的RST BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多RST BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。</p>
<p>•如上图所示：</p>
<ul>
<li>如果SW3被恶意用户侵占，伪造大量TC置位的RST BPDU并向外发送。SW2收到这些RST BPDU后，会频繁执行MAC地址表项的删除操作，形成巨大负担。</li>
</ul>
</blockquote>
<h1 id="RSTP的工作过程"><a href="#RSTP的工作过程" class="headerlink" title="RSTP的工作过程"></a><strong>RSTP的工作过程</strong></h1><h2 id="RSTP拓扑收敛过程-1"><a href="#RSTP拓扑收敛过程-1" class="headerlink" title="RSTP拓扑收敛过程(1)"></a><strong>RSTP拓扑收敛过程(1)</strong></h2><p><img src="/2021/05/06/RSTP/28.png"></p>
<blockquote>
<p>•RSTP收敛与STP收敛过程类似。</p>
<p>•网络初始化时，网络中所有的RSTP交换机都认为自己是“根桥”，并设置每个端口都为指定端口，发送RST BPDU。其中SW1的桥ID最优，最终会被选举为根桥。</p>
</blockquote>
<h2 id="RSTP拓扑收敛过程-2"><a href="#RSTP拓扑收敛过程-2" class="headerlink" title="RSTP拓扑收敛过程(2)"></a><strong>RSTP拓扑收敛过程(2)</strong></h2><p><img src="/2021/05/06/RSTP/29.png"></p>
<blockquote>
<p>•每个认为自己是“根桥”的交换机生成一个RST BPDU报文来协商指定网段的端口状态，此RST BPDU报文Flag字段里面的Proposal位需要置位。</p>
<p>•当一个端口收到RST BPDU报文时，此端口会比较收到的RST BPDU报文和本地的RST BPDU报文。如果本地的RST BPDU报文优于接收的RST BPDU报文，则端口会丢弃接收的RST BPDU报文，并发送Proposal置位的本地RST BPDU报文来回复对端设备。</p>
<p>•如图，RSTP上游链路的设备互联端口收敛过程，以SW1与SW2为例。</p>
</blockquote>
<h2 id="RSTP拓扑收敛过程-3"><a href="#RSTP拓扑收敛过程-3" class="headerlink" title="RSTP拓扑收敛过程(3)"></a><strong>RSTP拓扑收敛过程(3)</strong></h2><p><img src="/2021/05/06/RSTP/30.png"></p>
<blockquote>
<p>•如图，RSTP下游链路的设备互联端口会进入慢收敛过程，以SW2与SW3为例。</p>
</blockquote>
<h1 id="RSTP的基本配置"><a href="#RSTP的基本配置" class="headerlink" title="RSTP的基本配置"></a><strong>RSTP的基本配置</strong></h1><h2 id="RSTP的基础配置命令-1"><a href="#RSTP的基础配置命令-1" class="headerlink" title="RSTP的基础配置命令(1)"></a><strong>RSTP的基础配置命令(1)</strong></h2><p><img src="/2021/05/06/RSTP/31.png"></p>
<h2 id="RSTP的基础配置命令-2"><a href="#RSTP的基础配置命令-2" class="headerlink" title="RSTP的基础配置命令(2)"></a><strong>RSTP的基础配置命令(2)</strong></h2><p><img src="/2021/05/06/RSTP/32.png"></p>
<blockquote>
<p>•配置接口路径开销：</p>
<ul>
<li><p>dot1d-1998：指定路径开销值的计算方法是IEEE 802.1d-1998标准方法。使用IEEE 802.1d-1998标准方法时取值范围是1～65535。</p>
</li>
<li><p>dot1t：指定路径开销值的计算方法是IEEE 802.1t标准方法。使用IEEE 802.1t标准方法时取值范围是1～200,000,000。</p>
</li>
<li><p>legacy：指定路径开销值的计算方法是华为计算方法。使用华为计算方法时取值范围是1～200,000。</p>
</li>
</ul>
</blockquote>
<h2 id="RSTP的基础配置命令-3"><a href="#RSTP的基础配置命令-3" class="headerlink" title="RSTP的基础配置命令(3)"></a><strong>RSTP的基础配置命令(3)</strong></h2><p><img src="/2021/05/06/RSTP/33.png"></p>
<h2 id="RSTP的保护功能配置命令-1"><a href="#RSTP的保护功能配置命令-1" class="headerlink" title="RSTP的保护功能配置命令(1)"></a><strong>RSTP的保护功能配置命令(1)</strong></h2><p><img src="/2021/05/06/RSTP/34.png"></p>
<h2 id="RSTP的保护功能配置命令-2"><a href="#RSTP的保护功能配置命令-2" class="headerlink" title="RSTP的保护功能配置命令(2)"></a><strong>RSTP的保护功能配置命令(2)</strong></h2><p><img src="/2021/05/06/RSTP/35.png"></p>
<blockquote>
<p>•配置后，在<strong>stp</strong> <strong>tc-protection interval</strong>指定的时间内，设备只会处理<strong>stp</strong> <strong>tc-protection threshold</strong>指定数量的拓扑变化报文，对于其他的报文会延迟处理，所以可能会影响生成树的收敛速度。例如，时间设定为10秒，阈值设定为5，则设备收到拓扑变化报文后，在10秒内只会处理最开始收到的5个拓扑变化报文，对于后面收到的报文则会等10秒超时后再统一处理。</p>
</blockquote>
<h2 id="案例：RSTP的基础配置"><a href="#案例：RSTP的基础配置" class="headerlink" title="案例：RSTP的基础配置"></a><strong>案例：RSTP的基础配置</strong></h2><p><img src="/2021/05/06/RSTP/36.png"></p>
<p><img src="/2021/05/06/RSTP/37.png"></p>
<p><img src="/2021/05/06/RSTP/38.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）以下哪些是RSTP的端口状态？(   )</p>
<p>A.Idle</p>
<p><strong>B.Discarding</strong></p>
<p><strong>C.Forwarding</strong></p>
<p><strong>D.Learning</strong></p>
<p>2.（单选题）RSTP的根保护必须配置在设备的根端口上。(   )</p>
<p>A.对</p>
<p><strong>B.错</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•生成树是一个用于局域网中消除环路的协议。运行该协议的设备通过彼此交互信息而发现网络中的环路，并对某些接口进行阻塞以消除环路。由于局域网规模的不断增长，生成树协议已经成为重要的局域网协议之一。</p>
<p>•RSTP是生成树协议中的其中一个版本，它在STP的基础上，做了很多的改进，大大加快了网络收敛的速度。</p>
<p>•本章节，主要介绍了RSTP对STP的七个改进点，包括：端口角色、端口状态、配置BPDU格式、配置BPDU的处理方式、快速收敛机制、拓扑变更机制和4种保护特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/" itemprop="url">VLAN高级技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-06T12:20:26+08:00">
                2021-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="VLAN聚合"><a href="#VLAN聚合" class="headerlink" title="VLAN聚合"></a><strong>VLAN聚合</strong></h1><h2 id="VLAN聚合产生的技术背景"><a href="#VLAN聚合产生的技术背景" class="headerlink" title="VLAN聚合产生的技术背景"></a><strong>VLAN聚合产生的技术背景</strong></h2><p>•在一般的三层交换机中，通常是采用一个VLAN对应一个VLANIF接口的方式实现广播域之间的互通，这在某些情况下导致了IP地址的浪费。</p>
<p>•因为一个VLAN对应的子网中，子网号、子网广播地址、子网网关地址不能用作VLAN内的主机IP地址，且子网中实际接入的主机可能少于可用IP地址数量，空闲的IP地址也会因不能再被其他VLAN使用而被浪费掉。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/1.png"></p>
<h2 id="VLAN聚合概述"><a href="#VLAN聚合概述" class="headerlink" title="VLAN聚合概述"></a><strong>VLAN聚合概述</strong></h2><p>•<strong>VLAN聚合</strong>（VLAN Aggregation，也称Super-VLAN）: 指在一个物理网络内，用多个VLAN（称为Sub-VLAN）隔离广播域，并将这些Sub-VLAN聚合成一个逻辑的VLAN（称为Super-VLAN），这些Sub-VLAN使用同一个IP子网和缺省网关，进而达到节约IP地址资源的目的。</p>
<p>•<strong>Sub-VLAN</strong>：只包含物理接口，不能建立三层VLANIF接口，用于隔离广播域。每个Sub-VLAN内的主机与外部的三层通信是靠Super-VLAN的三层VLANIF接口来实现的。</p>
<p>•<strong>Super-VLAN</strong>：只建立三层VLANIF接口，不包含物理接口，与子网网关对应。与普通VLAN不同，Super-VLAN的VLANIF接口状态取决于所包含Sub-VLAN的物理接口状态。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/2.png"></p>
<h2 id="VLAN聚合的原理"><a href="#VLAN聚合的原理" class="headerlink" title="VLAN聚合的原理"></a><strong>VLAN聚合的原理</strong></h2><p>每个Sub-VLAN对应一个广播域，多个Sub-VLAN和一个Super-VLAN关联，只给Super-VLAN分配一个IP子网，所有Sub-VLAN都使用Super-VLAN的IP子网和缺省网关进行三层通信。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/3.png"></p>
<blockquote>
<p>•多个Sub-VLAN共享一个网关地址，节约了子网网络地址、子网定向广播地址、子网缺省网关地址，且各Sub-VLAN间的界线也不再是从前的子网界线了，可以根据每个Sub-VLAN内所需的IP地址数量进行灵活的地址规划，从而既保证了各个Sub-VLAN作为一个独立广播域实现广播隔离，又节省了IP地址资源，提高了编址的灵活性。</p>
</blockquote>
<h2 id="VLAN聚合的应用"><a href="#VLAN聚合的应用" class="headerlink" title="VLAN聚合的应用"></a><strong>VLAN聚合的应用</strong></h2><p>传统VLAN方式每一个VLAN需要划分不同的IP地址网段，在本例中需要耗费4个IP网段和产生4条路由条目；Super-VLAN方式只需要分配一个IP地址网段，下属二层VLAN共用同一个IP地址网段，共用同一个三层网关，同时VLAN之间保持二层隔离。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/4.png"></p>
<h2 id="相同Sub-VLAN内部通信"><a href="#相同Sub-VLAN内部通信" class="headerlink" title="相同Sub-VLAN内部通信"></a><strong>相同Sub-VLAN内部通信</strong></h2><p>同一个Sub-VLAN之间属于同一个广播域，因此相同Sub-VLAN之间可以通过二层直接通信。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/5.png"></p>
<h2 id="不同Sub-VLAN之间通信举例"><a href="#不同Sub-VLAN之间通信举例" class="headerlink" title="不同Sub-VLAN之间通信举例"></a><strong>不同Sub-VLAN之间通信举例</strong></h2><p>Super-VLAN VLANIF100开启ARP代理之后PC1和PC2之间通信过程如下：</p>
<p>1.PC1发现PC2与自己在同一网段，且自己ARP表无PC2对应表项，则直接发送ARP广播请求PC2的MAC地址。</p>
<p>2.作为网关的Super-VLAN对应的VLANIF 100收到PC1的ARP请求，由于网关上使能Sub-VLAN间的ARP代理功能，则向Super-VLAN 100的所有Sub-VLAN接口发送一个ARP广播，请求PC2的MAC地址。</p>
<p>3.PC2收到网关发送的ARP广播后，对此请求进行ARP应答。</p>
<p>4.网关收到PC2的应答后，就把自己的MAC地址回应给PC1，PC1之后要发给PC2的报文都先发送给网关，由网关做三层转发。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/6.png"></p>
<blockquote>
<p>•不同Sub-VLAN之间进行通信，IP地址属于相同网段，因此主机会发送ARP请求，但是实际不同Sub-VLAN之间属于不同的广播域，因而ARP报文无法传递到其他Sub-VLAN，ARP请求得不到响应，设备无法学习到对端MAC地址，从而无法完成Sub-VLAN之间通信。</p>
<p>•要实现Sub-VLAN之间的通信，需要在Super-VLAN 的VLANIF中开启ARP代理功能。</p>
</blockquote>
<h2 id="Sub-VLAN与其他设备的二层通信"><a href="#Sub-VLAN与其他设备的二层通信" class="headerlink" title="Sub-VLAN与其他设备的二层通信"></a><strong>Sub-VLAN与其他设备的二层通信</strong></h2><p>•当Sub-VLAN与其他设备进行二层通信时，与普通的VLAN内二层通信无区别。</p>
<p>•由于Super-VLAN不属于任何物理接口，即不会处理任何携带Super-VLAN标签的报文。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/7.png"></p>
<blockquote>
<p>•Sub-VLAN二层通信过程举例：</p>
<p>▫从PC1进入SW1的报文会被打上VLAN10的Tag。在SW1中这个Tag不会因为VLAN10是VLAN100的Sub-VLAN而变为VLAN100的Tag。</p>
<p>▫当报文从SW1的GE0/0/0出去时，依然携带VLAN10的Tag。也就是说，SW1本身不会发出VLAN100的报文。就算其他设备有VLAN100的报文发送到该设备上，这些报文也会因为SW1上没有VLAN100应的物理接口而被丢弃。</p>
<p>▫对于其他设备而言，有效的VLAN只有Sub-VLAN10，20和30， 所有的报文都是在这些VLAN中交互的。因此，SW1上虽然配置了VLAN聚合，但与其他设备的二层通信，不会涉及到Super-VLAN，与正常的二层通信流程一样。</p>
<p>•当Sub-VLAN内的PC需要与其他网络进行三层通信时，首先将数据发往默认网关，即Super-VLAN对应的VLANIF，再进行路由。</p>
</blockquote>
<h2 id="VLAN聚合关键配置命令"><a href="#VLAN聚合关键配置命令" class="headerlink" title="VLAN聚合关键配置命令"></a><strong>VLAN聚合关键配置命令</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/8.png"></p>
<h2 id="VLAN聚合配置举例-1"><a href="#VLAN聚合配置举例-1" class="headerlink" title="VLAN聚合配置举例 (1)"></a><strong>VLAN聚合配置举例</strong> <strong>(1)</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/9.png"></p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/10.png"></p>
<h2 id="VLAN聚合配置举例-2"><a href="#VLAN聚合配置举例-2" class="headerlink" title="VLAN聚合配置举例(2)"></a><strong>VLAN聚合配置举例(2)</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/11.png"></p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/12.png"></p>
<h1 id="MUX-VLAN"><a href="#MUX-VLAN" class="headerlink" title="MUX VLAN"></a><strong>MUX VLAN</strong></h1><h2 id="MUX-VLAN产生背景"><a href="#MUX-VLAN产生背景" class="headerlink" title="MUX VLAN产生背景"></a><strong>MUX VLAN产生背景</strong></h2><p>在企业网络中，各个部门之间网络需要相互独立，通常用VLAN技术可以实现这一要求。如果企业规模很大，且拥有大量的合作伙伴，要求各个合作伙伴能够访问公司服务器，但是不能相互访问，这时如果使用传统的VLAN技术，不但需要耗费大量的VLAN ID，还增加了网络管理者的工作量同时也增加了维护量。</p>
<p>MUX VLAN（Multiplex VLAN）提供了一种通过VLAN进行网络资源控制的机制。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/13.png"></p>
<h2 id="MUX-VLAN的基本概念"><a href="#MUX-VLAN的基本概念" class="headerlink" title="MUX VLAN的基本概念"></a><strong>MUX VLAN的基本概念</strong></h2><p>MUX VLAN分为Principal VLAN（主VLAN）和Subordinate VLAN（从VLAN），Subordinate VLAN又分为Separate VLAN（隔离型从VLAN）和Group VLAN（互通型从VLAN）。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/14.png"></p>
<blockquote>
<p>•在使用MUX VLAN的过程中，无论是Separate VLAN还是Group VLAN都必须与一个Principle VLAN绑定。</p>
<p>•加入Principal VLAN（主VLAN）中的接口，可以与MUX VLAN内的所有接口进行通信。</p>
</blockquote>
<h2 id="MUX-VLAN的应用"><a href="#MUX-VLAN的应用" class="headerlink" title="MUX VLAN的应用"></a><strong>MUX VLAN的应用</strong></h2><p>在交换机上，通过把部门A和部门B所在的VLAN分别设置为互通型从VLAN，把访客区所属的VLAN设置为隔离型从VLAN，把服务器所连接口所属VLAN设置为Principal VLAN，即主VLAN。并且所有从VLAN都与主VLAN绑定。从而实现如下网络设计要求：</p>
<p>▫部门A内的用户之间能够实现二层互通。</p>
<p>▫部门B内的用户之间能够实现二层互通。</p>
<p>▫部门A与部门B的用户之间二层隔离。</p>
<p>▫部门A和部门B的员工都能够通过二层访问服务器。</p>
<p>▫访客区内的任意PC除了能访问服务器之外，不能访问其他任意设备，包括其他访客。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/15.png"></p>
<h2 id="MUX-VLAN配置命令"><a href="#MUX-VLAN配置命令" class="headerlink" title="MUX VLAN配置命令"></a><strong>MUX VLAN配置命令</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/16.png"></p>
<blockquote>
<p>•只有使能接口MUX VLAN功能后，才能实现Principal VLAN与Subordinate VLAN之间通信、Group VLAN内的接口可以相互通信及Separate VLAN接口间不能相互通信的目的。</p>
</blockquote>
<h2 id="MUX-VLAN配置举例"><a href="#MUX-VLAN配置举例" class="headerlink" title="MUX VLAN配置举例"></a><strong>MUX VLAN配置举例</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/17.png"></p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/18.png"></p>
<h2 id="MUX-VLAN配置验证"><a href="#MUX-VLAN配置验证" class="headerlink" title="MUX VLAN配置验证"></a><strong>MUX VLAN配置验证</strong></h2><p>查看VLAN配置结果，通过ping命令检测PC5（192.168.1.5/24）与PC6（192.168.1.6/24）之间的网络连通性。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/19.png"></p>
<h1 id="QinQ"><a href="#QinQ" class="headerlink" title="QinQ"></a><strong>QinQ</strong></h1><h2 id="QinQ概述"><a href="#QinQ概述" class="headerlink" title="QinQ概述"></a><strong>QinQ概述</strong></h2><p>•随着以太网技术在网络中的大量部署，利用VLAN对用户进行隔离和标识受到很大限制。因为IEEE802.1Q中定义的VLAN Tag域只有12个比特，仅能表示4096个VLAN，无法满足城域以太网中标识大量用户的需求，于是QinQ技术应运而生。</p>
<p>•QinQ（802.1Q in 802.1Q）技术是一项扩展VLAN空间的技术，通过在802.1Q标签报文的基础上再增加一层802.1Q的Tag来达到扩展VLAN空间的功能。</p>
<p>•如下图所示用户报文在公网上传递时携带了两层Tag，内层是私网Tag，外层是公网Tag。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/20.png"></p>
<h2 id="QinQ封装结构"><a href="#QinQ封装结构" class="headerlink" title="QinQ封装结构"></a><strong>QinQ封装结构</strong></h2><p>QinQ封装报文是在无标签的以太网数据帧的源MAC地址字段后面加上两个VLAN标签构成。</p>
<p>•TPID（Tag Protocol Identifier，标签协议标识）表示帧类型。取值为0x8100时表示802.1Q Tag帧。如果不支持802.1Q的设备收到这样的帧，会将其丢弃。</p>
<p>•对于内层的802.1Q Tag，该值设置为0x8100；对于外层的802.1Q Tag，不同厂商所使用的值可能不相同：</p>
<p>​    ▫0x8100：Huawei路由器使用</p>
<p>​    ▫0x88A8：802.1ad规定外层802.1Q Tag中的TPID为0x88a8</p>
<p>•在华为设备上，外层802.1Q Tag缺省情况下值为0x8100，可以通过命令行调整该值。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/21.png"></p>
<h2 id="QinQ工作原理"><a href="#QinQ工作原理" class="headerlink" title="QinQ工作原理"></a><strong>QinQ工作原理</strong></h2><p>在公网的传输过程中，设备只根据外层VLAN Tag转发报文，并根据报文的外层VLAN Tag进行MAC地址学习，而用户的私网VLAN Tag将被当作报文的数据部分进行传输。即使私网VLAN Tag相同，也能通过公网VLAN Tag区分不同用户。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/22.png"></p>
<blockquote>
<p>•企业A和企业B的私网VLAN分别为VLAN 1～10和VLAN 1～20。公网为企业A和企业B分配的公网VLAN分别为VLAN 3和VLAN 4。当企业A和企业B中带VLAN Tag的报文进入公网时，报文外面就会被分别封装上VLAN 3和VLAN 4的VLAN标签。这样，来自不同企业网络的报文在公网中传输时被完全分开，即使这些企业网络各自的VLAN范围存在重叠，在公网中传输时也不会产生冲突。当报文穿过公网，到达公网另一侧PE设备后，报文会被剥离公网为其添加的公网VLAN标签，然后再传送给用户网络的CE设备。</p>
</blockquote>
<h2 id="QinQ实现方式-基本QinQ"><a href="#QinQ实现方式-基本QinQ" class="headerlink" title="QinQ实现方式 - 基本QinQ"></a>QinQ实现方式 - 基本QinQ</h2><p>基本QinQ的报文处理过程:</p>
<p>1.SW1收到VLAN ID为10和20的报文，将该报文发给SW2。</p>
<p>2.SW2收到该报文后，在该报文原有Tag的外侧再添加一层VLAN ID 为100的外层Tag。</p>
<p>3.带着两层Tag的用户数据报文在网络中按照正常的二层转发流程转发。</p>
<p>4.SW3收到VLAN100的报文后，剥离报文的外层Tag（VLAN ID 为100）。将报文发送给SW4，此时报文只有一层Tag（VLAN ID 为10或20）。</p>
<p>5.SW4收到该报文，根据VLAN ID和目的MAC地址进行相应的转发。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/23.png"></p>
<blockquote>
<p>•基本QinQ是基于端口方式实现的。开启端口的基本QinQ功能后，当该端口接收到报文，设备会为该报文打上本端口缺省VLAN 的VLAN Tag。如果接收到的是已经带有VLAN Tag的报文，该报文就成为双Tag的报文；如果接收到的是不带VLAN Tag的报文，该报文就成为带有端口缺省VLAN Tag的报文。</p>
<p>•基于端口的QinQ的缺点是外层VLAN Tag封装方式固定，不能根据业务种类选择外层VLAN Tag封装的方式，从而很难有效支持多业务的灵活运营。</p>
</blockquote>
<h2 id="QinQ实现方式-灵活QinQ"><a href="#QinQ实现方式-灵活QinQ" class="headerlink" title="QinQ实现方式 - 灵活QinQ"></a>QinQ实现方式 - 灵活QinQ</h2><p>灵活QinQ的报文处理过程：</p>
<p>1.SW1收到VLAN ID为10和20的报文，将该报文转发给SW2。</p>
<p>2.SW2收到VLAN ID为10的报文后，添加一层VLAN ID 为100 的外层Tag；SW2收到VLAN ID为20的报文后，添加一层VLAN ID为200的外层Tag。</p>
<p>3.带着两层Tag的用户数据报文在网络中按照正常的二层转发流程转发。</p>
<p>4.SW3收到报文后，剥离报文的外层Tag（VLAN ID 为100或200）。将报文发送给SW4，此时报文只有一层Tag（VLAN ID 为10或20）。</p>
<p>5.SW4收到报文，根据VLAN ID和目的MAC地址进行相应的转发。</p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/24.png"></p>
<blockquote>
<p>•灵活QinQ（Selective QinQ）可根据流分类的结果选择是否打外层VLAN Tag，打上何种外层VLAN Tag。灵活QinQ可根据用户的VLAN标签、优先级、MAC地址、IP协议、IP源地址、IP目的地址、或应用程序的端口号进行流分类。</p>
<p>•基于VLAN ID的灵活QinQ：为具有不同内层VLAN ID的报文添加不同的外层VLAN Tag。</p>
<p>•基于802.1p优先级的灵活QinQ：根据报文的原有内层VLAN的802.1p优先级添加不同的外层VLAN Tag。</p>
<p>•基于流策略的灵活QinQ：根据QoS策略添加不同的外层VLAN Tag。基于流策略的灵活QinQ能够针对业务类型提供差别服务。</p>
<p>•灵活QinQ功能是对基本QinQ功能的扩展，它比基本QinQ的功能更灵活。二者之间的主要区别是：</p>
<p>​    ▫基本QinQ：对进入二层QinQ接口的所有帧都加上相同的外    层Tag。</p>
<p>​    ▫灵活QinQ：对进入二层QinQ接口的帧，可以根据不同的内    层Tag而加上不同的外层Tag，对于用户VLAN的划分更加细    致</p>
</blockquote>
<h2 id="QinQ在园区网络中的应用"><a href="#QinQ在园区网络中的应用" class="headerlink" title="QinQ在园区网络中的应用"></a><strong>QinQ在园区网络中的应用</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/25.png"></p>
<blockquote>
<p>•BRAS：Broadband Remote Access Server，宽带远程接入服务器。BRAS提供宽带接入服务、实现多种业务的汇聚与转发，能满足不同用户对传输容量和带宽利用率的要求，因此RRAS是宽带用户接入的核心设备。</p>
<p>•BUM：Broadcast、Unknown unicast、Multicast，广播，未知单播、组播。交换机以泛洪的方式处理以上类型的数据帧。</p>
</blockquote>
<h2 id="QinQ配置命令介绍"><a href="#QinQ配置命令介绍" class="headerlink" title="QinQ配置命令介绍"></a><strong>QinQ配置命令介绍</strong></h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/26.png"></p>
<blockquote>
<p>•配置灵活QinQ的当前接口类型建议为Hybrid，并且必须先通过命令qinq vlan-translation enable先使能VLAN转换功能。灵活QinQ功能只在当前接口的入方向生效。</p>
<p>•接口配置VLAN Stacking功能后在发送帧时，若需要剥掉外层Tag，该接口要以Untagged方式加入叠加后的stack-vlan；若不需要剥掉外层Tag，该接口要以Tagged方式加入叠加后的stack-vlan。</p>
</blockquote>
<h2 id="QinQ配置举例-基本QinQ"><a href="#QinQ配置举例-基本QinQ" class="headerlink" title="QinQ配置举例 - 基本QinQ"></a>QinQ配置举例 - 基本QinQ</h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/27.png"></p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/28.png"></p>
<h2 id="QinQ配置举例-灵活QinQ"><a href="#QinQ配置举例-灵活QinQ" class="headerlink" title="QinQ配置举例 - 灵活QinQ"></a>QinQ配置举例 - 灵活QinQ</h2><p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/29.png"></p>
<p><img src="/2021/05/06/VLAN%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/30.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选题）当Sub-VLAN与外部进行二层通信时，在出接口打上的VLAN标记为？</p>
<p><strong>A.Sub-VLAN</strong></p>
<p>B.Secondary VLAN</p>
<p>C.Super-VLAN</p>
<p>D.Isolate VLAN</p>
<p>2.（单选题）下面关于QinQ描述错误的是？</p>
<p>A.QinQ报文在公网中报文根据外层VLAN Tag转发。</p>
<p><strong>B.QinQ报文在公网中报文根据内层VLAN Tag转发。</strong></p>
<p>C.QinQ为用户提供了一种更为简单的二层VPN隧道。</p>
<p>D.QinQ不需要信令协议的支持，可以通过纯静态配置实现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•VLAN聚合通过配置Super-VLAN和Sub-VLAN，不同Sub-VLAN之间进行通信，需要Super-VLAN开启ARP代理。VLAN聚合既避免了由于子网划分带来的网络地址规划复杂的问题，又能够实现通过VLAN隔离不同广播域的目的。</p>
<p>•MUX VLAN包括Principal VLAN和Subordinate VLAN，同时Subordinate VLAN又分为Separate VLAN和Group VLAN。Separate port只能和Principal port进行通信，和其他类型的接口实现完全隔离。Group port可以和Principal port进行通信，在同一组内的接口也可互相通信，但不能和其他组接口或Separate port通信。</p>
<p>•QinQ技术不仅扩展了标识VLAN的数量，而且可以实现用户报文携带私网VLAN标签在公网内的透传。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/" itemprop="url">以太网交换安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-05T20:01:37+08:00">
                2021-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="端口隔离"><a href="#端口隔离" class="headerlink" title="端口隔离"></a><strong>端口隔离</strong></h1><h2 id="端口隔离技术背景"><a href="#端口隔离技术背景" class="headerlink" title="端口隔离技术背景"></a><strong>端口隔离技术背景</strong></h2><p>•以太交换网络中为了实现报文之间的二层隔离，用户通常将不同的端口加入不同的VLAN，实现二层广播域的隔离。</p>
<p>•大型网络中，业务需求种类繁多，只通过VLAN实现报文二层隔离，会浪费有限的VLAN资源。</p>
<p>•如下图所示，由于某种业务需求，PC1与PC2虽然属于同一个VLAN ，但是要求它们在二层不能互通（但允许三层互通），PC1与PC3在任何情况下都不能互通，但是VLAN 3里的主机可以访问VLAN 2里的主机。 那么该如何解决这个问题呢？</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/1.png"></p>
<h2 id="端口隔离技术概述"><a href="#端口隔离技术概述" class="headerlink" title="端口隔离技术概述"></a><strong>端口隔离技术概述</strong></h2><p>采用端口隔离功能，可以实现同一VLAN内端口之间的隔离。用户只需要将端口加入到隔离组中，就可以实现隔离组内端口之间二层数据的隔离。端口隔离功能为用户提供了更安全、更灵活的组网方案。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/2.png"></p>
<h2 id="端口隔离技术原理"><a href="#端口隔离技术原理" class="headerlink" title="端口隔离技术原理"></a><strong>端口隔离技术原理</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/3.png"></p>
<blockquote>
<p>•采用二层隔离三层互通的隔离模式时，在VLANIF接口上使能VLAN内Proxy ARP功能，配置arp-proxy inner-sub-vlan-proxy enable，可以实现同一VLAN内主机通信。</p>
</blockquote>
<h2 id="端口隔离配置命令"><a href="#端口隔离配置命令" class="headerlink" title="端口隔离配置命令"></a><strong>端口隔离配置命令</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/4.png"></p>
<h2 id="端口隔离配置举例"><a href="#端口隔离配置举例" class="headerlink" title="端口隔离配置举例"></a><strong>端口隔离配置举例</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/5.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/6.png"></p>
<blockquote>
<p>•display port-isolate group { group-id | all }，查看端口隔离组的配置。</p>
<p>•clear configuration port-isolate命令一键式清除设备上所有的端口隔离配置。</p>
<p>•port-isolate exclude vlan命令配置端口隔离功能生效时排除的VLAN。</p>
</blockquote>
<h2 id="端口隔离配置验证"><a href="#端口隔离配置验证" class="headerlink" title="端口隔离配置验证"></a><strong>端口隔离配置验证</strong></h2><p>1.通过display port-isolate group <em>group-number</em>查看端口隔离组中的端口。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/7.png"></p>
<p>2.验证同一端口隔离组下主机网络不能互通。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/8.png"></p>
<h1 id="MAC地址表安全"><a href="#MAC地址表安全" class="headerlink" title="MAC地址表安全"></a>MAC地址表安全</h1><h2 id="MAC地址表项类型"><a href="#MAC地址表项类型" class="headerlink" title="MAC地址表项类型"></a>MAC地址表项类型</h2><p><strong>MAC地址表项类型包括:</strong></p>
<ul>
<li><strong>动态MAC地址表项</strong>:由接口通过报文中的源MAC地址学习获得，表项可老化。在系统复位、接口板热插拔或接口板复位后，动态表项会丢失。</li>
<li><strong>静态MAC地址表项</strong>:由用户手工配置并下发到各接口板，表项不老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。接口和MAC地址静态绑定后，其他接口收到源MAC是该MAC地址的报文将会被丢弃。</li>
<li><strong>黑洞MAC地址表项</strong>:由用户手工配置，并下发到各接口板，表项不可老化。配置黑洞MAC地址后，源MAC地址或目的MAC地址是该MAC的报文将会被丢弃。</li>
</ul>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/12.png"></p>
<blockquote>
<p>•MAC地址表记录了交换机学习到的MAC地址与接口的对应关系，以及接口所属VLAN等信息。</p>
<p>•设备在执行二层交换操作时，根据报文的目的MAC地址查询MAC地址表，如果MAC地址表中包含与报文目的MAC地址对应的表项，并且收到该报文的接口与对应的表项的接口不相同时，则直接通过该表项中的出接口转发该报文；如果相同，则丢弃该报文。</p>
<p>•如果MAC地址表中没有包含报文目的MAC地址对应的表项时，设备将采取广播方式在所属VLAN内除接收接口外的所有接口转发该报文。</p>
</blockquote>
<h2 id="MAC地址表安全功能"><a href="#MAC地址表安全功能" class="headerlink" title="MAC地址表安全功能"></a><strong>MAC地址表安全功能</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/13.png"></p>
<p>•为了防止一些关键设备（如各种服务器或上行设备）被非法用户恶意修改其MAC地址表项，可将这些设备的MAC地址配置为静态MAC地址表项，因为静态MAC地址表项优先于动态MAC地址表项，不易被非法修改。</p>
<p>•为了防止无用MAC地址表项占用MAC地址表，同时为了防止黑客通过MAC地址攻击用户设备或网络，可将那些有着恶意历史的非信任MAC地址配置为黑洞MAC地址，使设备在收到目的MAC或源MAC地址为这些黑洞MAC地址的报文时，直接予以丢弃，不修改原有的MAC地址表项，也不增加新的MAC地址表项。</p>
<p>•为了减轻手工配置静态MAC地址表项，华为S系列交换机缺省已使能了动态MAC地址表项学习功能。但为了避免MAC地址表项爆炸式增长，可合理配置动态MAC表项的老化时间，以便及时删除MAC地址表中的废弃MAC地址表项。</p>
<p>•为了提高网络的安全性，防止设备学习到非法的MAC地址，错误地修改MAC地址表中的原MAC地址表项，可以选择关闭设备上指定接口或指定VLAN中所有接口的MAC地址学习功能，这样设备将不再从这些接口上学习新的MAC地址。</p>
<p>•配置限制MAC地址学习数，当超过限制数时不再学习MAC地址，同时可以配置当MAC地址数达到限制后对报文采取的动作，从而防止MAC地址表资源耗尽，提高网络安全性。</p>
<h2 id="MAC地址表项配置"><a href="#MAC地址表项配置" class="headerlink" title="MAC地址表项配置"></a><strong>MAC地址表项配置</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/14.png"></p>
<h2 id="禁止MAC地址学习功能"><a href="#禁止MAC地址学习功能" class="headerlink" title="禁止MAC地址学习功能"></a><strong>禁止MAC地址学习功能</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/15.png"></p>
<h2 id="限制MAC地址学习数量"><a href="#限制MAC地址学习数量" class="headerlink" title="限制MAC地址学习数量"></a><strong>限制MAC地址学习数量</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/16.png"></p>
<h2 id="MAC地址表安全配置举例"><a href="#MAC地址表安全配置举例" class="headerlink" title="MAC地址表安全配置举例"></a>MAC地址表安全配置举例</h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/17.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/18.png"></p>
<h2 id="配置验证"><a href="#配置验证" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>执行display mac-limit命令，查看MAC地址学习限制规则是否配置成功。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/19.png"></p>
<h1 id="端口安全"><a href="#端口安全" class="headerlink" title="端口安全"></a><strong>端口安全</strong></h1><h2 id="端口安全技术背景"><a href="#端口安全技术背景" class="headerlink" title="端口安全技术背景"></a><strong>端口安全技术背景</strong></h2><p>•企业要求接入层交换机上每个连接终端设备的接口均只允许一台PC接入网络（限制MAC地址接入数量）。如果有员工试图在某个接口下级联一台小交换机或集线器从而扩展上网接口，那么这种行为应该被发现或被禁止，如左图所示。</p>
<p>•另一些企业还可能会要求只有MAC地址为可信任的终端发送的数据帧才允许被交换机转发到上层网络，员工不能私自更换位置（变更交换机的接入端口），如右图所示。</p>
<p>•通过交换机的端口安全（port security）特性可以解决这些问题。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/20.png"></p>
<h2 id="端口安全概述"><a href="#端口安全概述" class="headerlink" title="端口安全概述"></a><strong>端口安全概述</strong></h2><p>•通过在交换机的特定接口上部署端口安全，可以限制接口的MAC地址学习数量，并且配置出现越限时的惩罚措施。</p>
<p>•端口安全通过将接口学习到的动态MAC地址转换为安全MAC地址（包括安全动态MAC，安全静态MAC和Sticky MAC），阻止非法用户通过本接口和交换机通信，从而增强设备的安全性。</p>
<h2 id="端口安全技术原理"><a href="#端口安全技术原理" class="headerlink" title="端口安全技术原理"></a><strong>端口安全技术原理</strong></h2><p>安全MAC地址分为以下类型：</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/21.png"></p>
<p>安全MAC地址通常与安全保护动作结合使用，常见的安全保护动作有：</p>
<ul>
<li><p>Restrict：丢弃源MAC地址不存在的报文并上报告警。</p>
</li>
<li><p>Protect：只丢弃源MAC地址不存在的报文，不上报告警。</p>
</li>
<li><p>Shutdown：接口状态被置为error-down，并上报告警。</p>
</li>
</ul>
<blockquote>
<p>•安全动态MAC地址的老化类型分为：绝对时间老化和相对时间老化。</p>
<ul>
<li><p>如设置绝对老化时间为5分钟：系统每隔1分钟计算一次每个MAC的存在时间，若大于等于5分钟，则立即将该安全动态MAC地址老化。否则，等待下1分钟再检测计算。</p>
</li>
<li><p>如设置相对老化时间为5分钟：系统每隔1分钟检测一次是否有该MAC的流量。若没有流量，则经过5分钟后将该安全动态MAC地址老化。</p>
</li>
</ul>
<p>•默认情况下，接口关闭（error-down）后不会自动恢复，只能由网络管理人员在接口视图下使用restart命令重启接口进行恢复。</p>
<p>•如果用户希望被关闭的接口可以自动恢复，则可在接口error-down前通过在系统视图下执行error-down auto-recovery cause port-security interval interval-value命令使能接口状态自动恢复为Up的功能，并设置接口自动恢复为Up的延时时间，使被关闭的接口经过延时时间后能够自动恢复。</p>
<p>•当端口安全功能或者Sticky MAC功能使能/去使能时，接口上的MAC地址变化如下：</p>
<ul>
<li><p>端口安全功能</p>
<ul>
<li><p>使能之后，接口上之前学习到的动态MAC地址表项将被删除，之后学习到的MAC地址将变为安全动态MAC地址。</p>
</li>
<li><p>去使能之后，接口上的安全动态MAC地址将被删除，重新学习动态MAC地址。</p>
</li>
</ul>
</li>
<li><p>Sticky MAC功能</p>
<ul>
<li><p>使能之后，接口上的安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>去使能之后，接口上的Sticky MAC地址，会转换为安全动态MAC地址。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="端口安全配置命令"><a href="#端口安全配置命令" class="headerlink" title="端口安全配置命令"></a><strong>端口安全配置命令</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/22.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/23.png"></p>
<blockquote>
<p>port-security protect-action命令用来配置端口安全功能中接口学习到的MAC地址数超过限制或出现静态MAC地址漂移时<br>的保护动作。</p>
<ul>
<li><p>protect</p>
<ul>
<li><p>当学习到的MAC地址数超过接口限制数时，接口将丢弃源地址在MAC表以外的报文。</p>
</li>
<li><p>当出现静态MAC地址漂移时，接口将丢弃带有该MAC地址的报文。</p>
</li>
</ul>
</li>
<li><p>restrict</p>
<ul>
<li><p>当学习到的MAC地址数超过接口限制数时，接口将丢弃源地址在MAC表以外的报文，同时发出告警。</p>
</li>
<li><p>当出现静态MAC地址漂移时，接口将丢弃带有该MAC地址的报文，同时发出告警。</p>
</li>
</ul>
</li>
<li><p>shutdown</p>
<ul>
<li><p>当学习到的MAC地址数超过接口限制数时，接口将执行error down操作，同时发出告警。</p>
</li>
<li><p>当出现静态MAC地址漂移时，接口将执行error down操作，同时发出告警。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="端口安全配置举例-安全动态MAC"><a href="#端口安全配置举例-安全动态MAC" class="headerlink" title="端口安全配置举例 - 安全动态MAC"></a><strong>端口安全配置举例</strong> <strong>-</strong> <strong>安全动态MAC</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/24.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/25.png"></p>
<h2 id="配置验证-1"><a href="#配置验证-1" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>执行命令display mac-address security ，查看动态安全MAC表项。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/26.png"></p>
<blockquote>
<p>查看安全MAC地址：</p>
<ul>
<li><p>执行命令display mac-address security [ vlan vlan-id | interface-type interface-number ] * [ verbose ]，查看安全动态MAC表项。</p>
</li>
<li><p>执行命令display mac-address sec-config [ vlan vlan-id | interface-type interface-number ] * [ verbose ]，查看配置的安全静态MAC表项。</p>
</li>
<li><p>执行命令display mac-address sticky [ vlan vlan-id | interface-type interface-number ] * [ verbose ]，查看Sticky MAC表项。</p>
</li>
</ul>
</blockquote>
<h2 id="端口安全配置举例-Sticky-MAC"><a href="#端口安全配置举例-Sticky-MAC" class="headerlink" title="端口安全配置举例 - Sticky MAC"></a><strong>端口安全配置举例</strong> <strong>-</strong> <strong>Sticky MAC</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/27.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/28.png"></p>
<h2 id="配置验证-2"><a href="#配置验证-2" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>执行命令display mac-address sticky，查看Sticky MAC表项。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/29.png"></p>
<h1 id="MAC地址漂移防止与检测"><a href="#MAC地址漂移防止与检测" class="headerlink" title="MAC地址漂移防止与检测"></a><strong>MAC地址漂移防止与检测</strong></h1><h2 id="MAC地址漂移概述"><a href="#MAC地址漂移概述" class="headerlink" title="MAC地址漂移概述"></a><strong>MAC地址漂移概述</strong></h2><p>•MAC地址漂移是指交换机上一个VLAN内有两个端口学习到同一个MAC地址，后学习到的MAC地址表项覆盖原MAC地址表项的现象。</p>
<p>•当一个MAC地址在两个端口之间频繁发生迁移时，即会产生MAC地址漂移现象。</p>
<p>•正常情况下，网络中不会在短时间内出现大量MAC地址漂移的情况。出现这种现象一般都意味着网络中存在环路，或者存在网络攻击行为。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/30.png"></p>
<h2 id="防止MAC地址漂移"><a href="#防止MAC地址漂移" class="headerlink" title="防止MAC地址漂移"></a><strong>防止</strong>MAC地址漂移</h2><p>如果是环路引发MAC地址漂移，治本的方法是部署防环技术，例如STP，消除二层环路。如果由于网络攻击等其他原因引起，则可使用如下MAC地址防漂移特性：</p>
<h3 id="配置接口MAC地址学习优先级"><a href="#配置接口MAC地址学习优先级" class="headerlink" title="配置接口MAC地址学习优先级"></a><strong>配置接口MAC地址学习优先级</strong></h3><p>当MAC地址在交换机的两个接口之间发生漂移时，可以将其中一个接口的MAC地址学习优先级提高。高优先级的接口学习到的MAC地址表项将覆盖低优先级接口学习到的MAC地址表项。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/31.png"></p>
<h3 id="配置不允许相同优先级接口MAC地址漂移"><a href="#配置不允许相同优先级接口MAC地址漂移" class="headerlink" title="配置不允许相同优先级接口MAC地址漂移"></a><strong>配置不允许相同优先级接口MAC地址漂移</strong></h3><p>当伪造网络设备所连接口的MAC地址优先级与安全的网络设备相同时，后学习到的伪造网络设备MAC地址表项不会覆盖之前正确的表项。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/32.png"></p>
<blockquote>
<p>•缺省时接口MAC地址学习的优先级均为0，数值越大优先级越高。当同一个MAC地址被两个个接口学习到后，接口MAC地址学习优先级高的会被保留，MAC地址学习优先级低的被覆盖。</p>
<p>•在配置不允许相同优先级接口MAC地址漂移时，如果安全网络设备下电，则交换机仍会学习到伪造网络设备的MAC地址，当网络设备再次上电时将无法学习到正确的MAC地址。因此该特性需谨慎使用，如果交换机的接口连接的网络设备是服务器，当服务器下电后，另外的接口学习到与服务器相同的MAC地址，当服务器再次上电后就不能学习到正确的MAC地址。</p>
</blockquote>
<h2 id="MAC地址漂移检测"><a href="#MAC地址漂移检测" class="headerlink" title="MAC地址漂移检测"></a><strong>MAC地址漂移检测</strong></h2><p>交换机支持MAC地址漂移检测机制，分为以下两种方式：</p>
<p>基于VLAN的MAC地址漂移检测</p>
<ul>
<li><p>配置VLAN的MAC地址漂移检测功能可以检测指定VLAN下的所有的MAC地址是否发生漂移。</p>
</li>
<li><p>当MAC地址发生漂移后，可以配置指定的动作，例如告警、阻断接口或阻断MAC地址。</p>
</li>
</ul>
<p>全局MAC地址漂移检测</p>
<ul>
<li><p>该功能可以检测设备上的所有的MAC地址是否发生了漂移。</p>
</li>
<li><p>若发生漂移，设备会上报告警到网管系统。</p>
</li>
<li><p>用户也可以指定发生漂移后的处理动作，例如将接口关闭或退出VLAN。</p>
</li>
</ul>
<blockquote>
<p>华为交换机是否全部支持MAC地址漂移检测机制以具体型号产品为准。</p>
</blockquote>
<h3 id="基于VLAN的MAC地址漂移检测"><a href="#基于VLAN的MAC地址漂移检测" class="headerlink" title="基于VLAN的MAC地址漂移检测"></a><strong>基于VLAN的MAC地址漂移检测</strong></h3><p>在配置基于VLAN的MAC地址漂移检测功能后，如果MAC地址发生漂移时，则可根据需求配置接口做出的动作有以下三种：</p>
<p>1.发送告警，当检测到MAC地址发生漂移时只给网管发送告警。</p>
<p>2.接口阻断，当检测到MAC地址发生漂移时，根据设置的阻塞时间对接口进行阻塞，并关闭接口收发报文的能力。</p>
<p>3.MAC地址阻断，当检测到MAC地址发生漂移时，只阻塞当前MAC地址，而不对物理接口进行阻塞，当前接口下的其他MAC的通信不受影响。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/33.png"></p>
<blockquote>
<ul>
<li><p>MAC地址发生漂移后的三种动作在上图中分别表示为：1.产生并上报告警；2.阻断SW1上的GE0/0/2接口的收发报文的能力；3.阻断SW1上的GE0/0/2接口上针对指定MAC地址报文的收发能力。</p>
</li>
<li><p>当配置接口阻塞时：</p>
<ul>
<li>检测到VLAN2内产生MAC地址漂移时，将产生漂移后的接口直接阻塞。</li>
<li>接口将被阻塞10秒（该时长使用block-time关键字指定），接口被阻塞时是无法正常收发数据的。</li>
<li>10秒之后接口会被放开并重新进行检测，此时该接口可以正常收发数据，如果20秒内没有再检测到MAC地址漂移，则接口的阻塞将被彻底解除；而如果20秒内再次检测到MAC地址漂移，则再次将该接口阻塞，如此重复2次（该次数使用retry-times关键字指定），如果交换机依然能检测到该接口发生MAC地址漂移，则永久阻塞该接口。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="全局MAC地址漂移检测"><a href="#全局MAC地址漂移检测" class="headerlink" title="全局MAC地址漂移检测"></a><strong>全局MAC地址漂移检测</strong></h3><p>当交换机检测到MAC地址漂移，在缺省情况下，它只是简单地上报告警，并不会采取其他动作。在实际网络部署中，可以根据网络需求，对检测到MAC地址漂移之后定义以下动作：</p>
<ul>
<li><p>error-down</p>
<p>当配置了MAC地址漂移检测的端口检测到有MAC地址漂移时，将对应接口状态置为error-down，不再转发数据。</p>
</li>
<li><p>quit-vlan</p>
<p>当配置了MAC地址漂移检测的端口检测到有MAC地址漂移时，将退出当前接口所属的VLAN。</p>
</li>
</ul>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/34.png"></p>
<blockquote>
<ul>
<li><p>华为交换机默认开启全局MAC地址漂移检测功能，因此缺省时交换机便会对设备上的所有VLAN进行MAC地址漂移检测。</p>
</li>
<li><p>在某些场景下，需要对某些VLAN不进行MAC地址漂移检测，可以通过配置MAC地址漂移检测的VLAN白名单来实现。</p>
</li>
<li><p>如果接口由于发生了MAC地址漂移从而被设置为Error-Down，默认情况下是不会自动恢复的。</p>
</li>
<li><p>如果希望Error-Down的接口能够自动恢复，在系统视图下配置如下命令：<br> error-down auto-recovery cause mac-address-flapping interval <em>time-value</em></p>
</li>
<li><p>如果接口由于发生了MAC地址漂移，被设置为离开VLAN，如要实现接口自动恢复，可以在系统视图下配置如下命令：</p>
<p>mac-address flapping quit-vlan recover-time time-       value</p>
</li>
</ul>
</blockquote>
<h2 id="MAC地址漂移配置命令介绍"><a href="#MAC地址漂移配置命令介绍" class="headerlink" title="MAC地址漂移配置命令介绍"></a><strong>MAC</strong>地址漂移配置命令介绍</h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/35.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/36.png"></p>
<blockquote>
<p>一些安全性较差的网络容易受到黑客的MAC地址攻击，由于MAC地址表的容量是有限的，当黑客伪造大量源MAC地址不同的报文并发送给交换机后，交换机的MAC表项资源就可能被耗尽。当MAC表被填满后，即使它再收到正常的报文，也无法学习到报文中的源MAC地址。</p>
<p>配置限制MAC地址学习数，当超过限制数时不再学习MAC地址，同时可以配置当MAC地址数达到限制后对报文采取的动作，从而防止MAC地址表资源耗尽，提高网络安全性。</p>
</blockquote>
<h2 id="MAC地址漂移配置举例"><a href="#MAC地址漂移配置举例" class="headerlink" title="MAC地址漂移配置举例"></a><strong>MAC地址漂移配置举例</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/37.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/38.png"></p>
<blockquote>
<ul>
<li><p>当Switch3与Switch4之间误连接之后，Switch2的接口GE0/0/1的MAC地址漂移到接口GE0/0/2后，触发接口error-down，接口GE0/0/2关闭。</p>
</li>
<li><p>使用display mac-address flapping record可查看到漂移记录。</p>
</li>
</ul>
</blockquote>
<h2 id="配置验证-3"><a href="#配置验证-3" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>配置完成后，当Switch2的接口GE0/0/1的MAC地址漂移到接口GE0/0/2后，接口GE0/0/2关闭；使用display mac-address flapping record可查看到漂移记录。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/39.png"></p>
<h1 id="MACsec"><a href="#MACsec" class="headerlink" title="MACsec"></a><strong>MACsec</strong></h1><h2 id="MACsec，提供二层数据安全传输"><a href="#MACsec，提供二层数据安全传输" class="headerlink" title="MACsec，提供二层数据安全传输"></a>MACsec，提供二层数据安全传输</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>绝大部分数据在局域网链路中都是以明文形式传输的，在某些安全性要求较高的场景下存在安全隐患。</p>
<h3 id="MACsec概述"><a href="#MACsec概述" class="headerlink" title="MACsec概述"></a>MACsec概述</h3><p>MACsec定义了基于以太网的数据安全通信的方法，通过逐跳设备之间数据加密，保证数据传输安全性，对应的标准为802.1AE。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/41.png"></p>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li><p>在交换机之间部署MACsec保护数据安全，例如在接入交换机与上联的汇聚或核心交换机之间部署 。</p>
</li>
<li><p>当交换机之间存在传输设备时可部署MACsec保护数据安全。</p>
</li>
</ul>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/42.png"></p>
<h2 id="MACsec工作机制"><a href="#MACsec工作机制" class="headerlink" title="MACsec工作机制"></a><strong>MACsec工作机制</strong></h2><p>在设备运行点到点MACsec时，网络管理员在两台设备上通过命令行预配置相同的CAK，两台设备会通过MKA协议选举出一个Key Server，Key Server决定加密方案，Key Server会根据CAK等参数使用某种加密算法生成SAK数据密钥，由Key Server将SAK分发给对端设备，这样两台设备拥有相同的SAK数据密钥，可以进行后续MACsec数据报文加解密收发。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/40.png"></p>
<h1 id="交换机流量控制"><a href="#交换机流量控制" class="headerlink" title="交换机流量控制"></a>交换机流量控制</h1><h2 id="流量抑制概述"><a href="#流量抑制概述" class="headerlink" title="流量抑制概述"></a><strong>流量抑制概述</strong></h2><p>•<strong>网络中存在的问题：</strong></p>
<p>​    ▫正常情况下，当设备某个二层以太接口收到广播、未知组播或未知单播报文时，会向同一VLAN内的其他二层以太接口转发这些报文，从而导致流量泛洪，降低设备转发性能。</p>
<p>​    ▫当设备某个以太接口收到已知组播或已知单播报文时，如果某种报文流量过大则可能会对设备造成冲击，影响其他业务的正常处理。</p>
<p>•<strong>可用的解决方案：</strong></p>
<p>​    ▫流量抑制可以通过配置阈值来限制广播、未知组播、未知单播、已知组播和已知单播报文的速率，防止广播、未知组播报文和未知单播报文产生流量泛洪，阻止已知组播报文和已知单播报文的大流量冲击。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/43.png"></p>
<h2 id="流量抑制工作原理-1"><a href="#流量抑制工作原理-1" class="headerlink" title="流量抑制工作原理 (1)"></a><strong>流量抑制工作原理</strong> <strong>(1)</strong></h2><p>在接口入方向上，设备支持对广播、未知组播、未知单播、已知组播和已知单播报文按百分比、包速率和比特速率进行流量抑制。设备监控接口下的各类报文速率并和配置的阈值相比较，当入口流量超过配置的阈值时，设备会丢弃超额的流量。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/44.png"></p>
<blockquote>
<p>•在接口出方向上，设备支持对广播、未知组播和未知单播报文的阻塞（Block）。</p>
</blockquote>
<h2 id="流量抑制工作原理-2"><a href="#流量抑制工作原理-2" class="headerlink" title="流量抑制工作原理 (2)"></a><strong>流量抑制工作原理</strong> <strong>(2)</strong></h2><p>在VLAN视图下，设备支持对广播报文按比特速率进行流量抑制。设备监控同一VLAN内广播报文的速率并和配置的阈值相比较，当VLAN内流量超过配置的阈值时，设备会丢弃超额的流量。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/45.png"></p>
<blockquote>
<p>•流量抑制还可以通过配置阈值的方式对ICMP报文进行限速，防止大量ICMP报文上送CPU处理，导致其他业务功能异常。</p>
</blockquote>
<h2 id="流量抑制的应用"><a href="#流量抑制的应用" class="headerlink" title="流量抑制的应用"></a><strong>流量抑制的应用</strong></h2><p>流量抑制通过对不同类型的报文采取不同的限制措施，达到限制报文发送速率的目的。具体实施可分为以下三种情况：</p>
<p>1.在交换机接口的入方向，例如下图中SW1的GE0/0/1入方向，通过流量抑制功能可以限制任意报文的发送速率。</p>
<p>2.在交换机接口出方向，例如下图中SW1的GE0/0/1出方向，通过流量抑制功能可以阻塞广播，未知组播和未知单播报文。</p>
<p>3.在交换机的VLAN视图下，通过配置VLAN 内流量抑制限制VLAN内广播报文。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/46.png"></p>
<blockquote>
<p>•流量抑制中，可以为接口入方向的报文流量配置阈值，当流量超过阈值时，系统将丢弃多余的流量，阈值范围内的报文可以正常通过，从而将流量限制在合理的范围内。</p>
<p>•此外，流量抑制还支持对接口出方向的流量进行阻塞。</p>
<p>•风暴控制中，只可以为接口入方向的报文流量配置阈值。当流量超过阈值时，系统会阻塞该接口收到的该类型报文流量或者直接将该接口关闭。</p>
</blockquote>
<h2 id="流量抑制配置命令介绍"><a href="#流量抑制配置命令介绍" class="headerlink" title="流量抑制配置命令介绍"></a><strong>流量抑制配置命令介绍</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/47.png"></p>
<blockquote>
<p>•display flow-suppression interface interface-type interface-number查看流量抑制配置信息。</p>
<p>•当在接口视图下的入方向和VLAN视图下同时配置流量抑制功能时，接口视图的配置优先于VLAN视图下的配置。</p>
</blockquote>
<h2 id="流量抑制配置举例"><a href="#流量抑制配置举例" class="headerlink" title="流量抑制配置举例"></a><strong>流量抑制配置举例</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/48.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/49.png"></p>
<h2 id="配置验证-4"><a href="#配置验证-4" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>使用命令display flow-suppression interface 查看流量抑制配置信息。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/50.png"></p>
<h2 id="风暴控制概述"><a href="#风暴控制概述" class="headerlink" title="风暴控制概述"></a><strong>风暴控制概述</strong></h2><p>•<strong>网络中存在的问题：</strong></p>
<p>​    ▫正常情况下，当设备某个二层以太接口收到广播、未知组播或未知单播报文时，会向同一VLAN内的其他二层以太接口转发这些报文，如果网络存在环路，则会导致广播风暴，严重降低设备转发性能。</p>
<p>•<strong>可用的解决方案：</strong></p>
<p>​    ▫风暴控制可以通过阻塞报文或关闭端口来阻断广播、未知组播和未知单播报文的流量。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/51.png"></p>
<h2 id="风暴控制工作原理"><a href="#风暴控制工作原理" class="headerlink" title="风暴控制工作原理"></a><strong>风暴控制工作原理</strong></h2><p>风暴控制可以用来防止广播、未知组播以及未知单播报文产生广播风暴。在风暴控制检测时间间隔内，设备监控接口下接收的三类报文的包平均速率与配置的最大阈值相比较。当报文速率大于配置的最大阈值时，风暴控制将根据配置的动作来对接口进行阻塞报文或关闭接口的处理。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/52.png"></p>
<blockquote>
<p>•流量抑制与风暴控制的主要区别是：风暴控制功能可以对端口下发惩罚动作（block和shutdown)，而流量抑制功能只是对端口流量进行限制。</p>
</blockquote>
<h2 id="风暴控制的应用"><a href="#风暴控制的应用" class="headerlink" title="风暴控制的应用"></a><strong>风暴控制的应用</strong></h2><p>•风暴控制与流量抑制相比的优势是可以同时监控接口下的广播报文、未知组播报文和未知单播报文各自的包平均速率，并根据阈值对接口采取阻塞相关报文或者关闭物理接口的惩罚动作。</p>
<p>•本例中，Switch作为二层网络到路由器的衔接点，当需要限制二层网络转发过来的用户广播、未知组播和未知单播报文时，可以通过在Switch的GE0/0/1上配置风暴控制功能来实现。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/53.png"></p>
<blockquote>
<p>•流量抑制中，可以为接口入方向的报文流量配置阈值。当流量超过阈值时，系统将丢弃多余的流量，阈值范围内的报文可以正常通过，从而将流量限制在合理的范围内。此外，流量抑制还支持对接口出方向的流量进行阻塞。</p>
<p>•风暴控制中，只可以为接口入方向的报文流量配置阈值。当流量超过阈值时，系统会阻塞该接口收到的该类型报文流量或者直接将该接口关闭。</p>
</blockquote>
<h2 id="风暴控制配置命令介绍"><a href="#风暴控制配置命令介绍" class="headerlink" title="风暴控制配置命令介绍"></a><strong>风暴控制配置命令介绍</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/54.png"></p>
<blockquote>
<p>•display storm-control [ interface interface-type interface-number ]，查看接口的风暴控制信息。</p>
<p>•<strong>min-rate</strong> <em>min-rate-value</em></p>
<p>​    ▫指定包模式低阈值。如果指定了<em>min-rate-value</em>参数（单位pps），在风暴控制检测时间间隔内，当接口接收报文的平均速率小于该值时，则将该接口的报文恢复到正常转发状态。</p>
<p>•<strong>min-rate</strong> <strong>cir</strong> <em>min-rate-value-cir</em></p>
<p>​    ▫指定字节模式低阈值。如果指定了<em>min-rate-value-cir</em>参数（单位kbps），在风暴控制检测时间间隔内，当接口接收报文的平均速率小于该值时，则将该接口的报文恢复到正常转发状态。</p>
<p>•<strong>min-rate</strong> <strong>percent</strong> <em>min-rate-value-percent</em></p>
<p>​    ▫指定百分比模式低阈值。如果指定了<em>min-rate-value-percent</em>参数（百分比），在风暴控制检测时间间隔内，当接口接收报文的平均速率小于该值时，则将该接口的报文恢复到正常转发状态。</p>
<p>•<strong>max-rate</strong> <em>max-rate-value</em></p>
<p>​    ▫指定包模式高阈值。如果指定了<em>max-rate-value</em>参数（单位pps），在风暴控制检测时间间隔内，当接口接收报文的平均速率大于该值时，则对该接口进行风暴控制。</p>
<p>•<strong>max-rate</strong> <strong>cir</strong> <em>max-rate-value-cir</em></p>
<p>​    ▫指定字节模式高阈值。如果指定了<em>max-rate-value-cir</em>参数（单位kbps），在风暴控制检测时间间隔内，当接口接收报文的平均速率大于该值时，则对该接口进行风暴控制。</p>
<p>•<strong>max-rate</strong> <strong>percent</strong> <em>max-rate-value-percent</em></p>
<p>​    ▫指定百分比模式高阈值。如果指定了<em>max-rate-value-percent</em>参数，在风暴控制检测时间间隔内，当接口接收报文的平均速率大于该值时，则对该接口进行风暴控制。</p>
</blockquote>
<h2 id="风暴控制配置举例"><a href="#风暴控制配置举例" class="headerlink" title="风暴控制配置举例"></a><strong>风暴控制配置举例</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/55.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/56.png"></p>
<h2 id="配置验证-5"><a href="#配置验证-5" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>执行命令display storm-control interface查看GE0/0/1接口下的风暴控制配置情况。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/57.png"></p>
<h1 id="DHCP-Snooping"><a href="#DHCP-Snooping" class="headerlink" title="DHCP Snooping"></a><strong>DHCP Snooping</strong></h1><h2 id="DHCP工作原理概述"><a href="#DHCP工作原理概述" class="headerlink" title="DHCP工作原理概述"></a><strong>DHCP工作原理概述</strong></h2><p>•DHCP无中继工作原理：</p>
<p>1.发现阶段，DHCP客户端发送DHCP DISCOVER报文（广播）来发现DHCP服务器。DHCP DISCOVER报文中携带了客户端的MAC地址（DHCP DISCOVER报文中的chaddr字段）、需要请求的参数列表选项（Option55）、广播标志位（DHCP DISCOVER报文中的flags字段，表示客户端请求服务器以单播或广播形式发送响应报文）等信息。</p>
<p>2.提供阶段，服务器接收到DHCP DISCOVER报文后，选择跟接收DHCP DISCOVER报文接口的IP地址处于同一网段的地址池，并且从中选择一个可用的IP地址，然后通过DHCP OFFER报文发送给DHCP客户端。</p>
<p>3.请求阶段，如果有多个DHCP服务器向DHCP客户端回应DHCP OFFER报文，则DHCP客户端一般只接收第一个收到的DHCP OFFER报文，然后以广播方式发送DHCP REQUEST报文，该报文中包含客户端想选择的DHCP服务器标识符（即Option54）和客户端IP地址（即Option50，填充了接收的DHCP OFFER报文中yiaddr字段的IP地址）。以广播方式发送DHCP REQUEST报文，是为了通知所有的DHCP服务器，它将选择某个DHCP服务器提供的IP地址，其他DHCP服务器可以重新将曾经分配给客户端的IP地址分配给其他客户端。</p>
<p>4.确认阶段，DHCP客户端收到DHCP ACK报文，会广播发送免费ARP报文，探测本网段是否有其他终端使用服务器分配的IP地址。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/58.png"></p>
<p>•DHCP有中继工作原理：</p>
<p>​    ▫DHCP中继接收到DHCP客户端广播发送的DHCP DISCOVER报文后，主要动作含：检查DHCP报文中的giaddr字段。DHCP报文中的giaddr字段标识客户端网关的IP地址。如果服务器和客户端不在同一个网段且中间存在多个DHCP中继，当客户端发出DHCP请求时，第一个DHCP中继会把自己的IP地址填入此字段，后面的DHCP中继不修改此字段内容。DHCP服务器会根据此字段来判断出客户端所在的网段地址，从而为客户端分配该网段的IP地址。</p>
<p>​    ▫将DHCP报文的目的IP地址改为DHCP服务器或下一跳中继的IP地址，源地址改为中继连接客户端的接口地址，通过路由转发将DHCP报文单播发送到DHCP服务器或下一跳中继。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/59.png"></p>
<h2 id="DHCP-Snooping概述"><a href="#DHCP-Snooping概述" class="headerlink" title="DHCP Snooping概述"></a><strong>DHCP Snooping概述</strong></h2><p>•为了保证网络通信业务的安全性，引入了DHCP Snooping技术，在DHCP Client和DHCP Server之间建立一道防火墙，以抵御网络中针对DHCP的各种攻击。</p>
<p>•DHCP Snooping是DHCP的一种安全特性，用于保证DHCP客户端从合法的DHCP服务器获取IP地址。DHCP 服务器记录DHCP客户端IP地址与MAC地址等参数的对应关系，防止网络上针对DHCP攻击。</p>
<p>•目前DHCP协议在应用的过程中遇到很多安全方面的问题，网络中存在一些针对DHCP的攻击，如DHCP Server仿冒者攻击、DHCP Server的拒绝服务攻击、仿冒DHCP报文攻击等。</p>
<p>•DHCP Snooping主要是通过DHCP Snooping信任功能和DHCP Snooping绑定表实现DHCP网络安全。</p>
<h2 id="DHCP-Snooping信任功能"><a href="#DHCP-Snooping信任功能" class="headerlink" title="DHCP Snooping信任功能"></a><strong>DHCP Snooping信任功能</strong></h2><p>•DHCP Snooping的信任功能，能够保证DHCP客户端从合法的DHCP服务器获取IP地址。</p>
<p>•DHCP Snooping信任功能将接口分为信任接口和非信任接口：</p>
<p>​    ▫信任接口正常接收DHCP服务器响应的DHCP ACK、DHCP NAK和DHCP Offer报文。</p>
<p>​    ▫设备只将DHCP客户端的DHCP请求报文通过信任接口发送给合法的DHCP服务器，不会向非信任接口转发。</p>
<p>​    ▫非信任接口收到的DHCP Server发送的DHCP OFFER、DHCP ACK、DHCP NAK报文会被直接丢弃。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/60.png"></p>
<blockquote>
<p>•配置dhcp snooping enable命令的接口，收到DHCP请求报文后，转发给所有的信任接口；收到DHCP响应报文后丢弃。</p>
<p>•配置dhcp snooping trusted命令的接口，收到DHCP请求报文后，转发给所有的信任接口，如果没有其他信任接口，则丢弃该DHCP请求报文；收到DHCP响应报文后，只转发给连接对应客户端的并且配置命令dhcp snooping enable的接口，如果查不到上述接口，则丢弃该DHCP响应报文。</p>
</blockquote>
<h2 id="DHCP-Snooping绑定表"><a href="#DHCP-Snooping绑定表" class="headerlink" title="DHCP Snooping绑定表"></a><strong>DHCP Snooping绑定表</strong></h2><p>•二层接入设备使能了DHCP Snooping功能后，从收到DHCP ACK报文中提取关键信息（包括PC的MAC地址以及获取到的IP地址、地址租期），并获取与PC连接的使能了DHCP Snooping功能的接口信息（包括接口编号及该接口所属的VLAN），根据这些信息生成DHCP Snooping绑定表。</p>
<p>•由于DHCP Snooping绑定表记录了DHCP客户端IP地址与MAC地址等参数的对应关系，故通过对报文与DHCP Snooping绑定表进行匹配检查，能够有效防范非法用户的攻击。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/61.png"></p>
<blockquote>
<p>•DHCP Snooping绑定表根据DHCP租期进行老化或根据用户释放IP地址时发出的DHCP Release报文自动删除对应表项。</p>
</blockquote>
<h2 id="DHCP饿死攻击"><a href="#DHCP饿死攻击" class="headerlink" title="DHCP饿死攻击"></a><strong>DHCP饿死攻击</strong></h2><p>•攻击原理：攻击者持续大量地向DHCP Server申请IP地址，直到耗尽DHCP Server地址池中的IP地址，导致DHCP Server不能给正常的用户进行分配。</p>
<p>•漏洞分析：DHCP Server向申请者分配IP地址时，无法区分正常的申请者与恶意的申请者。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/62.png"></p>
<h2 id="DHCP-Snooping防饿死攻击"><a href="#DHCP-Snooping防饿死攻击" class="headerlink" title="DHCP Snooping防饿死攻击"></a><strong>DHCP Snooping防饿死攻击</strong></h2><p>解决方法：对于饿死攻击，可以通过DHCP Snooping的MAC地址限制功能来防止。该功能通过限制交换机接口上允许学习到的最多MAC地址数目，防止通过变换MAC地址，大量发送DHCP请求。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/63.png"></p>
<h2 id="改变CHADDR值的DoS攻击"><a href="#改变CHADDR值的DoS攻击" class="headerlink" title="改变CHADDR值的DoS攻击"></a>改变CHADDR值的DoS攻击</h2><p>•攻击原理：攻击者持续大量地向DHCP Server申请IP地址，直到耗尽DHCP Server地址池中的IP地址，导致DHCP Server不能给正常的用户进行分配。</p>
<p>•漏洞分析：DHCP Server向申请者分配IP地址时，无法区分正常的申请者与恶意的申请者。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/64.png"></p>
<h2 id="DHCP-Snooping防改变CHADDR值的DoS攻击"><a href="#DHCP-Snooping防改变CHADDR值的DoS攻击" class="headerlink" title="DHCP Snooping防改变CHADDR值的DoS攻击"></a><strong>DHCP Snooping防改变CHADDR值的DoS攻击</strong></h2><p>解决方法：为了避免受到攻击者改变CHADDR值的攻击，可以在设备上配置DHCP Snooping功能，检查DHCP Request报文中CHADDR字段。如果该字段跟数据帧头部的源MAC相匹配，转发报文；否则，丢弃报文。从而保证合法用户可以正常使用网络服务。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/65.png"></p>
<blockquote>
<p>•DHCP饿死攻击是攻击者通过持续大量地向DHCP Server申请IP地址来实现的，其目的是耗尽DHCP Server地址池中的IP地址，导致DHCP Server没有IP地址分配给正常的用户。DHCP消息中有一个名叫CHADDR（Client Hardware Address）的字段，该字段是由DHCP客户端填写的，表示的是客户端的硬件地址（也就是客户端的MAC地址）。DHCP Server是针对CHADDR来分配IP地址的，对于不同的CHADDR，DHCP Server会分配不同的IP地址；DHCP Server无法区分什么样的CHADDR是合法的，什么样的CHADDR是非法的。利用这个漏洞，攻击者每申请一个IP地址时，就在DHCP消息的CHADDR字段中填写一个不同的值，以此来冒充是不同的用户在申请IP地址。</p>
<p>•为了弥补上述漏洞，从而阻止饿死攻击，DHCP Snooping技术支持在端口下对DHCP Request报文的源MAC地址与CHADDR进行一致性检查：如果二者相同，则转发报文；如果二者不相同，则丢弃。如果要在某端口下实施源MAC地址与CHADDR的一致性检查，可以在该端口下使用命令dhcp snooping check dhcp-chaddr enable。</p>
<p>•还可能存在这样一种饿死攻击，就是攻击者不断同时变换MAC地址和CHADDR，并且每一次变换时，都让CHADDR与MAC地址相同，如此一来，便可以躲过上述源MAC地址与CHADDR的一致性检查！</p>
</blockquote>
<h2 id="DHCP中间人攻击"><a href="#DHCP中间人攻击" class="headerlink" title="DHCP中间人攻击"></a><strong>DHCP中间人攻击</strong></h2><p>•攻击原理：攻击者利用ARP机制，让Client学习到DHCP Server IP与Attacker MAC的映射关系，又让Server学习到Client IP与Attacker Mac的映射关系。如此一来，Client与Server之间交互的IP报文都会经过攻击者中转。</p>
<p>•漏洞分析：从本质上讲，中间人攻击是一种Spoofing IP/MAC攻击，中间人利用了虚假的IP地址与MAC地址之间的映射关系来同时欺骗DHCP的客户端和服务器。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/66.png"></p>
<blockquote>
<p>•如图所示，攻击者利用ARP机制，让PC1学习到IP-S与MAC2的映射关系，又让Server学习到IP1与MAC2的映射关系。当PC1向DHCP Server发送IP报文时，目的IP地址为IP-S，源IP地址为IP1，而封装这个IP报文的帧的目的MAC地址为MAC2，源MAC地址为MAC1，所以这个帧会首先到达攻击者PC2。攻击者收到这个帧后，将这个帧的目的MAC地址更换为MAC-S，源MAC地址更换为MAC2，然后将这个帧发往Server。如此“偷梁换柱”，Server是看不出任何破绽的。另一方面，当DHCP Server向PC1发送IP报文时，目的IP地址为IP1，源IP地址为IP-S，而封装这个IP报文的帧的目的MAC地址为MAC2，源MAC地址为MAC-S，所以这个帧也会首先到达攻击者PC2。攻击者收到这个帧后，将这个帧的目的MAC地址更换为MAC1，源MAC地址更换为MAC2，然后将这个帧发往PC1。同样，PC1也是看不出任何破绽的。</p>
<p>•由于往来于PC1与DHCP Server之间的IP报文都会经过攻击者（中间人）进行中转，攻击者便很容易窃取这些IP报文中的某些信息，并利用这些信息来进行其他的破坏行为。攻击者也可以很容易对往来于PC1与DHCP Server之间的DHCP消息（这些消息是封装在UDP报文中的，而UDP报文又是封装在IP报文中的）进行篡改，达到直接攻击DHCP的目的。</p>
</blockquote>
<h2 id="DHCP-Snooping防DHCP中间人攻击"><a href="#DHCP-Snooping防DHCP中间人攻击" class="headerlink" title="DHCP Snooping防DHCP中间人攻击"></a><strong>DHCP Snooping防DHCP中间人攻击</strong></h2><p>解决方法：为防御中间人攻击与IP/MAC Spoofing攻击，可使用DHCP Snooping的绑定表工作模式，当接口接收到ARP或者IP报文，使用ARP或者IP报文中的“源IP+源MAC”匹配DHCP Snooping绑定表。如果匹配就进行转发，如果不匹配就丢弃。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/67.png"></p>
<blockquote>
<p>•DHCP中间人攻击本质上是一种Spoofing IP/MAC攻击。要想防止DHCP中间人攻击，其实就是要防止Spoofing IP/MAC攻击。</p>
<p>•运行了DHCP Snooping的交换机会“侦听（Snooping）”往来于用户与DHCP Server之间的DHCP消息，并从中收集用户的MAC地址（这里的MAC地址是指DHCP消息中CHADDR字段的值）、用户的IP地址（这里的IP地址是指DHCP Server分配给相应CHADDR的IP地址）等信息，这些信息会集中存放在一个数据库中，该数据库也被称为DHCP Snooping绑定表。运行了DHCP Snooping的交换机会建立并动态维护DHCP Snooping绑定表，绑定表中除了包含了用户的MAC地址、用户的IP地址外，还包括IP地址租用期、VLAN ID等等信息。</p>
<p>•如图所示，假设DHCP Server给PC1分配了IP地址IP1，给PC2分配了IP地址IP2，那么IP1与MAC1就形成了绑定关系，IP2与MAC2也形成了绑定关系，这种绑定关系都存放于DHCP Snooping绑定表中。攻击者为了让Server学习到IP1与MAC2的映射关系，会发送ARP请求报文（将ARP报文中的源IP地址填为IP1，源MAC地址填为MAC2）。交换机接收到ARP请求报文后，会检查该ARP请求报文中的源IP地址和源MAC地址，发现该IP/MAC（IP1/MAC2）映射关系不能匹配DHCP Snooping绑定表中的条目，于是会丢弃该ARP请求报文，这样就有效地防止了Spoofing IP/MAC攻击。</p>
<p>•如果需要使用上面所描述的防止Spoofing IP/MAC攻击（进而防止中间人）的方法，就必须在交换机的系统视图下执行配置命令arp dhcp-snooping-detect enable。</p>
</blockquote>
<h2 id="DHCP-Snooping配置命令介绍"><a href="#DHCP-Snooping配置命令介绍" class="headerlink" title="DHCP Snooping配置命令介绍"></a><strong>DHCP Snooping配置命令介绍</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/68.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/69.png"></p>
<h2 id="DHCP-Snooping配置举例"><a href="#DHCP-Snooping配置举例" class="headerlink" title="DHCP Snooping配置举例"></a>DHCP Snooping配置举例</h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/70.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/71.png"></p>
<h2 id="配置验证-6"><a href="#配置验证-6" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>执行命令display dhcp snooping interface，查看接口下的DHCP Snooping运行信息。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/72.png"></p>
<h2 id="IP-Source-Guard"><a href="#IP-Source-Guard" class="headerlink" title="IP Source Guard"></a><strong>IP Source Guard</strong></h2><h2 id="IPSG技术概述"><a href="#IPSG技术概述" class="headerlink" title="IPSG技术概述"></a><strong>IPSG技术概述</strong></h2><p>•IP地址欺骗攻击中，攻击者通过伪造合法用户的IP地址获取网络访问权限，非法访问网络，甚至造成合法用户无法访问网络，或者信息泄露。IPSG针对IP地址欺骗攻击提供了一种防御机制，可以有效阻止此类网络攻击行为。</p>
<p>•IP源防攻击（IPSG，IP Source Guard）是一种基于二层接口的源IP地址过滤技术。它能够防止恶意主机伪造合法主机的IP地址来仿冒合法主机，还能确保非授权主机不能通过自己指定IP地址的方式来访问网络或攻击网络。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/73.png"></p>
<blockquote>
<p>•非法主机伪造合法主机的IP地址获取上网权限时，通过在Switch的接入用户侧的接口或VLAN上部署IPSG功能，Switch可以对进入接口的IP报文进行检查，丢弃非法主机的报文，从而阻止此类攻击。</p>
<p>•IPSG一般应用在与用户直连的接入设备上，可以基于接口或者基于VLAN应用。</p>
</blockquote>
<h2 id="IPSG工作原理"><a href="#IPSG工作原理" class="headerlink" title="IPSG工作原理"></a><strong>IPSG</strong>工作原理</h2><p>IPSG利用绑定表（源IP地址、源MAC地址、所属VLAN、入接口的绑定关系）去匹配检查二层接口上收到的IP报文，只有匹配绑定表的报文才允许通过，其他报文将被丢弃。常见的绑定表有静态绑定表和DHCP Snooping动态绑定表。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/74.png"></p>
<blockquote>
<p>•绑定表生成后，IPSG基于绑定表向指定的接口或者指定的VLAN下发ACL，由该ACL来匹配检查所有IP报文。主机发送的报文，只有匹配绑定表才会允许通过，不匹配绑定表的报文都将被丢弃。当绑定表信息变化时，设备会重新下发ACL。</p>
<p>•缺省情况下，如果在没有绑定表的情况下使能了IPSG，设备将拒绝除DHCP请求报文外的所有IP报文。</p>
<p>•静态绑定表项包含：MAC地址、IP地址、VLAN ID、入接口。静态绑定表项中指定的信息均用于IPSG过滤接口收到的报文。</p>
<p>•动态绑定表项包含：MAC地址、IP地址、VLAN ID、入接口。IPSG依据该表项中的哪些信息过滤接口收到的报文，由用户设置的检查项决定，缺省是四项都进行匹配检查。常用的检查项有基于源IP地址过滤,基于源MAC地址过滤,基于源IP地址+源MAC地址过滤,基于源IP地址+源MAC地址+接口过滤,基于源IP地址+源MAC地址+接口+VLAN过滤等。</p>
</blockquote>
<h2 id="IPSG应用场景"><a href="#IPSG应用场景" class="headerlink" title="IPSG应用场景"></a><strong>IPSG应用场景</strong></h2><p>•通过IPSG防止PC私自更改IP地址。</p>
<p>​    ▫PC只能使用DHCP Server分配的IP地址或者管理员配置的静态地址，随意更改IP地址后无法访问网络，防止PC非法取得上网权限。</p>
<p>•小型网络IP地址是静态分配时，通过IPSG限制非法PC接入。</p>
<p>​    ▫外来人员自带电脑不能随意接入内网，防止内网资源泄露。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/75.png"></p>
<h2 id="IPSG配置命令介绍"><a href="#IPSG配置命令介绍" class="headerlink" title="IPSG配置命令介绍"></a><strong>IPSG配置命令介绍</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/76.png"></p>
<h2 id="IPSG配置举例"><a href="#IPSG配置举例" class="headerlink" title="IPSG配置举例"></a><strong>IPSG配置举例</strong></h2><p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/77.png"></p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/78.png"></p>
<h2 id="配置验证-7"><a href="#配置验证-7" class="headerlink" title="配置验证"></a><strong>配置验证</strong></h2><p>•在Switch上执行display dhcp static user-bind all命令，可以查看静态绑定表信息。</p>
<p>•PC1和PC2使用管理员分配的固定IP地址可以正常访问网络，更改IP地址后无法访问网络。</p>
<p><img src="/2021/05/05/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8/79.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）DHCP Snooping是一种DHCP安全特性，可以用于防御多种攻击，其中包括 (   ) </p>
<p><strong>A.防御改变CHADDR值的饿死攻击</strong></p>
<p><strong>B.防御DHCP仿冒者攻击</strong></p>
<p>C.防御TCP flag攻击</p>
<p><strong>D.防御中间人攻击和IP/MAC Spoofing攻击</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•端口隔离实现同一VLAN内端口之间的隔离。端口隔离模式分别为二层隔离三层互通、二层三层都隔离。</p>
<p>•交换机MAC地址表可以分为静态MAC地址表、黑洞MAC地址表、动态MAC地址表。</p>
<p>•端口安全通过将接口学习到的动态MAC地址转换为安全MAC地址，安全MAC地址通常与安全保护动作结合使用。</p>
<p>•交换机开启MAC地址漂移检测有助于工程师快速处理交换机环路故障。</p>
<p>•MACsec定义了基于以太网的数据安全通信的方法，通过逐跳设备之间数据加密，保证数据传输安全性。</p>
<p>•流量抑制与风暴控制主要区别在于流量控制仅仅是对各种报文进行限速处理，超过阈值之后就丢弃，而风暴控制能够根据报文速率的大小采取不同的惩罚动作，包括关闭端口或者阻塞报文。</p>
<p>•DHCP Snooping技术对于防御以太网中关于终端设备自动获取IP的网络攻击有很大的作用，通过配置DHCP Snooping信任端口功能和DHCP Snooping绑定表，可以很好的防范针对DHCP的网络攻击。</p>
<p>•IPSG通过查看交换机绑定表，阻止IP地址欺骗攻击，杜绝非法用户盗用合法IP地址对网络发起攻击。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/" itemprop="url">认识网络设备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-05T20:01:18+08:00">
                2021-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络设备框架介绍"><a href="#网络设备框架介绍" class="headerlink" title="网络设备框架介绍"></a>网络设备框架介绍</h1><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><ul>
<li><p>网络基础设施由交换机、路由器、防火墙等构成，这些设备日复一日地接收、发送数据，从一个接口收到的数据如何经过设备内部转发到另外一个接口？</p>
</li>
<li><p>设备有哪些组件构成？这些组件如何协同工作？。</p>
</li>
</ul>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/1.png"></p>
<h2 id="框式设备硬件模块"><a href="#框式设备硬件模块" class="headerlink" title="框式设备硬件模块"></a>框式设备硬件模块</h2><p>为方便理解网络设备内部的各个功能模块，以S12700E-8为例讲解典型网络设备的构架：</p>
<p>▫主控板(MPU，Main Processing Unit)：负责整个系统的控制平面。</p>
<p>▫交换网板(SFU，Switch Fabric Unit)：负责整个系统的数据平面。数据平面提供高速无阻塞数据通道，实现各个业务模块之间的业务交换功能。</p>
<p>▫接口板(LPU，Line Processing Unit)：线路处理单元是物理设备上用于提供数据转发功能的模块，提供不同速率的光口、电口。</p>
<p>▫交换网板、接口板上都有自己的管理芯片，与主控板共同组成整个设备的控制管理平面。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/2.png"></p>
<h3 id="主控板"><a href="#主控板" class="headerlink" title="主控板"></a><strong>主控板</strong></h3><p>主控板提供了整个系统的控制平面和管理平面。</p>
<p>▫ 控制平面完成系统的协议处理、业务处理、路由运算、转发控制、业务调度、流量统计、系统安全等功能。</p>
<p>▫ 管理平面完成系统的运行状态监控、环境监控、日志和告警信息处理、系统加载、系统升级等功能。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/3.png"></p>
<h3 id="交换网板"><a href="#交换网板" class="headerlink" title="交换网板"></a><strong>交换网板</strong></h3><p>交换网板提供整个系统的数据平面。接口板、主控板之间通过交换网板完成通信。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/4.png"></p>
<h3 id="接口板"><a href="#接口板" class="headerlink" title="接口板"></a><strong>接口板</strong></h3><p>接口板提供了不同类型（光口、电口），不同速率的接入接口，通过分布式数据平面对数据进行转发。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/5.png"></p>
<h2 id="盒式设备"><a href="#盒式设备" class="headerlink" title="盒式设备"></a><strong>盒式设备</strong></h2><p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/6.png"></p>
<p>不同于框式设备，盒式设备的各个业务模块并不是独立的硬件模块，而是集成在一个框内。</p>
<h2 id="模块连接逻辑图"><a href="#模块连接逻辑图" class="headerlink" title="模块连接逻辑图"></a>模块连接逻辑图</h2><p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/7.png"></p>
<p>•框式设备各个模块分为不同的单板，单板之间通过框式设备内部的连接进行通信。</p>
<p>•盒式设备内部集成了这些模块，各个模块之间同样也是通过内部连接进行通信。</p>
<p>•接口板和接口板之间通过交换网板连接了起来，接口板之间的通信统一经由交换网板进行转发。</p>
<h2 id="网络设备逻辑构架"><a href="#网络设备逻辑构架" class="headerlink" title="网络设备逻辑构架"></a><strong>网络设备逻辑构架</strong></h2><p>网络设备从逻辑上可以分为以下三个平面：数据平面、控制管理平面和监控平面。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/8.png"> </p>
<p>以交换机为例，设备可以分为以下的三个平面（参考RFC7426中对网络设备平面划分）：</p>
<ul>
<li><p>交换机转发平面：转发平面提供高速无阻塞数据通道，实现各个业务模块之间的业务交换功能。交换机的基本任务是处理和转发交换机各不同端口上各种类型的数据。L2/L3/ACL/QoS/组播/安全防护等各种具体的数据处理转发过程，都属于交换机转发平面的任务范畴。</p>
</li>
<li><p>交换机控制平面：控制平面完成系统的协议处理、业务处理、路由运算、转发控制、业务调度、流量统计、系统安全等功能。交换机的控制平面用于控制和管理所有网络协议的运行。控制平面提供了数据平面数据处理转发前所必须的各种网络信息和转发查询表项。</p>
</li>
<li><p>交换机管理平面：管理平面完成系统的运行状态监控、环境监控、日志和告警信息处理、系统加载、系统升级等功能。交换机的管理平面是提供给网络管理人员使用TELNET、WEB、SSH、SNMP、RMON等方式来管理设备，并支持、理解和执行管理人员对于网络设备各种网络协议的设置命令。管理平面必须预先设置好控制平面中各种协议的相关参数，并支持在必要时刻对控制平面的运行进行干预。</p>
</li>
</ul>
<p>在华为产品具体的实现上，部分系列产品将功能组合区分为数据平面、管理平面和监控平面。</p>
<h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a><strong>控制平面</strong></h3><p>•设备的控制平面由主控板以及接口板的管理单元组成。</p>
<p>•控制管理平面完成系统的控制管理功能，是整个系统的中枢神经系统。控制平面完成系统的协议处理、业务处理、路由运算、转发控制、业务调度、流量统计、系统安全等功能。交换机的控制平面用于控制和管理所有网络协议的运行。控制平面提供了数据平面数据处理转发前所必须的各种网络信息和转发查询表项。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/9.png"></p>
<h3 id="转发平面"><a href="#转发平面" class="headerlink" title="转发平面"></a><strong>转发平面</strong></h3><p>•设备的转发平面由交换网板以及接口板组成。</p>
<p>•LPU上存在FPE（转发引擎），其本质也是一个交换芯片，完成本接口板端口之间的交换。</p>
<p>•数据平面完成数据报文的高速处理和内部无阻塞交换。包括报文的封装与解封装、IPv4/IPv6/MPLS转发处理、QoS与调度处理、内部高速交换以及各种统计。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/10.png"></p>
<h3 id="监控平面"><a href="#监控平面" class="headerlink" title="监控平面"></a><strong>监控平面</strong></h3><p>•监控平面由主控板、接口板的监控单元构成，部分框式设备还会存在单独的集中监控板(CMU)。</p>
<p>•监控平面独立完成系统的环境监控，包括电压检测、系统上下电控制、温度监测与风扇控制等，以保证系统的安全稳定运行，在出现单元故障的情况下及时隔离故障，保障系统其它部分的正常运行。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/11.png"></p>
<h1 id="网络设备对报文的处理流程"><a href="#网络设备对报文的处理流程" class="headerlink" title="网络设备对报文的处理流程"></a><strong>网络设备对报文的处理流程</strong></h1><h2 id="报文转发上行、下行"><a href="#报文转发上行、下行" class="headerlink" title="报文转发上行、下行"></a><strong>报文转发上行、下行</strong></h2><p>以交换网板为中心，可将报文在设备的行程一分为二，前半程称为“上行”，下半程称为“下行”。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/12.png"></p>
<blockquote>
<p>•设备处理报文分类：一种是业务报文、一种是协议报文。</p>
<p>•对于业务报文设备只会进行转发，从一个接口进入之后依据转发表项从另外一个接口发送出去。</p>
<p>•协议报文（如ARP、OSPF、BGP等协议的报文）设备在收到之后会交由控制层面进行处理，如ARP报文交由控制层面处理、判断之后决定是否回应，是否学习ARP报文中的源MAC、源IP。</p>
</blockquote>
<h2 id="业务报文转发处理流程"><a href="#业务报文转发处理流程" class="headerlink" title="业务报文转发处理流程"></a><strong>业务报文转发处理流程</strong></h2><p>业务报文从接口进入上行接口板处理之后，通过框式交换机内部总线交由交换网板，交换网板交由下行接口板处理之后从接口发出去。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/13.png"></p>
<blockquote>
<p>•PFE（Packet Forwarding Engine）：包转发引擎。</p>
<p>•业务报文：服务、应用在交互过程中涉及的报文。</p>
<p>•切片：把报文送往交换网板之前，进行切片处理，也就是把报文按一定粒度进行切片，切成固定长度。</p>
<p>•重组：将交换网板发送过来的已经切片的报文进行重新组合。</p>
</blockquote>
<h3 id="确定报文出口-1"><a href="#确定报文出口-1" class="headerlink" title="确定报文出口 (1)"></a><strong>确定报文出口</strong> <strong>(1)</strong></h3><p>•当报文从接口板进入时，设备需要依据转发表项（IP路由表、MAC地址表等）确定报文的出接口（对于框式设备需要确定下行接口板）。</p>
<p>•报文到达交换网板时已经明确了出接口、下行接口板，因此表项查询需要在上行接口板的处理过程中完成。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/14.png"></p>
<h3 id="确定报文出口-2"><a href="#确定报文出口-2" class="headerlink" title="确定报文出口 (2)"></a><strong>确定报文出口</strong> <strong>(2)</strong></h3><p>•转发表项存放在主控板上，报文进入接口板之后，接口板从主控板处查询表项。</p>
<p>•每次转发都需要与主控板进行通信，转发效率低，报文时延增加，对高速率接口板而言转发速率严重下跌。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/15.png"></p>
<h3 id="确定报文出口-3"><a href="#确定报文出口-3" class="headerlink" title="确定报文出口 (3)"></a><strong>确定报文出口</strong> <strong>(3)</strong></h3><p>•转发表项存放在接口板上，报文进入接口板之后直接在接口板完成报文查询，报文转发效率高。</p>
<p>•所有接口板上都要存储转发表项，控制平面资源占用率高。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/16.png"></p>
<blockquote>
<p>二层转发查询MAC地址表，三层转发查询三层路由表。</p>
</blockquote>
<h3 id="转发信息"><a href="#转发信息" class="headerlink" title="转发信息"></a><strong>转发信息</strong></h3><p>•高端设备业务报文不经过主控板CPU处理，由接口板提供转发信息查询。</p>
<p>•接口板上存在的转发信息并非存在于主控板上的转发表项（IP路由表、MAC地址表…）。主控板生成转发表项之后，生成对应的转发信息下发在接口板。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/17.png"></p>
<h3 id="硬件转发"><a href="#硬件转发" class="headerlink" title="硬件转发"></a><strong>硬件转发</strong></h3><p>•接口板执行转发的部件为包转发引擎PFE（Packet Forwarding Engine），通常为NP或者ASIC芯片，报文直接由接口板独立完成转发，无需主控板参与。</p>
<p>•高端框式设备把转发层面和控制层面分配在不同的组件，控制层面组件（主控板）负责运行转发相关协议、维护转发表项，转发平面组件（接口板）依据控制层面下发的转发信息能够独立完成转发工作，互不影响，控制层面组件高负载时并不会影响转发平面的正常工作，这种工作机制被称为转控分离。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/18.png"></p>
<h2 id="协议报文转发处理流程"><a href="#协议报文转发处理流程" class="headerlink" title="协议报文转发处理流程"></a><strong>协议报文转发处理流程</strong></h2><p>设备收到的协议报文，如路由协议：OSPF、IS-IS、BGP报文，ARP报文，STP报文，对设备的ICMP请求报文等，需要交由设备的控制平面处理，即上送主控板由主控板的CPU进行处理。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/19.png"></p>
<blockquote>
<p>•主控板CPU收到协议报文之后进行相应的处理之后如果需要回应报文，则主控板会构造协议报文进行回应，如收到发往自身的ARP Request、ICMP Echo Request报文，主控板处理之后构造ARP Reply、ICMP Echo Reply进行回应。</p>
<p>•主控板CPU处理能力有限，如果过多的协议报文上送主控板CPU处理，会造成其繁忙，无法及时对协议报文进行响应，为此设备默认限制了各种类型的协议报文上送主控板CPU的速率。</p>
</blockquote>
<h3 id="设备自身发送协议报文处理流程"><a href="#设备自身发送协议报文处理流程" class="headerlink" title="设备自身发送协议报文处理流程"></a><strong>设备自身发送协议报文处理流程</strong></h3><p>设备自身发送的协议报文，如路由协议报文: OSPF、IS-IS、BGP报文，ARP报文，STP报文，ICMP报文等，由主控板CPU构造之后交由接口板对外发送。</p>
<p><img src="/2021/05/05/%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/20.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选题）框式设备中负责运行路由协议，生成、维护路由表的模块是？</p>
<p>A.接口板</p>
<p>B.交换网板</p>
<p><strong>C.主控板</strong></p>
<p>D.SPU</p>
<p>2.（简答题）高端框式设备转发业务报文时是否会向主控板查询转发表项？</p>
<p><strong>不需要，高端框式设备将转发信息下发到接口板，接口板直接转发报文，无需向主控板查询转发表项。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>每台网络设备存在独立的控制平面、转发平面、监控平面，控制平面负责系统的协议处理、路由运算、业务调度等，而转发平面负责转发数据，实现各个业务模块之间的报文交互。监控平面负责系统的环境监控，以保证系统的安全稳定运行。</p>
</li>
<li><p>高端框式设备各个平面以不同的板卡形式存在，接口板、交换网板实现转发平面的功能，主控板实现控制平面的功能，监控板实现监控平面的功能。</p>
</li>
<li><p>高端框式设备采用“硬转发”，报文的转发由接口板直接完成，无需控制平面参与，报文转发效率极高。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/03/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/03/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/" itemprop="url">路由策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-03T20:32:10+08:00">
                2021-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kaoa000/article/details/55097156/">https://blog.csdn.net/kaoa000/article/details/55097156/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
