<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/6/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/IPv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/26/IPv6/" itemprop="url">IPv6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-26T15:06:24+08:00">
                2021-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><h3 id="IPv4现状"><a href="#IPv4现状" class="headerlink" title="IPv4现状"></a>IPv4现状</h3><p>2011年2月3日，IANA ( Internet Assigned Numbers Authority，因特网地址分配组织）宣布将其最后的468万个IPv4地址平均分配到全球5个RIR ( Regional Internet Registry，区域互联网注册管理机构），此后IANA再没有可分配的IPv4地址。<br><img src="/2021/04/26/IPv6/IPv4%E7%8E%B0%E7%8A%B6.png" alt="IPv4现状"></p>
<h3 id="IPv6优势"><a href="#IPv6优势" class="headerlink" title="IPv6优势"></a>IPv6优势</h3><table>
<thead>
<tr>
<th>优势</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>“无限”地址空间</td>
<td align="left">地址长度为128 bit，海量的地址空间，满足物联网等新兴业务、有利于业务演进及扩展。</td>
</tr>
<tr>
<td>层次化的地址结构</td>
<td align="left">相较于IPv4地址，IPv6地址的分配更加规范，利于路由聚合（缩减IPv6路由表规模)、路由快速查询。</td>
</tr>
<tr>
<td>即插即用</td>
<td align="left">IPv6支持无状态地址自动配置( SLAAC)，终端接入更简单。</td>
</tr>
<tr>
<td>简化的报文头部</td>
<td align="left">简化报文头，提高效率;通过扩展包头支持新应用，利于路由器等网络设备的转发处理，降低投资成本。</td>
</tr>
<tr>
<td>安全特性</td>
<td align="left">lPsec、真实源地址认证等保证端到端安全;避免NAT破坏端到端通信的完整性。</td>
</tr>
<tr>
<td>移动性</td>
<td align="left">对移动网络实时通信有较大改进，整个移动网络性能有比较大的提升。</td>
</tr>
<tr>
<td>增强的QoS特性</td>
<td align="left">额外定义了流标签字段，可为应用程序或者终端所用，针对特殊的服务和数据流，分配特定的资源。</td>
</tr>
</tbody></table>
<h2 id="IPv6包头格式"><a href="#IPv6包头格式" class="headerlink" title="IPv6包头格式"></a>IPv6包头格式</h2><h3 id="基本包头"><a href="#基本包头" class="headerlink" title="基本包头"></a>基本包头</h3><ul>
<li>IPv6包头由一个IPv6基本包头（必须存在)和多个扩展包头(可能不存在)组成。</li>
<li>基本包头提供报文转发的基本信息，会被转发路径上的所有设备解析。</li>
</ul>
<p><img src="/2021/04/26/IPv6/IPv6%E5%9F%BA%E6%9C%AC%E5%8C%85%E5%A4%B4.png" alt="基本包头"></p>
<h3 id="扩展包头"><a href="#扩展包头" class="headerlink" title="扩展包头"></a>扩展包头</h3><ul>
<li><p>Extension Header Length:扩展包头长度，长度为8 bit。表示扩展包头的长度（不包含Next Header字段)。</p>
</li>
<li><p>Extension Header Data:扩展包头数据，长度可变。扩展包头的内容，为一系列选项字段和填充字段的组合。</p>
</li>
</ul>
<p><img src="/2021/04/26/IPv6/IPv6%E6%89%A9%E5%B1%95%E5%8C%85%E5%A4%B4.png" alt="扩展包头"></p>
<h3 id="报文处理机制"><a href="#报文处理机制" class="headerlink" title="报文处理机制"></a>报文处理机制</h3><p><img src="/2021/04/26/IPv6/IPv6%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.png" alt="IPv6报文处理机制"></p>
<h2 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h2><h3 id="IPv6地址结构"><a href="#IPv6地址结构" class="headerlink" title="IPv6地址结构"></a>IPv6地址结构</h3><ul>
<li><p>IPv6地址的长度为128 bit。一般用冒号分割为8段，每一段16 bit，每一段内用十六进制表示。</p>
</li>
<li><p>与IPv4地址类似，IPv6也用“IPv6地址/掩码长度”的方式来表示IPv6地址。</p>
<p>例如2001:0DB8:2345:CD30:1230:4567:89AB:CDEF/64<br><strong>IPv6地址</strong>: 2001:0DB8:2345:CD30:1230:4567:89AB:CDEF<br><strong>子网号</strong>: 2001:ODB8:2345:CD30::/64</p>
</li>
</ul>
<h3 id="IPv6地址缩写规范"><a href="#IPv6地址缩写规范" class="headerlink" title="IPv6地址缩写规范"></a>IPv6地址缩写规范</h3><ol>
<li>每组16 bit的单元中的前导0可以省略，但是如果16 bit单元的所有比特都为0，那么至少要保留一个“0”字符;拖尾的O不能被省略。</li>
<li>一个或多个连续的16 bit字符为0时，可用“:”表示，但整个IPv6地址缩写中只允许有一个“::”。</li>
</ol>
<blockquote>
<p>若缩写后的IPv6地址出现两个“::”，会导致无法还原为原始IPv6地址。</p>
</blockquote>
<p><img src="/2021/04/26/IPv6/IPv6%E7%BC%A9%E5%86%99%E7%A4%BA%E4%BE%8B.png" alt="IPv6缩写示例"></p>
<h3 id="IPv6地址分类"><a href="#IPv6地址分类" class="headerlink" title="IPv6地址分类"></a>IPv6地址分类</h3><p>根据IPv6地址前缀，可将IPv6地址分为为单播地址、组播地址和任播地址。</p>
<p>单播地址又分为全球单播地址（2000::/3）、唯—本地地址(FD00::/8)、链路本地地址(FE80::/10)、特殊地址、其他单播地址。</p>
<h3 id="IPv6单播地址"><a href="#IPv6单播地址" class="headerlink" title="IPv6单播地址"></a>IPv6单播地址</h3><h4 id="IPv6单播地址结构"><a href="#IPv6单播地址结构" class="headerlink" title="IPv6单播地址结构"></a>IPv6单播地址结构</h4><ul>
<li><p>一个IPv6单播地址可以分为如下两部分:</p>
<p>1.网络前缀(Network Prefix ) : n bit，相当于IPv4地址中的网络ID。</p>
<p>2.接口标识( Interface identify ) : ( 128-n ) bit ，相当于IPv4地址中的主机ID。</p>
</li>
<li><p>常见的IPv6单播地址如全球单播地址、链路本地地址等，要求网络前缀和接口标识必须为64 bit。</p>
</li>
</ul>
<h4 id="IPv6单播地址接口标识"><a href="#IPv6单播地址接口标识" class="headerlink" title="IPv6单播地址接口标识"></a>IPv6单播地址接口标识</h4><p>接口标识可通过三种方法生成：手工配置、系统自动生成或通过IEEE EUI-64规范生成</p>
<p>其中EUl-64规范最为常用，此规范将MAC地址从中间劈开插入FFFE且第7bit取反得到IPv6接口标识。</p>
<p><img src="/2021/04/26/IPv6/EUI-64%E8%A7%84%E8%8C%83.png" alt="EUI-64规范"></p>
<h4 id="IPv6单播地址-GUA"><a href="#IPv6单播地址-GUA" class="headerlink" title="IPv6单播地址-GUA"></a>IPv6单播地址-GUA</h4><p>GUA ( Global Unicast Address，全球单播地址)，也被称为可聚合全球单播地址。该类地址全球唯一，用于需要有互联网访问需求的主机，相当于IPv4的公网地址。</p>
<p><img src="/2021/04/26/IPv6/GUI.png" alt="GUI"></p>
<ul>
<li>通常GUA的网络部分长度为64 bit，接口标识也为64 bit。</li>
<li>全局路由前缀:由提供商指定给一个组织机构，一般至少为45 bit。</li>
<li>子网ID:组织机构根据自身网络需求划分子网。·接口标识:用来标识一个设备（的接口)。</li>
</ul>
<h4 id="IPv6常见单播地址-ULA"><a href="#IPv6常见单播地址-ULA" class="headerlink" title="IPv6常见单播地址-ULA"></a>IPv6常见单播地址-ULA</h4><p>ULA ( Unique Local Address，唯一本地地址）是IPv6私网地址，只能够在内网中使用。该地址空间在IPv6公网中不可被路由，因此不能直接访问公网。</p>
<p><img src="/2021/04/26/IPv6/ULA.png" alt="ULA"></p>
<ul>
<li>唯一本地地址使用FCOO::/7地址块，目前仅使用了FDO0:/8地址段。FCOO::/8预留为以后拓展用。 </li>
<li>ULA虽然只在有限范围内有效，但也具有全球唯一的前缀（虽然随机方式产生，但是冲突概率很低）。</li>
</ul>
<h4 id="lPv6常见单播地址-LLA"><a href="#lPv6常见单播地址-LLA" class="headerlink" title="lPv6常见单播地址-LLA"></a>lPv6常见单播地址-LLA</h4><p>LLA ( Link-Local Address，链路本地地址）是IPv6中另一种应用范围受限制的地址类型。LLA的有效范围是本地链路，前缀为FE80::/10。</p>
<p><img src="/2021/04/26/IPv6/LLA.png" alt="LLA"></p>
<ul>
<li>LLA用于一条单一链路层面的通信，例如IPv6地址无状态自动配置、IPv6邻居发现等。</li>
<li>源或目的IPv6地址为链路本地地址的数据包将不会被转发到始发的链路之外，换句话说，链路本地地址的有效范围为本地链路。</li>
<li>每一个IPv6接口都必须具备一个链路本地地址。华为设备支持自动生成和手工指定两种配置方式。</li>
</ul>
<h3 id="IPv6组播地址"><a href="#IPv6组播地址" class="headerlink" title="IPv6组播地址"></a>IPv6组播地址</h3><ul>
<li><p>IPv6组播地址标识多个接口，一般用于“一对多”的通信场景。</p>
</li>
<li><p>IPv6组播地址只可以作为IPv6报文的目的地址。</p>
</li>
</ul>
<p><img src="/2021/04/26/IPv6/IPv6%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80.png" alt="IPv6组播地址"></p>
<pre><code>Flags:用来表示永久或临时组播组。
Scope:表示组播组的范围。
Group ID:组播组ID。
</code></pre>
<p><img src="/2021/04/26/IPv6/%E7%BB%84%E6%92%AD.png" alt="组播"></p>
<h4 id="被请求节点组播地址"><a href="#被请求节点组播地址" class="headerlink" title="被请求节点组播地址"></a>被请求节点组播地址</h4><p>当一个节点具有了单播或任播地址，就会对应生成一个被请求节点组播地址，并且加入这个组播组。该地址主要用于邻居发现机制和地址重复检测功能。被请求节点组播地址的有效范围为本地链路范围。</p>
<p><img src="/2021/04/26/IPv6/%E8%A2%AB%E8%AF%B7%E6%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80.png" alt="被请求节点的组播地址"></p>
<h3 id="任播地址"><a href="#任播地址" class="headerlink" title="任播地址"></a>任播地址</h3><ul>
<li>任播地址标识一组网络接口（通常属于不同的节点)。</li>
<li>任播地址可以作为IPv6报文的源地址，也可以作为目的地址。</li>
</ul>
<p><img src="/2021/04/26/IPv6/%E4%BB%BB%E6%92%AD.png" alt="任播"></p>
<h2 id="IPv6地址配置"><a href="#IPv6地址配置" class="headerlink" title="IPv6地址配置"></a>IPv6地址配置</h2><h3 id="主机和路由器的IPv6地址"><a href="#主机和路由器的IPv6地址" class="headerlink" title="主机和路由器的IPv6地址"></a>主机和路由器的IPv6地址</h3><p>一般情况下，主机和路由器的单播IPv6地址以及加入的组播地址如下所示:</p>
<p><img src="/2021/04/26/IPv6/%E5%9C%B0%E5%9D%80%E7%A4%BA%E4%BE%8B.png"></p>
<h3 id="lPv6单播地址业务流程"><a href="#lPv6单播地址业务流程" class="headerlink" title="lPv6单播地址业务流程"></a>lPv6单播地址业务流程</h3><p>一个接口在发送IPv6报文之前要经历地址配置、DAD、地址解析这三个阶段，NDP ( Neighbor Discovery Protocol，邻居发现协议)扮演了重要角色。</p>
<p><img src="/2021/04/26/IPv6/%E6%B5%81%E7%A8%8B.png" alt="流程"></p>
<h3 id="NDP"><a href="#NDP" class="headerlink" title="NDP"></a>NDP</h3><ul>
<li>RFC2461定义了NDP，该RFC后来被RFC4861替代。</li>
<li>NDP使用ICMPv6报文实现其功能。</li>
</ul>
<p><img src="/2021/04/26/IPv6/NDP.png" alt="NDP"></p>
<h3 id="IPv6动态配置地址"><a href="#IPv6动态配置地址" class="headerlink" title="IPv6动态配置地址"></a>IPv6动态配置地址</h3><h4 id="有状态地址配置"><a href="#有状态地址配置" class="headerlink" title="有状态地址配置"></a>有状态地址配置</h4><p><img src="/2021/04/26/IPv6/%E6%9C%89%E7%8A%B6%E6%80%81%E5%9C%B0%E5%9D%80%E9%85%8D%E7%BD%AE.png" alt="有状态地址配置"></p>
<ul>
<li>通过DHCPv6报文交互，DHCPv6服务器端自动配置IPv6地址/前缀及其他网络配置参数(DNS、NIS.SNTP服务器地址等参数)。</li>
</ul>
<h4 id="无状态地址配置"><a href="#无状态地址配置" class="headerlink" title="无状态地址配置"></a>无状态地址配置</h4><p><img src="/2021/04/26/IPv6/%E6%97%A0%E7%8A%B6%E6%80%81%E5%9C%B0%E5%9D%80%E9%85%8D%E7%BD%AE.png" alt="无状态地址配置"></p>
<ul>
<li>主机根据RA中的地址前缀，并结合本地生成的64 bit接口标识（例如EUI-64 )，生成单播地址。</li>
<li>仅可以获得IPv6地址信息，无法获得NIS、SNTP服务器等参数，需要配合DHCPv6或者手工配置来获取其他配置信息。</li>
</ul>
<h3 id="DAD"><a href="#DAD" class="headerlink" title="DAD"></a>DAD</h3><p>DAD ( Duplicate Address Detection，重复地址检测）类似于IPv4中的免费ARP检测,用于检测当前地址是否与其他接口冲突。</p>
<p>无论通过何种方式配置了IPv6单播地址，主机或路由器都会:</p>
<ul>
<li>通过ICMPv6报文进行DAD</li>
<li>仅当DAD通过之后才会使用该单播地址</li>
</ul>
<p><img src="/2021/04/26/IPv6/DAD.png" alt="DAD"></p>
<h3 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h3><p>lPv6使用ICMPv6的NS和NA报文来取代ARP在IPv4中的地址解析功能。</p>
<p><img src="/2021/04/26/IPv6/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90.png" alt="地址解析"></p>
<h2 id="IPv6地址配置基础命令"><a href="#IPv6地址配置基础命令" class="headerlink" title="IPv6地址配置基础命令"></a>IPv6地址配置基础命令</h2><p>1.使能lPv6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] ipv6</span><br></pre></td></tr></table></figure>
<p>使能设备转发IPv6单播报文，包括本地IPv6报文的发送与接收。[Huawei-GigabitEtherneto/o/0] ipv6 enable<br>在接口视图下，在接口上使能该接口的IPv6功能。</p>
<p>2.配置接口的链路本地地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] ipv6 address ipv6-address link-local</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] ipv6 address auto link-local</span><br></pre></td></tr></table></figure>
<p>在接口视图下，通过手工或者自动的方式，配置接口的链路本地地址。</p>
<p>3.配置接口的全球单播地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] ipv6 address &#123; ipv6-address prefix-length l ipv6-address&#x2F; prefix-length &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] ipv6 address auto &#123; global | dhcp &#125;</span><br></pre></td></tr></table></figure>

<p>在接口视图下，通过手工或者自动（有状态或无状态）的方式，配置接口的全球单播地址。<br>4.配置lPv6静态路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] ipv6 route-static dest-ipv6-address prefix-length &#123; interface-type interface-number [ nexthop-ipv6-address ] | nexthop-ipv6-address &#125; [ preference preference j</span><br></pre></td></tr></table></figure>
<p>5.查看接口的IPv6信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] display ipv6 interface [ interface-type interface-number | brief ]</span><br></pre></td></tr></table></figure>
<p>6.查看邻居表项信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] display ipv6 neighbors</span><br></pre></td></tr></table></figure>
<p>7.使能系统发布RA报文功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;0]undo ipv6 nd ra halt</span><br></pre></td></tr></table></figure>
<p>默认情况下，华为路由器接口不发送ICMPv6 RA报文，则该接口所连链路上的其他设备无法进行无状态地址自动配置。若想进行IPv6无状态地址配置，需要手工开启发送RA报文。</p>
<h2 id="IPv6配置案例-配置一个小型IPv6网络"><a href="#IPv6配置案例-配置一个小型IPv6网络" class="headerlink" title="IPv6配置案例-配置一个小型IPv6网络"></a>IPv6配置案例-配置一个小型IPv6网络</h2><p><img src="/2021/04/26/IPv6/IPv6%E6%8B%93%E6%89%91.png" alt="IPv6拓扑"></p>
<h3 id="R1和R2之间使用静态IPv6地址互联。"><a href="#R1和R2之间使用静态IPv6地址互联。" class="headerlink" title="R1和R2之间使用静态IPv6地址互联。"></a>R1和R2之间使用静态IPv6地址互联。</h3><p>1.在R1、R2、R3、R4全局和相关接口使能IPv6功能，同时自动生成链路本地地址（以R1配置为例)</p>
<p>[R1]ipv6<br>[R1]interface GigabitEthernet 0/0/0</p>
<p>[R1-GigabitEthernet0/0/0]ipv6 enable</p>
<p>[R1-GigabitEthernet0/0/0]ipv6 address auto link-local</p>
<p>2.在R1、R2相应接口配置静态IPv6全球单播地址</p>
<p>[R1]interface GigabitEthernet 0/0/0</p>
<p>[R1-GigabitEthernet0/0/0]ipv6 address 2001::1 64    </p>
<p>[R2]interface GigabitEthernet 1/0/0</p>
<p>[R2-GigabitEthernet1/0/0]ipv6 address 2001:2 64</p>
<p>[R2-GigabitEthernet1/0/0]interface GigabitEthernet 0/0/0</p>
<p>[R2-GigabitEtherneto/0/0]ipv6 address 2002::1 64</p>
<p>[R2-GigabitEtherneto/0/0]interface GigabitEthernet 0/0/1</p>
<p>[R2-GigabitEtherneto/0/1]ipv6 address 2003:1 64</p>
<h3 id="R2作为DHCPv6服务器给R3的GE0-0-0分配全球单播地址。"><a href="#R2作为DHCPv6服务器给R3的GE0-0-0分配全球单播地址。" class="headerlink" title="R2作为DHCPv6服务器给R3的GE0/0/0分配全球单播地址。"></a>R2作为DHCPv6服务器给R3的GE0/0/0分配全球单播地址。</h3><p>3.在R2上配置DHCPv6服务器功能，R3接口通过DHCPv6方式获取全球单播地址</p>
<p>[R2]dhcp enable[R2]dhcpv6 pool pool1</p>
<p>[R2-dhcpv6-pool-pool1]address prefix 2002::/64    </p>
<p>[R2]interface GigabitEthernet 0/0/0</p>
<p>[R2-GigabitEtherneto/0/0]dhcpv6 server pool1</p>
<p>[R3]dhcp enable</p>
<p>[R3]interface GigabitEthernet 0/0/0</p>
<p>[R3-GigabitEthernetO/0/0]ipv6 address auto dhcp</p>
<h3 id="R4的GE0-0-0接口通过R2的RA进行无状态地址自动配置。"><a href="#R4的GE0-0-0接口通过R2的RA进行无状态地址自动配置。" class="headerlink" title="R4的GE0/0/0接口通过R2的RA进行无状态地址自动配置。"></a>R4的GE0/0/0接口通过R2的RA进行无状态地址自动配置。</h3><p>4.在R2使能发布RA报文的功能，R4通过无状态地址配置的方式获取地址</p>
<p>[R2]interface GigabitEthernet 0/0/1</p>
<p>[R2-GigabitEthernet0/0/1]undo ipv6 nd ra halt</p>
<p>[R4]interface GigabitEthernet 0/0/0</p>
<p>[R4-GigabitEtherneto/0/0]ipv6 address auto global</p>
<h3 id="配置静态路由-实现各设备之间互访。"><a href="#配置静态路由-实现各设备之间互访。" class="headerlink" title="配置静态路由,实现各设备之间互访。"></a>配置静态路由,实现各设备之间互访。</h3><p>5.在R4上配置静态路由</p>
<p>[R4]ipv6 route-static 2001:: 64 2003::1   </p>
<p>[R4]ipv6 route-static 2002:: 64 2003::1</p>
<p>6.在R1上配置聚合后的静态路由</p>
<p>[R1]ipv6 route-static 2002:: 15 2001::2</p>
<p>7.在R3上配置默认路由</p>
<p>[R3]ipv6 route-static :: 0 2002::1</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/" itemprop="url">以太网链路聚合与交换机堆叠、集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-25T19:02:07+08:00">
                2021-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络可靠性的需求"><a href="#网络可靠性的需求" class="headerlink" title="网络可靠性的需求"></a>网络可靠性的需求</h2><p>网络的可靠性指当设备或者链路出现单点或者多点故障时保证网络服务不间断的能力。</p>
<p>网络的可靠性可以从单板、设备、链路多个层面实现。</p>
<h3 id="单板可靠性"><a href="#单板可靠性" class="headerlink" title="单板可靠性"></a>单板可靠性</h3><ul>
<li>框式交换机由机框、电源模块、风扇模块、主控板(MPU)、交换网板( SFU)、线路板(LPU)构成。</li>
<li>以S1270OE-8为例，设备提供8个线路板槽位、4个交换网板槽位、2个主控板槽位、6个电源模块槽位、4个风扇模块槽位。</li>
<li>框式交换机配置多个主控板、交换网板可保证设备自身的可靠性，单个槽位的交换网板、主控板损坏不影响设备的正常运行。</li>
<li>框式交换机的线路板损坏后，该板卡上的接口无法正常转发数据。</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E5%8D%95%E6%9D%BF%E5%8F%AF%E9%9D%A0%E6%80%A7.png" alt="单板可靠性"></p>
<h3 id="设备可靠性"><a href="#设备可靠性" class="headerlink" title="设备可靠性"></a>设备可靠性</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E8%AE%BE%E5%A4%87%E5%8F%AF%E9%9D%A0%E6%80%A7.png" alt="设备可靠性"></p>
<h3 id="链路可靠性"><a href="#链路可靠性" class="headerlink" title="链路可靠性"></a>链路可靠性</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E9%93%BE%E8%B7%AF%E5%8F%AF%E9%9D%A0%E6%80%A7.png" alt="链路可靠性"></p>
<h2 id="链路聚合技术"><a href="#链路聚合技术" class="headerlink" title="链路聚合技术"></a>链路聚合技术</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>设备之间存在多条链路时，由于STP的存在，实际只会有一条链路转发流量，设备间链路带宽无法得到提升。</p>
</li>
<li><p>以太网链路聚合Eth-Trunk:简称链路聚合，通过将多个物理接口捆绑成为一个逻辑接口，可以在不进行硬件升级的条件下，达到增加链路带宽的目的。</p>
</li>
<li><p>链路聚合模式分为手工模式和LACP模式。</p>
</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/Eth-Trunk.png" alt="Eth-Trunk"></p>
<h3 id="链路聚合基本术语"><a href="#链路聚合基本术语" class="headerlink" title="链路聚合基本术语"></a>链路聚合基本术语</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.png" alt="基本术语"></p>
<h3 id="链路聚合手工模式"><a href="#链路聚合手工模式" class="headerlink" title="链路聚合手工模式"></a>链路聚合手工模式</h3><h4 id="手工模式概述"><a href="#手工模式概述" class="headerlink" title="手工模式概述"></a>手工模式概述</h4><ul>
<li>手工模式: Eth-Trunk的建立、成员接口的加入均由手动配置，双方系统之间不使用LACP进行协商。</li>
<li>正常情况下所有链路都是活动链路，该模式下所有活动链路都参与数据的转发，平均分担流量，如果某条活动链路故障，<br>链路聚合组自动在剩余的活动链路中平均分担流量。</li>
<li>有些低端、老旧设备不支持LACP协议。当聚合的两端设备中存在一个不支持LACP协议时，可以使用手工模式。设备两端使用的链路聚合模式必须相同。</li>
</ul>
<h4 id="手工模式缺陷"><a href="#手工模式缺陷" class="headerlink" title="手工模式缺陷"></a>手工模式缺陷</h4><ol>
<li><p>为了使链路聚合接口正常工作，必须保证本端链路聚合接口中所有成员接口的对端接口：</p>
<ul>
<li>属于同一设备</li>
<li>加入同一链路聚合接口</li>
</ul>
<p>手工模式下，设备间没有报文交互，因此只能通过管理员人工确认。</p>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E6%89%8B%E5%B7%A5%E6%A8%A1%E5%BC%8F%E7%BC%BA%E9%99%B71.png" alt="手工模式缺陷1"></p>
<blockquote>
<p>如图，若不满足条件导致数据转发错误</p>
</blockquote>
</li>
<li><p>手动模式下，因为设备间没有报文交互，因此只能通过管理员人工通过物理层状态判断对端接口是否正常工作。</p>
</li>
</ol>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E6%89%8B%E5%B7%A5%E6%A8%A1%E5%BC%8F%E7%BC%BA%E9%99%B72.png" alt="手工模式缺陷2"></p>
<h3 id="链路聚合LACP模式"><a href="#链路聚合LACP模式" class="headerlink" title="链路聚合LACP模式"></a>链路聚合LACP模式</h3><h4 id="LACP模式概述"><a href="#LACP模式概述" class="headerlink" title="LACP模式概述"></a>LACP模式概述</h4><ul>
<li>LACP模式:采用LACP协议的一种链路聚合模式。设备间通过链路聚合控制协议数据单元( Link Aggregation ControlProtocol Data Unit，LACPDU )进行交互，通过协议协商确保对端是同一台设备、同一个聚合接口的成员接口。</li>
<li>LACPDU报文中包含设备优先级、MAC地址、接口优先级、接口号等。</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/LACPDU.png" alt="LACPDU"></p>
<h4 id="LACPDU报文字段含义"><a href="#LACPDU报文字段含义" class="headerlink" title="LACPDU报文字段含义"></a>LACPDU报文字段含义</h4><h5 id="系统优先级"><a href="#系统优先级" class="headerlink" title="系统优先级"></a>系统优先级</h5><ul>
<li><p>LACP模式下，两端设备所选择的活动接口数目必须保持一致，否则链路聚合组就无法建立。此时可以通过设备优先级使其中一端成为主动端，另一端（被动端）根据主动端选择活动接口。</p>
</li>
<li><p>系统LACP优先级默认32768，越小越优，通常保持默认。当优先级—致时LACP会通过比较MAC地址选择主动端MAC地址越小越优。</p>
</li>
</ul>
<h5 id="接口优先级"><a href="#接口优先级" class="headerlink" title="接口优先级"></a>接口优先级</h5><ul>
<li><p>选出主动端后，两端都会以主动端的接口优先级来选择活动接口，优先级高的接口将优先被选为活动接口。接口LACP优先级值越小，优先级越高。</p>
</li>
<li><p>接口LACP优先级默认为32768，越小越优，通常保持默认，当优先级一致时LACP会通过接口编号选择活动接口,越小越优。</p>
</li>
</ul>
<h3 id="最大活动接口数"><a href="#最大活动接口数" class="headerlink" title="最大活动接口数"></a>最大活动接口数</h3><ul>
<li>LACP模式支持配置最大活动接口数目，当成员接口数目超过最大活动接口数目时会通过比较接口优先级、接口号选举出较优的接口成为活动接口，其余的则成为备份端口（非活动接口)，同时对应的链路分别成为活动链路、非活动链路。交换机只会从活动接口中发送、接收报文。</li>
<li>当活动链路中出现链路故障时，可以从非活动链路中找出一条优先级最高（接口优先级、接口编号比较）的链路替换故障链路，实现总体带宽不发生变化、业务的不间断转发。</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E6%95%85%E9%9A%9C%E9%80%89%E5%8F%96%E8%A7%84%E5%88%99.png" alt="故障选取规则"></p>
<h3 id="链路聚合活动链路的选取过程"><a href="#链路聚合活动链路的选取过程" class="headerlink" title="链路聚合活动链路的选取过程"></a>链路聚合活动链路的选取过程</h3><ol>
<li>sw1、sw2配置LACP模式的链路聚合。两端都设置最大活跃接口数为2。</li>
<li>通过LACPDU选举出优先级较高的交换机SW1，作为LACP协商过程的主动端。</li>
</ol>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E9%80%89%E5%8F%96%E8%BF%87%E7%A8%8B1.png" alt="选取过程1"></p>
<ol start="3">
<li>sW1在本端通过比较接口优先级、接口编号选举出活动接口，其中1、2号接口在相同的接口优先级下拥有更小的接口编号，成为活动接口。</li>
</ol>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E9%80%89%E5%8F%96%E6%B5%81%E7%A8%8B2.png" alt="选取流程2"></p>
<ol start="4">
<li>SW1通过LACPDU将本端活动端口选举结果告知对端。</li>
</ol>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E9%80%89%E5%8F%96%E6%B5%81%E7%A8%8B3.png" alt="选取流程3"></p>
<ol start="5">
<li>SW2依据SW1的选举结果，明确本端的活动接口，同时对应的链路成为活动链路。</li>
</ol>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E9%80%89%E5%8F%96%E6%B5%81%E7%A8%8B4.png" alt="选取流程4"></p>
<ol start="6">
<li>至此，Eth-Trunk的活动链路选举过程完成。</li>
</ol>
<h3 id="负载分担"><a href="#负载分担" class="headerlink" title="负载分担"></a>负载分担</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%88%86%E6%8B%85.png" alt="负载分担"></p>
<h4 id="负载分担模式"><a href="#负载分担模式" class="headerlink" title="负载分担模式"></a>负载分担模式</h4><ul>
<li><p>Eth-trunk支持基于报文的IP地址或MAC地址来进行负载分担，可以配置不同的模式（本地有效，对出方向报文生效)将数据流分担到不同的成员接口上。</p>
</li>
<li><p>常见的模式有:源IP、源MAC、目的IP、目的MAC、源目IP、源目MAC。</p>
</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E8%B4%9F%E8%BD%BD%E5%88%86%E6%8B%85%E6%A8%A1%E5%BC%8F.png" alt="负载分担模式"></p>
<h3 id="链路聚合使用场景"><a href="#链路聚合使用场景" class="headerlink" title="链路聚合使用场景"></a>链路聚合使用场景</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF1.png" alt="使用场景"></p>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF2.png" alt="使用场景"></p>
<h3 id="链路聚合配置命令"><a href="#链路聚合配置命令" class="headerlink" title="链路聚合配置命令"></a>链路聚合配置命令</h3><p>1.创建链路聚合组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] interface eth-trunk trunk-id</span><br></pre></td></tr></table></figure>
<p>创建Eth-Trunk接口，并进入Eth-Trunk接口视图。</p>
<p>2.配置链路聚合模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-Eth-Trunk1] mode &#123;lacp &#x2F; manual load-balance &#125;</span><br></pre></td></tr></table></figure>
<p>Mode lacp配置链路聚合模式为lacp模式，mode manual load-balance配置链路聚合模式为手工模式。注意:需要保持两端链路聚合模式一致。</p>
<p>3.将接口加入链路聚合组中（以太网接口视图)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEtherneto&#x2F;0&#x2F;1] eth-trunk trunk-id</span><br></pre></td></tr></table></figure>
<p>在接口视图下，把接口加入到Eth-Trunk中。</p>
<p>4.将接口加入链路聚合组中（ Eth-Trunk视图)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-Eth-Trunk1] trunkport interface-type &#123; interface-number&#125;</span><br></pre></td></tr></table></figure>
<p>在Eth-Trunk视图中将接口加入到链路聚合组中。3、4两种方式都可以将接口加入到链路聚合组中。</p>
<p>5．使能允许不同速率端口加入同一Eth-Trunk接口的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-Eth-Trunk1] mixed-rate link enable</span><br></pre></td></tr></table></figure>
<p>缺省情况下，设备未使能允许不同速率端口加入同一Eth-Trunk接口的功能，只能相同速率的接口加入到同一个Eth-Trunk接口中。</p>
<p>6.配置系统LACP优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] lacp priority priority</span><br></pre></td></tr></table></figure>
<p>系统LACP优先级值越小优先级越高，缺省情况下，系统LACP优先级为32768。</p>
<p>7.配置接口LACP优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;1] lacp priority priority</span><br></pre></td></tr></table></figure>
<p>在接口视图下配置接口LACP优先级。缺省情况下，接口的LACP优先级是32768。接口优先级取值越小，接口的LACP优先级越高。<br>只有在接口已经加入到链路聚合中才可以配置该命令。</p>
<p>8.配置最大活动接口数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-Eth-Trunk1] max active-linknumber inumber&#125;</span><br></pre></td></tr></table></figure>
<p>配置时需注意保持本端和对端的最大活动接口数一致，只有LACP模式支持配置最大活动接口数。</p>
<p>9.配置最小活动接口数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-Eth-Trunk1] least active-linknumber inumber&#125;</span><br></pre></td></tr></table></figure>
<p>本端和对端设备的活动接口数下限阈值可以不同，手动模式、LACP模式都支持配置最小活动接口数。<br>配置最小活动接口数目的是为了保证最小带宽，当前活动链路数目小于下限阈值时，Eth-Trunk接口的状态转为Down。</p>
<h3 id="链路聚合配置案例"><a href="#链路聚合配置案例" class="headerlink" title="链路聚合配置案例"></a>链路聚合配置案例</h3><ol>
<li><p>手工模式</p>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E6%89%8B%E5%B7%A5%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B.png" alt="手工模式配置案例"></p>
</li>
<li><p>LACP模式</p>
</li>
</ol>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/LACP%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B1.png" alt="LACP模式配置案例1"></p>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/LACP%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B2.png" alt="LACP模式配置案例2"></p>
<h2 id="堆叠、集群"><a href="#堆叠、集群" class="headerlink" title="堆叠、集群"></a>堆叠、集群</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>堆叠（iStack )︰多台支持堆叠特性的交换机通过堆叠线缆连接在一起，从逻辑上变成一台交换设备，作为一个整体参与数据转发。</li>
<li>集群(Cluster Switch System，CSS )∶将两台支持集群特性的交换机设备组合在一起，从逻辑上组合成一台交换设备。</li>
<li>集群只支持两台设备，一般框式交换机支持CSS，盒式设备支持iStack。</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4.png" alt="堆叠、集群"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%98%E5%8A%BF.png" alt="堆叠、集群的优势"></p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A81.png" alt="堆叠、集群的实际应用"></p>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A82.png" alt="堆叠、集群的实际应用"></p>
<ul>
<li>两台设备组成集群，虚拟成单一的逻辑设备。简化后的组网不再需要使用MSTP、VRRP等协议，简化了网络配置，同时依靠跨设备的链路聚合，实现快速收敛，提高了可靠性。</li>
</ul>
<h2 id="三种技术结合的推荐架构"><a href="#三种技术结合的推荐架构" class="headerlink" title="三种技术结合的推荐架构"></a>三种技术结合的推荐架构</h2><p>核心层</p>
<ul>
<li>核心使用CSS集群组网，上下行采用Eth-Trunk，构建高可靠、无环的网络。</li>
</ul>
<p>汇聚层</p>
<ul>
<li>汇聚交换机采用iStack，上下行采用Eth-Trunk，构建高可靠、无环的网络。</li>
</ul>
<p>接入层</p>
<ul>
<li>地理位置接近的接入设备（如一个楼宇内的接入交换机）使用iStack虚拟化成为一台逻辑上的设备，端口数量充足，简化了管理。</li>
<li>使用Eth-Trunk和汇聚层互联，逻辑上网络结构简单，不再需要使用STP、VRRP。具有高可靠性、高上行带宽、快速收敛的优势。</li>
</ul>
<p><img src="/2021/04/25/%E4%BB%A5%E5%A4%AA%E7%BD%91%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A0%86%E5%8F%A0%E3%80%81%E9%9B%86%E7%BE%A4/%E6%8E%A8%E8%8D%90%E6%9E%B6%E6%9E%84.png" alt="推荐架构"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/ACL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/25/ACL/" itemprop="url">ACL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-25T12:18:52+08:00">
                2021-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ACL产生背景"><a href="#ACL产生背景" class="headerlink" title="ACL产生背景"></a>ACL产生背景</h2><p>提供一个工具，实现浏览的过滤。</p>
<p><img src="/2021/04/25/ACL/ACL%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF.png" alt="ACL产生背景"></p>
<h2 id="ACL概述"><a href="#ACL概述" class="headerlink" title="ACL概述"></a>ACL概述</h2><p>访问控制列表ACL（Access Control List）是由一条或多条规则组成的集合。所谓规则，是指描述报文匹配条件的判断语句，这些条件可以是报文的源地址、目的地址、端口号等。</p>
<p> ACL本质上是一种报文过滤器，规则是过滤器的滤芯。设备基于这些规则进行报文匹配，可以过滤出特定的报文，并根据应用ACL的业务模块的处理策略来允许或阻止该报文通过。</p>
<p>ACL技术总是与防火墙、路由策略、QoS、流量过滤、NAT等其他技术结合使用。</p>
<h2 id="ACL的基本概念及其工作原理"><a href="#ACL的基本概念及其工作原理" class="headerlink" title="ACL的基本概念及其工作原理"></a>ACL的基本概念及其工作原理</h2><h3 id="ACL组成"><a href="#ACL组成" class="headerlink" title="ACL组成"></a>ACL组成</h3><p>ACL由若千条permit或deny语句组成。每条语句就是该ACL的一条规则，每条语句中的permit或deny就是与这条规则相对应的处理动作。</p>
<p><img src="/2021/04/25/ACL/ACL%E7%BB%84%E6%88%90.png" alt="ACL组成"></p>
<h3 id="规则编号"><a href="#规则编号" class="headerlink" title="规则编号"></a>规则编号</h3><ul>
<li>规则编号(Rule ID ) :<br>一个ACL中的每一条规则都有一个相应的编号。</li>
<li>步长( Step ) :<br>步长是系统自动为ACL规则分配编号时，每个相邻规则编号之间的差值，缺省值为5。步长的作用是为了方便后续在旧规则之间，插入新的规则。</li>
<li>Rule ID分配规则:<br>系统为ACL中首条未手工指定编号的规则分配编号时，使用步长值（例如步长=5，首条规则编号为5)作为该规则的起始编号;为后续规则分配编号时(若无指定规则编号)，则使用大于当前ACL内最大规则编号且是步长整数倍的最小整数作为规则编号。</li>
</ul>
<p><img src="/2021/04/25/ACL/ACL%E8%A7%84%E5%88%99%E7%BC%96%E5%8F%B7.png" alt="ACL规则编号"></p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul>
<li><p>通配符（Wildcard）是一个32比特长度的数值，用于指示IP地址中，哪些比特位需要严格匹配，哪些比特位无需匹配。</p>
</li>
<li><p>匹配规则为：“0”表示“匹配”；“1”表示“随机分配”</p>
<p>特殊的通配符</p>
<ul>
<li><p>精确匹配192.168.1.1这个IP地址</p>
<p>192.168.1.1 0.0.0.0 = 192.168.1.1 0</p>
</li>
<li><p>匹配所有IP地址<br>0.0.0.0 255.255.255 = any</p>
</li>
</ul>
</li>
<li><p>通配符通常采用类似网络掩码的点分十进制形式表示，但是含义却与网络掩码完全不同。</p>
</li>
</ul>
<p><img src="/2021/04/25/ACL/ACL%E9%80%9A%E9%85%8D%E7%AC%A6.png" alt="ACL通配符"></p>
<h3 id="ACL分类与标识"><a href="#ACL分类与标识" class="headerlink" title="ACL分类与标识"></a>ACL分类与标识</h3><ul>
<li>基于ACL规则定义方式的分类</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>编号范围</th>
<th>规则定义描述</th>
</tr>
</thead>
<tbody><tr>
<td>基本ACL</td>
<td>2000~2999</td>
<td>仅使用报文的源IP地址、分片信息和生效时间段信息来定义规则。</td>
</tr>
<tr>
<td>高级ACL</td>
<td>3000~3999</td>
<td>可使用IPv4报文的源IP地址、目的IP地址、IP协议类型、ICMP类型、TCP源/目的端口号、UDP源/目的端口号、生效时间段等来定义规则。</td>
</tr>
<tr>
<td>二层ACL</td>
<td>4000~4999</td>
<td>使用报文的以太网帧头信息来定义规则，如根据源MAC地址、目的MAC地址、二层协议类型等。</td>
</tr>
<tr>
<td>用户自定义ACL</td>
<td>5000~5999</td>
<td>使用报文头、偏移位置、字符串掩码和用户自定义字符串来定义规则。</td>
</tr>
<tr>
<td>用户ACL</td>
<td>6000~6999</td>
<td>既可使用IPv4报文的源IP地址或源UCL ( User Control List )组，也可使用目的IP地址或目的UCL组、IP协议类型、ICMP类型、TCP源端口/目的端口、UDP源端口/目的端口号等来定义规则。</td>
</tr>
</tbody></table>
<ul>
<li>基于ACL标识方法的分类</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>规则定义描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字型ACL</td>
<td>传统的ACL标识方法。创建ACL时，指定一个唯一的数字标识该ACL。</td>
</tr>
<tr>
<td>命名型ACL</td>
<td>通过名称代替编号来标识ACL。</td>
</tr>
</tbody></table>
<h3 id="基本ACL与高级ACL"><a href="#基本ACL与高级ACL" class="headerlink" title="基本ACL与高级ACL"></a>基本ACL与高级ACL</h3><ul>
<li>基本ACL</li>
</ul>
<p><img src="/2021/04/25/ACL/%E5%9F%BA%E6%9C%ACACL.png" alt="基本ACL"></p>
<ul>
<li>高级ACL</li>
</ul>
<p><img src="/2021/04/25/ACL/%E9%AB%98%E7%BA%A7ACL.png" alt="高级ACL"></p>
<h3 id="ACL的匹配机制"><a href="#ACL的匹配机制" class="headerlink" title="ACL的匹配机制"></a>ACL的匹配机制</h3><p><img src="/2021/04/25/ACL/ACL%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6.png" alt="ACL匹配机制"></p>
<h3 id="ACL匹配位置"><a href="#ACL匹配位置" class="headerlink" title="ACL匹配位置"></a>ACL匹配位置</h3><p>入站(Inbound)及出站(Outbound)方向</p>
<p><img src="/2021/04/25/ACL/ACL%E5%8C%B9%E9%85%8D%E6%96%B9%E5%90%91.png" alt="ACL匹配方向"></p>
<h2 id="ACL应用规则"><a href="#ACL应用规则" class="headerlink" title="ACL应用规则"></a>ACL应用规则</h2><ol>
<li><p>“3P”原则</p>
<p>在路由器上应用ACL时，可以为每种协议（Per Protocol）、每个方向（Per Direction）</p>
<p>和每个接口（Per Interface）配置一个ACL，一般称为“3P原则”。</p>
<p>（1）一个ACL只能基于一种协议，因此每种协议都需要配置单独的ACL。</p>
<p>（2）经过路由器接口的数据有进（ln）和出（Out）两个方向，因此在接口上配置访问控制列表也有进（In）和出（Out）两个方向。每个接口可以配置进方向的ACL，也可以配置出方向的ACL，或者两者都配置，但是一个ACL只能控制一个方向。</p>
<p>（3）一个ACL只能控制一个接口上的数据流量，无法同时控制多个接口上的数据流量。</p>
</li>
<li><p>语句顺序决定了对数据的控制顺序</p>
<p>ACL的语句是一种自上而下的逻辑排列关系。数据匹配过程中是依次对语句进行比较，一旦匹配成功则按照当前语句控制策略处理，不再与之后的语句进行比较。因此，正确的语句顺序才能得到所需的控制效果。</p>
</li>
<li><p>至少有一条允许（Permit）语句</p>
<p>所有ACL的最后一条语句都是隐式拒绝语句，表示当所有语句都无法匹配时，将拒绝数据通过并自动丢弃数据，以防数据意外进入网络。因此，在写“拒绝（deny）”的ACL时，一定至少要有一条允许（Permit）语句，否则配置ACL的接口将拒绝任何数据通过，影响正常的网络通信。</p>
</li>
<li><p>最有限制性的语句应该放在ACL的靠前位置</p>
<p>最有限制性的语句放在ACL的靠前位置，可以首先过滤掉很多不符合条件的数据，节省后面语句的比较时间，从而提高路由器的工作效率。 </p>
</li>
</ol>
<h2 id="ACL基础配置命名"><a href="#ACL基础配置命名" class="headerlink" title="ACL基础配置命名"></a>ACL基础配置命名</h2><p>1.创建基本ACL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] acl [ number ] acl-number [ match-order config ]</span><br></pre></td></tr></table></figure>
<p>使用编号(2000~2999）创建一个数字型的基本ACL，并进入基本ACL视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] acl name acl-name &#123; basic | acl-number &#125; [ match-order config]</span><br></pre></td></tr></table></figure>
<p>使用名称创建一个命名型的基本ACL，并进入基本ACL视图。</p>
<p>2.配置基本ACL的规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-acl-basic-2000] rule [ rule-id ] &#123; deny | permit &#125; [ source &#123; source-address source-wildcard| any &#125; time-range time-name ]</span><br></pre></td></tr></table></figure>
<p>在基本ACL视图下，通过此命令来配置基本ACL的规则。</p>
<p>3.创建高级ACL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] acl [ number ] acl-number [ match-order config ]</span><br></pre></td></tr></table></figure>
<p>使用编号（ 3000~3999 )创建一个数字型的高级ACL，并进入高级ACL视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] acl name acl-name &#123; advance | acl-number &#125; [ match-order config ]</span><br></pre></td></tr></table></figure>
<p>使用名称创建一个命名型的高级ACL，进入高级ACL视图。</p>
<p>4.配置高级ACL的规则</p>
<p>根据IP承载的协议类型不同，在设备上配置不同的高级ACL规则。对于不同的协议类型，有不同的参数组合。<br>当参数protocol为lP时，高级ACL的命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule [ rule-id ] &#123; deny | permit &#125; ip [ destination &#123; destination-address destination-wildcard| any &#125; &#x2F; source &#123; source-addresssource-wildcard | any &#125; &#x2F; time-range time-name| [ dscp dscp | [ tos tos | precedence precedence]]]</span><br></pre></td></tr></table></figure>
<p>在高级ACL视图下，通过此命令来配置高级ACL的规则。<br>当参数protocol为TCP时，高级ACL的命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule [ rule-id] &#123; deny | permit &#125; &#123; protocol-number| tcp &#125; [ destination &#123; destination-address destination-wildcard l any &#125;ldestination-port &#123; eq port | gt port | t port | range port-start port-end &#125; | source &#123; source-address source-wildcard| any &#125; lsource-port &#123; eq port | gt port | lt port | range port-start port-end &#125; | tcp-flag &#123; ack l fin &#x2F; syn &#125; * &#x2F; time-range time-name ]*</span><br></pre></td></tr></table></figure>
<p>在高级ACL视图下，通过此命令来配置高级ACL的规则。</p>
<p>5.接口视图下应用ACL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEtherneto&#x2F;0&#x2F;1] traffic-filter &#123; inbound | outbound &#125; acl acl-number</span><br></pre></td></tr></table></figure>

<p>在设备接口的入方向或出方向配置ACL</p>
<h2 id="ACL配置案例"><a href="#ACL配置案例" class="headerlink" title="ACL配置案例"></a>ACL配置案例</h2><p>案例1——-拒绝某台机器访问<br>按照下图所示拓扑结构，禁止主机pc2与pc1通信，而允许所有其他流量</p>
<p> <img src="/2021/04/25/ACL/ACL%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B.png" alt="ACL配置案例"></p>
<p>配置思路:<br>    ①在路由器上配置两个端口,设置好ip地址<br>    ②配置好主机的ip/子网掩码/网关<br>    ③在路由器上添加一条访问控制权限,基本acl 2000<br>    ④把这条acl限制规则应用到g0/0/1的端口上(可以称作监听端口)</p>
<p>R1配置:</p>
<p>[Huawei]interface GigabitEthernet 0/0/0                      //为0端口配置ip<br>[Huawei-GigabitEthernet0/0/0] ip address 192.168.1.254 24<br>[Huawei]acl 2000               //进入acl 2000 列表<br>[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0      //定义一条规则 deny代表拒绝 source代表来源 0代表仅此一台<br>[Huawei]interface GigabitEthernet 0/0/1<br>[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.254 24<br>[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000               //用端口1来监听这条规则</p>
<p>测试:</p>
<ol>
<li>pc1 ping pc3 ,    通信成功</li>
<li>pc1 ping pc2,     通信失败</li>
<li>pc2 ping pc3,     通信成功</li>
</ol>
<hr>
<p>案例2——拒绝所有机器访问<br>还是刚才的案例,将</p>
<p>[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0</p>
<p>更改为</p>
<p>[Huawei-acl-basic-2000]rule deny any 即可</p>
<hr>
<p>案例3——-仅允许某台机器访问<br>实验要求:仅允许pc2访问pc1</p>
<blockquote>
<p>根据acl规则4:最有限制性的语句应该放在ACL的靠前位置 和规则3: 至少有一条允许（Permit）语句</p>
</blockquote>
<p>配置如下:<br>[Huawei]interface GigabitEthernet 0/0/0                      //为0端口配置ip<br>[Huawei-GigabitEthernet0/0/0] ip address 192.168.1.254 24<br>[Huawei]acl 2000               //进入acl 2000 列表<br>[Huawei-acl-basic-2000]rule permit source 192.168.2.1 0      //定义一条规则 permit代表拒绝 source代表来源 0代表仅此一台<br>[Huawei-acl-basic-2000]rule deny any             // 拒绝所有访问<br>[Huawei]interface GigabitEthernet 0/0/1<br>[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.254 24<br>[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000               //用端口1来监听这条规则</p>
<hr>
<p>案例4———-拒绝访问ftp或者http服务<br>实验要求: 禁止pc2访问pc1的ftp服务，禁止pc3访问pc1的www服务，所有主机的其他服务不受限制</p>
<blockquote>
<p>ftp与http都是基于tcp协议的,所以我们可以拒绝tcp协议来限制</p>
</blockquote>
<p>R1配置:<br>[Huawei]acl 3000            //拒绝tcp为高级控制,所以3000起<br>[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1     //destination代表目的地地址<br>[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1<br>[Huawei]interface g0/0/1<br>[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 3000 //在接口中应用acl</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/AAA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/24/AAA/" itemprop="url">AAA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-24T19:11:49+08:00">
                2021-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AAA概述"><a href="#AAA概述" class="headerlink" title="AAA概述"></a>AAA概述</h2><p>AAA是Authentication (认证)、Authorization(授权）和Accounting(计费）的简称，是网络安全的一种管理机制，提供了认证、授权、计费三种安全功能。</p>
<p><img src="/2021/04/24/AAA/AAA%E6%A6%82%E8%BF%B0.png" alt="AAA概述"></p>
<h2 id="AAA基本架构"><a href="#AAA基本架构" class="headerlink" title="AAA基本架构"></a>AAA基本架构</h2><p>AAA常见网络架构中包括用户、NAS ( Network Access Server )、AAA服务器(AAA Server ) 。</p>
<ul>
<li>NAS负责集中收集和管理用户的访问请求。</li>
<li>在NAS上会创建多个域来管理用户。不同的域可以关联不同的AAA方案。AAA方案包含认证方案，授权方案，计费方案。</li>
<li>当收到用户接入网络的请求时，NAS会根据用户名来判断用户所在的域，根据该域对应的AAA方案对用户进行管控。</li>
</ul>
<p><img src="/2021/04/24/AAA/AAA%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="AAA基本架构"></p>
<h2 id="Authentication-认证"><a href="#Authentication-认证" class="headerlink" title="Authentication (认证)"></a>Authentication (认证)</h2><p>AAA支持的认证方式有:不认证，本地认证，远端认证。</p>
<ul>
<li>不认证：对用户非常信任，不对其进行合法检查，一般情况下不采用这种方式。 </li>
<li>本地认证：将用户信息配置在网络接入服务器上。本地认证的优点是速度快，可以为运营降低成本，缺点是存储信息量受设备硬件条件限制。 </li>
<li>远端认证：将用户信息配置在认证服务器上。支持通过 RADIUS（Remote Authentication Dial In User Service）协议或 HWTACACS（HuaWei Terminal Access Controller Access Control System）协议进行远端认证。 </li>
</ul>
<p><img src="/2021/04/24/AAA/%E8%AE%A4%E8%AF%81.png" alt="认证"></p>
<h2 id="Authorization-授权）"><a href="#Authorization-授权）" class="headerlink" title="Authorization(授权）"></a>Authorization(授权）</h2><p>AAA支持的授权方式有:不授权，本地授权，远端授权。</p>
<ul>
<li><p>不授权：不对用户进行授权处理。 </p>
</li>
<li><p>本地授权：根据网络接入服务器为本地用户账号配置的相关属性进行授权。 </p>
</li>
<li><p>HWTACACS 授权：由 HWTACACS 服务器对用户进行授权。 </p>
</li>
<li><p>if-authenticated 授权：如果用户通过了认证，而且使用的认证</p>
<p>模式是本地或远端认证，则用户授权通过。 </p>
</li>
<li><p>RADIUS 认证成功后授权：RADIUS 协议的认证和授权是绑定在一起的，不能单独使用 RADIUS 进行授权。 </p>
</li>
</ul>
<p>授权信息包括:所属用户组、所属VLAN、ACL编号等。</p>
<p><img src="/2021/04/24/AAA/%E6%8E%88%E6%9D%83.png" alt="授权"></p>
<h2 id="Accounting-计费）"><a href="#Accounting-计费）" class="headerlink" title="Accounting(计费）"></a>Accounting(计费）</h2><p>计费功能用于<strong>监控授权用户的网络行为和网络资源的使用情况</strong></p>
<p>AAA支持的计费方式有:不计费，远端计费。</p>
<ul>
<li> 不计费：不对用户计费。 </li>
<li>远端计费：支持通过 RADIUS 服务器或 HWTACACS 服务器进行远端计费。 </li>
</ul>
<h2 id="AAA实现-RADIUS-协议"><a href="#AAA实现-RADIUS-协议" class="headerlink" title="AAA实现-RADIUS 协议"></a>AAA实现-RADIUS 协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>远程认证拨号用户服务 RADIUS（Remote Authentication Dial-In User Service）是一种分布式的、客 户端/服务器结构的信息交互协议，能保护网络不受未授权访问的干扰，常应用在既要求较高安全 性、又允许远程用户访问的各种网络环境中。该协议定义了基于 UDP 的 RADIUS 帧格式及其消息 传输机制，并规定 UDP 端口 1812、1813 分别作为认证、计费端口。<br>RADIUS 最初仅是针对拨号用户的 AAA 协议，后来随着用户接入方式的多样化发展，RADIUS 也 适应多种用户接入方式，如以太网接入、ADSL 接入。它通过认证授权来提供接入服务，通过计费 来收集、记录用户对网络资源的使用。 </p>
<h3 id="RADIUS服务器"><a href="#RADIUS服务器" class="headerlink" title="RADIUS服务器"></a>RADIUS服务器</h3><p>RADIUS 服务器一般运行在中心计算机或工作站上，维护相关的用户认证和网络服务访问信息，负 责接收用户连接请求并认证用户，然后给客户端返回所有需要的信息（如接受/拒绝认证请求）。</p>
<p>RADIUS 服务器通常要维护三个数据库：</p>
<p><img src="/2021/04/24/AAA/RADIUS%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="RADIUS数据库"></p>
<p>“Users”：用于存储用户信息（如用户名、口令以及使用的协议、IP 地址等配置信息）。<br>“Clients”：用于存储 RADIUS 客户端的信息（如接入设备的共享密钥、IP 地址等）。<br>“Dictionary”：用于存储 RADIUS 协议中的属性和属性值含义的信息。 </p>
<h3 id="RADIUS客户端"><a href="#RADIUS客户端" class="headerlink" title="RADIUS客户端"></a>RADIUS客户端</h3><p>RADIUS 客户端一般位于网络接入服务器 NAS（Network Access Server）设备上，可以遍布整个网 络，负责传输用户信息到指定的 RADIUS 服务器，然后根据从服务器返回的信息进行相应处理（如 接受/拒绝用户接入）。<br>网络接入服务器作为 RADIUS 协议的客户端，实现以下功能：<br>      标准 RADIUS 协议及扩充属性，包括 RFC2865、RFC2866。<br>      华为扩展的私有属性。<br>      对 RADIUS 服务器状态的主动探测功能。<br>      计费结束报文的本地缓存重传功能。</p>
<p>​      RADIUS 服务器的自动切换功能。 </p>
<h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><p>RADIUS 客户端和 RADIUS 服务器之间认证消息的交互是通过共享密钥的参与来完成的，并且共 享密钥不能通过网络来传输，增强了信息交互的安全性。另外，为防止用户密码在不安全的网络上 传递时被窃取，在传输过程中对密码进行了加密。 </p>
<h3 id="认证和计费消息流程"><a href="#认证和计费消息流程" class="headerlink" title="认证和计费消息流程"></a>认证和计费消息流程</h3><ul>
<li>用户登录网络接入服务器时，会将用户名和密码发送给该网络接入服务器； </li>
<li>该网络接入服务器中的 RADIUS 客户端接收用户名和密码，并向 RADIUS 服务器发送认证请求； </li>
<li>RADIUS 服务器接收到合法的请求后，完成认证，并把所需的用户授权信息返回给客户端； 对于非法的请求，RADIUS 服务器返回认证失败的信息给客户端。 </li>
<li>计费的消息流程和认证/授权的消息流程类似。 </li>
</ul>
<p><img src="/2021/04/24/AAA/RADIUS%E6%B5%81%E7%A8%8B.png" alt="RADIUS流程"></p>
<h2 id="AAA实现-HWTACACS-协议"><a href="#AAA实现-HWTACACS-协议" class="headerlink" title="AAA实现-HWTACACS 协议"></a>AAA实现-HWTACACS 协议</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>HW 终端访问控制器控制系统协议 HWTACACS（Huawei Terminal Access Controller Access Control System）是在 TACACS（RFC 1492）基础上进行了功能增强的安全协议。该协议与 RADIUS 协议 类似，采用客户端/服务器模式实现 NAS 与 HWTACACS 服务器之间的通信。<br>HWTACACS 协议主要用于点对点协议 PPP（Point-to-Point Protocol）和虚拟私有拨号网络 VPDN （Virtual Private Dial-up Network）接入用户及终端用户的认证、授权和计费。其典型应用是对需要 登录到设备上进行操作的终端用户进行认证、授权、计费。设备作为 HWTACACS 的客户端，将 用户名和密码发给 HWTACACS 服务器进行验证。用户验证通过并得到授权之后可以登录到设备 上进行操作。 </p>
<h3 id="HWTACACS-协议和-RADIUS-协议的比较"><a href="#HWTACACS-协议和-RADIUS-协议的比较" class="headerlink" title="HWTACACS 协议和 RADIUS 协议的比较"></a>HWTACACS 协议和 RADIUS 协议的比较</h3><table>
<thead>
<tr>
<th>HWTACACS</th>
<th>RADIUS</th>
</tr>
</thead>
<tbody><tr>
<td>使用TCP，网络传输更可靠</td>
<td>使用UDP</td>
</tr>
<tr>
<td>除了标准的HWTACACS报文头,对报文主体全部进行加密</td>
<td>只是对认证报文中的密码字段进行加密</td>
</tr>
<tr>
<td>认证与授权分离</td>
<td>认证与授权一起处理</td>
</tr>
<tr>
<td>适于进行安全控制</td>
<td>适于进行计费</td>
</tr>
<tr>
<td>支持对设备上的配置命令进行授权使用</td>
<td>不支持</td>
</tr>
</tbody></table>
<h3 id="HWTACACS-的基本消息交互流程"><a href="#HWTACACS-的基本消息交互流程" class="headerlink" title="HWTACACS 的基本消息交互流程"></a>HWTACACS 的基本消息交互流程</h3><p>下面以 Telnet 用户为例，说明使用 HWTACACS 对用户进行认证、授权和计费的过程。</p>
<p><img src="/2021/04/24/AAA/HWTACACS%E8%BF%87%E7%A8%8B.png" alt="HWTACACS过程"></p>
<blockquote>
<p>HWTACACS 协议与其他厂商支持的 TACACS+协议都实现了认证、授权、计费的功能。HWTACACS 和 TACACS+的认证流程与实现方式是一致的，HWTACACS 协议能够完全兼容 TACACS+协议。 </p>
</blockquote>
<h2 id="AAA基于域的用户管理"><a href="#AAA基于域的用户管理" class="headerlink" title="AAA基于域的用户管理"></a>AAA基于域的用户管理</h2><p>一个域是由属于同一个域的用户构成的群体。<br>NAS 设备对用户的管理是基于域的，每个接入用户都属于一个域。用户所属的域是由用户登录时提供的用户名决定的。</p>
<p><img src="/2021/04/24/AAA/AAA%E5%9F%9F.png" alt="AAA域"></p>
<blockquote>
<p>用户的认证、授权、计费都是在相应的域视图下应用预先配置的认证、授权、计费方案来实现的。 AAA 有缺省的认证、授权、计费方案，分别为本地认证、本地授权、本地计费。如果用户所属的 域下未应用任何认证、授权、计费方案，系统将使用缺省的认证、授权、计费方案。 </p>
</blockquote>
<h2 id="AAA配置命令"><a href="#AAA配置命令" class="headerlink" title="AAA配置命令"></a>AAA配置命令</h2><p>1．进入AAA视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] aaa</span><br></pre></td></tr></table></figure>
<p>从系统视图进入AAA视图进行配置<br>2. 创建认证方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa] authentication-scheme authentication-scheme-name</span><br></pre></td></tr></table></figure>
<p>创建认证方案并进入相应的认证方案视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa-authentication-scheme-name] authentication-mode &#123; hwtacacs &#x2F; local | radius &#125;</span><br></pre></td></tr></table></figure>
<p>配置认证方式，local指定认证方式为本地认证。缺省情况下，认证方式为本地认证。<br>3. 创建domain并绑定认证方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa] domain domain-name</span><br></pre></td></tr></table></figure>
<p>创建domain并进入相应的domain视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa-domain-name] authentication-scheme authentication-scheme-name</span><br></pre></td></tr></table></figure>
<p>在相应的domain视图下绑定认证方案<br>4. 创建用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa] local-user user-name password cipher password</span><br></pre></td></tr></table></figure>
<p>创建本地用户，并配置本地用户的密码:<br>如果用户名中带域名分隔符，如@，则认为@前面的部分是用户名，后面部分是域名·如果没有@，则整个字符串为用户名，域为默认域。<br>5. 配置用户接入类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa] local-user user-name service-type &#123; &#123; terminal | telnet | ftp | ssh &#x2F; snmp | http ]&#x2F; ppp | none &#125;</span><br></pre></td></tr></table></figure>
<p>设置本地用户的接入类型。缺省情况下，本地用户关闭所有的接入类型。<br>6. 配置用户级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-aaa] local-user user-name privilege level level</span><br></pre></td></tr></table></figure>
<p>指定本地用户的权限级别。</p>
<ol start="7">
<li>显示历史用户登录记录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei]display aaa offline-record all</span><br></pre></td></tr></table></figure>

<h2 id="AAA配置案例"><a href="#AAA配置案例" class="headerlink" title="AAA配置案例"></a>AAA配置案例</h2><h3 id="AAA-Radius进行认证、授权、计费（使用UDP端口1812和1813）"><a href="#AAA-Radius进行认证、授权、计费（使用UDP端口1812和1813）" class="headerlink" title="AAA+Radius进行认证、授权、计费（使用UDP端口1812和1813）"></a>AAA+Radius进行认证、授权、计费（使用UDP端口1812和1813）</h3><p>下述拓扑中用户处于huawei域中，通过出口设备LSW1去访问Internet，LSW2作为运营商边界设备负责对用户访问internet的权限进行控制，执行AAA认证，认证模式采用Radius服务器认证和计费，现在需要实现ISP对huawei域内的企业用户进行Radius认证，必须在LSW2上配置AAA认证和Radius模板来完成对接入用户的控制。</p>
<p><img src="/2021/04/24/AAA/RADIUS%E6%A1%88%E4%BE%8B.png" alt="RADIUS案例"></p>
<p>在LSW2上的配置如下：</p>
<p>一、配置AAA认证方案</p>
<p>[Huawei]aaa</p>
<p>[Huawei-aaa]authentication-scheme ren_zheng                          配置AAA认证方案名为ren_zheng</p>
<p>[Huawei-aaa-authen-aaa]authentication-mode radius local        配置AAA认证模式为先Radius，如无响应则本地认证</p>
<p>[Huawei-aaa-authen-aaa]quit</p>
<p>[Huawei-aaa]accounting-scheme ji_fei                                       配置AAA计费方案名为ji_fei</p>
<p>[Huawei-aaa-accounting-ji_fei]accounting-mode radius             配置AAA计费模式为Radius服务器计费</p>
<p>[Huawei-aaa-accounting-ji_fei]accounting start-fail offline         配置当开始计费失败时，将用户离线</p>
<p>[Huawei-aaa-accounting-ji_fei]quit</p>
<p>二、配置Radius模板</p>
<p>[Huawei]radius-server template huawei_use                              配置Raduis模板名为huawei_use</p>
<p>[Huawei-radius-huawei_use]radius-server authentication 192.168.1.254 1812    主radius认证服务地址和端口</p>
<p>[Huawei-radius-huawei_use]radius-server authentication 192.168.1.253 1812 secondary  备用认证服务器</p>
<p>[Huawei-radius-huawei_use]radius-server accounting 192.168.1.253 1812         主radius计费服务地址和端口</p>
<p>[Huawei-radius-huawei_use]radius-server accounting 192.168.1.253 1813 secondary       备用计费服务器</p>
<p>[Huawei-radius-huawei_use]radius-server shared-key cipher hello      配置设备与Radius通信的共享秘钥为hello</p>
<p>[Huawei-radius-huawei_use]radius-server retransmit 2 timeout 5       配置设备向Radius服务器发送请求报文的超时重传次数为2s，间隔为5s</p>
<p>[Huawei-radius-huawei_use]quit</p>
<p>三、在AAA用户域绑定要使用的AAA认证和Radius模板</p>
<p>[Huawei]aaa</p>
<p>[Huawei-aaa]domain huawei                   配置AAA域，名称huawei</p>
<p>[Huawei-aaa-domain-huawei]authentication-scheme ren_zheng     在域中绑定AAA认证方案</p>
<p>[Huawei-aaa-domain-huawei]accounting-scheme ji_fei                   在域中绑定AAA计费方案</p>
<p>[Huawei-aaa-domain-huawei]radius-server huawei_use                   在域中绑定Radius模板</p>
<p>[Huawei-aaa-domain-huawei]quit</p>
<p>四、检查命令：</p>
<p><strong>[Huawei]display radius-server configuration template huawei_use</strong></p>
<hr>
<p>  Server-template-name             :  huawei_use<br>  Protocol-version                 :  standard<br>  Traffic-unit                     :  B<br>  Shared-secret-key                :  aaYOZ$V^P35NZPO3JBXBHA!!<br>  Timeout-interval(in second)      :  5<br>  Primary-authentication-server    :  192.168.1.254  :1812 :-LoopBack:NULL   Source-IP:0.0.0.0<br>  Primary-accounting-server        :  192.168.1.254  :1813 :-LoopBack:NULL   Source-IP:0.0.0.0<br>  Secondary-authentication-server  :  192.168.1.253  :1812 :-LoopBack:NULL   Source-IP:0.0.0.0<br>  Secondary-accounting-server      :  192.168.1.253  :1813 :-LoopBack:NULL   Source-IP:0.0.0.0<br>  Retransmission                   :  2<br>  Domain-included                  :  YES<br>  NAS-IP-Address                   :  0.0.0.0</p>
<p>Calling-station-id MAC-format    :  xxxx-xxxx-xxxx</p>
<hr>
<p>[Huawei]</p>
<p><strong>[Huawei]display domain name huawei</strong></p>
<hr>
<p>  Domain-name                     : huawei<br>  Domain-state                      : Active<br>  Authentication-scheme-name      : ren_zheng<br>  Accounting-scheme-name           : ji_fei<br>  Authorization-scheme-name       : -<br>  Service-scheme-name              : -<br>  RADIUS-server-template          : huawei_use<br>  HWTACACS-server-template        : -</p>
<hr>
<p>[Huawei]</p>
<h3 id="AAA-HWTACACS进行认证、授权、计费（默认所有使用TCP端口49）"><a href="#AAA-HWTACACS进行认证、授权、计费（默认所有使用TCP端口49）" class="headerlink" title="AAA+HWTACACS进行认证、授权、计费（默认所有使用TCP端口49）"></a>AAA+HWTACACS进行认证、授权、计费（默认所有使用TCP端口49）</h3><p>拓扑图如下:</p>
<p><img src="/2021/04/24/AAA/RADIUS%E6%A1%88%E4%BE%8B.png" alt="RADIUS案例"></p>
<p>在LSW2上的配置如下：</p>
<p>一、配置AAA认证方案</p>
<p>[Huawei]aaa<br>[Huawei-aaa]authentication-scheme ren_zheng                              配置AAA认证方案名为ren_zheng<br>[Huawei-aaa-authen-aaa]authentication-mode hwtacacs local        配置AAA认证模式为先hwtacacs，如无响应则本地认证<br>[Huawei-aaa-authen-aaa]authentication-super hwtacacs super       接入用户进行提权时，先进行hwtacacs认证，如无响应再本地认证<br>[Huawei-aaa-authen-aaa]quit<br>[Huawei]aaa<br>[Huawei-aaa]authorization-scheme shou_quan                             配置AAA授权方案名为ren_zheng<br>[Huawei-aaa-author-aaa]authorization-mode hwtacacs local        配置AAA授权模式为先hwtacacs，如无响应则本地授权</p>
<p>[Huawei-aaa-author-aaa]quit</p>
<p>[Huawei-aaa]accounting-scheme ji_fei                                    配置AAA计费方案名为ji_fei<br>[Huawei-aaa-accounting-ji_fei]accounting-mode hwtacacs     配置AAA计费模式为hwtacacs服务器计费<br>[Huawei-aaa-accounting-ji_fei]accounting start-fail offline      配置当开始计费失败时，将用户离线<br>[Huawei-aaa-accounting-ji_fei]accounting relaltime 3              配置对用户进行实时计费，计费间隔为3min<br>[Huawei-aaa-accounting-ji_fei]quit</p>
<p>二、配置hwtacacs模板</p>
<p>[Huawei]hwtacacs-server template huawei_use                       配置hwtacacs模板名为huawei_use<br>[Huawei-hwtacacs-huawei_use]hwtacacs-server authentication 192.168.1.254 49    主hwtacacs认证服务地址和端口<br>[Huawei-hwtacacs-huawei_use]hwtacacs-server authentication 192.168.1.253 49 secondary     备用认证服务器<br>[Huawei-hwtacacs-huawei_use]hwtacacs-server authorization 192.168.1.253 49      主hwtacacs授权服务地址和端口<br>[Huawei-hwtacacs-huawei_use]hwtacacs-server authorization 192.168.1.253 49 secondary       备用授权服务器</p>
<p>[Huawei-hwtacacs-huawei_use]hwtacacs-server accounting 192.168.1.253 49         主hwtacacs计费服务地址和端口<br>[Huawei-hwtacacs-huawei_use]hwtacacs-server accounting 192.168.1.253 49 secondary          备用计费服务器</p>
<p>[Huawei-hwtacacs-huawei_use]hwtacacs-server shared-key cipher hello      配置设备与hwtacacs通信的共享秘钥为hello</p>
<p>[Huawei-hwtacacs-huawei_use]quit<br>三、在AAA用户域绑定要使用的AAA认证和hwtacacs模板</p>
<p>[Huawei]aaa<br>[Huawei-aaa]domain huawei                   配置AAA域，名称huawei<br>[Huawei-aaa-domain-huawei]authentication-scheme ren_zheng    在域中绑定AAA认证方案<br>[Huawei-aaa-domain-huawei]authorization-scheme shou_quan     在域中绑定AAA认证方案<br>[Huawei-aaa-domain-huawei]accounting-scheme ji_fei                   在域中绑定AAA计费方案<br>[Huawei-aaa-domain-huawei]hwtacacs-server huawei_use              在域中绑定hwtacacs模板</p>
<p>[Huawei-aaa-domain-huawei]quit</p>
<p>四、检查命令：</p>
<p><strong>[Huawei]display hwtacacs-server template huawei_use</strong></p>
<hr>
<p> HWTACACS-server template name   : huawei_use<br>  Primary-authentication-server  : 192.168.1.254:49:-<br>  Primary-authorization-server    : 192.168.1.254:49-<br>  Primary-accounting-server       : 192.168.1.254:49:-<br>  Secondary-authentication-server : 192.168.1.253:49:-<br>  Secondary-authorization-server   : 192.168.1.253:49:-<br>  Secondary-accounting-server      : 192.168.1.253:49:-<br>  Current-authentication-server   : 192.168.1.254:49:-<br>  Current-authorization-server     : 192.168.1.254:49:-<br>  Current-accounting-server        : 192.168.1.254:49:-<br>  Source-IP-address               : 0.0.0.0<br>  Shared-key                      : hello<br>  Quiet-interval(min)             : 5<br>  Response-timeout-Interval(sec)  : 5<br>  Domain-included                 : Yes<br>  Traffic-unit                    : B</p>
<p>  Total 1,1 printed</p>
<hr>
<p>[Huawei]</p>
<p><strong>[Huawei]display domain name huawei</strong></p>
<hr>
<p>  Domain-name                     : huawei<br>  Domain-state                      : Active<br>  Authentication-scheme-name     : ren_zheng<br>  Accounting-scheme-name          : ji_fei<br>  Authorization-scheme-name       : shou_quan<br>  Service-scheme-name              : -<br>  RADIUS-server-template          : -<br>  HWTACACS-server-template        : huawei_use</p>
<hr>
<p>[Huawei]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/ospf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/23/ospf/" itemprop="url">OSPF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-23T19:37:08+08:00">
                2021-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>路由协议OSPF全称为Open Shortest Path First，也就开放的最短路径优先协议，因为OSPF是由IETF开发的，它的使用不受任何厂商限制，所有人都可以使用，所以称为开放的，而最短路径优先（SPF）只是OSPF的核心思想，其使用的算法是Dijkstra算法，最短路径优先并没有太多特殊的含义，并没有任何一个路由协议是最长路径优先的，所有协议，都会选最短的。</p>
<ul>
<li>OSPF的流量使用IP协议号89。</li>
<li>OSPF工作在单个AS，是个绝对的内部网关路由协议（Interior Gateway Protocol，即IGP）。</li>
<li>OSPF对网络没有跳数限制，支持 Classless Interdomain Routing (CIDR)和Variable-Length Subnet Masks (VLSMs)，没有自动汇总功能，但可以手工在任意比特位汇总，并且手工汇总没有任何条件限制，可以汇总到任意掩码长度。</li>
<li>OSPF支持认证，并且支持明文和MD5认证；OSPF不可以通过Offset list来改变路由的metric。</li>
<li>OSPF并不会周期性更新路由表，而采用增量更新，即只在路由有变化时，才会发送更新，并且只发送有变化的路由信息；事实上，OSPF是间接设置了周期性更新路由的规则，因为所有路由都是有刷新时间的，当达到刷新时间阀值时，该路由就会产生一次更新，默认时间为1800秒，即30分钟，所以OSPF路由的定期更新周期默认为30分钟。</li>
<li>OSPF所有路由的管理距离(Ddministrative Distance)为110，OSPF只支持等价负载均衡。</li>
<li>目前针对IPv4协议使用的是OSPF version 2 ( RFC2328 );针对IPv6协议使用OSPF version 3 ( RFC2740 )。</li>
<li>距离矢量路由协议的根本特征就是自己的 路由表是完全从其它路由器学来的，并且将收到的路由条目一丝不变地放进自己的路由表，运行距离矢量路由协议的路由器之间交换的是路由表，距离矢量路由协议 是没有大脑的，路由表从来不会自己计算，总是把别人的路由表拿来就用；而OSPF完全抛弃了这种不可靠的算法，OSPF是典型的链路状态路由协议，路由器之间交换的并不是路由表，而是链路状态（LS，Link State）信息，OSPF通过获得网络中所有的链路状态信息，从而计算出到达每个目标精确的网络路径。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="Router-id"><a href="#Router-id" class="headerlink" title="Router-id"></a>Router-id</h3><p>必须给每一个OSPF路由器定义一个身份，就相当于人的名字，这就是Router-ID，并且Router-ID在网络中绝对不可以有重名，否则路由器收到的链路状态，就无法确定发起者的身份，也就无法通过链路状态信息确定网络位置，OSPF路由器发出的链路状态都会写上自己的Router-ID，可以理解为该链路状态的签名，不同路由器产生的链路状态，签名绝不会相同。<br>每一台OSPF路由器只有一个Router-ID，Router-ID使用IP地址的形式来表示，确定Router-ID的方法为：<br>1 .手工指定Router-ID。<br>2 .路由器上活动Loopback接口中IP地址最大的，也就是数字最大的，如C类地址优先于B类地址，一个非活动的接口的IP地址是不能被选为Router-ID的。<br>3 .如果没有活动的Loopback接口，则选择活动物理接口IP地址最大的。</p>
<blockquote>
<p>如果一台路由器收到一条链路状态，无法到达该Router-ID的位置，就无法到达链路状态中的目标网络。<br>Router-ID只在OSPF启动时计算，或者重置OSPF进程后计算。</p>
</blockquote>
<h3 id="度量值-Cost"><a href="#度量值-Cost" class="headerlink" title="度量值-Cost"></a>度量值-Cost</h3><p>OSPF使用接口的带宽来计算Metric，每一个激活了OSPF的接口都会维护一个接口Cost值，缺省时，接口Cost值=（100Mbit/s） /（ 接口带宽）。其中100 Mbit/s为OSPF指定的缺省参考值，该值是可配置的。</p>
<p>因为Cost值必须为整数，所以即使是一个1000 Mbit/s（1GBbit/s）的接口，Cost值和100Mbit/s一样，为1。如果路由器要经过两个接口才能到达目标网络，那么很显然，两个接口的Cost值要累加起来，才算是到达目标网络的Metric值，所以OSPF路由器计算到达目标网络的Metric值，必须将沿途中所有接口的Cost值累加起来，在累加时，同EIGRP一样，只计算出接口，不计算进接口。<br>接口带宽</p>
<ul>
<li>OSPF会自动计算接口上的Cost值，但也可以通过手工指定该接口的Cost值，手工指定的优先于自动计算的值。</li>
<li>OSPF计算的Cost，同样是和接口带宽成反比，带宽越高，Cost值越小。到达目标相同Cost值的路径，可以执行负载均衡，最多6条链路同时执行负载均衡。</li>
</ul>
<p><img src="/2021/04/23/ospf/cost%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png" alt="cost计算方法"></p>
<h4 id="度量值修改举例"><a href="#度量值修改举例" class="headerlink" title="度量值修改举例"></a>度量值修改举例</h4><p><img src="/2021/04/23/ospf/5.png"></p>
<h3 id="链路（Link）"><a href="#链路（Link）" class="headerlink" title="链路（Link）"></a>链路（Link）</h3><p>OSPF路由器之间的连接类型，例如帧中继和以太网。</p>
<h3 id="链路状态（Link-State）"><a href="#链路状态（Link-State）" class="headerlink" title="链路状态（Link-State）"></a>链路状态（Link-State）</h3><p>链路状态（LSA）就是OSPF接口上的描述信息，例如接口上的IP地址，子网掩码，网络类型，Cost值等等，OSPF路由器之间交换的并不是路由表，而是链路状态（LSA），OSPF通过获得网络中所有的链路状态信息，从而计算出到达每个目标精确的网络路径。OSPF路由器会将自己所有的链路状态毫不保留地全部发给邻居，邻居将收到的链路状态全部放入链路状态数据库（Link-State Database），邻居再发给自己的所有邻居，并且在传递过程种，绝对不会有任何更改。通过这样的过程，最终，网络中所有的OSPF路 由器都拥有网络中所有的链路状态，并且所有路由器的链路状态应该能描绘出相同的网络拓朴。</p>
<h3 id="OSPF三大表项"><a href="#OSPF三大表项" class="headerlink" title="OSPF三大表项"></a><strong>OSPF三大表项</strong></h3><h4 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h4><p>OSPF有三张重要的表项，OSPF邻居表、LSDB和OSPF路由表。对于OSPF的邻居表，需要了解：</p>
<p>▫OSPF在传递链路状态信息之前，需先建立OSPF邻居关系。</p>
<p>▫OSPF的邻居关系通过交互Hello报文建立。</p>
<p>▫OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看。</p>
<p><img src="/2021/04/23/ospf/1.png"></p>
<h4 id="LSDB"><a href="#LSDB" class="headerlink" title="LSDB"></a>LSDB</h4><p>对于OSPF的LSDB，需要了解：</p>
<p>▫LSDB会保存自己产生的及从邻居收到的LSA信息，本例中R1的LSDB包含了三条LSA。</p>
<p>▫Type标识LSA的类型，AdvRouter标识发送LSA的路由器。</p>
<p>▫使用命令行display ospf lsdb查看LSDB表。</p>
<p><img src="/2021/04/23/ospf/2.png"></p>
<h4 id="OSPF路由表"><a href="#OSPF路由表" class="headerlink" title="OSPF路由表"></a>OSPF路由表</h4><p>对于OSPF的路由表，需要了解：</p>
<p>▫OSPF路由表和路由器路由表是两张不同的表。本例中OSPF路由表有三条路由。</p>
<p>▫OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。</p>
<p>▫使用命令display ospf routing查看OSPF路由表。</p>
<p><img src="/2021/04/23/ospf/3.png"></p>
<h3 id="OSPF区域"><a href="#OSPF区域" class="headerlink" title="OSPF区域"></a>OSPF区域</h3><h4 id="OSPF区域存在作用"><a href="#OSPF区域存在作用" class="headerlink" title="OSPF区域存在作用"></a>OSPF区域存在作用</h4><p>因为OSPF路由器之间会将所有的链路状态（LSA）相互交换，毫不保留，当网络规模达到一定程度时，LSA将形成一个庞大的数据库，势必会给OSPF计算带来巨大的压力；为了能够降低OSPF计算的复杂程度，缓存计算压力，OSPF采用分区域计算，将网络中所有OSPF路由器划分成不同的区域，每个区域负责各自区域精确的LSA传递与路由计算，然后再将一个区域的LSA简化和汇总之后转发到另外一个区域，这样一来，在区域内部，拥有网络精确的LSA，而在不同区域，则传递简化的LSA。区域的划分为了能够尽量设计成无环网络，所以采用了Hub-Spoke的拓朴架构，也就是采用核心与分支的拓朴。</p>
<p><img src="/2021/04/23/ospf/OSPF%E5%8C%BA%E5%9F%9F.png" alt="OSPF区域"></p>
<h4 id="OSPF区域命名和分类"><a href="#OSPF区域命名和分类" class="headerlink" title="OSPF区域命名和分类"></a>OSPF区域命名和分类</h4><p>区域的命名可以采用整数数字，如1、2、3、4，也可以采用IP地址的形式，0.0.0.1、0.0.0.2，因为采用了Hub-Spoke的架构，所以必须定义出一个核心，然后其它部分都与核心相连，OSPF的区域0就是所有区域的核心，称为BackBone 区域（骨干区域），而其它区域称为Normal 区域（常规区域），在理论上，所有的常规区域应该直接和骨干区域相连，常规区域只能和骨干区域交换LSA，常规区域与常规区域之间即使直连也无法互换LSA，如上图中Area 1、Area 2、Area 3、Area 4只能和Area 0互换LSA，然后再由Area 0转发，Area 0就像是一个中转站，两个常规区域需要交换LSA，只能先交给Area 0，再由Area 0转发，而常规区域之间无法互相转发。</p>
<h4 id="OSPF区域划分规则"><a href="#OSPF区域划分规则" class="headerlink" title="OSPF区域划分规则"></a>OSPF区域划分规则</h4><p>OSPF区域是基于路由器的接口划分的，而不是基于整台路由器划分的，一台路由器可以属于单个区域，也可以属于多个区域。</p>
<h3 id="OSPF路由器类型"><a href="#OSPF路由器类型" class="headerlink" title="OSPF路由器类型"></a>OSPF路由器类型</h3><h4 id="区域内部路由器-Internal-Router，IR"><a href="#区域内部路由器-Internal-Router，IR" class="headerlink" title="区域内部路由器(Internal Router，IR)"></a>区域内部路由器(Internal Router，IR)</h4><p>区域内部路由器指路由器本身及与其相连接的网络都属干同一个OSPF 区域。这种路由器只有一个单一的链路拓扑数据库,因为它们只属于一个区域。</p>
<p>区域内部路由器上仅运行其所属区域的OSPF运算法则。</p>
<h4 id="区域边界路由器-Area-Border-Router-，ABR"><a href="#区域边界路由器-Area-Border-Router-，ABR" class="headerlink" title="区域边界路由器(Area Border Router ，ABR)"></a>区域边界路由器(Area Border Router ，ABR)</h4><p>区域边界路由器连接于多个OSPF 区域,所以在一个OSPF 网络中有可能有多个ABR。因此,ABR需要维护多个链路状态数据库实例。ABR为每个区域创建一个汇总数据库,并将其发送到骨干区域中。</p>
<p>那些位于一个或多个OSPF 区域边界并且连接这些区域与骨干网络的路由器叫作区域边界路由器。它们既属于OSPF 区域又属于其他附属区域。ABR 会向骨干区域发送LSA，<strong>ABR必须与骨干区域连接</strong>。</p>
<h4 id="自治系统边界路由器-Autonomous-System-Boundary-Router-，ASBR"><a href="#自治系统边界路由器-Autonomous-System-Boundary-Router-，ASBR" class="headerlink" title="自治系统边界路由器(Autonomous System Boundary Router ，ASBR)"></a>自治系统边界路由器(Autonomous System Boundary Router ，ASBR)</h4><p>与多个自治系统相连的OSPF路由器成为自治系统边界路由器。ASBR在其所属自治系统内部通告得到的外部路由信息。自治系统内的路由器知道如何到达本自治系统的ASBR。一般情况下,ASBR 既运行OSPF 协议,也运行其他协议。ASBR 所存在的区域必须是非末节区域。</p>
<h4 id="骨千路由器（-Border-Router，BR"><a href="#骨千路由器（-Border-Router，BR" class="headerlink" title="骨千路由器（ Border Router，BR)"></a>骨千路由器（ Border Router，BR)</h4><p>如果路由器所有的接口只与骨干区域相连接,这种路由器就被称为骨干路由器(BR)。BR没有与其他区域连接的接口,否则就成了ABR。</p>
<p>该类路由器至少有一个接口属于骨干区域。因此,所有的ABR和位于Area0的内部路由器都是骨干路由器。</p>
<blockquote>
<p>可以配置任何OSPF路由器成为ABR或ASBR。</p>
</blockquote>
<p><img src="/2021/04/23/ospf/%E8%B7%AF%E7%94%B1%E5%99%A8%E8%A7%92%E8%89%B2.png" alt="路由器角色"></p>
<h3 id="OSPF路由类型和选择策略"><a href="#OSPF路由类型和选择策略" class="headerlink" title="OSPF路由类型和选择策略"></a>OSPF路由类型和选择策略</h3><h4 id="区域内部路由（Intra-Area-Route）"><a href="#区域内部路由（Intra-Area-Route）" class="headerlink" title="区域内部路由（Intra-Area Route）"></a>区域内部路由（Intra-Area Route）</h4><p>区域内部路由指目的地址在同一个OSPF 区城之内的路由选择。路由器(类型1)和网络(类型2)链路状态通告（LSA)描述OSPF 区域内拓扑。在OSPF 路由表中,这些区域内部路由条目表示为“O”。</p>
<h4 id="区域间路由（Inter-Area-Route或Summary-Route）"><a href="#区域间路由（Inter-Area-Route或Summary-Route）" class="headerlink" title="区域间路由（Inter-Area Route或Summary Route）"></a>区域间路由（Inter-Area Route或Summary Route）</h4><p>区域间路由指目的地址需要穿过两个或多个OSPF 区域但仍然属于同一个自治系统。网络汇总(类型3)LSA用于描述这种拓扑。当报文在两个非骨干区域间路由的时候，需要使用骨干区域做转发。例如:</p>
<p>(1）从源路由器到区域边界路由器之间需要使用区域内部路径。</p>
<p>(2）从源区域到目的区域需要经过骨干区域。</p>
<p>(3）从目的区域的边界路由器到目的地址之间需要使用区域内部路径。</p>
<p>这三种路由放在一起就形成了区域间路由,在路由表中用“OIA”来表示。</p>
<h4 id="外部路由（External-Route）"><a href="#外部路由（External-Route）" class="headerlink" title="外部路由（External Route）"></a>外部路由（External Route）</h4><p>外部路由是指通过非OSPF 协议获得或从自治系统外获得的路由信息。最常见的情况就是通过其他路由协议的重发布。由于外部路由往往很重要,所以必须保证整个OSPF自治系统都能访问到这些信息。自治系统边界服务器(ASBR)不会汇总这些外部路由信息,但会在整个自治系统中进行浜泛除了末节区域之外的所有路由器都会收到这些信息。</p>
<p>OSPF中使用的外部路由类型如下。<br>(1)El路由:E1路由的度量值是内部加外部的OSPF 度量值总和。例如,如果报文是发往另外一个自治系统的,那么El路由就获得远端自治系统的度量再加上所有内部OSPF度量值。在路由表中用“O E1”来表示。<br>(2)E2路由:E2路由是OSPF外部路由的默认值。这种路由的度量值并不加上内部OSPF 度量值。无论处于哪个自治系统中,都只采用远程AS的度量。例如,如果分组是去往另一个自治系统，E2路由只是加在目的自治系统的度量值。在路由表中用“O E2”来表示。</p>
<h4 id="路由选择策略"><a href="#路由选择策略" class="headerlink" title="路由选择策略"></a>路由选择策略</h4><p>当存在多种路由可以到达同一目的地时，OSPF将根据先后顺序来选择要使用的路由，所有路由的先后顺序为：<br>Intra-Area — Inter-Area — External E1 — External E2，即 O — O IA — O E1 — O E2。</p>
<blockquote>
<p>一台路由器可以运行多个OSPF进程，不同进程的OSPF，可视为没有任何关系，如需要获得相互的路由信息，需要重分布。<br>每个OSPF进程可以有多个区域，而路由器的链路状态数据库是分进程和分区域存放的。</p>
</blockquote>
<h3 id="邻居（Neighbor）"><a href="#邻居（Neighbor）" class="headerlink" title="邻居（Neighbor）"></a>邻居（Neighbor）</h3><p>OSPF只有邻居之间才会交换LSA，路由器会将链路状态数据库中所有的内容毫不保留地发给所有邻居，要想在OSPF路由器之间交换LSA，必须先形成OSPF邻居，OSPF邻居靠发送Hello包来建立和维护，Hello包会在启动了OSPF的接口上周期性发送，在不同的网络中，发送Hello包的间隔也会不同，当超过4倍的Hello时间，也就是Dead时间过后还没有收到邻居的Hello包，邻居关系将被断开。<br>两台OSPF路由器必须满足4个条件，才能形成OSPF邻居，4个必备条件如下：<br><strong>1.Area-id（区域号码）</strong><br>即路由器之间必须配置在相同的OSPF区域，否则无法形成邻居。<br><strong>2.Hello and Dead Interval（Hello时间与Dead时间）</strong><br>即路由器之间的Hello时间和Dead时间必须一致，否则无法形成邻居。<br><strong>3.Authentication（认证）</strong><br>路由器之间必须配置相同的认证密码，如果密码不同，则无法形成邻居。<br><strong>4.Stub Area Flag（末节标签）</strong><br>路由器之间的末节标签必须一致，即处在相同的末节区域内，否则无法形成邻居。</p>
<blockquote>
<p>OSPF只能使用接口的Primary地址建立邻居，不能使用Secondary建立邻居。<br>路由器双方接口要么都为手工配置地址（Numbered），要么都为借用地址（Unnumbered），否则无法建立邻居。</p>
</blockquote>
<h3 id="邻接（Adjacency）"><a href="#邻接（Adjacency）" class="headerlink" title="邻接（Adjacency）"></a>邻接（Adjacency）</h3><p>两台OSPF路由器能够形成邻居，但并不一定能相互交换LSA，只要能交换LSA，关系则称为邻接（Adjacency）。邻居之间只交换Hello包，而邻接（Adjacency）之间不仅交换Hello包，还要交换LSA。</p>
<h3 id="DR-BDR"><a href="#DR-BDR" class="headerlink" title="DR/BDR"></a>DR/BDR</h3><h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p>当多台OSPF路由器连到同一个多路访问网段时，如果每两台路由器之间都相互交换LSA，那么该网段将充满着众多LSA条目，为了能够尽量减少LSA的传播数量，通过在多路访问网段中选择出一个核心路由器，称为DR（Designated Router），网段中所有的OSPF路由器都和DR互换LSA，这样一来，DR就会拥有所有的LSA，并且将所有的LSA转发给每一台路由器；DR就像是该网段的LSA中转站，所有的路由器都与该中转站互换LSA，如果DR失效后，那么就会造成LSA的丢失与不完整，所以在多路访问网络中除了选举出DR之外，还会选举出一台路由器作为DR的备份，称为BDR（Backup Designated Router），BDR在DR不可用时，代替DR的工作，而既不是DR，也不是BDR的路由器称为Drother，事实上，Dother除了和DR互换LSA之外，同时还会和BDR互换LSA。</p>
<p><img src="/2021/04/23/ospf/DR%E5%92%8CBDR.png" alt="DR与BDR"></p>
<p>上图中R1被选为DR，R2被选为BDR，而R3和R4为Drother，R3同时和R1与R2互换LSA，R4也同时和R1与R2互换LSA，但R3与R4却不能互换LSA。<br>其实不难看出，DR与BDR并没有任何本质与功能的区别，只有在多路访问的网络环境，才需要DR和BDR，DR与BDR的选举是在一个二层网段内选举的，即在多个路由器互连的接口范围内，与OSPF区域没有任何关系，一个区域可能有多个多路访问网段，那么就会存在多个DR和BDR，但一个多路访问网段，只能有一个DR和BDR。</p>
<h4 id="选举原则"><a href="#选举原则" class="headerlink" title="选举原则"></a>选举原则</h4><p><strong>比较接口优先级</strong><br>选举优先级最高的成为DR，优先级数字越大，表示优先级越高，被选为DR的几率就越大，次优先级的为BDR，优先级范围是0-255，默认为1，优先级为0表示没有资格选举DR和BDR。<br><strong>Route-Id大小</strong><br>如果在优先级都相同的情况下，Route-Id 最大的成为DR，其次是BDR，数字越大，被选为DR的几率就越大。</p>
<blockquote>
<p>因为所有路由器都能与DR和BDR互换LSA，所以所有路由器都与DR和BDR是邻接（Adjacency）关系，而Drother与Drother之间无法互换LSA，所以Drother与Drother之间只是邻居关系。</p>
</blockquote>
<p>在一个多路访问网络中，选举DR和BDR是有时间限制的，该时间为Wait时间，默认为4倍的Hello时间，即与Dead时间相同，如果OSPF路由器在超过Wait时间后也没有其它路由器与自己竞争DR与BDR的选举，那么就选自己为DR；当一个多路访问网络中选举出DR与BDR之后，在DR与BDR没有失效的情况下，不会进行重新选举，也就是在选举出DR与BDR之后，即使有更高优先级的路由器加入网络，也不会影响DR与BDR的角色，在越出选举时间（Wait时间）后，只有DR与BDR失效后，才会重新选举。DR失效后，会同时重新选举DR与BDR，而在BDR失效后，只会重新选举BDR。</p>
<h4 id="数据包处理原则"><a href="#数据包处理原则" class="headerlink" title="数据包处理原则"></a>数据包处理原则</h4><p>所有OSPF路由器，包括DR与BDR，都能够接收和传递目标地址为224.0.0.5的数据包。<br>只有DR和BDR才能接收和传递目标地址为224.0.0.6的数据包。<br>由此可见，Drother路由器将数据包发向目标地址224.0.0.6，只能被DR和BDR接收，其它Drother不能接收；而DR和BDR将数据包发向目标地址224.0.0.5，可以被所有路由器接收。</p>
<h2 id="OSPF报文格式和类型"><a href="#OSPF报文格式和类型" class="headerlink" title="OSPF报文格式和类型"></a>OSPF报文格式和类型</h2><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>•OSPF一共定义了5种类型的报文，不同类型的OSPF报文有相同的头部格式。</p>
<p>•OSPF报文直接采用IP封装，在报文的IP头部中，协议号为89。</p>
<p><img src="/2021/04/23/ospf/4.png"></p>
<h3 id="数据包类型"><a href="#数据包类型" class="headerlink" title="数据包类型"></a>数据包类型</h3><p>OSPF的5种数据包类型：</p>
<ol>
<li><p>hello 包  </p>
<p>Hello包是用来建立和维护OSPF邻居的，要交换LSA，必须先通过Hello包建立OSPF邻居。</p>
</li>
<li><p>DBD包 （Database Description Packets ） -数据库描述包</p>
<p>描述本地LSDB的摘要信息，用于两台设备进行数据库同步。</p>
<p>邻居建立之后，并不会立刻就将自己链路状态数据库中所有的LSA全部发给邻居，而是将LSA的基本描述信息发给邻居，这就是Database Description Packets （DBD），是LSA的目录信息，相当于书的目录，邻居在看完DBD之后，就能知道哪些LSA是需要邻居发送给自己的。</p>
</li>
<li><p>LSR（Link-state Request）链路状态请求</p>
<p>用于向对方请求所需要的LSA。设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文。</p>
<p>邻居在看完发来的LSA描述信息（DBD）之后，就知道哪些LSA是需要邻居发送给自己的，自己就会向邻居发送LSA请求（LSR），告诉邻居自己需要哪些LSA。</p>
</li>
<li><p>LSU（Link-state update）链路状态更新</p>
<p>用于向对方发送其所需要的LSA。</p>
<p>当邻居收到其它路由器发来的LSA请求（LSR）之后，就知道对方需要哪些LSA，然后根据LSR，将完整的LSA内容全部发给邻居，以供计算路由表。</p>
</li>
<li><p>LSAck（Link-state Ack） 链路状态确认</p>
<p>通知邻居已经收到其发送的LSA。</p>
</li>
</ol>
<p><img src="/2021/04/23/ospf/ospf%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B0%81%E8%A3%85.png" alt="ospf数据包封装"></p>
<h2 id="OSPF-LSDB（链路状态数据库）同步过程"><a href="#OSPF-LSDB（链路状态数据库）同步过程" class="headerlink" title="OSPF LSDB（链路状态数据库）同步过程"></a>OSPF LSDB（链路状态数据库）同步过程</h2><p>路由器从启动OSPF进程，到根据链路状态数据库计算出路由表，同样需要经历一系列的启动过程，总共有8种可能的启动过程，但并不是一定会经历这8个过程，具体过程如下：</p>
<p><strong>Down → Attempt → Init → Two-way → Exstart → Exchange → Loading → Full</strong></p>
<h3 id="Down"><a href="#Down" class="headerlink" title="Down"></a>Down</h3><p>路由器刚刚启动OSPF进程，还没有从任何路由器收到任何数据包，Hello包也没有收到，在此进程，可以向外发送Hello包，以试图发现邻居。</p>
<h3 id="Attempt"><a href="#Attempt" class="headerlink" title="Attempt"></a>Attempt</h3><p>因为OSPF使用组播发送数据包，如使用组播发送Hello包，如果Hello包不能发出去被其它路由器收到，就不能和其它路由器建立OSPF邻居；在一些组播不能发送的网络中，例如帧中继这样的非广播网络环境，组播不能够传递，在这种情况下，就需要指定OSPF使用单播向邻居发送Hello包，以此试图和指定的邻居建立OSPF邻居关系，在此状态下，OSPF称为Attempt状态。</p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><p>只是OSPF路由器一方收到了另一方的Hello，但并没有双方都交换Hello，也就是对方的Hello中还没有将自己列为邻居。</p>
<h3 id="Two-way"><a href="#Two-way" class="headerlink" title="Two-way"></a>Two-way</h3><p>双方都已经交换了Hello信息，并且从Hello中看到对方已经将自己列为邻居，此状态，就表示OSPF邻居关系已经建立，并且如果是需要选举DR和BDR的话，也已经选举出来，但OSPF邻居之间并不一定就会交换LSA，如果不需要交换LSA，则永远停留在此状态，如果需要形成邻接并互相交换LSA，则状态继续往下进行。（比如Drother与Drother之间将永远停留在Two-way状态，因为Drother与Drother之间不需要交换LSA。）</p>
<p><img src="/2021/04/23/ospf/%E9%82%BB%E5%B1%85%E7%9A%84%E5%BB%BA%E7%AB%8B.png" alt="邻居的建立"></p>
<h3 id="Exstart"><a href="#Exstart" class="headerlink" title="Exstart"></a>Exstart</h3><p>因为在OSPF邻居之间交换完整的LSA之前，会先发送Database Description Packets （DBD），Link-state Request （LSR）等数据包，邻居之间是谁先发，谁后发，需要确定顺序，在Exstart状态，就是确定邻居之间的主从关系（Master—Slave关系），Router-ID数字大的为主路由器，另一端为从路由器，由主路由器先向从路由器发送信息。在选举DR与BDR的网络环境中，并不一定DR就是主路由器，BDR就是从路由器，因为DR和BDR可以通过调整接口优先级来控制，所以DR也许是因为优先级比BDR高，而Router-ID并不比BDR高。</p>
<blockquote>
<p>在任何网络环境下，OSPF在交换LSA之前，都需要确定主从关系。</p>
</blockquote>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>就是交换Database Description Packets （DBD）的过程，DBD只是LSA的简单描述，只包含LSA的一些头部信息，收到DBD的路由器会和自己的链路状态数据库作对比，确定需要哪些LSA的完整信息，就会发送LSR请求给邻居。</p>
<p><img src="/2021/04/23/ospf/DBD%E6%8A%A5%E6%96%87%E4%BA%A4%E4%BA%92.png" alt="DBD报文交互"></p>
<h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>邻居根据收到的LSR（Link-State Request），向对方回复Link-state update（LSU）。</p>
<h3 id="Full"><a href="#Full" class="headerlink" title="Full"></a>Full</h3><p>等到OSPF都收到了邻居回复的所有Link-state update（LSU），那么此时的数据库状态就变成了收敛状态，此状态就是Full状态，但此时只是数据库已经同步，但路由表却还在计算当中。</p>
<blockquote>
<p>除了Two-way和Full这两个状态，邻居停留在任何状态，都是不正常。</p>
</blockquote>
<p><img src="/2021/04/23/ospf/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5.png" alt="LSDB同步"></p>
<h2 id="OSPF网络类型（Network-Type）"><a href="#OSPF网络类型（Network-Type）" class="headerlink" title="OSPF网络类型（Network Type）"></a>OSPF网络类型（Network Type）</h2><p>OSPF是一个在各方面都考虑比较周全的路由协议，也会因此将该协议变得更为复杂化，OSPF并不像RIP与EIGRP那样，RIP与EIGRP在运行时，并不考虑OSI模型在二层所定义的内容，即并不关心二层的链路介质类型，而OSPF在运行时，必须考虑链路层的类型，称为OSPF网络类型（Network Type），对于不同二层介质类型，OSPF将有不同的操作和运行过程，网络类型，可分为如下几种：</p>
<ul>
<li>点到点（Point-To-Point）</li>
<li>点到多点（Point-To-Multipoint ）</li>
<li>广播（Broadcast ）</li>
<li>非广播（Non-Broadcast ）</li>
<li>点到多点非广播（Point-To-Multipoint Non-Broadcast）</li>
</ul>
<p>对于不同的网络类型，将会影响到OSPF的Hello时间与Dead时间，关系到DR与BDR的选举与否，影响到OSPF邻居是自动建立还是手工建立，总结如下:</p>
<table>
<thead>
<tr>
<th>网络类型</th>
<th>Hello时间</th>
<th>选举DR/BDR</th>
<th>邻居建立方式</th>
</tr>
</thead>
<tbody><tr>
<td>点到点(p2p)</td>
<td>10s</td>
<td>否</td>
<td>自动</td>
</tr>
<tr>
<td>点到多点(p2mp)</td>
<td>30s</td>
<td>否</td>
<td>自动</td>
</tr>
<tr>
<td>广播(Boradcast)</td>
<td>10s</td>
<td>是</td>
<td>自动</td>
</tr>
<tr>
<td>非广播(Non-B)</td>
<td>30s</td>
<td>是</td>
<td>手工</td>
</tr>
<tr>
<td>点到多点非广播(p2mp-Non-B)</td>
<td>30s</td>
<td>否</td>
<td>手工</td>
</tr>
</tbody></table>
<blockquote>
<p>OSPF网络类型（Network Type）是根据二层链路层的介质决定的，但也可以手工定义网络类型，因此可以在各类型之间手工切换。<br>OSPF邻居的成功建立，并不要求双方网络类型一致，但双方网络类型不一致，将可能导致链路状态数据库中的条目无法进入路由表。</p>
</blockquote>
<h2 id="OSPF链路类型（Link-Type）"><a href="#OSPF链路类型（Link-Type）" class="headerlink" title="OSPF链路类型（Link Type）"></a>OSPF链路类型（Link Type）</h2><p>OSPF确实因为考虑问题的全面，而导致路由协议的复杂，OSPF不仅因为不同的二层链路层介质定义了不同的OSPF网络类型（Network Type），还因为链路上的邻居，而定义了OSPF链路类型（Link Type） 。</p>
<p>OSPF网络类型（Network Type）是完全根据二层链路层的介质决定的，而OSPF链路类型（Link Type）不仅受二层链路层介质的影响，还受到链路中OSPF邻居的影响，同时还影响到LSA，因此变得复杂。</p>
<blockquote>
<p>OSPF链路类型（Link Type）不会影响人们操作OSPF，所以可以选择不深入理解OSPF链路类型（Link Type），但OSPF网络类型（Network Type）却影响到OSPF的操作，OSPF网络类型（Network Type）必须理解和牢记。<br>OSPF链路类型（Link Type）与OSPF网络类型（Network Type）没有对应关系，没有因果关系.</p>
</blockquote>
<p>OSPF链路类型（Link Type）分为以下几种：</p>
<h3 id="Stub-Network-Link"><a href="#Stub-Network-Link" class="headerlink" title="Stub Network Link"></a>Stub Network Link</h3><p>在一个网段中只有一台OSPF路由器的情况下，该网段被OSPF链路类型定义为Stub Network Link；因为一个网段中只有一台OSPF路由器，所以在这个网段就不可能有OSPF邻居，一个接口被通告进OSPF，无论其二层链路是什么介质，只要在该接口上没有OSPF邻居，那么就是Stub Network Link；Loopback接口永远被定义为Stub Network Link，默认使用32位掩码表示，无论将Loopback接口改为哪种OSPF网络类型（Network Type），始终改变不了它的OSPF链路类型（Link Type）属性，但可以改变它在LSA中的掩码长度。</p>
<h3 id="Point-To-Point-Link"><a href="#Point-To-Point-Link" class="headerlink" title="Point-To-Point Link"></a>Point-To-Point Link</h3><p>OSPF网络类型（Network Type）为Point-To-Point的接口，OSPF链路类型（Link Type）为Point-To-Point Link，但Loopback接口除外；而网络类型为点到多点（Point-To-Multipoint）的接口，同样链路类型也为Point-To-Point Link。</p>
<p>Point-To-Point Link可以是手工配置的地址（Numbered），也可以是借用的地址（Unnumbered），也可以是物理接口或逻辑子接口。</p>
<h3 id="Transit-Link"><a href="#Transit-Link" class="headerlink" title="Transit Link"></a>Transit Link</h3><p>拥有两台或两台以上OSPF路由器的链路，简单理解为有邻居的OSPF接口就是Transit Link，但网络类型为Point-To-Point和点到多点（Point-To-Multipoint）的接口除外，因为它们被定义为Point-To-Point Link。</p>
<h3 id="Virtual-link"><a href="#Virtual-link" class="headerlink" title="Virtual link"></a>Virtual link</h3><p>就是OSPF虚链路（Virtual Link），但希奇的是，虚链路（Virtual Link）被定义为手工配置的地址（Numbered）的Point-To-Point Link。</p>
<h2 id="OSPF外部路由"><a href="#OSPF外部路由" class="headerlink" title="OSPF外部路由"></a>OSPF外部路由</h2><p>OSPF同其它路由协议一样，可以将其它外部协议的路由信息或其它OSPF进程的路由信息重分布进自己的域内，这样的路由在OSPF域内就是OSPF外部路由（External Route），在路由表中的表示方法和OSPF自己的路由会有所不同，因为OSPF外部路由可以分为两类，分为Type 2和Type  1，所以在路由表中分别表示为OE2和OE1。</p>
<p>OE2与OE1在路由条目上没有任何区别，只是对于路由的Metric值计算有区别；类型为OE2的外部路由，在该路由进入OSPF之前的Metric值为多少，进入OSPF域后，所有OSPF路由器看到关于该路由的Metric值全部相同，不会再为该路由增加任何Metric值，OE2默认Metric值为20。而OE1的路由在OSPF路由器上的Metric值包含该路由进入OSPF域之前的Metric值，再加上在OSPF域内传递的Metric值，也就是到达外部路由的Metric值为到达ASBR的Metric值再加上进入OSPF域之前的Metric值之和，不同OSPF路由器看到OE1的路由的Metric值可能会有不同。如下图：<br> <img src="/2021/04/23/ospf/ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B11.png" alt="ospf_oe1_oe2"><br>  在上图中，R5将EIGRP重分布进OSPF，如果使用OE2类型重分布进OSPF，并且取默认Metric值20，那么OSPF域内的路由器R1，R2，R3，R4，R5看到外部路由的Metric值全部都为20，不会有任何变化。如果使用OE1类型重分布进OSPF，并且取默认Metric值20，那么OSPF域内的路由器在计算Metric值时，还会在原有Metric值的基础上，再加上到达ASBR（R5）所需的Metric值，假设R1选择从R3到R5再到外部路由，那么R1到外部路由的Metric值为20+1+10=31，所以使用OE2时，R1到外部路由的Metric值为20，而在使用OE1时，R1到外部路由的Metric值为31。</p>
<p>所以必须给每一个OSPF路由器定义一个身份，就相当于人的名字，这就是Router-ID，并且Router-ID在网络中绝对不可以有重名，否则路由器收到的链路状态，就无法确定发起者的身份，也就无法通过链路状态信息确定网络位置，OSPF路由器发出的链路状态都会写上自己的Router-ID，可以理解为该链路状态的签名，不同路由器产生的链路状态，签名绝不会相同。</p>
<p>之前说过，每一台OSPF路由器都有一个Router-ID，在自己产生LSA时，都会在LSA中写上自己的Router-ID，表示LSA的身份，类似于签名，如果一台路由器收到一条链路状态，无法到达该Router-ID的位置，就无法到达链路状态中的目标网络。其实，在同区域内，每台OSPF路由器的Router-ID对于每一台路由器都是可达的，因为同区域内会有精确的LSA信息，包含Router-ID，但需要说明，同区域路由器的Router-ID并不是单独通过LSA来通告的，而是通过精确的LSA计算出来的，也就是说Router-ID的位置是推算出来的，但您放心，这不会有错；因为同区域路由器的Router-ID都有精确的路径信息，所以网络是通畅的，然而，不同区域的OSPF路由器，Router-ID是不知道的，也可以理解为Router-ID不会跨区域传递，那么是否就意味着不同区域的路由是不可达的呢？答案当然是可达的，只要同区域所有路由器可达，那么不同区域自然就是可达的，理由是，不同区域是通过ABR相连的，因为ABR连接着不同区域，所以只要各个区域路由器和ABR是通的，那么不同区域当然可以实现网络连通，所以，ABR在将一个区域的LSA转发至另一个区域时，产生该LSA的Router-ID就不再是原来的Router-ID，会被修改为ABR的Router-ID，这样一来，和ABR相通的路由器只要到达ABR，就能到达其它区域；如下图所示：<br> <img src="/2021/04/23/ospf/ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B12.png" alt="ospf_abr"><br> 上图中，R2和R3是ABR，Area 0一定拥有全网的LSA，R2可以在Area 0与Area 2之间转发LSA，而R3可以在Area  0与Area 1之间转发LSA，但是对于其它区域的路由，R1无法到达，因为R1只有Area  2每台路由器的Router-ID，R4的情况同样如此；最终结果是，R2在将Area 0的LSA转发给Area  2时，已经将所有LSA的Router-ID改成了自己的，所以所有的路由对于R1来说，只要交给ABR（R2）即可，因为R2能够全网可达，在Area 1也是一样，R3在将Area 0的LSA转发给Area  1时，已经将所有LSA的Router-ID改成了自己的，所以所有的路由对于R4来说，只要交给ABR（R3）即可，由此可见，OSPF中，不同区域之间的路由互通，是由于ABR在转发区域是的LSA时，将LSA的Router-ID改成了自己的Router-ID，才使得该区域可以与其它区域通信，如果没有ABR这种自动修改Router-ID的行为，那么OSPF不同区域间将会无法通信。</p>
<p>对于外部路由，执行重分布的路由器同样需要在LSA中写上自己的Router-ID，其实就是ASBR的Router-ID，因为外部路由会在多个OSPF区域之间传递，所以会被多个ABR转发，而ABR在转发外部路由的LSA时，是没有权限修改LSA的Router-ID，这样一来，外部路由的Router-ID在所有OSPF路由器上都不会改变，永远是ASBR的Router-ID，最终造成的结果是只有与ASBR同在一个区域的路由器才能到达外部路由，因为只有与ASBR同在一个区域的路由器才知道如何到达ASBR的Router-ID，而其它区域的路由器对此却无能为力；为了能够让OSPF所有区域都能与外部路由连通，在ABR将外部路由从ASBR所在的区域转发至其它区域时，需要发送单独的LSA来告知如何到达ASBR的Router-ID，因为ABR将外部路由的LSA告诉了其它区域，是有义务让它们与外部路由可达的，所以额外发送了单独的LSA来告知如何到达ASBR的Router-ID；从这里也可以看出，任何一个ASBR所在区域外的其它区域，都必须靠ABR通告一条通往ASBR 的Router-ID的LSA，此LSA就是后面将会详细解释的LSA 类型的第4类。如下图：<br> <img src="/2021/04/23/ospf/ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B13.png" alt="ospf_asbr"></p>
<p> 在上图中，因为ASBR（R4）将外部路由（EIGRP）重分布进OSPF后，自己的Router-ID对于Area  1的所有路由器是可达的，但对于Area 2和Area 0中的路由器是不可达的，所以在ABR将外部路由的LSA发向Area 0和Area  2时，会额外通过单独的LSA 4将ASBR（R4）的Router-ID发向这些区域。</p>
<p>OSPF外部路由有许多是需要理解的地方，外部LSA的Forward  Address是一个其它LSA没有的特征，每一条外部LSA都带有一个Forward  Address，该地址是用来告诉收到此LSA的路由器如何到达外部路由，那么一条外部路由的LSA，Forward  Address究竟该是什么地址呢？在ASBR的路由表中，外部路由的下一跳地址是什么，那么在外部路由的LSA中Forward  Address就是什么，但是OSPF内部路由器是通过Forward Address来到达外部路由的，如果它们连这个Forward  Address都到达不了，比如Forward Address本身就是外部路由而不包含在OSPF进程中，那么可想而知，Forward  Address的意义等于0，所以，如果ASBR的路由表中，外部路由的下一跳地址是OSPF进程自己的路由，那么外部路由LSA的Forward  Address就是该地址，所有OSPF内部路由器则通过该地址去往外部路由，但如果ASBR的路由表中，外部路由的下一跳地址不在OSPF进程中，那么该地址对于其它所有OSPF路由器都不可达，这时，ASBR就将外部路由LSA的Forward Address设置为0.0.0.0，当Forward  Address为0.0.0.0时，所有OSPF路由器通过外部LSA的Router-ID去往外部路由；如下图所示：<br> <img src="/2021/04/23/ospf/ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B14.png" alt="ospf_forward_address"><br>  在上图中，当R5（ASBR）将外部路由EIGRP重分布进OSPF时，因为R5到达外部路由的下一跳地址是56.1.1.6，如果该地址的网段被通告进OSPF进程，那么此时外部路由的Forward  Address就是56.1.1.6，所有OSPF路由器通过去往地址56.1.1.6来去往外部路由；但如果该地址并不在OSPF进程中，那么外部路由的Forward Address就是0.0.0.0，则所有OSPF路由器通过去往ASBR（R5）的Router-ID去往外部路由。</p>
<blockquote>
<p><strong>重分布外部路由时，默认类型为O E2，如果通过两个ASBR能到达相同的外部路由，选择O E1的优先，其次是O  E2，但如果都为O E1或O E2，则选择到达Forward Address最小Metric的路径优先，如果Forward  Address都为0.0.0.0，最后选择到达ASBR最小Metric的路径优先，但如果Forward  Address地址一个为0.0.0.0，一个为真实地址，统一比较到ASBR的Metric。</strong></p>
</blockquote>
<h2 id="OSPF末节区域"><a href="#OSPF末节区域" class="headerlink" title="OSPF末节区域"></a>OSPF末节区域</h2><p>如果路由增加，就意味着LSA的增加，有时，在一个末梢网络中，许多路由信息是多余的，并不需要通告进来，因为一个OSPF区域内的所有路由器都能够通过该区域的ABR去往其它OSPF区域或者OSPF以外的外部网络，既然一个区域的路由器只要知道去往ABR，就能去往区域外的网络，所以可以过滤掉区域外的路由进入某个区域，这样的区域称为OSPF末节区域（Stub Area）；一个末节区域的所有路由器虽然可以从ABR去往区域外的网络，但路由器上还是得有指向ABR的路由，所以末节区域的路由器只需要有默认路由，而不需要明细路由，即可与区域外的网络通信，根据末节区域过滤掉区域外的不同路由，可将末节区域分为如下四类：</p>
<ul>
<li>Stub Area（末节区域）</li>
<li>Totally Stub Area（完全末节区域）</li>
<li>Not-so-Stubby Area（NSSA）</li>
<li>Totally Not-so-Stubby Area（Totally NSSA）</li>
</ul>
<p>各类型的特征如下：</p>
<h3 id="Stub-Area（末节区域）"><a href="#Stub-Area（末节区域）" class="headerlink" title="Stub Area（末节区域）"></a>Stub Area（末节区域）</h3><p>在Stub Area（末节区域）下，ABR将过滤掉所有外部路由进入末节区域，同时，末节区域内的路由器也不可以将外部路由重分布进OSPF进程，即末节区域内的路由器不可以成为ASBR，但其它OSPF区域的路由（Inter-Area Route）可以进入末节区域，由于没有去往外部网络的路由，所以ABR会自动向末节区域内发送一条指向自己的默认路由，如下图：</p>
<p><img src="/2021/04/23/ospf/StubArea.png" alt="Stub Area"></p>
<h3 id="Totally-Stub-Area（完全末节区域）"><a href="#Totally-Stub-Area（完全末节区域）" class="headerlink" title="Totally Stub Area（完全末节区域）"></a>Totally Stub Area（完全末节区域）</h3><p>在Totally Stub Area（完全末节区域）下，ABR将过滤掉所有外部路由和其它OSPF区域的路由（Inter-Area Route）进入完全末节区域，同时，末节区域内的路由器也不可以将外部路由重分布进OSPF进程，即完全末节区域内的路由器不可以成为ASBR，由于没有去往外部网络的路由，所以ABR会自动向完全末节区域内发送一条指向自己的默认路由，如下图：</p>
<p><img src="/2021/04/23/ospf/TotallyStubArea.png" alt="Totally Stub Area"></p>
<blockquote>
<p>可以发现，末节区域与完全末节区域的不同之处在于，末节区域可以允许其它OSPF区域的路由（Inter-Area Route）进入，而完全末节区域却不可以。</p>
</blockquote>
<h3 id="Not-so-Stubby-Area（NSSA）"><a href="#Not-so-Stubby-Area（NSSA）" class="headerlink" title="Not-so-Stubby Area（NSSA）"></a>Not-so-Stubby Area（NSSA）</h3><p>在Not-so-Stubby Area（NSSA）下，ABR将过滤掉所有外部路由进入末节区域，同时也允许其它OSPF区域的路由（Inter-Area Route）进入NSSA区域，并且路由器还可以将外部路由重分布进OSPF进程，即NSSA区域内的路由器可以成为ASBR，由于自身可以将外部网络的路由重分布进OSPF进程，所以ABR不会自动向NSSA区域内发送一条指向自己的默认路由，但可以手工向NSSA域内发送默认路由，并且只可在ABR上发送默认路由；如下图：</p>
<p><img src="/2021/04/23/ospf/Not-so-StubbyArea.png" alt="Not-so-Stubby Area"></p>
<blockquote>
<p>NSSA与末节区域的最大区别在于，NSSA区域可以允许自身将外部路由重分布进OSPF，而末节区域则不可以。</p>
</blockquote>
<h3 id="Totally-Not-so-Stubby-Area（Totally-NSSA）"><a href="#Totally-Not-so-Stubby-Area（Totally-NSSA）" class="headerlink" title="Totally Not-so-Stubby Area（Totally NSSA）"></a>Totally Not-so-Stubby Area（Totally NSSA）</h3><p>在Totally Not-so-Stubby Area（Totally NSSA）下，ABR将过滤掉所有外部路由和其它OSPF区域的路由（Inter-Area Route）进入Totally NSSA区域，但路由器可以将外部路由重分布进OSPF进程，即Totally NSSA区域内的路由器可以成为ASBR，由于没有去往其它OSPF区域的路由，所以ABR会自动向Totally NSSA内发送一条指向自己的默认路由，如下图：</p>
<p><img src="/2021/04/23/ospf/TotallyNot-so-StubbyArea.png" alt="Totally Not-so-Stubby Area"></p>
<blockquote>
<p>Totally NSSA与NSSA的区别在于，NSSA区域可以允许其它OSPF区域的路由（Inter-Area Route）进入，而Totally NSSA区域却不可以，但Totally NSSA区域的ABR会自动向Totally NSSA区域内发送一条指向自己的默认路由。</p>
</blockquote>
<p><strong>总结各区域的特征如下：</strong></p>
<table>
<thead>
<tr>
<th>区域类型</th>
<th>接收区域间路由</th>
<th>ABR是否发送默认路由</th>
<th>是否可以重分布外部路由</th>
</tr>
</thead>
<tbody><tr>
<td>Stub Area</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Totally Stub Area</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>NSSA</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Totally NSSA</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>在末节区域下，ABR自动发出的默认路由，Metric值默认为1，可通过命令area area-id default-cost cost修改，默认路由除了默认的Cost值以外，还会累加真实接口的Cost值。</li>
</ul>
</blockquote>
<ul>
<li>骨干区域不能配置为任何末节区域。</li>
<li>当将某个区域配置为末节区域后，则区域中所有路由器都必须配置为末节区域，因为配置为末节区域的路由器上所有接口发出的Hello包中都会有末节标签，所有如果对方没有末节标签，则不能成为邻居。</li>
</ul>
<h2 id="OSPF-LSA类型"><a href="#OSPF-LSA类型" class="headerlink" title="OSPF LSA类型"></a>OSPF LSA类型</h2><p>OSPF由于有着多种区域类型，多种网络类型，多种链路类型，多种路由器身份，所以LSA（Link-State Advertisements）也是多样的。<br>在详细讲解LSA之前，需要重点说明，只有同一个区域内的LSA，才是精确的，区域外的LSA，并不一定包含所有必备的信息，因此，所有LSA知识信息，并不一定可以套用到每一类LSA。</p>
<p>OSPF中共有11类LSA，而在CCIE的要求中，只需要理解1、2、3、4、5、7共6类即可，这些LSA会因为区域类型，网络类型，链路类型，路由器身份的不同而不同，以下是详细介绍：</p>
<h3 id="类型-1-（Router-Link）"><a href="#类型-1-（Router-Link）" class="headerlink" title="类型 1 （Router Link）"></a>类型 1 （Router Link）</h3><p>类型1的LSA是任何一台OSPF路由器都会产生的，每一台OSPF路由器的每一个OSPF接口都会有自己的链路状态，但是每台OSPF路由器只能产生一条类型1的LSA，即使有多个OSPF接口，也只有一条类型1的LSA，因为所有OSPF接口的链路状态是被打包成一条类型1的LSA发送的。<br>一个区域正是由于LSA 1的存在，才有精确的路由表，一个区域如果只有LSA 1，同样可以正常通信。LSA 1 只能在单个区域内传递，ABR不能将LSA 1转到发另外一个区域，并且没有任何权利修改LSA 1。</p>
<h3 id="类型-2-（Network-Link）"><a href="#类型-2-（Network-Link）" class="headerlink" title="类型 2 （Network Link）"></a>类型 2 （Network Link）</h3><p>类型2的LSA只有在需要选举DR/BDR的网络类型中才会产生，并且只是DR产生，BDR没有权利产生，LSA 2与LSA 1没有任何关联，没有任何依存关系，是相互独立的。</p>
<h3 id="类型-3-（Summary-Link）"><a href="#类型-3-（Summary-Link）" class="headerlink" title="类型 3 （Summary Link）"></a>类型 3 （Summary Link）</h3><p>类型3的LSA就是将一个区域的LSA发向另一个区域时的汇总和简化，ABR其实就是将LSA 1汇总和简化，变成LSA 3后再发到另一个区域的，如果是详细完整的LSA 1，是绝不允许的，LSA 3是LSA 1的缩略版。</p>
<h3 id="类型-4-（ASBR-Summary-Link）"><a href="#类型-4-（ASBR-Summary-Link）" class="headerlink" title="类型 4 （ASBR Summary Link）"></a>类型 4 （ASBR Summary Link）</h3><p>对于外部路由，执行重分布的路由器ASBR在LSA中写上自己的Router-ID，然后传递到多个OSPF区域，所以会被多个ABR转发，而ABR在转发外部路由的LSA时，是没有权限修改LSA的Router-ID，这样一来，外部路由的Router-ID在所有OSPF路由器上都不会改变，永远是ASBR的Router-ID，最终造成的结果是只有与ASBR同在一个区域的路由器才能到达外部路由，因为只有与ASBR同在一个区域的路由器才知道如何到达ASBR的Router-ID，而其它区域的路由器对此却无能为力；为了能够让OSPF所有区域都能与外部路由连通，在ABR将外部路由从ASBR所在的区域转发至其它区域时，需要发送单独的LSA来告知如何到达ASBR的Router-ID，因为ABR将外部路由的LSA告诉了其它区域，是有义务让它们与外部路由可达的，所以额外发送了单独的LSA来告知如何到达ASBR的Router-ID；这个单独的LSA就是类型4的LSA，LSA 4是包含的ASBR 的Router-ID，只要不是ASBR所在的区域，都需要ABR发送LSA 4来告知如何去往ASBR。</p>
<h3 id="类型-5-（External-Link）"><a href="#类型-5-（External-Link）" class="headerlink" title="类型 5 （External Link）"></a>类型 5 （External Link）</h3><p>类型5的LSA就是外部路由重分布进OSPF时产生的，并且是由ASBR产生的，LSA中包含ASBR的Router-ID，任何路由器都不允许更改该Router-ID，LSA 5中还包含Forward Address，对于LSA 5 的Metric值计算与选路规则也有所不同，详细信息请见OSPF外部路由部分。</p>
<h3 id="类型-7-（NSSA-Link）"><a href="#类型-7-（NSSA-Link）" class="headerlink" title="类型 7 （NSSA Link）"></a>类型 7 （NSSA Link）</h3><p>因为NSSA区域可以将外部路由重分布进OSPF进程，而NSSA不是一般的常规区域，所以在NSSA将外部路由重分布进OSPF时，路由信息使用类型7来表示，LSA 7由NSSA区域的ASBR产生，LSA 7也只能在NSSA区域内传递，如果要传递到NSSA之外的其它区域，需要同时连接NSSA与其它区域的ABR将LSA 7 转变成LSA 5后再转发。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>范围</th>
<th>通告者</th>
<th>携带的信息</th>
<th>link-id</th>
<th>通告者ID</th>
</tr>
</thead>
<tbody><tr>
<td>LSA1 router</td>
<td>设备所在区域</td>
<td>该区域的每台设备</td>
<td>本地直连拓扑</td>
<td>通告者的RID</td>
<td>该区域的每台设备</td>
</tr>
<tr>
<td>LSA2 network</td>
<td>设备所在区域</td>
<td>DR</td>
<td>MA网段部分的拓扑</td>
<td>DR的接口ip</td>
<td>DR的RID</td>
</tr>
<tr>
<td>LSA3 Summary</td>
<td>整个OSPF域</td>
<td>ABR</td>
<td>O IA 域间路由</td>
<td>O IA 路由条目的网络号</td>
<td>ABR；经过下一台ABR时，修改为新的ABR RID</td>
</tr>
<tr>
<td>LSA4 asbr-summary</td>
<td>ASBR所在区域外的整个OSPF域</td>
<td>ABR</td>
<td>ASBR位置</td>
<td>ASBR RID</td>
<td>ABR（与ASBR在同一区域）经过下一台ABR时，修改为</td>
</tr>
<tr>
<td>LSA5 External</td>
<td>整个OSPF域</td>
<td>ASBR</td>
<td>O E1/2 域外路由</td>
<td>O E1/2 路由条目的网络号</td>
<td>ASBR-默认在传播过程中不修改</td>
</tr>
<tr>
<td>LSA7nssa-external</td>
<td>单个NSSA区域</td>
<td>ASBR</td>
<td>O N1/2域外路由</td>
<td>O N1/2路由条目的网络号</td>
<td>ASBR-在传递出该NSSA区域后，被新的ASBR转换为5类</td>
</tr>
</tbody></table>
<h2 id="OSPF虚链路（Virtual-Link）"><a href="#OSPF虚链路（Virtual-Link）" class="headerlink" title="OSPF虚链路（Virtual Link）"></a>OSPF虚链路（Virtual Link）</h2><p>因为OSPF采用了区域化的设计，并且区域也采用了Hub-Spoke的架构，所有区域中定义出一个核心，然后其它部分都与核心相连，OSPF的区域0就是所有区域的核心，称为BackBone 区域（骨干区域），而其它Normal 区域（常规区域）应该直接和骨干区域相连，常规区域只能和骨干区域交换LSA，常规区域与常规区域之间即使直连也无法互换LSA，但在某些情况下，某些常规区域无法与骨干区域直连，这时便无法得到其它区域的路由，因此，设计了将骨干区域的范围通过虚拟的方法进行扩展到相邻常规区域的位置，因而让不能直接与骨干区域相连的区域，最终可以与骨干区域直连，这种对骨干虚拟的扩展和拉伸就是OSPF虚链路（Virtual Link）能实现的；因为某些常规区域不能与骨干区域直连而只能与其它常规区域直连，所以OSPF虚链路（Virtual Link）通过将相邻的常规区域虚拟为骨干区域，从而让那些不能与骨干区域直连的常规区域也能获得其它OSPF区域的路由。与骨干区域相邻的常规区域被扩展后，该区域被称为Transit Area，理论上Transit Area不应该为末节区域；在扩展后，原本为常规区域的Transit Area，将变成骨干区域，所以路由将从Inter-Area Route转变为Intra-Area Route，路由表示形式也将从O IA改变为O的形式；在进行OSPF虚链路扩展时，是将Transit Area中与骨干区域直连的ABR和连接另一个常规区域的ABR相连，连接这两个ABR时，使用双方的Router-ID来连接。如下图：</p>
<p><img src="/2021/04/23/ospf/VirtualLink1.png" alt="Virtual Link1"></p>
<p>在上图中，区域2只能与区域1直连，而无法与骨干区域直连，在这种情况下，由于常规区域与常规区域之间即使直连也无法互换LSA，所以R3虽然是ABR，但因为没有连接骨干区域，最后不可能将任何区域的LSA发进区域2，最终导致区域2无法外其它区域通信，在这种情况下，需要通过OSPF虚链路将骨干区域的范围扩展到相邻的区域1，如下图：</p>
<p><img src="/2021/04/23/ospf/VirtualLink2.png" alt="Virtual Link2"></p>
<p>在进行OSPF虚链路扩展后，区域1被虚拟成了骨干区域，而这时的R3等同于连接骨干区域和区域2的ABR，所以可以将自己所有的LSA发进区域2。在扩展OSPF虚链路时，是通过连接R2（ABR）与R3（ABR）的Router-ID 来建立的。<br>因为OSPF虚链路（Virtual Link）能将骨干区域扩展到相邻的常规区域，从而将常规区域虚拟为骨干区域，所以在某些情况下，如公司合并，或者为了备份骨干区域，可能出现骨干区域被常规区域所隔离，如下图：</p>
<p><img src="/2021/04/23/ospf/VirtualLink3.png" alt="Virtual Link3"></p>
<p>图中骨干区域被区域1分割为两部分，将使得骨干区域自己的路由无法相互传递，在使用OSPF虚链路后，可以将区域1也扩展为骨干区域，如下图：</p>
<p><img src="/2021/04/23/ospf/VirtualLink4.png" alt="Virtual Link4"></p>
<p>在经过OSPF虚链路将区域1也扩展为骨干区域后，可见所有的区域都变成了骨干区域，从而使网络中骨干区域能够收到另外一边被分割的骨干区域的路由，并且最后骨干区域自己的路由都为Intra-Area Route，但Area 1与骨干区域的路由将仍然为O IA。</p>
<blockquote>
<p>OSPF虚链路必须是在两个拥有共同区域的ABR之间建立的，其中必须至少有一个ABR是连接骨干的。<br>OSPF虚链路被认为是骨干区域的一个接口，一条链路，也需要建立OSPF邻居，但在邻居建立之后，链路上是没有Hello包传递的。</p>
</blockquote>
<h2 id="OSPF认证"><a href="#OSPF认证" class="headerlink" title="OSPF认证"></a>OSPF认证</h2><p>同RIP和EIGRP一样，出于安全考虑，OSPF也使用了认证，OSPF同时支持明文和MD5认证，在启用OSPF认证后，Hello包中将携带密码，双方Hello包中的密码必须相同，才能建立OSPF邻居关系，需要注意，空密码也是密码的一种。</p>
<p>当OSPF邻居的一方在接口上启用认证后，从该接口发出的Hello包中就会带有密码，双方的Hello包中拥有相同的密码时，邻居方可建立；一台OSPF路由器可能有多个OSPF接口，也可能多个接口在多个OSPF区域，只要在接口上输入OSPF认证的命令后，便表示开启了OSPF认证，可以在每个接口上一个一个启用，也可以一次性开启多个接口的认证，如果需要开启多个接口的认证功能，那么认证的命令就并非直接在接口上输入，而是到OSPF进程模式下输入，并且是对某个区域全局开启的，当在进程下对某个区域开启OSPF认证后，就表示在属于该区域的所有接口上开启了认证。所以，在进程下对区域配置认证，是快速配置多个接口认证的方法，与在多个接口上一个一个开启，没有本质区别。因为OSPF虚链路被认为是骨干区域的一个接口，一条链路，所以在OSPF进程下对骨干区域开启认证后，不仅表示开启了区域0下所有接口的认证，同时也开启了OSPF虚链路的认证，但OSPF虚链路在建立后，并没有Hello包的传递，所以认证在没有重置OSPF进程的情况下，是不会生效的。</p>
<h2 id="OSPF汇总路由"><a href="#OSPF汇总路由" class="headerlink" title="OSPF汇总路由"></a>OSPF汇总路由</h2><p>在OSPF同区域内，LSA是绝对不允许以任何形式或任何手段更改的，但在一个区域与另一个区域之间，LSA可以被ABR修改后传递，从而得知，在同一个区域内，OSPF路由是不能被汇总的，而是当路由从一个区域被ABR转发到另外一个区域时，就可以执行路由汇总，并且汇总必须是在ABR上执行的，但该汇总不对OSPF外部路由生效；在将外部路由重分布进OSPF时，也可以执行路由汇总，此时的汇总必须在ASBR上配置。<br>为了防止路由黑洞，需要在执行路由汇总的路由器上将汇总由指向空接口（null0），在IOS 12.1(6)以后的版本，配置汇总后会自动产生指向空接口的路由，但在IOS 12.1(6)及以前的版本需要手工创建。</p>
<blockquote>
<p>OSPF RFC (1583)并没有规定一个区域适合多少台路由器，一个网段多少个邻居，或如何布署网络。</p>
</blockquote>
<h2 id="OSPF命令配置"><a href="#OSPF命令配置" class="headerlink" title="OSPF命令配置"></a>OSPF命令配置</h2><ol>
<li>(系统视图）创建并运行OSPF进程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] ospf [ process-id \ router-id router-id ]</span><br></pre></td></tr></table></figure>

<p>porcess-id用于标识OSPF进程，默认进程号为1。OSPF支持多进程，在同一台设备上可以运行多个不同的OSPF进程，它们之间互不影响，彼此独立。router-id用于手工指定设备的ID号。如果没有通过命令指定ID号，系统会从当前接口的IP地址中自动选取一个作为设备的ID号。</p>
<ol start="2">
<li>( OSPF视图）创建并进入OSPF区域</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] area area-id</span><br></pre></td></tr></table></figure>

<p>area命令用来创建OSPF区域，并进入OSPF区域视图。<br>area-id可以是十进制整数或点分十进制格式。采取整数形式时，取值范围是0~4294967295。</p>
<ol start="3">
<li><p>(OSPF区域视图）指定运行OSPF的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-ospf-1-area-0.0.0.0] network network-address wildcard-mask</span><br></pre></td></tr></table></figure>

<p>network命令用来指定运行OSPF协议的接口和接口所属的区域。network-address为接口所在的网段地址。wildcard-mask为IP地址的反码，相当于将IP地址的掩码反转（0变1，1变0)，例如0.0.0.255表示掩码长度24 bit。</p>
</li>
<li><p>（接口视图）配置OSPF接口开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GE1&#x2F;0&#x2F;1] ospf cost cost</span><br></pre></td></tr></table></figure>
<p>ospf cost命令用来配置接口上运行OSPF协议所需的开销。缺省情况下，OSPF会根据该接口的带宽自动计算其开销值cost取值范围是1~65535。</p>
</li>
<li><p>(OSPF视图）设置OSPF带宽参考值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-ospf-1] bandwidth-reference value</span><br></pre></td></tr></table></figure>
<p>bandwidth-reference命令用来设置通过公式计算接口开销所依据的带宽参考值。value取值范围是1~2147483648,单位是Mbit/s，缺省值是100Mbit/s。</p>
</li>
<li><p>（接口视图)设置接口在选举DR时的优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] ospf dr-priority priority</span><br></pre></td></tr></table></figure>
<p>ospf dr-priority命令用来设置接口在选举DR时的优先级。priority值越大，优先级越高，取值范围是0~255。缺省为1，值为0代表不参与选举。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/stp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/21/stp/" itemprop="url">STP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-21T21:00:22+08:00">
                2021-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-STP协议概述"><a href="#1-STP协议概述" class="headerlink" title="1.STP协议概述"></a>1.STP协议概述</h3><h5 id="生成树协议产生背景"><a href="#生成树协议产生背景" class="headerlink" title="生成树协议产生背景"></a>生成树协议产生背景</h5><p>生成树协议STP（Spanning Tree Protocol)可以在提高可靠性的同时又能避免环路带来的各种问题。</p>
<p>现网中越来越多的交换机与主机之间互联，如果交换机之间仅使用一条链路进行连接，链路出现故障时，可能导致业务中断。因此使用冗余链路来防止单点故障产生导致网络中断，但引入冗余链路的时候，也引入环路。当然，环路的产生也有可能是人为误操作造成的（如将链路连到本交换机上），因此提出了STP协议用于破除交换机之间的环路，来保证交换机设备的安全和网络可靠性。</p>
<h5 id="环路带来的问题"><a href="#环路带来的问题" class="headerlink" title="环路带来的问题"></a>环路带来的问题</h5><ol>
<li><p>网络风暴</p>
<p>根据交换机的转发原则，如果交换机从一个端口上接收到的是一个广播帧，或者是一个目的MAC地址未知的单播帧，则会将这个帧向除源端口之外的所有其他端口转发。如果交换网络中有环路，则这个帧会被无限转发，此时便会形成广播风暴，网络中也会充斥着重复的数据帧。如下图主机A给主机B发送单播帧，SWB的MAC表上没有目的MAC地址为主机B的地址，因此将从其它两个端口发出，结果将造成两个方向的环路第一条为B-A-C-B，第二条为B-C-A-B，SWB将收到两个相同的单播帧，若MAC表不改变，则循环将一次循环，将造成网络风暴，导致网络带宽占用或设备损坏。若主机A发送广播帧同理。</p>
<p><img src="/2021/04/21/stp/%E7%BD%91%E7%BB%9C%E9%A3%8E%E6%9A%B4.png" alt="网络风暴"></p>
</li>
<li><p>MAC地址表震荡</p>
<p>交换机是根据所接收到的数据帧的源地址和接收端口生成MAC地址表项的。 主机A向外发送一个单播帧，假设此单播帧的目的MAC地址在网络中所有交换机的MAC地址表中都暂时不存在。SWB收到此数据帧之后，在MAC地址表中生成一个MAC地址表项，00-01-02-03-04-AA，对应端口为G0/0/3，并将其从G0/0/1和G0/0/2端口转发。此例仅以SWB从G0/0/1端口转发此帧为例进行说明。 SWA接收到此帧后，由于MAC地址表中没有对应此帧目的MAC地址的表项，所以SWA会将此帧从G0/0/2转发出去。 SWC接收到此帧后，由于MAC地址表中也没有对应此帧目的MAC地址的表项，所以SWC会将此帧从G0/0/2端口发送回SWB，也会发给主机B。 SWB从G0/0/2接口接收到此数据帧之后，会在MAC地址表中删除原有的相关表项，生成一个新的表项，00-01-02-03-04-AA，对应端口为G0/0/2。此过程会不断重复，从而导致MAC地址表震荡。        </p>
<p><img src="/2021/04/21/stp/MAC%E5%9C%B0%E5%9D%80%E5%81%8F%E7%A7%BB.png" alt="MAC地址表震荡"></p>
</li>
</ol>
<h3 id="2-STP协议BUPD报文"><a href="#2-STP协议BUPD报文" class="headerlink" title="2.STP协议BUPD报文"></a>2.STP协议BUPD报文</h3><p>为了计算生成树，交换机之间需要交换相关的信息和参数，这些信息和参数被封装在BPDU（Bridge Protocol Data Unit，网桥协议数据单元）中。 </p>
<ul>
<li><p>BPDU有两种类型：</p>
<ul>
<li><p>配置BPDU (Configuration BPDU)</p>
<p>配置BPDU包含了桥ID、路径开销和端口ID等参数。STP协议通过在交换机之间传递配置BPDU来选举根交换机，以及确定每个交换机端口的角色和状态。在初始化过程中，每个桥都主动发送配置BPDU。</p>
<p>在网络拓扑稳定以后，只有根桥主动发送配置BPDU，其他交换机在收到上游传来的配置BPDU后，才会发送自己的配置BPDU。</p>
</li>
<li><p>TCN BUPD (Topology Change Notification BUPD)    </p>
<p>TCN BPDU是指下游交换机感知到拓扑发生变化时向上游发送的拓扑变化通知。 </p>
</li>
</ul>
</li>
</ul>
<h5 id="BPDU报文字段相关概念"><a href="#BPDU报文字段相关概念" class="headerlink" title="BPDU报文字段相关概念"></a>BPDU报文字段相关概念</h5><ol>
<li><p>BID(Bridge ID,桥ID)</p>
<ul>
<li><p>IEEE 802.1D标准中规定BID由16位的桥优先级（ Bridge Priority )与桥MAC地址构成。</p>
<p>桥优先级（取值范围0～65535），默认值为32768，步长为4096。</p>
</li>
<li><p>每一台运行STP的交换机都拥有一个唯一的BID。</p>
</li>
<li><p>BID桥优先级占据高16bit，其余的低48bit是桥MAC地址。在STP网络中，BID最小的设备会被选举为根桥。</p>
</li>
</ul>
</li>
<li><p>RPC(Root Path cost,根路径开销)</p>
<p>一台设备从某个接口到达根桥的RPC等于从根桥到该设备沿途所有<strong>入方向</strong>接口的Cost累加。</p>
<p>或者是从该设备到根桥沿途所有<strong>出方向</strong>接口的Cost累加。</p>
<p><img src="/2021/04/21/stp/RPC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png" alt="RPC计算方法"></p>
<p>cost(开销):交换机上每个接口都有对应的cost值</p>
<ul>
<li><p>接口的Cost主要用于计算根路径开销，也就是到达根的开销。</p>
</li>
<li><p>接口的缺省Cost除了与其速率、工作模式有关，还与交换机使用的STP Cost计算方法有关。</p>
</li>
<li><p>接口带宽越大，则Cost值越小。</p>
</li>
<li><p>用户也可以根据需要通过命令调整接口的Cost。</p>
</li>
</ul>
<p><img src="/2021/04/21/stp/Cost%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png" alt="cost计算方法" title="cost计算方法"></p>
</li>
<li><p>PID(Port ID,接口ID)</p>
<ul>
<li>接口ID由两部分构成的，高8 bit是接口优先级，低8 bit是接口编号。</li>
<li>激活STP的接口会维护一个缺省的接口优先级（取值范围0到240），在华为交换机上，该值为128，步长为16。</li>
</ul>
</li>
<li><p>Flags</p>
<p>由8位组成。最低位为TC（Topology Change）标志位，最高位位TCA（Topology Change Acknowledge）标志位；其他6位保留。</p>
</li>
<li><p>Message Age</p>
<p>从根桥发送到当前交换机接收到BPDU的总时间，包括传输延时等。如果配置BPDU是根桥发出的，则Message Age为0。实际实现中，配置BPDU报文每经过一个交换机，Message Age增加1。</p>
</li>
<li><p>Max Age</p>
<p>最大寿命，当一段时间未收到任何BPDU，生存期到达最大寿命时，网桥认为该接口连接的链路发生故障。默认20s。</p>
<p>可在根桥上通过命令人为改动这个值，Max Age通过配置BPDU报文的传递，可以保证Max Age在整网中一致。非根桥设备收到配置BPDU报文后，会将报文中的Message Age和Max Age进行比较：如果Message Age小于等于Max Age，则该非根桥设备会继续转发配置BPDU报文。如果Message Age大于Max Age，则该配置BPDU报文将被老化掉。该非根桥设备将直接丢弃该配置BPDU，并认为是网络直径过大，导致了根桥连接失败。</p>
</li>
<li><p>Hello Time</p>
<p>根桥生成配置BPDU的周期，默认时间为2s，指运行STP协议的设备发送配置BPDU的时间间隔，用于检测链路是否存在故障。交换机每隔Hello Time时间会向周围的交换机发送配置BPDU报文，以确认链路是否存在故障。当网络拓扑稳定后，该值只有在根桥上修改才有效。</p>
</li>
<li><p>Forward Delay</p>
<p>端口状态迁移的延时。（配置BPDU传播到全网的最大时延，默认为15s）</p>
</li>
</ol>
<h5 id="配置BPDU报文格式"><a href="#配置BPDU报文格式" class="headerlink" title="配置BPDU报文格式"></a>配置BPDU报文格式</h5><p><img src="/2021/04/21/stp/%E9%85%8D%E7%BD%AEBPDU%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p>
<h5 id="配置BPDU转发过程"><a href="#配置BPDU转发过程" class="headerlink" title="配置BPDU转发过程"></a>配置BPDU转发过程</h5><p><img src="/2021/04/21/stp/%E9%85%8D%E7%BD%AEBPDU%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B.png" alt="配置BPDU转发过程"></p>
<h3 id="3-STP根桥和端口角色"><a href="#3-STP根桥和端口角色" class="headerlink" title="3.STP根桥和端口角色"></a>3.STP根桥和端口角色</h3><h5 id="根桥"><a href="#根桥" class="headerlink" title="根桥"></a>根桥</h5><ul>
<li>在一个广播域中有且只有一个根桥（Root Bridge）</li>
<li>STP的主要作用之一是在整个交换网络中计算出一棵无环的“树”( STP树)</li>
<li>根桥是一个STP交换网络中的“树根”</li>
<li>STP开始工作后，会在交换网络中选举一个根桥，作为无环拓扑的“树根”</li>
</ul>
<h5 id="端口角色"><a href="#端口角色" class="headerlink" title="端口角色"></a>端口角色</h5><p>STP中定义了三种端口角色：指定端口，根端口和预备端口。 </p>
<ul>
<li><p>指定端口(Designated port,DP)</p>
<p>非根桥去往根桥开销最小的接口，接收BPDU，转发数据，学习MAC</p>
<p>指定端口是交换机向所连网段转发配置BPDU的端口，每个网段有且只能有一个指定端口。</p>
<p>一般情况下(除非根桥在物理上存在环路)，根桥的每个端口总是指定端口。</p>
</li>
<li><p>根端口(Root port,RP)</p>
<p>链路上去往根桥开销最小的接口，发送BPDU，转发数据，学习MAC</p>
<p>在一个运行STP协议的交换机上最多只有一个根端口，但根桥上没有根端口。</p>
</li>
<li><p>非指定端口(Non-designated port,N-DP)</p>
<p>非根桥去往根桥开销次优的接口，接收BPDU，不转发数据，不学习MAC，RP的备份接口</p>
<p>如果一个端口既不是指定端口也不是根端口，则此端口为预备端口。预备端口将被阻塞。                                                                                                     </p>
</li>
</ul>
<h3 id="4-STP工作过程"><a href="#4-STP工作过程" class="headerlink" title="4.STP工作过程"></a>4.STP工作过程</h3><ol>
<li><p>在交换网络中选举一个根桥</p>
<ul>
<li><p>STP在交换网络中开始工作后，每个交换机都会向网络中发送配置BPDU。配置BPDU中包含交换机自己的桥ID。</p>
<p>交换机启动后就自动开始进行生成树收敛计算。默认情况下，所有交换机启动时都认为自己是根桥，自己的所有端口都为指定端口，这样BPDU报文就可以通过所有端口转发。对端交换机收到BPDU报文后，会比较BPDU中的根桥ID和自己的桥ID。如果收到的BPDU报文中的桥ID优先级低，接收交换机会继续通告自己的配置BPDU报文给邻居交换机。如果收到的BPDU报文中的桥ID优先级高，则交换机会修改自己的BPDU报文的根桥ID字段，宣告新的根桥。</p>
</li>
<li><p>网络中拥有最小桥ID的交换机成为根桥。</p>
<p>桥ID由16位的桥优先级（Bridge  Priority）和48位的MAC地址构成。在STP网络中，桥优先级是可以配置的，取值范围是0～65535，默认值为32768。优先级最高的设备（数值越小越优先）会被选举为根桥。如果优先级相同，则会比较MAC地址，MAC地址越小则越优先。</p>
</li>
<li><p>在一个连续的STP交换网络中只会存在一个根桥。·</p>
</li>
<li><p>根桥的角色是可抢占的。</p>
</li>
<li><p>为了确保交换网络的稳定，建议提前规划STP组网，并将规划为根桥的交换机的桥优先级设置为最小值0。</p>
</li>
</ul>
</li>
<li><p>在每台非根桥上选举一个根接口</p>
<ul>
<li><p>每一台非根桥交换机都会在自己的接口中选举出一个接口。</p>
<p>非根交换机在选举根端口时分别依据该端口的根路径开销、对端BID（Bridge ID）、对端PID（Port ID）和本端PID。</p>
<ol>
<li><p>比较根路径开销</p>
<p>根端口的确定需要比较RPC。当网桥从一个端口接收到配置BPDU后，首先获取其中的RPC，和接收端口的链路开销相加，得到此端口的RPC，每个收到配置BPDU的端口都进行同样的计算。然后比较各端口的RPC，拥有最小RPC值的端口即为本网桥的根端口。</p>
</li>
<li><p>RPC相同，比较对端BID</p>
<p>如果有两个或两个以上的端口计算得到的累计路径开销相同，那么选择收到发送者BID最小的那个端口作为根端口。</p>
</li>
<li><p>对端BID相同，比较对端PID</p>
<p> 如果两个或两个以上的端口连接到同一台交换机上，则选择发送者PID最小的那个端口作为根端口。</p>
</li>
<li><p>对端PID相同，比较本段PID</p>
<p>如果两个或两个以上的端口通过Hub连接到同一台交换机的同一个接口上，则选择本交换机的这些端口中的PID最小的作为根端口。</p>
</li>
</ol>
</li>
<li><p>非根桥交换机上有且只会有一个根接口。</p>
</li>
<li><p>当非根桥交换机有多个接口接入网络中时，根接口是其收到最优配置BPDU的接口。</p>
</li>
<li><p>可以形象地理解为，根接口是每台非根桥上“朝向”根桥的接口。</p>
</li>
</ul>
</li>
<li><p>在每条链路上选举一个指定接口</p>
<ul>
<li><p>每条链路只有一个指定端口</p>
<p>在网段上抑制其他端口（无论是自己的还是其他设备的）发送BPDU报文的端口，就是该网段的指定端口。</p>
</li>
<li><p>在每条链路上选举一个指定接口时分别依据该端口的累计路径开销、本端BID（Bridge ID）、本端PID（Port ID）</p>
<p>（比较端口发送的配置BPDU和接收的配置BPDU，如果发送的配置BPDU优于接收到的配置BPDU，表明端口在本Physical Segment上拥有最优的配置BPDU，则该端口为指定端口。）</p>
<ol>
<li><p>比较累计路径开销</p>
<p>累计路径开销最小的端口就是指定端口。</p>
</li>
<li><p>累计路径开销相同，比较本端BID</p>
<p>如果累计路径开销相同，则比较端口所在交换机的桥ID，所在桥ID小的端口被选举为指定端口。</p>
</li>
<li><p>前两者选举不出来比较本端PID</p>
<p>如果通过累计路径开销和所在桥ID选举不出来，则比较端口ID，端口ID最小的被选举为指定端口。</p>
</li>
</ol>
</li>
<li><p>一般情况下，根桥的所有接口都是指定接口。</p>
</li>
</ul>
</li>
<li><p>非指定接口被阻塞</p>
<ul>
<li>一台交换机上，既不是根接口，又不是指定接口的接口被称为非指定接口。</li>
<li>STP操作的最后一步是阻塞网络中的非指定接口。这一步完成后，网络中的二层环路就此消除。</li>
</ul>
</li>
</ol>
<h3 id="5-STP接口状态及转换"><a href="#5-STP接口状态及转换" class="headerlink" title="5.STP接口状态及转换"></a>5.STP接口状态及转换</h3><h5 id="STP接口状态"><a href="#STP接口状态" class="headerlink" title="STP接口状态"></a>STP接口状态</h5><table>
<thead>
<tr>
<th>状态名称</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>禁用(Disable)</td>
<td>该接口不能收发BPDU，也不能收发业务数据帧，例如接口为down</td>
</tr>
<tr>
<td>阻塞(Blocking)</td>
<td>该接口被STP阻塞。处于阻塞状态的接口不能发送BPDU，但是会持续侦听BPDU，而且不能收发业务数据帧，也不会进行MAC地址学习</td>
</tr>
<tr>
<td>侦听(Listening)</td>
<td>当接口处于该状态时，表明STP初步认定该接口为根接口或指定接口，但接口依然处于STP计算的过程中，此时接口可以收发BPDU，但是不能收发业务数据帧,也不会进行MAC地址学习</td>
</tr>
<tr>
<td>学习(Learning)</td>
<td>当接口处于该状态时，会侦听业务数据帧（但是不能转发业务数据帧），并且在收到业务数据帧后进行MAC地址学习</td>
</tr>
<tr>
<td>转发(Forwarding)</td>
<td>处于该状态的接口可以正常地收发业务数据帧，也会进行BPDU处理。接口的角色需是根接口或指定接口才能进入转发状态</td>
</tr>
</tbody></table>
<h5 id="STP接口状态转换"><a href="#STP接口状态转换" class="headerlink" title="STP接口状态转换"></a>STP接口状态转换</h5><p><img src="/2021/04/21/stp/%E6%8E%A5%E5%8F%A3%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E5%9B%BE.png" alt="接口状态转换图"></p>
<h3 id="6-拓扑变化及其收敛时间"><a href="#6-拓扑变化及其收敛时间" class="headerlink" title="6.拓扑变化及其收敛时间"></a>6.拓扑变化及其收敛时间</h3><h5 id="拓扑变化-根桥故障"><a href="#拓扑变化-根桥故障" class="headerlink" title="拓扑变化-根桥故障"></a>拓扑变化-根桥故障</h5><ol>
<li>SWA根桥发生故障，停止发送BPDU报文。</li>
<li>SWB等待Max Age计时器( 20 s)超时，从而导致已经收到的BPDU报文失效，又接收不到根桥发送的新的BPDU报文，从而得知上游出现故障。</li>
<li>非根桥会互相发送配置BPDU，重新选举新的根桥。</li>
<li>经过重新选举后，SWC的A端口经过两个Forward Delay( 15 s )时间恢复转发状态。</li>
</ol>
<ul>
<li>非根桥会在BPDU老化之后开始根桥的重新选举。</li>
<li>根桥故障会导致50 s左右的恢复时间。</li>
</ul>
<p><img src="/2021/04/21/stp/%E6%A0%B9%E6%A1%A5%E6%95%85%E9%9A%9C.png" alt="根桥故障"></p>
<h5 id="拓扑变化-直连链路故障"><a href="#拓扑变化-直连链路故障" class="headerlink" title="拓扑变化-直连链路故障"></a>拓扑变化-直连链路故障</h5><p>当交换机SWB网络稳定时检测到根端口的链路发生故障，则其备用端口会经过两倍的Forward Delay ( 15s )时间进入用户流量转发状态。</p>
<ul>
<li>SW2检测到直连链路物理故障后，会将预备端口转换为根端口。</li>
<li>直连链路故障，备用端口会经过30s后恢复转发状态。</li>
</ul>
<p><img src="/2021/04/21/stp/%E7%9B%B4%E8%BF%9E%E9%93%BE%E8%B7%AF%E6%95%85%E9%9A%9C.png" alt="直连链路故障"></p>
<h5 id="拓扑变化-非直连链路故障"><a href="#拓扑变化-非直连链路故障" class="headerlink" title="拓扑变化-非直连链路故障"></a>拓扑变化-非直连链路故障</h5><ol>
<li><p>SWB与SWA之间的链路发生了某种故障（非物理层故障），SWB因此一直收不到来自SWA的BPDU报文。</p>
</li>
<li><p>Max Age（20 s）定时器超时后，SWB、SWC几乎同时会收到对方发来的BPDU。</p>
<p>SWB的Max Age定时器超时后，SWB会认为根桥SWA不再有效，并认为自己是根桥，于是开始发送自己的BPDU报文给SWC，通知SWC自己作为新的根桥。在此期间，由于SWC的Alternate端口再也不能收到包含原根桥ID的BPDU报文。其Max Age定时器超时后，SWC会切换Alternate端口为指定端口并且转发来自其根端口的BPDU报文给SWB。</p>
</li>
<li><p>经过STP重新计算后，SWB放弃宣称自己是根桥并重新确定端口角色</p>
<ul>
<li><p>非直连链路故障后，SWC的备用端口恢复到转发状态，需要经过两个Forward Delay( 15 s )时间恢复转发状态。</p>
<p>SWC接口的状态转换：blocking–&gt;Listening–&gt;Learning–&gt; forwarding</p>
</li>
<li><p>非直连故障会导致50s左右的恢复时间（Mac Age+Forward Delay+Forward Delay）。</p>
</li>
</ul>
</li>
</ol>
<p><img src="/2021/04/21/stp/%E9%9D%9E%E7%9B%B4%E8%BF%9E%E9%93%BE%E8%B7%AF%E6%95%85%E9%9A%9C.png" alt="非直连链路故障"></p>
<h5 id="拓扑变化导致MAC地址表错误"><a href="#拓扑变化导致MAC地址表错误" class="headerlink" title="拓扑变化导致MAC地址表错误"></a>拓扑变化导致MAC地址表错误</h5><p>如图，SWC的根端口发生故障，导致生成树拓扑重新收敛，在生成树拓扑完成收敛之后,从主机A到主机B的帧仍然不能到达目的地。这是因为交换机依赖MAC地址表转发数据帧,缺省情况下，MAC地址表项的老化时间是300秒。若SWB的MAC地址表不及时更新将导致数据丢失。</p>
<p><img src="/2021/04/21/stp/MAC%E5%9C%B0%E5%9D%80%E8%A1%A8%E9%94%99%E8%AF%AF.png" alt="MAC地址表错误"></p>
<h5 id="拓扑变化导致MAC地址表错误解决过程"><a href="#拓扑变化导致MAC地址表错误解决过程" class="headerlink" title="拓扑变化导致MAC地址表错误解决过程"></a>拓扑变化导致MAC地址表错误解决过程</h5><p>拓扑变化过程中，根桥通过TCN BPDU报文获知生成树拓扑里发生了故障。根桥生成TC用来通知其他交换机加速老化现有的MAC地址表项。</p>
<ul>
<li><p>TCN BPDU在网络拓扑变化的时候产生。报文格式:协议标识、版本号和类型。</p>
<p>TCN BPDU产生条件</p>
<ul>
<li>网桥上有端口转变为Forwarding状态，且该网桥至少包含一个指定端口。</li>
<li>网桥上有端口从Forwarding状态或Learning状态转变为Blocking状态。</li>
</ul>
</li>
<li><p>拓扑变化:会使用到配置BPDU中Flags的TCA和TC位。</p>
</li>
</ul>
<p>拓扑变更以及MAC地址表项更新的具体过程如下：</p>
<ol>
<li><p>SWC感知到网络拓扑发生变化后，会不间断地向SWB发送TCN BPDU报文。</p>
</li>
<li><p>SWB收到SWC发来的TCN BPDU报文后，会把配置BPDU报文中的Flags的TCA位设置1，然后发送给SWC，告知SWC停止发送TCN BPDU报文。</p>
<p>网桥发送TCN BPDU的周期位Hello Time，即当网桥发送TCN BPDU后，如果Hello  Time时间内没有收到TCA置位的配置BPDU，则网桥会重复发送TCN BPDU。如果网桥在Hello  Time时间内收到TCA置位的配置BPDU，则网桥停止从根端口发送TCN BPDU。</p>
</li>
<li><p>SWB向根桥转发TCN BPDU报文。</p>
</li>
<li><p>SWA给SWB发送TCA置位的BPDU，告知SWB停止发送TCN BPDU报文。</p>
</li>
<li><p>SWA把配置BPDU报文中的Flags的TC位设置为1后发送，通知下游设备修改MAC地址表项的老化时间。</p>
<p>根桥在之后的Max Age+Forward Delay时间内，将发送配置的BPDU中的TC置位，当网桥收到根桥发送的TC置位的BPDU后，会将自身的MAC地址老化时间由300s缩短为Forward Delay（默认15 s）。</p>
</li>
<li><p>最多等待15秒之后，SWB中的错误MAC地址表项会被自动清除。此后，SWB就能重新开始MAC表项的学习及转发操作。</p>
</li>
</ol>
<p><img src="/2021/04/21/stp/%E4%BF%AE%E6%94%B9MAC%E8%A1%A8%E6%B5%81%E7%A8%8B.png" alt="修改MAC表流程"></p>
<h3 id="7-STP协议的不足"><a href="#7-STP协议的不足" class="headerlink" title="7.STP协议的不足"></a>7.STP协议的不足</h3><p>STP为了避免临时环路的产生，每一个端口在确认位根端口或指定端口后仍然需要等待30s的时间才能进入转发状态。在此30s时间内，端口不能进行数据的转发，这对于一些对时延敏感的应用是不可接受的。</p>
<p>此外，对于拓扑不稳定的网络，经常需要重新进行STP计算，某些端口可能会长期处于阻塞状态而导致网络长时间的中断。</p>
<p>STP定义了TCN BPDU，可以使得网络拓扑变化时，在50s之内实现收敛。</p>
<p>TCN BPDU产生的条件之一是网桥有端口转变为Forwarding状态，且该网桥至少包含一个指定端口。</p>
<p>当网络中有大量的用户主机时，由于用户主机位置不固定，可能会频繁地上下线，这样会使得交换机频繁发送TCN BPDU，导致网桥MAC地址老化时间长期保持为15s。MAC地址频繁的刷新会导致网络充斥大量由未知单播造成的广播报文，严重影响网络中的应用。</p>
<h3 id="8-STP相关配置命令"><a href="#8-STP相关配置命令" class="headerlink" title="8.STP相关配置命令"></a>8.STP相关配置命令</h3><p>1．配置生成树工作模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] stp mode &#123; stp | rstp | mstp &#125;</span><br></pre></td></tr></table></figure>
<p>交换机支持STP、RSTP和MSTP (Multiple Spanning Tree Protocol)三种生成树工作模式，默认情况工作在MSTP模式。<br>2.（可选）配置根桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] stp root primary</span><br></pre></td></tr></table></figure>
<p>配置当前设备为根桥。缺省情况下，交换机不作为任何生成树的根桥。配置后该设备优先级数值自动为0，并且不能更改设备优先级。<br>3.（可选）备份根桥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] stp root secondary</span><br></pre></td></tr></table></figure>
<p>配置当前交换机为备份根桥。缺省情况下，交换机不作为任何生成树的备份根桥。配置后该设备优先级数值为4096,并且不能更改设备优先级。<br>4.（可选）配置交换机的STP优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] stp priority priority</span><br></pre></td></tr></table></figure>
<p>缺省情况下，交换机的优先级取值是32768。<br>5.（可选）配置接口路径开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] stp pathcost-standard &#123; dot1d-1998 | dot1t | legacy &#125;</span><br></pre></td></tr></table></figure>
<p>配置接口路径开销计算方法。缺省情况下，路径开销值的计算方法为IEEE 802.1t ( dot1t)标准方法。同一网络内所有交换机的接口路径开销应使用相同的计算方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0&#x2F;0&#x2F;1] stp cost cost</span><br></pre></td></tr></table></figure>
<p>设置当前接口的路径开销值。<br>6.（可选）配置接口优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei-intf] stp priority priority</span><br></pre></td></tr></table></figure>
<p>配置接口的优先级。缺省情况下，交换机接口的优先级取值是128。<br>7.启用STP/RSTP/MSTP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Huawei] stp enable</span><br></pre></td></tr></table></figure>
<p>使能交换机的STP/RSTP/MSTP功能。缺省情况下，设备的STP/RSTP/MSTP功能处于启用状态。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
