<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/" itemprop="url">IE-LAN技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-20T17:56:08+08:00">
                2021-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%871.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%872.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%873.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%874.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%875.png"></p>
<blockquote>
<p>MAC地址表的定义</p>
<ul>
<li>MAC地址表记录了交换机学习到的其他设备的MAC地址与接口的对应关系，以及接口所属VLAN等信息。设备在转发报文时，根据报文的目的MAC地址查询MAC地址表，如果MAC地址表中包含与报文目的MAC地址对应的表项，则直接通过该表项中的出接口转发该报文；如果MAC地址表中没有包含报文目的MAC地址对应的表项时，设备将采取广播方式在所属VLAN内除接收接口外的所有接口转发该报文。</li>
</ul>
<p>MAC地址表中的表项分为：动态表项、静态表项和黑洞表项。</p>
<ul>
<li><p>动态表项：由接口通过报文中的源MAC地址学习获得，表项可老化。在系统复位、接口板热插拔或接口板复位后，动态表项会丢失。可以通过查看动态MAC地址表项，可以判断两台相连设备之间是否有数据转发；也可以通过查看指定动态MAC地址表项的个数，可以获取接口下通信的用户数。</p>
</li>
<li><p>静态表项：由用户手工配置，并下发到各接口板，表项不可老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。一条静态MAC地址表项，只能绑定一个出接口。一个接口和MAC地址静态绑定后，不会影响该接口动态MAC地址表项的学习。通过绑定静态MAC地址表项，可以保证合法用户的使用，防止其他用户使用该MAC进行攻击。</p>
</li>
<li><p>黑洞表项：由用户手工配置，并下发到各接口板，表项不可老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。通过配置黑洞MAC地址表项，可以过滤掉非法用户。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%876.png"></p>
<blockquote>
<p>通过“display mac-address”命令，可以查看设备的mac表项，如图所示，mac表的组成可以分为动态、静态和黑洞。从表项中也可以看出，mac地址所对应的VLAN以及VSI。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%877.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%878.png"><br><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%879.png"></p>
<blockquote>
<ul>
<li><p>接口使能端口安全功能时，接口上之前学习到的动态MAC地址表项将被删除，之后学习到的MAC地址将变为安全动态MAC地址。</p>
</li>
<li><p>接口使能Sticky MAC功能时，接口上的安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>接口去使能端口安全功能时，接口上的安全动态MAC地址将被删除，重新学习动态MAC地址。</p>
</li>
<li><p>接口去使能Sticky MAC功能时，接口上的Sticky MAC地址，会转换为安全动态MAC地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8710.png"></p>
<blockquote>
<p>说明：</p>
<ul>
<li><p>接口使能Sticky MAC功能，安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>接口使能Sticky MAC功能，即使配置了port-security aging-time，Sticky MAC也不会被老化。</p>
</li>
<li><p>Sticky MAC地址表项，保存后重启设备不丢弃。</p>
</li>
</ul>
<p>端口安全的保护动作：</p>
<ul>
<li><p>Restrict：丢弃源MAC地址不存在的报文并上报告警。推荐使用restrict动作。</p>
</li>
<li><p>Protect：只丢弃源MAC地址不存在的报文，不上报告警。</p>
</li>
<li><p>Shutdown：接口状态被置为error-down，并上报告警。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8711.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8712.png"></p>
<blockquote>
<ul>
<li><p>如图所示，MAC地址为0011-0022-0034的表项，出接口由GE1/0/1刷新为GE1/0/2，这就是MAC地址漂移。设备出现MAC地址漂移时，设备CPU占用率会有不同程度的升高。正常情况下，网络中不会在短时间内出现大量MAC地址漂移的情况。出现这种现象一般都意味着网络中存在环路，可以通过查看告警信息和漂移记录，快速定位和排除环路。</p>
</li>
<li><p>网络中产生环路或非法用户进行网络攻击都会造成MAC地址发生漂移，导致MAC地址不稳定。在规划网络时，可以通过下面两种方式来避免这种情况：</p>
<ul>
<li>提高接口MAC地址学习优先级。当不同接口学到相同的MAC地址表项时，高优先级接口学到的MAC地址表项可以覆盖低优先级接口学到的MAC地址表项，防止MAC地址在接口间发生漂移。</li>
<li>不允许相同优先级的接口发生MAC地址表项覆盖。当伪造网络设备所连接口的优先级与安全的网络设备相同时，后学习到的伪造网络设备的MAC地址表项不会覆盖之前正确的表项。但如果网络设备下电，仍会学习到伪造网络设备的MAC地址，当网络设备再次上电时将无法学习到正确的MAC地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8713.png"></p>
<blockquote>
<ul>
<li><p>配置MAC地址漂移检测功能后，在发生MAC地址漂移时，可以上报包括MAC地址、VLAN，以及跳变的接口等信息的告警。其中跳变的接口即为可能出现环路的接口。网络管理员可以根据告警信息，手工排查网络中环路的源头，也可以使用MAC漂移检测提供的后续动作，使跳变的端口down或者VLAN从端口中退出，实现自动破环。</p>
</li>
<li><p>如图所示网络中，若SwitchC和SwitchD之间误接网线，则SwitchB、SwitchC、SwitchD之间形成环路。当SwitchA上Port1接口从网络中收到一个广播报文后转发给SwitchB，该报文经过环路，会被SwitchA上Port2接口收到。配置MAC地址漂移检测功能，SwitchA就会感知到MAC地址出接口跳变的现象。若连续出现此现象，SwitchA就会上报MAC漂移告警，提醒管理员进行维护。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8714.png"></p>
<blockquote>
<ul>
<li><p>接口配置不同的MAC地址学习优先级后，如果不同接口学到相同的MAC地址表项，那么高优先级接口学到的MAC地址表项可以覆盖低优先级接口学到的MAC地址表项，防止MAC地址发生漂移。</p>
</li>
<li><p>配置不允许相同优先级的接口发生MAC地址表项覆盖，也可以防止MAC地址漂移，提高网络的安全性。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8715.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8716.png"></p>
<blockquote>
<p>免费ARP有如下作用：</p>
<ul>
<li>IP地址冲突检测：当设备接口的协议状态变为Up时，设备主动对外发送免费ARP报文。正常情况下不会收到ARP应答，如果收到，则表明本网络中存在与自身IP地址重复的地址。如果检测到IP地址冲突，设备会周期性的广播发送免费ARP应答报文，直到冲突解除。</li>
<li>用于通告一个新的MAC地址：发送方更换了网卡，MAC地址变化了，为了能够在动态ARP表项老化前通告网络中其他设备，发送方可以发送一个免费ARP。</li>
<li>在VRRP备份组中用来通告主备发生变换：发生主备变换后，MASTER设备会广播发送一个免费ARP报文来通告发生了主备变换。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8717.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8718.png"></p>
<blockquote>
<ul>
<li><p>在STP和RSTP的算法中，所有VLAN共享一课生成树，会造成部分VLAN无法通信、次优路径、流量无法负载分担等问题。</p>
</li>
<li><p>为了弥补STP和RSTP的缺陷，IEEE于2002年发布的802.1S标准定义了MSTP。MSTP兼容STP和RSTP，既可以快速收敛，又提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8719.png"></p>
<blockquote>
<ul>
<li><p>所谓生成树实例就是多个VLAN的一个集合。通过将多个VLAN捆绑到一个实例，可以节省通信开销和资源占用率。MSTP各个实例拓扑的计算相互独立，在这些实例上可以实现负载均衡。可以把多个相同拓扑结构的VLAN映射到一个实例里，这些VLAN在端口上的转发状态取决于端口在对应MSTP实例的状态。</p>
</li>
<li><p>如图所示，MSTP通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。</p>
</li>
<li><p>经计算，最终生成两棵生成树：</p>
<ul>
<li>MSTI1以S4为根交换设备，转发VLAN2的报文。</li>
<li>MSTI2以S6为根交换设备，转发VLAN3的报文。</li>
</ul>
</li>
<li><p>这样所有VLAN内部可以互通，同时不同VLAN的报文沿不同的路径转发，实现了负载分担。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8720.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8721.png"></p>
<blockquote>
<ul>
<li><p>MST由交换网络中的多台交换设备以及它们间的网段所构成。MSTI是MST域下实例，一个MST域下可以有多个MSTI。</p>
</li>
<li><p>VLAN映射表描述了VLAN和MSTI之间的映射关系。如图2所示，MST Region4中，VLAN1映射到MSTI1，VLAN2映射到MSTI2，其余VLAN映射到MSTI3。</p>
</li>
<li><p>公共生成树CST是连接交换网络内所有MST域的一棵生成树。如果把每个MST域看作是一个节点，CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树。</p>
</li>
<li><p>内部生成树IST（Internal Spanning Tree）是各MST域内的一棵生成树。IST是一个特殊的MSTI，MSTI的ID为0，通常称为MSTI0。</p>
</li>
<li><p>SST（Single Spanning Tree）：运行STP或RSTP的交换设备只能属于一个生成树；MST域中只有一个交换设备，这个交换设备构成单生成树。</p>
</li>
<li><p>所有MST域的IST加上CST就构成一棵完整的生成树，即CIST。</p>
</li>
<li><p>域根（Regional Root）分为IST域根和MSTI域根。</p>
<ul>
<li>IST域根如图1所示，在MST域中IST生成树中距离总根最近的交换设备是IST域根。</li>
<li>一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI。MSTI域根是每个多生成树实例的树根。如图3所示，域中不同的MSTI有各自的域根。</li>
</ul>
</li>
<li><p>总根是CIST（Common and Internal Spanning Tree）的根桥。如图1中的S1。</p>
</li>
<li><p>主桥（Master Bridge）也就是IST Master，它是域内距离总根最近的交换设备。如图1中的黄色交换机。如果总根在MST域中，则总根为该域的主桥。</p>
</li>
<li><p>端口角色：同RSTP，MSTP中定义了根端口、指定端口、Alternate端口、Backup端口和边缘端口。</p>
</li>
<li><p>端口状态：同RSTP，MSTP定义的端口状态有Forwarding, Learning, Discarding。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8722.png"></p>
<blockquote>
<p>MSTI的特点：</p>
<ul>
<li>每个MSTI独立计算自己的生成树，互不干扰。</li>
<li>每个MSTI的生成树计算方法与STP基本相同。</li>
<li>每个MSTI的生成树可以有不同的根，不同的拓扑。</li>
<li>每个MSTI在自己的生成树内发送BPDU。</li>
<li>每个MSTI的拓扑通过命令配置决定。</li>
<li>每个端口在不同MSTI上的生成树参数可以不同。</li>
<li>每个端口在不同MSTI上的角色、状态可以不同。</li>
</ul>
<p>在运行MSTP协议的网络中，一个VLAN报文将沿着如下路径进行转发：</p>
<ul>
<li><p>在MST域内，沿着其对应的MSTI转发。</p>
</li>
<li><p>在MST域间，沿着CST转发。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8723.png"></p>
<blockquote>
<ul>
<li><p>如图所示，在MSTP中，P/A机制工作过程如下：</p>
<p>1.上游设备发送Proposal报文，请求进行快速迁移。下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口。</p>
<p>2.上游设备继续发送Agreement报文。下游设备接收到后，根端口转为Forwarding状态。</p>
<p>3.下游设备回应Agreement报文。上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</p>
</li>
<li><p>缺省情况下，华为数据通信设备使用增强的快速迁移机制。如果华为数据通信设备和其他制造商的设备进行互通，而其他制造商的设备P/A机制使用普通的快速迁移机制，此时，可在华为数据通信设备上通过设置P/A机制为普通的快速迁移机制，从而实现华为数据通信设备和其他制造商的设备进行互通。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8724.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8725.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8726.png"></p>
<blockquote>
<ul>
<li><p>如图所示，为园区网络CSS+iStack组网之一，其主要有简单、高效、可靠的特点。</p>
</li>
<li><p>简单</p>
<ul>
<li>各层设备均使用堆叠技术，逻辑设备少，网络拓扑简单，二层天然无环，无需部署xSTP破环协议。</li>
</ul>
</li>
<li><p>高效</p>
<ul>
<li>各层设备间使用Eth-Trunk链路聚合技术，负载分担算法灵活，链路利用率高。</li>
</ul>
</li>
<li><p>可靠</p>
<ul>
<li>服务器和主机可以配置多NIC网卡Teaming负载均衡或主备冗余链路提高服务器接入可靠性。</li>
<li>堆叠技术同链路聚合技术结合使用，各层物理设备形成双归接入组网，提高整网可靠性。</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><p>对设备性能要求较高，盒式设备堆叠台数过多，可能导致堆叠主的主控性能下降。</p>
</li>
<li><p>如果采用业务口堆叠或集群，会占用业务端口数。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8727.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8728.png"></p>
<blockquote>
<ul>
<li>通过交换机堆叠，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。<ul>
<li>高可靠性。堆叠系统多台成员交换机之间冗余备份；堆叠支持跨设备的链路聚合功能，实现跨设备的链路冗余备份。</li>
<li>强大的网络扩展能力。通过增加成员交换机，可以轻松的扩展堆叠系统的端口数、带宽和处理能力；同时支持成员交换机热插拔，新加入的成员交换机自动同步主交换机的配置文件和系统软件版本。</li>
<li>简化配置和管理。一方面，用户可以通过任何一台成员交换机登录堆叠系统，对堆叠系统所有成员交换机进行统一配置和管理；另一方面，堆叠形成后，不需要配置复杂的二层破环协议和三层保护倒换协议，简化了网络配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8729.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8730.png"></p>
<blockquote>
<ul>
<li><p>“系统自动完成堆叠”实际上可以细分为三步：</p>
<p>1.主交换机选举</p>
<p>​    ①运行状态比较，已经运行的交换机比处于启动状态的交换机优先竞争为主交换机。</p>
<p>​    ②堆叠优先级高的交换机优先竞争为主交换机。</p>
<p>​    ③堆叠优先级相同时，MAC地址小的交换机优先竞争为主交换机。</p>
<p>2.拓扑收集和备交换机选举</p>
<ul>
<li>主交换机选举完成后，主交换机会收集所有成员交换机的拓扑信息，根据拓扑信息计算出堆叠转发表项和破环点信息下发给堆叠中的所有成员交换机，并向所有成员交换机分配堆叠ID。之后进行备交换机的选举，作为主交换机的备份交换机。当除主交换机外其它交换机同时完成启动时：<ul>
<li>堆叠优先级最高的设备成为备交换机。</li>
<li>堆叠优先级相同时，MAC地址最小的成为备交换机。</li>
</ul>
</li>
</ul>
<p>3.稳定运行</p>
<ul>
<li>角色选举、拓扑收集完成之后，剩下的其他成员交换机作为从交换机加入堆叠，所有成员交换机会自动同步主交换机的系统软件和配置文件：<ul>
<li>堆叠具有自动加载系统软件的功能，待组成堆叠的成员交换机不需要具有相同软件版本，只需要版本间兼容即可。当备交换机或从交换机与主交换机的软件版本不一致时，备交换机或从交换机会自动从主交换机下载系统软件，然后使用新系统软件重启，并重新加入堆叠。</li>
<li>堆叠具有配置文件同步机制，备交换机或从交换机会将主交换机的配置文件同步到本设备并执行，以保证堆叠中的多台设备能够像一台设备一样在网络中工作，并且在主交换机出现故障之后，其余交换机仍能够正常执行各项功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8731.png"></p>
<blockquote>
<ul>
<li><p>物理成员端口</p>
<ul>
<li>成员交换机之间用于堆叠连接的物理端口。物理成员端口用于转发需要跨成员交换机的业务报文或成员交换机之间的堆叠协议报文。</li>
</ul>
</li>
<li><p>逻辑堆叠端口</p>
<ul>
<li>逻辑堆叠端口是专用于堆叠的逻辑端口，需要和物理成员端口绑定。堆叠的每台成员交换机上支持两个逻辑堆叠端口，分别为stack-port n/1和stack-port n/2，其中n为成员交换机的堆叠ID。</li>
</ul>
</li>
<li><p>业务口堆叠根据连接线缆的不同又可以分为：普通线缆堆叠和专用线缆堆叠。</p>
<ul>
<li>普通线缆堆叠<ul>
<li>普通堆叠线缆包括：光线缆、网线和高速电缆。使用普通线缆堆叠时，逻辑堆叠端口需要手动进行配置，否则无法组建堆叠。</li>
</ul>
</li>
<li>专用线缆堆叠<ul>
<li>专用堆叠线缆的两端区分主和备，带有Master标签的一端为主端，不带有标签的一端为备端。使用专用线缆堆叠时，专用堆叠线缆按照规则插入端口后，交换机就可以自动组建堆叠。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8732.png"></p>
<blockquote>
<ul>
<li><p>堆叠成员加入是指向已经稳定运行的堆叠系统添加一台新的交换机。</p>
</li>
<li><p>使能堆叠并配置好SWD的堆叠参数</p>
<ul>
<li>如果是业务口堆叠，新加入的交换机需要配置物理成员端口加入逻辑堆叠端口；并且链形连接时，当前堆叠系统链形两端（或一端）的成员交换机也需要配置物理成员端口加入逻辑堆叠口。</li>
<li>如果是堆叠卡堆叠，新加入的成员交换机需要使能堆叠功能。</li>
<li>为了便于管理，建议为新加入的交换机配置堆叠ID。如果不配置，堆叠系统会为其分配一个堆叠ID。</li>
</ul>
</li>
<li><p>将SWD连接到堆叠系统</p>
<ul>
<li>如果是链形连接，新加入的交换机建议添加到链形的两端，这样对现有的业务影响最小。</li>
<li>如果是环形连接，需要把当前环形拆成链形，然后在链形的两端添加设备。</li>
</ul>
</li>
<li><p>系统完成堆叠</p>
<p>1.新加入的交换机连线上电启动后，进行角色选举，新加入的交换机会选举为从交换机，堆叠系统中原有主备从角色不变。</p>
<p>2.角色选举结束后，主交换机更新堆叠拓扑信息，同步到其他成员交换机上，并向新加入的交换机分配堆叠ID（新加入的交换机没有配置堆叠ID或配置的堆叠ID与原堆叠系统的冲突时）。</p>
<p>3.新加入的交换机更新堆叠ID，并同步主交换机的配置文件和系统软件，之后进入稳定运行状态。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8733.png"></p>
<blockquote>
<ul>
<li><p>堆叠合并是指稳定运行的两个堆叠系统合并成一个新的堆叠系统。如图所示，两个堆叠系统的主交换机SWA和SWD通过竞争，选举出一个更优的作为新堆叠系统的主交换机。竞争成功的主交换机SWA所在的堆叠系统将保持原有主备从角色和配置不变，业务也不会受到影响；而另外一个堆叠系统的所有成员交换机SWD和SWE将重新启动，以从交换机的角色加入到新堆叠系统，其堆叠ID将由新主交换机重新分配，并将同步新主交换机的配置文件和系统软件，该堆叠系统的原有业务也将中断。</p>
</li>
<li><p>堆叠合并通常在以下两种情形下出现：</p>
<ul>
<li>堆叠链路或设备故障导致堆叠分裂，链路或设备故障恢复后，分裂的堆叠系统重新合并。</li>
<li>待加入堆叠系统的交换机配置了堆叠功能，在不下电的情况下，使用堆叠线缆连接到正在运行的堆叠系统。通常情况下，不建议使用该方式形成堆叠，因为在合并前过程中可能会导致正在运行的堆叠系统重启，影响业务运行。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8734.png"></p>
<blockquote>
<p>堆叠成员退出是指成员交换机从堆叠系统中离开。根据退出成员交换机角色的不同，对堆叠系统的影响也有所不同：</p>
<ul>
<li>当主交换机退出，备份交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，指定新的备交换机，之后进入稳定运行状态。</li>
<li>当备交换机退出，主交换机重新指定备交换机，重新计算堆叠拓扑并同步到其他成员交换机，之后进入稳定运行状态。</li>
<li>当从交换机退出，主交换机重新计算堆叠拓扑并同步到其他成员交换机，之后进入稳定运行状态。</li>
</ul>
<p>堆叠成员交换机退出的过程，主要就是拆除堆叠线缆和移除交换机的过程：</p>
<ul>
<li>对于环形堆叠：成员交换机退出后，为保证网络的可靠性还需要把退出交换机连接的两个端口通过堆叠线缆进行连接。</li>
<li>对于链形堆叠：拆除中间交换机会造成堆叠分裂。这时需要在拆除前进行业务分析，尽量减少对业务的影响。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8735.png"></p>
<blockquote>
<p>堆叠分裂是指稳定运行的堆叠系统中带电移出部分成员交换机，或者堆叠线缆多点故障导致一个堆叠系统变成多个堆叠系统。根据原堆叠系统主备交换机分裂后所处位置的不同，堆叠分裂可分为以下两类：</p>
<ul>
<li><p>堆叠分裂后，原主备交换机被分裂到同一个堆叠系统中：原主交换机会重新计算堆叠拓扑，将移出的成员交换机的拓扑信息删除，并将新的拓扑信息同步给其他成员交换机；而移出的成员交换机检测到堆叠协议报文超时，将自行复位，重新进行选举。</p>
</li>
<li><p>堆叠分裂后，原主备交换机被分裂到不同的堆叠系统中：原主交换机所在堆叠系统重新指定备交换机，重新计算拓扑信息并同步给其他成员交换机；原备交换机所在堆叠系统将发生备升主，原备交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，并指定新的备交换机。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8736.png"></p>
<blockquote>
<ul>
<li><p>由于堆叠系统中所有成员交换机都使用同一个IP地址和MAC地址（堆叠系统MAC），一个堆叠分裂后，可能产生多个具有相同IP地址和MAC地址的堆叠系统。为防止堆叠分裂后，产生多个具有相同IP地址和MAC地址的堆叠系统，引起网络故障，必须进行IP地址和MAC地址的冲突检查。多主检测MAD（Multi-Active Detection），是一种检测和处理堆叠分裂的协议。链路故障导致堆叠系统分裂后，MAD可以实现堆叠分裂的检测、冲突处理和故障恢复，降低堆叠分裂对业务的影响。</p>
</li>
<li><p>MAD检测方式有两种：直连检测方式和代理检测方式。在同一个堆叠系统中，两种检测方式互斥，不可以同时配置。</p>
</li>
<li><p>直连检测方式是指堆叠成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，堆叠系统正常运行时，不发送MAD报文；堆叠系统分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>通过中间设备直连：堆叠系统的所有成员交换机之间至少有一条检测链路与中间设备相连。</p>
</li>
<li><p>Full-mesh方式直连：堆叠系统的各成员交换机之间通过检测链路建立Full-mesh全连接，即每两台成员交换机之间至少有一条检测链路。</p>
</li>
<li><p>通过中间设备直连可以实现通过中间设备缩短堆叠成员交换机之间的检测链路长度，适用于成员交换机相距较远的场景。与通过中间设备直连相比，Full-mesh方式直连可以避免由中间设备故障导致的MAD检测失败，但是每两台成员交换机之间都建立全连接会占用较多的接口，所以该方式适用于成员交换机数目较少的场景。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8737.png"></p>
<blockquote>
<ul>
<li><p>代理检测方式是在堆叠系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求堆叠系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
</li>
<li><p>在代理检测方式中，堆叠系统正常运行时，堆叠成员交换机以30s为周期通过检测链路发送MAD报文。堆叠成员交换机对在正常工作状态下收到的MAD报文不做任何处理；堆叠分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>MAD冲突处理</p>
<ul>
<li>堆叠分裂后，MAD冲突处理机制会使分裂后的堆叠系统处于Detect状态或Recovery状态。Detect状态表示堆叠正常工作状态，Recovery状态表示堆叠禁用状态。</li>
<li>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在多个处于Detect状态的堆叠系统，这些堆叠系统之间相互竞争，竞争成功的堆叠系统保持Detect状态，竞争失败的堆叠系统会转入Recovery状态；并且在Recovery状态堆叠系统的所有成员交换机上，关闭除保留端口以外的其它所有物理端口，以保证该堆叠系统不再转发业务报文。</li>
</ul>
</li>
<li><p>MAD故障恢复</p>
</li>
<li><p>通过修复故障链路，分裂后的堆叠系统重新合并为一个堆叠系统。重新合并的方式有以下两种：</p>
<ul>
<li>堆叠链路修复后，处于Recovery状态的堆叠系统重新启动，与Detect状态的堆叠系统合并，同时将被关闭的业务端口恢复Up，整个堆叠系统恢复。</li>
<li>如果故障链路修复前，承载业务的Detect状态的堆叠系统也出现了故障。此时，可以先将Detect状态的堆叠系统从网络中移除，再通过命令行启用Recovery状态的堆叠系统，接替原来的业务，然后再修复原Detect状态堆叠系统的故障及链路故障。故障修复后，重新合并堆叠系统。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8738.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8739.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8740.png"></p>
<blockquote>
<ul>
<li><p>CSS与iStack的区别在于，一般框式交换机堆叠称为CSS，盒式交换机堆叠称为iStack，都可以称为堆叠。两者只是叫法和实现有些差异，但是功能是一样的。</p>
</li>
<li><p>通过交换机集群，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。</p>
<ul>
<li>高可靠性：集群系统两台成员交换机之间冗余备份，同时利用链路聚合功能实现跨设备的链路冗余备份。</li>
<li>强大的网络扩展能力：通过组建集群增加交换机，从而轻松的扩展端口数、带宽和处理能力。</li>
<li>简化配置和管理：集群建立后，两台物理设备虚拟成为一台设备，用户只需登录一台成员交换机即可对集群系统所有成员交换机进行统一配置和管理。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8741.png"></p>
<blockquote>
<p>不同于iStack可以多台设备堆叠，对于CSS集群，集群中只能有一主一备两台交换机。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8742.png"></p>
<blockquote>
<ul>
<li><p>集群建立时，成员交换机间相互发送集群竞争报文，通过竞争，一台成为主交换机，负责管理整个集群系统，另一台则成为备交换机。</p>
</li>
<li><p>角色选举</p>
<p>1.最先完成启动，并进入单框集群运行状态的交换机成为主交换机。</p>
<p>2.当两台交换机同时启动时，集群优先级高的交换机成为主交换机。</p>
<p>3.当两台交换机同时启动，且集群优先级又相同时，MAC地址小的交换机成为主交换机。</p>
<p>4.当两台交换机同时启动，且集群优先级和MAC都相同时，集群ID小的交换机成为主交换机。</p>
</li>
<li><p>版本同步</p>
<ul>
<li>集群具有自动加载系统软件的功能，待组成集群的成员交换机不需要具有相同的软件版本，只需要版本间兼容即可。当主交换机选举结束后，如果备交换机与主交换机的软件版本号不一致时，备交换机会自动从主交换机下载系统软件，然后使用新的系统软件重启，并重新加入集群。</li>
</ul>
</li>
<li><p>配置同步</p>
<ul>
<li>集群具有严格的配置文件同步机制，来保证集群中的多台交换机能够像一台设备一样在网络中工作。</li>
</ul>
</li>
<li><p>配置备份</p>
<ul>
<li>交换机从非集群状态进入集群状态后，会自动将原有的非集群状态下的配置文件加上.bak的扩展名进行备份，以便去使能集群功能后，恢复原有配置。例如，原配置文件扩展名为.cfg，则备份配置文件扩展名为.cfg.bak。去使能交换机集群功能时，用户如果希望恢复交换机的原有配置，可以更改备份配置文件名并指定其为下一次启动的配置文件，然后重新启动交换机，恢复原有配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8743.png"></p>
<blockquote>
<ul>
<li><p>物理成员端口</p>
<ul>
<li>成员交换机之间用于集群连接的普通业务口。物理成员端口用于转发需要跨成员交换机的业务报文或成员交换机之间的集群协议报文。</li>
</ul>
</li>
<li><p>逻辑集群端口</p>
<ul>
<li>逻辑集群端口是专用于集群的逻辑端口，需要和物理成员端口绑定。集群的每台成员交换机上支持两个逻辑集群端口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8744.png"></p>
<blockquote>
<ul>
<li><p>使能了集群功能的单台交换机即为单框集群。</p>
<ul>
<li>集群成员加入是指向稳定运行的单框集群系统中添加一台新的交换机。如图1所示，新交换机SwitchB将加入单框集群系统从而形成新的集群系统。原单框集群的交换机成为主交换机，新加入的交换机成为备交换机。</li>
</ul>
</li>
<li><p>集群加入通常在以下两种情形下出现：</p>
<ul>
<li>在建立集群时，先将一台交换机使能集群功能后重启，重启后这台交换机将进入单框集群状态。然后再使能另外一台交换机的集群功能后重启，则后启动的交换机则按照集群成员加入的流程加入集群系统，成为备交换机。</li>
<li>在稳定运行的两框集群场景中，将其中一台交换机重启，则这台交换机将以集群成员加入的流程重新加入集群系统，并成为备交换机。</li>
</ul>
</li>
<li><p>集群合并是指稳定运行的两个单框集群系统合并成一个新的集群系统。如图2所示，两个单框集群系统将自动选出一个更优的作为合并后集群系统的主交换机。被选为主交换机的配置不变，业务也不会受到影响，框内的备用主控板将重启。而备交换机将整框重启，以集群备的角色加入新的集群系统，并将同步主交换机的配置，该交换机原有的业务也将中断。</p>
</li>
<li><p>集群合并通常在以下两种情形下出现：</p>
<ul>
<li>将两台交换机分别使能集群功能后重启（重启后的两台交换机都属于单框集群），再使用集群线缆将两台交换机连接，之后会进入集群合并流程。</li>
<li>集群链路或设备故障导致集群分裂。故障恢复后，分裂后的两个单框集群系统重新合并。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8745.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8746.png"></p>
<blockquote>
<ul>
<li><p>由于集群系统中所有成员交换机都使用同一个IP地址和MAC地址（集群系统MAC），一个集群分裂后，由于这些成员交换机运行着相同的配置文件（即原集群系统的配置文件），就会产生两个具有相同IP地址和MAC地址的集群系统。为防止集群分裂后，产生两个具有相同IP地址和MAC地址的集群系统，引起网络故障，必须进行IP地址和MAC地址的冲突检查。</p>
</li>
<li><p>多主检测MAD（Multi-Active Detection），是一种检测和处理集群分裂的协议。链路故障导致集群系统分裂后，MAD可以实现集群分裂的检测、冲突处理和故障恢复，降低集群分裂对业务的影响。</p>
</li>
<li><p>MAD检测方式有两种：直连检测方式和代理检测方式。在同一个集群系统中，两种检测方式互斥，不可以同时配置。</p>
</li>
<li><p>直连检测方式是指集群成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，集群系统正常运行时，不发送MAD报文；集群系统分裂后，分裂后的两台交换机周期性地通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>直连检测的连接方式包括通过中间设备直连和集群成员交换机直接直连：</p>
<ul>
<li>通过中间设备直连：集群系统的成员交换机之间至少有一条检测链路与中间设备相连。此种方式适用于成员交换机相距较远的场景。</li>
<li>直接直连：集群成员交换机直接直连可以避免由中间设备故障导致MAD检测失败。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8747.png"></p>
<blockquote>
<ul>
<li><p>代理检测方式是在集群系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求集群系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
</li>
<li><p>在代理检测方式中，集群系统正常运行时，集群成员交换机以30s为周期通过检测链路发送MAD报文。集群成员交换机对在正常工作状态下收到的MAD报文不做任何处理；集群分裂后，分裂后的两台交换机周期性地通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>MAD冲突处理</p>
<ul>
<li>集群分裂后，MAD冲突处理机制会使分裂后的单框集群系统处于Detect状态或Recovery状态。Detect状态表示集群正常工作状态，Recovery状态表示集群禁用状态。</li>
<li>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在两个处于Detect状态的集群系统即两台交换机，此时会进行集群优先级比较（优先级相同比较MAC地址，MAC地址相同则比较集群ID），优先级高的交换机将成为主交换机继续正常工作，另一台交换机会转入Recovery状态；并且在Recovery状态的交换机上，关闭除保留端口以外的其它所有物理端口，以保证该交换机不再转发业务报文。</li>
</ul>
</li>
<li><p>MAD故障恢复</p>
</li>
<li><p>通过修复故障链路，分裂后的集群系统重新合并为一个集群系统。重新合并的方式有以下两种：</p>
<ul>
<li>集群链路修复后，处于Recovery状态的集群系统重新启动，与Detect状态的集群系统合并，同时将被关闭的业务端口恢复Up，整个集群系统恢复。</li>
<li>如果故障链路修复前，承载业务的Detect状态的集群系统也出现了故障。此时，可以先将Detect状态的集群系统从网络中移除，再通过命令行启用Recovery状态的集群系统，接替原来的业务，然后再修复原Detect状态集群系统的故障。故障修复后，重新合并集群系统。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8748.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8749.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8750.png"></p>
<blockquote>
<ul>
<li><p>链路聚合技术主要有以下三个优势：增加带宽、提高可靠性和负载分担。</p>
</li>
<li><p>链路聚合组和成员接口</p>
<ul>
<li>链路聚合组LAG是指将若干条以太链路捆绑在一起所形成的逻辑链路。组成Eth-Trunk接口的各个物理接口称为成员接口。</li>
</ul>
</li>
<li><p>活动接口和非活动接口、活动链路和非活动链路</p>
<ul>
<li>链路聚合组的成员接口存在活动接口和非活动接口两种。转发数据的接口称为活动接口，不转发数据的接口称为非活动接口。</li>
<li>活动接口对应的链路称为活动链路，非活动接口对应的链路称为非活动链路。</li>
</ul>
</li>
<li><p>活动接口数上限阈值</p>
<ul>
<li>当前活动链路数目达到上限阈值时，再向Eth-Trunk中添加成员接口，不会增加Eth-Trunk活动接口的数目，超过上限阈值的链路状态将被置为Down，作为备份链路。</li>
</ul>
</li>
<li><p>活动接口数下限阈值</p>
<ul>
<li>设置活动接口数下限阈值是为了保证最小带宽，当前活动链路数目小于下限阈值时，Eth-Trunk接口的状态转为Down。</li>
</ul>
</li>
<li><p>设备支持的链路聚合方式</p>
<ul>
<li>同板：是指链路聚合时，同一聚合组的成员接口分布在同一单板上。</li>
<li>跨板：是指链路聚合时，同一聚合组的成员接口分布在不同的单板上。</li>
<li>跨框：是指在集群场景下，成员接口分布在集群的各个成员设备上。</li>
<li>跨设备：是指E-Trunk基于LACP进行了扩展，能够实现多台设备间的链路聚合。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8751.png"></p>
<blockquote>
<ul>
<li><p>Eth-Trunk模块根据转发表转发数据帧的过程如下：</p>
<p>1.Eth-Trunk模块从MAC子层接收到一个数据帧后，根据负载分担方式提取数据帧的源MAC地址/IP地址或目的MAC地址/IP地址。</p>
<p>2.根据HASH算法进行计算，得到HASH-KEY值。</p>
<p>3.Eth-Trunk模块根据HASH-KEY值在转发表中查找对应的接口，把数据帧从该接口发送出去。</p>
</li>
<li><p>例如 ，某设备每Eth-Trunk支持最大加入接口数为8个，将接口1、2、3、4捆绑为一个Eth-Trunk接口，此时生成的转发表如图2所示。其中HASH-KEY值为0、1、2、3、4、5、6、7，对应的出接口号分别为1、2、3、4、1、2、3、4。</p>
</li>
<li><p>为了避免数据包乱序情况的发生，Eth-Trunk采用逐流负载分担的机制，其中如何转发数据则由于选择不同的负载分担方式而有所差别。</p>
</li>
<li><p>负载分担的方式主要包括以下几种，用户可以根据具体应用选择不同的负载分担方式。</p>
<ul>
<li>根据报文的源MAC地址进行负载分担；</li>
<li>根据报文的目的MAC地址进行负载分担；</li>
<li>根据报文的源IP地址进行负载分担；</li>
<li>根据报文的目的IP地址进行负载分担；</li>
<li>根据报文的源MAC地址和目的MAC地址进行负载分担；</li>
<li>根据报文的源IP地址和目的IP地址进行负载分担；</li>
<li>根据报文的VLAN、源物理端口等对L2、IPv4、IPv6和MPLS报文进行增强型负载分担。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8752.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8753.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8754.png"></p>
<blockquote>
<p>作为链路聚合技术，手工模式Eth-Trunk可以完成多个物理接口聚合成一个Eth-Trunk口来提高带宽，同时能够检测到同一聚合组内的成员链路有断路等有限故障，但是无法检测到链路层故障、链路错连等故障。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8755.png"></p>
<blockquote>
<ul>
<li><p>如图所示，两端设备均会收到对端发来的LACPDU报文。以DeviceB为例，当DeviceB收到DeviceA发送的报文时，DeviceB会查看并记录对端信息，然后比较系统优先级字段，如果DeviceA的系统优先级高于本端的系统优先级，则确定DeviceA为LACP主动端。如果DeviceA和DeviceB的系统优先级相同，比较两端设备的MAC地址，确定MAC地址小的一端为LACP主动端。</p>
</li>
<li><p>选出主动端后，两端都会以主动端的接口优先级来选择活动接口，如果主动端的接口优先级都相同则选择接口编号比较小的为活动接口。两端设备选择了一致的活动接口，活动链路组便可以建立起来，从这些活动链路中以负载分担的方式转发数据。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8756.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8757.png"></p>
<blockquote>
<ul>
<li><p>在设备集群情况下，为了保证流量的可靠传输，流量的出接口设置为Eth-Trunk接口。那么Eth-Trunk接口中必定存在跨框成员口。当集群设备转发流量时，Eth-Trunk接口通过HASH算法可能会选择跨框的成员口。由于集群设备间线缆带宽有限，跨框转发流量增加了集群设备之间的带宽承载压力，同时也降低了流量转发效率。为了解决这个问题，可以使能Eth-Trunk接口流量本地优先转发。</p>
</li>
<li><p>如图所示，DeviceB和DeviceC组成集群，集群设备和DeviceA之间用Eth-Trunk连接。通过在集群设备上部署接口流量本地优先转发功能，可实现：</p>
<ul>
<li>入本设备流量从本设备转发<ul>
<li>当Eth-Trunk接口在DeviceB有出接口且出接口无故障时，DeviceB的Eth-Trunk接口转发表中将只包含DeviceB的出接口。这样DeviceB到DeviceA的流量在通过HASH算法选择出接口时只能选中DeviceB的接口，流量从DeviceB本设备转发出去。</li>
</ul>
</li>
<li>入本设备流量跨框转发<ul>
<li>当Eth-Trunk接口在DeviceB本设备无出接口或者出接口全部故障时，DeviceB的Eth-Trunk转发表中将包含Eth-Trunk接口中所有可转发的出接口。这样DeviceB到DeviceA的流量在通过HASH算法选择出接口时将选中DeviceC上的出接口，流量将通过DeviceC跨框转发。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8758.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8759.png"></p>
<blockquote>
<ul>
<li><p>E-Trunk机制主要应用于CE双归接入VPLS、VLL、PWE3网络时，CE与PE间的链路保护以及对PE设备节点故障的保护。在没有使用E-Trunk前，CE通过Eth-Trunk链路只能单归到一个PE设备。如果Eth-Trunk出现故障或者PE设备故障，CE将无法与PE设备继续进行通信。使用E-Trunk后，CE可以双归到PE上，从而实现设备间保护。</p>
</li>
<li><p>如图，CE分别与PE1和PE2直连，PE1和PE2之间运行E-Trunk。PE侧，需要在PE1和PE2设备上分别创建ID相同的E-Trunk和Eth-Trunk，并将Eth-Trunk加入到E-Trunk。CE侧，在CE设备上配置LACP模式的Eth-Trunk，此Eth-Trunk分别与PE1和PE2设备相连。对CE设备而言，E-Trunk不可见。</p>
</li>
<li><p>PE1与PE2设备之间通过E-Trunk报文进行主备协商，确定E-Trunk的主备状态。正常情况下两台PE的协商结果是一个为主用一个为备用。PE设备上E-Trunk主备状态是根据报文中所携带的E-Trunk优先级和E-Trunk系统ID确定的。优先级的数值越小，优先级越高，优先级高的为主用。如果E-Trunk优先级相同，那么E-Trunk系统ID小的为主用。PE1为主，PE1的Eth-Trunk 10为主，链路状态为Up。PE2为备，PE2的Eth-Trunk 10为备，链路状态为Down。</p>
</li>
<li><p>如果CE到PE1间的链路出现故障：PE1会向对端发送E-Trunk报文，报文中携带PE1的Eth-Trunk 10故障的信息。PE2收到E-Trunk报文后，发现对端Eth-Trunk 10故障，则PE2设备上Eth-Trunk 10的状态将变为主。然后经过LACP协商，PE2设备上的Eth-Trunk 10的状态变为Up。这样PE2设备的Eth-Trunk状态变为Up，CE的流量会通过PE2转发，以达到对CE的流量进行保护的目的。</p>
</li>
<li><p>如果PE1设备出现故障：如果PE设备上配置了BFD，PE2检测到BFD会话状态为Down后，PE2设备从备用状态变为主用状态，PE2的Eth-Trunk 10状态也变为主。如果PE设备上没有配置BFD，PE2设备上的定时器超时后仍然没有收到PE1设备发送的E-Trunk报文，PE2设备从备用状态变为主用状态，PE2的Eth-Trunk 10状态也变为主。经过LACP协商，PE2设备上的Eth-Trunk 10的状态变为Up。CE的流量会通过PE2转发，以达到对CE的流量进行保护的目的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8760.png"></p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>如何清除MAC地址表项和ARP表项？</p>
<ul>
<li>清除所有动态MAC（系统视图）：undo mac-address dynamic </li>
<li>清除所有静态MAC（系统视图） ：undo mac-address static</li>
<li>删除一条静态ARP表项（系统视图）：undo arp static</li>
<li>删除多条ARP表项（用户视图）：reset arp</li>
</ul>
</li>
<li><p>MSTP域如何配置？</p>
<ul>
<li>MSTP的域信息在stp region-configuration视图下配置，同一个域中各台设备的域配置信息必须完全一致。存在任何一点差异，就不在同一个域中。MSTP可以配置的域信息有：<ul>
<li>Format selector：格式选择符，在命令行不能配置，默认为0；</li>
<li>Region name：域名，默认是桥MAC地址；</li>
<li>Revision level：修订级别，默认是0；</li>
<li>Instance/Vlans Mapped：实例和VLAN映射表，默认全部VLAN映射到实例0。</li>
</ul>
</li>
</ul>
</li>
<li><p>Eth-Trunk是否支持抢占功能？</p>
<ul>
<li>只有在LACP模式下，Eth-Trunk才支持优先级抢占功能，可以执行lacp preempt enable命令使能优先级抢占功能。在LACP模式下，当活动链路中出现故障链路时，系统会从备用链路中选择优先级最高的链路替代故障链路；如果被替代的故障链路恢复了正常，而且该链路的优先级又高于替代自己的链路，这种情况下，如果使能了LACP优先级抢占功能，高优先级链路会抢占低优先级链路，回切到活动状态。要求Eth-Trunk两端LACP抢占功能使能情况配置一致，即：统一使能或不使能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8761.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/" itemprop="url">IE-WAN技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-20T08:22:43+08:00">
                2021-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/1.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/2.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/3.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/4.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/5.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/6.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/7.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/8.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/9.png"></p>
<blockquote>
<p>lT: 表示双绞线；</p>
<p>lTX：表示2对高质量的双绞线；</p>
<p>lFX：表示2根光纤。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/10.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/11.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/12.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/13.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/14.png"></p>
<blockquote>
<p>lOC-n: Optical Carrier level n（光载体等级）是光纤传输的一种单位，最小的单位为OC-1，其传输数据量约为51.84 Mbps。</p>
<p>lSTM: Synchronous Transport Module，同步传输模块。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/15.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/16.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/17.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/18.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/19.png"></p>
<blockquote>
<ul>
<li><p>PPP共定义了三个协议组件，分别是数据封装方式，链路控制协议（Link Control Protocol，LCP）和网络层控制协议（Network Control Protocol，NCP）。</p>
</li>
<li><p>数据封装方式定义了如何封装多种类型的上层协议数据包。</p>
</li>
<li><p>为了能适应多种多样的链路类型，PPP定义了链路控制协议LCP。LCP可以自动检测链路环境，如是否存在环路；协商链路参数，如最大数据包长度，使用何种认证协议等等。与其他数据链路层协议相比，PPP协议的一个重要特点是可以提供认证功能，链路两端可以协商使用何种认证协议并实施认证过程，只有认证成功才会建立连接。这个特点使PPP协议适合运营商用来接入分散的用户。</p>
</li>
<li><p>PPP定义了一组网络层控制协议NCP，每一个协议对应一种网络层协议，用于协商网络层地址等参数，例如IPCP用于协商控制IP，IPXCP用于协商控制IPX协议等。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/20.png"></p>
<blockquote>
<p>PPP报文封转格式</p>
<ul>
<li><p>Flag域</p>
<ul>
<li>Flag域标识一个物理帧的起始和结束，该字节为0x7E。</li>
</ul>
</li>
<li><p>Address域</p>
<ul>
<li>Address域可以唯一标识对端。PPP协议是被运用在点对点的链路上，因此，使用PPP协议互连的两个通信设备无须知道对方的数据链路层地址。按照协议的规定将该字节填充为全1的广播地址，对于PPP协议来说，该字段无实际意义。</li>
</ul>
</li>
<li><p>Control域</p>
<ul>
<li>该字段默认值为0x03，表明为无序号帧，PPP默认没有采用序列号和确认来实现可靠传输。</li>
<li>Address和Control域一起标识此报文为PPP报文，即PPP报文头为FF03。</li>
</ul>
</li>
<li><p>Protocol域</p>
<ul>
<li>协议域可用来区分PPP数据帧中信息域所承载的数据报类型。</li>
</ul>
</li>
<li><p>Code域</p>
<ul>
<li>代码域的长度为一个字节，主要是用来标识LCP数据报文的类型。</li>
</ul>
</li>
<li><p>Identifier域</p>
<ul>
<li>标识域为1个字节，用来匹配请求和响应，当标识域值为非法时，该报文将被丢弃。</li>
<li>通常一个配置请求报文的ID是从0x01开始逐步加1的。当对端接收到该配置请求报文后，无论使用何种报文回应对方，但必须要求回应报文中的ID要与接收报文中的ID一致。</li>
</ul>
</li>
<li><p>Length域</p>
<ul>
<li>长度域的值就是该LCP报文的总字节数据。它是代码域、标志域、长度域和数据域四个域长度的总和。</li>
<li>长度域所指示字节数之外的字节将被当作填充字节而忽略掉，而且该域的内容不能超过MRU的值。</li>
</ul>
</li>
<li><p>Data域</p>
<ul>
<li>Type为协商选项类型。</li>
<li>Length为协商选项长度，它是指Data域的总长度，也就是包含Type、Length和Data。</li>
<li>Data为协商的选项具体内容。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/22.png"></p>
<blockquote>
<p>建链过程</p>
<ul>
<li>Dead：这是PPP工作开始和结束的阶段。当物理层变为可用状态（UP）之后，PPP进入Establish阶段。</li>
<li>Establish：PPP在此阶段使用LCP协商链路层参数。如果链路层参数协商不成功（FAIL），则PPP连接建立不成功，PPP退回到Dead阶段。如果链路层参数协商成功（OPENED），则PPP进入Authenticate阶段。</li>
<li>Authenticate：PPP在此阶段认证对端，如果认证失败（FAIL），则PPP进入Terminate阶段；如果认证成功（SUCCESS）或者没配置认证（NONE），则PPP进入Network阶段。</li>
<li>Network：PPP在此阶段使用NCP进行网络层参数协商，协商成功则PPP连接建立成功，开始传输网络层数据包。当上层协议认为应当关闭此连接（例如按需电路）或者管理员手工关闭PPP连接（CLOSING），则PPP进入Terminate阶段。</li>
<li>Terminate：PPP在此阶段使用LCP关闭PPP连接。PPP连接关闭（Down）后，PPP进入Dead阶段。</li>
</ul>
<p>注意：此处列出的是PPP的工作阶段，并非PPP的协议状态。由于PPP是由一组协议组成的，因此PPP本身没有协议状态。只有特定的的协议如LCP和NCP等才有协议状态和状态转换（协议状态机）。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/23.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/24.png"></p>
<blockquote>
<ul>
<li><p>LCP协议有3大类报文：</p>
<p>1.链路配置包，用于建立和配置链路：Configure-Request（匹配请求），Configure-Ack（匹配确认），Configure-Nak（匹配否认），和Configure-Reject（匹配拒绝）。</p>
<p>2.链路结束包，用于结束一个链路：Terminate-Request（终止请求） 和 Terminate-Ack（终止确认）。</p>
<p>3.链路维修包，用于管理和调试一个链路：Code-Reject（代码拒绝）, Protocol-Reject（协议拒绝）, Echo-Request（回波请求）, Echo-Reply（回波应答）, 和 Discard-Request（抛弃请求）。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/25.png"></p>
<blockquote>
<ul>
<li>用于协商的参数<ul>
<li>在VRP平台上，MRU参数使用接口上配置的最大传输单元（MTU）值来表示的。</li>
<li>常用的PPP认证协议有PAP和CHAP（后续章节介绍），一条PPP链路的两端可以使用不同的认证协议认证对端，但是被认证方必须支持认证方使用的认证协议并正确配置用户名和密码等认证信息。</li>
<li>LCP使用魔术字（Magic-Number）检测链路环路和其它异常情况。魔术字为随机产生的一个数字，随机机制需要保证两端产生相同魔术字的可能性几乎为0。</li>
<li>收到一个Configure-Request报文之后，其包含的魔术字需要和本地产生的魔术字做比较，如果不同，表示链路无环路，则使用Confugure-Ack报文确认（其他参数也协商成功），表示魔术字协商成功。在后续发送的报文中，如果报文含有魔术字字段，则该字段设置为协商成功的魔术字，LCP不再产生新的魔术字。</li>
<li>如果收到的Configure-Request报文和自身产生的魔术字相同，则发送一个Configure-Nak报文，携带一个新的魔术字。然后，不管新收到的Configure-Nak报文中是否携带相同的魔术字，LCP都发送一个新的Configure-Request报文，携带一个新的魔术字。如果链路有环路，则这个过程会不停的持续下去，如果链路没有环路，则报文交互会很快恢复正常。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/26.png"></p>
<blockquote>
<ul>
<li><p>链路协商成功</p>
<ul>
<li>如图所示，R1和R2使用串行链路相连，运行PPP。当物理层链路变为可用状态之后，R1和R2使用LCP协商链路参数。本例中，R1首先发送一个LCP报文。</li>
<li>R1向R2发送Configure-Request报文，此报文包含在发送者（R1）上配置的链路层参数，每个链路层参数使用“类型，长度，取值”的结构表示。</li>
<li>当R2收到此Configure-Request报文之后，如果R2能识别此报文中的所有链路层参数，并且认为每个参数的取值都是可以接受的，则向R1回应一个Configure-Ack报文。</li>
<li>在没有收到Configure-Ack报文的情况下，每隔3秒重传一次Configure-Request报文，如果连续10次发送Configure-Request报文仍然没有收到Configure-Ack报文，则认为对端不可用，停止发送Configure-Request报文。</li>
</ul>
</li>
<li><p>注：完成上述过程只是表明R2认为R1上的链路参数配置是可接受的。R2也需要向R1发送Configure-Request报文，使R1检测R2上的链路参数配置是不是可接受的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/27.png"></p>
<blockquote>
<ul>
<li>链路协商参数不成功</li>
<li>当R2收到R1发送的Configure-Request报文之后，如果R2能识别此报文中携带的所有链路层参数，但是认为部分或全部参数的取值不能接受，即参数的取值协商不成功，则R2需要向R1回应一个Configure-Nak报文。</li>
<li>在这个Configure-Nak报文中，只包含不能接受的那部分链路层参数列表，每一个包含在此报文中链路层参数的取值均被修改为此报文的发送者（R2）上可以接受的取值（或取值范围）。</li>
<li>在收到Configure-Nak报文之后，R1需要根据此报文中的链路层参数重新选择本地使用的相关参数，并重新发送一个Configure-Request。</li>
<li>连续五次协商仍然不成功的参数将被禁用，不再继续协商。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/28.png"></p>
<blockquote>
<ul>
<li>链路参数协商参数不能识别<ul>
<li>当R2收到R1发送的Configure-Request报文之后，如果R2不能识别此报文中携带的部分或全部链路层参数，则R2需要向R1回应一个Configure-Reject报文。</li>
<li>在此Configure-Reject报文中，只包含不被识别的那部分链路层参数列表。</li>
<li>在收到Configure-Reject报文之后，R1需要向R2重新发送一个Configure-Request报文，在新的Configure-Request报文中，不再包含不被对端（R2）识别的参数。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/29.png"></p>
<blockquote>
<ul>
<li>检测链路状态<ul>
<li>LCP建立连接之后，可以使用Echo-Request报文和Echo-Reply报文检测链路状态，收到一个Echo-Request报文之后应当回应一个Echo-Reply报文，表示链路状态正常。</li>
<li>VRP平台默认每隔10秒发送一次Echo-Request报文。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/30.png"></p>
<blockquote>
<ul>
<li>连接关闭<ul>
<li>认证不成功或者管理员手工关闭等原因可以使LCP关闭已经建立的连接。</li>
<li>LCP关闭连接使用Terminate-Request报文和Terminate-Ack报文，Terminate-Request报文用于请求对端关闭连接，一旦收到一个Terminate-Request报文，LCP必须回应一个Terminate-Ack报文确认连接关闭。</li>
<li>在没有收到Terminate-Ack报文的情况下，每隔3秒重传一次Terminate-Request报文，连续两次重传没有收到Terminate-Ack报文，则认为对端不可用，连接关闭。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/31.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/32.png"></p>
<blockquote>
<p>lPAP报文直接封装在PPP报文中。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/33.png"></p>
<blockquote>
<ul>
<li>PAP工作模式<ul>
<li>被认证方将配置的用户名和密码信息使用Authenticate-Request报文以明文方式发送给认证方，本例中，用户名为“huawei”，密码为“hello”；</li>
<li>认证方收到被认证方发送的用户名和密码信息之后，根据本地配置的用户名和密码数据库检查用户名和密码信息是否正确匹配，如果正确，则返回Authenticate-Ack报文，表示认证成功，如果不能正确匹配，则返回Authenticate-Nak报文，表示认证失败。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/34.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/35.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/36.png"></p>
<blockquote>
<ul>
<li><p>CHAP的认证过程需要三次报文的交互。为了匹配请求报文和回应报文，报文中含有Identifier字段，一次认证过程所使用的报文均使用相同的Identifier信息。CHAP单向验证过程分为两种情况：验证方配置了用户名和验证方没有配置用户名。推荐使用验证方配置用户名的方式，这样可以对验证方的用户名进行确认。</p>
</li>
<li><p>验证方配置了用户名的验证过程（即接口配置命令ppp chap user username）：</p>
<ul>
<li>验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge），并同时将本端的用户名附带上一起发送给被验证方。</li>
<li>被验证方接到验证方的验证请求后，先检查本端接口上是否配置了ppp chap password命令，如果配置了该命令，则被验证方将生成的密文（（Identifier＋密码＋随机数）的MD5）和自己的用户名发回验证方（Response）。如果接口上未配置ppp chap password命令，则根据此报文中验证方的用户名在本端的用户表查找该用户对应的密码，将密文（（Identifier＋密码＋随机数）的MD5）和被验证方自己的用户名发回验证方（Response）。</li>
<li>验证方将自己本身保存的密码、Identifier和随机数进行MD5算法，和收到respone中的密文进行比较，以验证认证是否正确。</li>
</ul>
</li>
<li><p>验证方没有配置用户名（即接口没有配置命令ppp chap user username）：</p>
<ul>
<li>验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge）。</li>
<li>被验证方接到验证方的验证请求后，利用Identifier、ppp chap password命令配置的CHAP密码和随机数进行MD5算法，将生成的密文和自己的用户名发回验证方（Response）。</li>
<li>验证方将自己本身保存的密码、Identifier和随机数进行MD5算法，和收到respone中的密文进行比较，以验证认证是否正确。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/37.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/38.png"></p>
<blockquote>
<ul>
<li><p>IPCP，用于协商控制IP参数，使PPP可用于传输IP数据包。</p>
</li>
<li><p>IPCP使用和LCP相同的协商机制、报文类型，但IPCP并非调用LCP，只是工作过程、报文等和LCP相同。</p>
<ul>
<li>两端配置的IP地址分别为12.1.1.1/24和12.1.1.2/24（两端IP地址即使不在同一网段也会通过IPCP协商）。</li>
<li>两端静态配置IP地址的时候协商过程如下：<ul>
<li>R1和R2都要发送Configure-Request报文，在此报文中包含本地配置的IP地址。</li>
<li>R1和R2接收到对端的Configure-Request报文之后，检查其中的IP地址，如果IP地址是一个合法的单播IP地址，而且和本地配置的IP地址不同（没有IP冲突），则认为对端可以使用该地址，回应一个Configure-Ack报文。</li>
<li>通过IPCP发送的信息，PPP链路的两端都可以知道对端使用的32位IP地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/39.png"></p>
<blockquote>
<ul>
<li><p>如图所示，R1配置为请求对端分配IP地址，R2配置IP地址12.1.1.2/24，并且启用R2给对端分配IP地址的能力，给R1分配IP地址12.1.1.1。</p>
</li>
<li><p>两端动态协商IP地址的过程如下：</p>
<ul>
<li>R1向R2发送一个Configure-Request报文，此报文中含有IP地址0.0.0.0，一个含有0.0.0.0的IP地址的Configure-Request报文表示向对端请求IP地址；</li>
<li>R2收到上述Configure-Request报文后，认为其中包含的地址（0.0.0.0）不合法，使用Configure-Nak回应一个新的IP地址12.1.1.1；</li>
<li>R1收到此Configure-Nak报文之后，更新本地IP地址，并重新发送一个Configure-Request报文，包含新的IP地址12.1.1.1；</li>
<li>R2收到Configure-Request报文后，认为其中包含的IP地址为合法地址，回应一个Configure-Ack报文；</li>
<li>同时，R2也要向R1发送Configure-Request报文请求使用地址12.1.1.2，R1认为此地址合法，回应Configure-Ack报文。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/40.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/41.png"></p>
<blockquote>
<p>MultiLink PPP允许将报文分片，分片将从多个点对点链路上送到同一个目的地。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/42.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/43.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>ppp authentication-mode命令用来设置本端PPP协议对对端设备的认证方式。</li>
<li>ppp chap user命令用来配置CHAP验证的用户名。</li>
<li>ppp chap password命令用来配置CHAP验证的口令。</li>
<li>ip address ppp-negotiate命令用来为本端接口配置IP地址可协商属性，使本端接口接受PPP协商产生的由对端分配的IP地址。</li>
<li>remote address命令用来配置为对端分配IP地址或指定地址池。</li>
</ul>
</li>
<li><p>ppp authentication-mode { chap | pap }</p>
<ul>
<li>chap：采用CHAP认证方式。</li>
<li>pap：采用PAP认证方式。</li>
</ul>
</li>
<li><p>ppp chap user username</p>
<ul>
<li>username：设置CHAP验证的用户名。</li>
</ul>
</li>
<li><p>ppp chap password { cipher | simple } password</p>
<ul>
<li>cipher：表示密码为密文显示。</li>
<li>simple：表示密码为明文显示。</li>
<li>password：设置CHAP认证的口令。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/44.png"></p>
<blockquote>
<ul>
<li>命令含义<ul>
<li>interface mp-group命令用来创建一个MP-Group类型的接口并进入MP-Group接口视图。</li>
<li>ppp mp mp-group命令用来将接口加入指定的MP-group，使该接口工作在MP方式。</li>
<li>restart命令用来重新启动当前接口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/45.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/46.png"></p>
<blockquote>
<ul>
<li>Trunk接口分为Eth-Trunk和IP-Trunk两种。<ul>
<li>Eth-Trunk只能由以太网链路构成。</li>
<li>IP-Trunk一般由POS接口构成。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/47.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/48.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/49.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/50.png"></p>
<blockquote>
<ul>
<li>PPPoE概述<ul>
<li>PPPoE利用以太网将大量主机组成网络，通过一个远端接入设备连入因特网，并运用PPP协议对接入的每个主机进行控制，具有适用范围广、安全性高、计费方便的特点。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/51.png"></p>
<blockquote>
<ul>
<li><p>PPPoE可分为三个阶段，即Discovery阶段、Session阶段和Terminate阶段。</p>
</li>
<li><p>Discovery阶段：</p>
<ul>
<li>PPPoE Client广播发送一个PADI（PPPoE Active Discovery Initial）报文，在此报文中包含PPPoE Client想要得到的服务类型信息。</li>
<li>所有的PPPoE Server收到PADI报文之后，将其中请求的服务与自己能够提供的服务进行比较，如果可以提供，则单播回复一个PADO（PPPoE Active Discovery Offer）报文。</li>
<li>根据网络的拓扑结构，PPPoE Client可能收到多个PPPoE Server发送的PADO报文，PPPoE Client选择最先收到的PADO报文对应的PPPoE Server做为自己的PPPoE Server，并单播发送一个PADR（PPPoE Active Discovery Request）报文。</li>
<li>PPPoE Server产生一个唯一的会话ID（Session ID），标识和PPPoE Client的这个会话，通过发送一个PADS（PPPoE Active Discovery Session-confirmation）报文把会话ID发送给PPPoE Client，会话建立成功后便进入PPPoE Session阶段。</li>
<li>完成后通信双方都会知道PPPoE的Session_ID及对方MAC，它们共同确定唯一的PPPoE Session。</li>
</ul>
</li>
<li><p>Seesion阶段：</p>
<ul>
<li>PPPoE Session上的PPP协商和普通的PPP协商方式一致。PPPoE Session的PPP协商成功后，就可以承载PPP数据报文。在PPPoE Session阶段所有的以太网数据包都是单播发送的。</li>
</ul>
</li>
<li><p>Terminate阶段：</p>
<ul>
<li>进入PPPoE Session阶段后，PPPoE Client和PPPoE Server都可以通过发送PADT报文的方式来结束PPPoE连接。PADT数据包可以在会话建立以后的任意时刻单播发送。在发送或接收到PADT后，就不允许再使用该会话发送PPP流量了。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/52.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/53.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/54.png"></p>
<blockquote>
<p>此例中，R1模拟PPPoE客户机PC进行PPPoE拨号上网，R4作为PPPoE Server对其进行验证和地址分配。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/55.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E5%89%B2%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E5%89%B2%E6%8E%A5/" itemprop="url">IPadv-网络割接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T13:47:55+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/" itemprop="url">IPadv-网络故障排除</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T13:47:46+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" itemprop="url">IPadv-网络运维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T13:47:37+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/" itemprop="url">IPadv-IPv6路由</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T12:56:13+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/IPv6%E8%B7%AF%E7%94%B1.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•随着万物互联时代的到来，IPv4地址空间不足，IPv6取代IPv4势在必行。那么如何实现IPv6网络中各个节点之间的可达性呢？与IPv4网络相同，IPv6网络同样支持静态路由和动态路由协议。</p>
<p>•IPv6静态路由与IPv4静态路由在配置方式上颇为相似。为了实现对IPv6网络的支持，IETF制定了OSPFv3，同时对IS-IS、BGP做了扩展。</p>
<p>•本课程将介绍IPv6静态路由的概念及配置，还会介绍常见的IPv6动态路由协议，包括：OSPFv3，IS-IS（IPv6），以及BGP4+。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫实现IPv6静态路由的配置</p>
<p>▫分析OSPFv3与OSPFv2的不同点</p>
<p>▫实现OSPFv3的基本配置</p>
<p>▫描述IS-IS对IPv6的扩展</p>
<p>▫实现IS-IS（IPv6）的基本配置</p>
<p>▫描述BGP对IPv6的扩展</p>
<p>▫实现BGP4+的基本配置</p>
<h1 id="1-IPv6静态路由"><a href="#1-IPv6静态路由" class="headerlink" title="1.IPv6静态路由"></a>1.IPv6静态路由</h1><h2 id="IPv6静态路由"><a href="#IPv6静态路由" class="headerlink" title="IPv6静态路由"></a>IPv6静态路由</h2><p>•IPv6静态路由与IPv4静态路由类似，也需要管理员手工配置，适合于一些结构比较简单的IPv6网络。</p>
<p>•在创建IPv6静态路由时，可以同时指定出接口和下一跳，或者只指定出接口或只指定下一跳。</p>
<p>​    ▫对于点到点接口：指定出接口。</p>
<p>​    ▫对于广播类型接口：指定下一跳。</p>
<p>•IPv6静态路由负载分担和备份：</p>
<p>​    ▫在创建相同目的地址的多条IPv6静态路由时，如果指定相同优先级，则可实现负载分担，如果指定不同优先级，则可实现路由备份。</p>
<blockquote>
<p>•IPv6静态路由与IPv4静态路由之间的主要区别是目的地址和下一跳地址有所不同，IPv6静态路由使用的是IPv6地址，而IPv4静态路由使用IPv4地址。</p>
</blockquote>
<h2 id="IPv6静态路由的基础配置命令"><a href="#IPv6静态路由的基础配置命令" class="headerlink" title="IPv6静态路由的基础配置命令"></a>IPv6静态路由的基础配置命令</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/1.png"></p>
<blockquote>
<p>•[Huawei] <strong>ipv6</strong> <strong>route-static</strong> <em>dest-ipv6-address</em> <em>prefix-length</em> { <em>interface-type</em> <em>interface-number</em> [ <em>nexthop-ipv6-address</em> ] | <em>nexthop-ipv6-address</em> | <strong>vpn-instance</strong> <em>vpn-destination-name</em> <em>nexthop-ipv6-address</em> } [ <strong>preference</strong> <em>preference</em>]  [ <strong>permanent</strong> | <strong>inherit-cost</strong> ] [ <strong>description</strong> <em>text</em> ]</p>
<ul>
<li><strong>preference</strong> <em>preference</em>：指定路由优先级。整数形式，取值范围为1～255。缺省值是60。</li>
<li><strong>permanent</strong>：指定IPv6静态路由永久发布。</li>
<li><strong>inherit-cost</strong>：指定IPv6静态路由继承迭代路由的开销值。</li>
<li><strong>description</strong> <em>text</em>：指定静态路由的描述信息。字符串形式，支持空格，长度范围是1～80。</li>
</ul>
<p>•[Huawei] <strong>ipv6</strong> <strong>route-static</strong> <strong>vpn-instance</strong> <em>vpn-instance-name</em> <em>dest-ipv6-address</em> <em>prefix-length</em> { [ <em>interface-type</em> <em>interface-number</em> [ <em>nexthop-ipv6-address</em> ] ] | <em>nexthop-ipv6-address</em> [ <strong>public</strong> ] | <strong>vpn**</strong>-instance** <em>vpn*</em>-destination-name* <em>nexthop-ipv6-address</em> } [ <strong>preference</strong> <em>preference</em> ] [ <strong>permanent</strong> | <strong>inherit-cost</strong> ] [ <strong>description</strong> <em>text</em> ]</p>
<ul>
<li><strong>public</strong>：指定<em>nexthop-ipv6-address</em>是公网地址，而不是源VPN中的地址。</li>
</ul>
</blockquote>
<h2 id="IPv6静态路由配置举例"><a href="#IPv6静态路由配置举例" class="headerlink" title="IPv6静态路由配置举例"></a>IPv6静态路由配置举例</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/2.png"></p>
<h1 id="2-OSPFv3原理与配置"><a href="#2-OSPFv3原理与配置" class="headerlink" title="2.OSPFv3原理与配置"></a>2.OSPFv3原理与配置</h1><h2 id="OSPFv3的基本工作原理"><a href="#OSPFv3的基本工作原理" class="headerlink" title="OSPFv3的基本工作原理"></a>OSPFv3的基本工作原理</h2><h3 id="OSPFv3概述"><a href="#OSPFv3概述" class="headerlink" title="OSPFv3概述"></a>OSPFv3概述</h3><p>•OSPF是IETF定义的一种基于链路状态的内部网关路由协议。目前针对IPv4协议使用的是OSPF Version 2（OSPFv2），针对IPv6协议使用OSPF Version 3（OSPFv3）。</p>
<p>•OSPFv3的主要目的是开发一种独立于任何具体网络层的路由协议。为实现这一目的，OSPFv3的内部路由器信息被重新进行了设计。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/3.png"></p>
<h3 id="OSPFv3与OSPFv2的相同点"><a href="#OSPFv3与OSPFv2的相同点" class="headerlink" title="OSPFv3与OSPFv2的相同点"></a>OSPFv3与OSPFv2的相同点</h3><p>OSPF的基本运行机制没有改变，包括：</p>
<p>▫基本概念：</p>
<p>​    ▪区域划分及路由器类型</p>
<p>​    ▪路由计算影响参数：优先级、度量值</p>
<p>​    ▪支持的网络类型：Broadcast（广播类型）、NBMA、P2P（点到点类型）、P2MP（点到多点类型）</p>
<p>​    ▪报文类型：Hello报文、DD报文、LSR报文、LSU报文和LSAck报文</p>
<p>▫工作原理：</p>
<p>​    ▪邻居关系的建立及邻居状态的转换</p>
<p>​    ▪DR与BDR的选举</p>
<p>​    ▪LSA泛洪机制</p>
<p>​    ▪路由计算过程</p>
<blockquote>
<p>•相同点还包括：对特殊区域、虚连接、多进程的支持等。</p>
<p>•本课程对以上内容不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
</blockquote>
<h3 id="OSPFv3拓扑和路由器类型"><a href="#OSPFv3拓扑和路由器类型" class="headerlink" title="OSPFv3拓扑和路由器类型"></a>OSPFv3拓扑和路由器类型</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/4.png"></p>
<h3 id="OSPFv3的基本工作原理与OSPFv2相似"><a href="#OSPFv3的基本工作原理与OSPFv2相似" class="headerlink" title="OSPFv3的基本工作原理与OSPFv2相似"></a>OSPFv3的基本工作原理与OSPFv2相似</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/5.png"></p>
<h3 id="OSPFv3与OSPFv2的不同点"><a href="#OSPFv3与OSPFv2的不同点" class="headerlink" title="OSPFv3与OSPFv2的不同点"></a>OSPFv3与OSPFv2的不同点</h3><p>•OSPFv3基于链路运行以及拓扑计算，而不再是网段。</p>
<p>•OSPFv3支持一个链路上多个实例。</p>
<p>•OSPFv3报文和LSA中去掉了IP地址的意义，且重构了报文格式和LSA格式。</p>
<p>​    ▫OSPFv3报文和Router LSA/Network LSA中不包含IP地址。</p>
<p>​    ▫OSPFv3的LSA中定义了LSA的泛洪范围。</p>
<p>​    ▫OSPFv3中创建了新的LSA承载IPv6地址和前缀。</p>
<p>​    ▫OSPFv3邻居不再由IP地址标识，只由Router ID标识。</p>
<h3 id="唯一邻居标识：Router-ID"><a href="#唯一邻居标识：Router-ID" class="headerlink" title="唯一邻居标识：Router ID"></a>唯一邻居标识：Router ID</h3><p>OSPFv3通过Router ID来标识网络设备。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/6.png"></p>
<blockquote>
<p>•OSPFv2在Broadcast、NBMA、P2P和P2MP网络中是通过IPv4接口地址来标识邻居，而在虚连接网络中是通过Router ID来标识邻居。</p>
</blockquote>
<h3 id="OSPFv3基于链路运行"><a href="#OSPFv3基于链路运行" class="headerlink" title="OSPFv3基于链路运行"></a>OSPFv3基于链路运行</h3><p>OSPFv3是基于链路运行的，设备只要在同一链路，就可以建立邻居关系。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/7.png"></p>
<blockquote>
<p>•IPv6中重点强调了链路的概念，在IPv6中，一个链路上可以分配多个IP子网，也就是IPv6前缀。和IPv4不同的是，同一个链路上的两个节点即使不具有相同的IPv6前缀，也可以直接通过这个链路通信。这一点极大地改变了OSPF的行为。</p>
<p>•在OSPFv3中我们更多的是使用“链路”和“前缀”这两个术语。但这两个概念是分离的，没有必然的对应关系，所以在讨论路由协议时，OSPFv2的术语“网络”和“子网”在这里应该用“链路”替换掉。</p>
</blockquote>
<h3 id="链路支持多实例"><a href="#链路支持多实例" class="headerlink" title="链路支持多实例"></a>链路支持多实例</h3><p>•一个OSPFv3物理接口可以和多个实例绑定，并用不同的实例标识（Instance ID）区分，即OSPFv3的单个链路支持运行多个OSPFv3实例。</p>
<p>•这些运行在同一条物理链路上的多个OSPFv3实例，分别与链路对端设备建立邻居及发送报文，且互不干扰，这样可以充分共享同一链路资源。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/8.png"></p>
<blockquote>
<p>•多实例通过在OSPFv3报文头部增加一个Instance ID区别不同的实例来实现。一个分配了给定Instance ID的实例，将会丢弃那些与该Instance ID不匹配的OSPFv3报文。</p>
</blockquote>
<h3 id="OSPFv3对链路本地地址的使用"><a href="#OSPFv3对链路本地地址的使用" class="headerlink" title="OSPFv3对链路本地地址的使用"></a>OSPFv3对链路本地地址的使用</h3><p>•OSPFv3使用链路本地（FE80::/10）地址作为发送报文的源地址和路由的下一跳地址。</p>
<ul>
<li>使用链路本地地址来维持邻居关系，同步LSA数据库。</li>
<li>在虚连接上，必须使用全球单播地址或者站点本地地址作为OSPFv3协议报文的源地址。</li>
</ul>
<p>•优势：</p>
<ul>
<li>不需要配置IPv6全球单播地址，就可以得到OSPFv3拓扑，实现拓扑与地址分离。</li>
<li>OSPFv3报文不会被转发到始发链路范围之外，减少了报文不必要的泛洪，节省了带宽。</li>
</ul>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/9.png"></p>
<blockquote>
<p>•IPv6使用链路本地（Link-Local）地址在同一链路上发现邻居及自动配置。运行IPv6的路由器不转发目的地址为链路本地地址的IPv6报文，此类报文只在同一链路有效。</p>
<p>•OSPFv3是运行在IPv6上的路由协议，使用链路本地地址来发送OSPFv3报文。</p>
<ul>
<li><p>OSPFv3假定每个路由器在每个连接的链路上都已被分配链路本地地址，在除虚连接外的所有OSPFv3接口上使用接口关联的链路本地地址作为源地址发送OSPFv3报文。</p>
</li>
<li><p>路由器学习所有其他连接到该链路上的路由器的链路本地地址，并且使用这些地址作为下一跳进行报文转发。</p>
</li>
<li><p>注意：关于链路本地地址的描述仅出现在Link-LSA（链路LSA，OSPFv3新增LSA）中。</p>
</li>
</ul>
</blockquote>
<h3 id="OSPFv3报文"><a href="#OSPFv3报文" class="headerlink" title="OSPFv3报文"></a>OSPFv3报文</h3><p>•OSPFv3与OSPFv2有相同类型的报文：</p>
<p>​    ▫Hello报文、DD报文、LSR报文、LSU报文和LSAck报文。</p>
<p>•OSPFv3与OSPFv2使用相同的协议号89。</p>
<p>​    ▫OSPFv2：IPv4报文头部中的协议号（Protocol）为89。</p>
<p>​    ▫OSPFv3：IPv6报文头部中的下一报头号（Next Header）为89。</p>
<p>•OSPFv3与OSPFv2类似，使用组播地址作为OSPF报文目的地址。</p>
<p>​    ▫OSPFv2使用IPv4组播地址： </p>
<p>​        ▪OSPF IGP Routers：224.0.0.5；OSPF IGP DR ：224.0.0.6。</p>
<p>​    ▫OSPFv3使用IPv6组播地址：</p>
<p>​        ▪OSPF IGP Routers：FF02::5；OSPF IGP DR：FF02::6。</p>
<blockquote>
<p>•OSPFv3报文作用：</p>
<p>▫Hello报文：周期性发送，用来发现、建立和维持OSPFv3邻居关系。</p>
<p>▫DD报文：描述了本地LSDB的摘要信息，用于两台设备进行数据库同步。</p>
<p>▫LSR报文：用于向对方请求所需的LSA。设备只有在OSPFv3邻居双方成功交换DD报文后，才会向对方发出LSR报文。</p>
<p>▫LSU报文：向对方发送其所需的LSA。</p>
<p>▫LSAck报文：用来对收到的LSA进行确认。</p>
</blockquote>
<h3 id="OSPFv3报文头部"><a href="#OSPFv3报文头部" class="headerlink" title="OSPFv3报文头部"></a>OSPFv3报文头部</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/10.png"></p>
<blockquote>
<p>•Version：1Byte，版本，OSPF的版本号。对于OSPFv3来说，其值为3。 </p>
<p>•Type：1Byte，类型，OSPFv3报文的类型，有下面几种类型：</p>
<p>​    ▫1：Hello报文；</p>
<p>​    ▫2：DD报文；</p>
<p>​    ▫3：LSR报文；</p>
<p>​    ▫4：LSU报文；</p>
<p>​    ▫5：LSAck报文。</p>
<p>•Packet length：2Byte，OSPFv3报文的总长度，包括报文头在内，单位为字节。</p>
<p>•Router ID：4Byte，始发此报文的路由器的Router ID。</p>
<p>•Area ID：4Byte，发送该报文的所属区域。</p>
<p>•Checksum：2Byte，使用IPv6标准16位校验和。</p>
<p>•0：1Byte，保留字段，必须填0。 </p>
</blockquote>
<h3 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/11.png"></p>
<blockquote>
<p>•Rtr Pri：1Byte，Router Priority，DR优先级。默认为1。如果设置为0，则路由器不能参与DR或BDR的选举。 </p>
<p>•Options：3Byte，可选项。</p>
<ul>
<li>AT：1bit，表示是否支持OSPFv3认证。若AT=1，则在OSPFv3报文后增加认证尾部字段，包含认证信息。</li>
<li>DC：1bit，表示是否具有支持按需电路的能力。</li>
<li>R：1bit，指明始发路由器是否是一台有效的路由器。</li>
<li>NP：1bit，表示是否为NSSA区域。</li>
<li>MC：1bit，表示是否支持转发组播数据报文。</li>
<li>E：1bit，表示是否支持外部路由。</li>
<li>V6：1bit，表示是否参与IPv6路由计算。如果该位为0，表示该路由器或链路不参与IPv6路由计算。</li>
</ul>
<p>•HelloInterval：2Byte，发送Hello报文的时间间隔。</p>
<p>•RouterDeadInterval ：2Byte，失效时间。如果在此时间内未收到邻居发来的Hello报文，则认为邻居失效。</p>
<p>•Designated Router ID：4Byte，DR的Router ID。</p>
<p>•Backup Designated Router ID ：4Byte，BDR的Router ID。</p>
<p>•Neighbor ID：4Byte，邻居，以Router ID标识。</p>
<p>•说明：DD报文、LSR报文、LSU报文和LSAck报文格式与OSPFv2相比变化不大，本课程不再赘述。</p>
</blockquote>
<h3 id="OSPFv3的LSA头部"><a href="#OSPFv3的LSA头部" class="headerlink" title="OSPFv3的LSA头部"></a>OSPFv3的LSA头部</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/12.png"></p>
<blockquote>
<p>•LS Age：2Byte，LSA产生后所经过的时间，以秒为单位。无论LSA是在链路上传送，还是保存在LSDB中，其值都会在不停的增长。</p>
<p>•LS Type：2Byte，LSA的类型。该字段的高3位标识LSA的通用属性，剩下的比特位标识LSA的特定功能。</p>
<ul>
<li><p>U位标识了对未知LSA的处理方法，即标识了不识别LSA功能代码的路由器应如何处理LSA。</p>
<ul>
<li>0：把此LSA当作具有链路本地泛洪范围来对待，从而只能泛洪到本地链路上。</li>
<li>1：把此LSA当作类型已知的LSA来处理，也就是存储下来并泛洪出去。</li>
</ul>
</li>
<li><p>S2/S1位标识了LSA的泛洪范围。</p>
<ul>
<li>S2 S1=0 0：链路本地范围内，即只在始发链路上泛洪。</li>
<li>S2 S1=0 1：区域范围内，即泛洪到始发区域内的所有路由器。</li>
<li>S2 S1=1 0：AS范围内，即泛洪到本AS的所有路由器。</li>
<li>S2 S1=1 1：预留。</li>
</ul>
</li>
</ul>
<p>•Link State ID：4Byte，本地32位标识符，与IPv6地址无关，与LSA中的LS Type和Advertising Router一起在路由域中描述一个LSA。OSPFv3与OSPFv2相比，Link State ID不再包含地址信息。</p>
<p>•Advertising Router：4Byte，产生此LSA的路由器的Router ID。</p>
<p>•LS Sequence Number：4Byte，LSA的序列号。其他路由器根据这个值可以判断哪个LSA是最新的。</p>
<p>•LS Checksum：2Byte，除了LS Age外其它各域的校验和。</p>
<p>•Length：2Byte，LSA的总长度，包括LSA Header，以字节为单位。</p>
</blockquote>
<h3 id="OSPFv3的LSA类型"><a href="#OSPFv3的LSA类型" class="headerlink" title="OSPFv3的LSA类型"></a>OSPFv3的LSA类型</h3><p>•OSPFv3与OSPFv2相比，具有类似的LSA名称，但是功能略有区别。</p>
<p>•OSPFv3新增了两类LSA，包括：链路LSA和区域内前缀LSA。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/13.png"></p>
<blockquote>
<p>•如表中所示，OSPFv3的LS Type字段，U位缺省为0；除Type5和Type8的LSA外，其余的LSA泛洪范围都是区域范围内（S2 S1=0 1）。</p>
<ul>
<li>链路本地范围。LSA仅在本地链路上泛洪，包括：Link-LSA。</li>
<li>区域范围。LSA在单个OSPF区域内泛洪，包括：Router-LSA、Network-LSA、Inter-Area-Prefix-LSA、Inter-Area-Router-LSA、NSSA LSA和Intra-Area-Prefix-LSA。</li>
<li>AS范围。LSA在整个路由域（自治系统）中扩散，包括：AS-External-LSA。</li>
</ul>
</blockquote>
<h3 id="Type1：Router-LSA"><a href="#Type1：Router-LSA" class="headerlink" title="Type1：Router-LSA"></a>Type1：Router-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/14.png"></p>
<blockquote>
<p>•OSPFv3的Router-LSA字段解释：</p>
<p>▫W：Wild-Card Receiver，值为1时，表示该路由器支持组播路由。</p>
<p>▫V：Virtual Link，值为1时，表示产生此LSA的路由器是虚连接的一端。</p>
<p>▫E：External，值为1时，表示产生此LSA的路由器是ASBR。</p>
<p>▫B：Border，值为1时，表示产生此LSA的路由器是ABR。</p>
<p>▫Options：3Byte，可选项。</p>
<p>​    ▪DC：1bit，表示是否具有支持按需电路的能力。</p>
<p>​    ▪R：1bit，指明始发路由器是否是一台有效的路由器。</p>
<p>​    ▪NP：1bit，表示是否为NSSA区域。</p>
<p>​    ▪MC：1bit，表示是否支持转发组播数据报文。</p>
<p>​    ▪E：1bit，表示是否支持外部路由。</p>
<p>​    ▪V6：1bit，表示是否参与IPv6路由计算。如果该位为0，表示该路由器或链路不参与IPv6路由计算。</p>
<p>▫Link Type：1Byte，链路类型。</p>
<p>​    ▪1：点到点连接到另一台路由器。</p>
<p>​    ▪2：连接到一个传送网络（Transit Network）。</p>
<p>​    ▪3：保留。</p>
<p>​    ▪4：虚链路。</p>
<p>▫Metric：2Byte，流量出接口的开销值。</p>
</blockquote>
<h3 id="Type2：Network-LSA"><a href="#Type2：Network-LSA" class="headerlink" title="Type2：Network-LSA"></a>Type2：Network-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/15.png"></p>
<blockquote>
<p>•OSPFv3的Network-LSA字段解释：</p>
<p>​    ▫Options：与Router-LSA中的Options字段相同。</p>
</blockquote>
<h3 id="Type3：Inter-Area-Prefix-LSA"><a href="#Type3：Inter-Area-Prefix-LSA" class="headerlink" title="Type3：Inter-Area-Prefix-LSA"></a>Type3：Inter-Area-Prefix-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/16.png"></p>
<blockquote>
<p>•OSPFv3的Inter-Area-Prefix-LSA字段解释：</p>
<ul>
<li><p>Metric：3Byte，到目的地址的开销值。</p>
</li>
<li><p>PrefixOptions：由LSA公告的每个前缀都拥有一个自己的PrefixOptions字段。</p>
<ul>
<li>P位: 传播位。如果一个NSSA区域的前缀需要被ABR传播出去，就需要设置这一位。</li>
<li>MC位: 组播位。如果设置为1，则这个前缀应该纳入组播计算中，否则不纳入组播计算。</li>
<li>LA位: 本地地址位。如果设置为1，则这个前缀是路由器的一个接口地址。</li>
<li>NU位: 非单播位。如果设置为1，则这个前缀不会纳入IPv6单播路由计算中。</li>
</ul>
</li>
</ul>
<p>•注意：缺省路由的前缀长度为0。ABR也能够始发一个区域间Type3的LSA向一个末梢区域通告一条缺省路由。</p>
</blockquote>
<h3 id="Type4：Inter-Area-Router-LSA"><a href="#Type4：Inter-Area-Router-LSA" class="headerlink" title="Type4：Inter-Area-Router-LSA"></a>Type4：Inter-Area-Router-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/17.png"></p>
<blockquote>
<p>•OSPFv3的Inter-Area-Router-LSA字段解释：</p>
<p>​    ▫Options：Options字段描述的不是源路由器的能力，而是目的路由器所支持的能力，所以此字段值应该等于目的路由器的Router-LSA的Options字段值。</p>
<p>​    ▫Metric：3Byte，到目的地址的开销值。</p>
</blockquote>
<h3 id="Type5：AS-External-LSA"><a href="#Type5：AS-External-LSA" class="headerlink" title="Type5：AS-External-LSA"></a>Type5：AS-External-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/18.png"></p>
<blockquote>
<p>•OSPFv3的AS-External-LSA字段解释：</p>
<p>▫E：1bit，外部路由的Metric类型。</p>
<ul>
<li><p>如果设置为1，表示此为2类外部路由，其Metric不随着路由的传递而增长。</p>
</li>
<li><p>如果设置为0，表示此为1类外部路由，其Metric随着路由的传递而增长。</p>
</li>
</ul>
<p>▫F：1bit，如果设置为1，则表示后面的Forwarding Address可选字段存在。</p>
<p>▫T：1bit，如果设置为1，则表示后面的External Route Tag可选字段存在。</p>
<p>▫Metric：3Byte，到目的地址的开销值。</p>
<p>▫PrefixLength、PrefixOptions和Address Prefix为描述前缀的三元组，与Inter-Area-Prefix-LSA中该字段含义相同。</p>
<p>▫Forwarding Address：4Byte，可选的128位IPv6地址，当前面的F位为1时存在。表示到达目的的数据应该转发到这个地址。</p>
<p>▫External Route Tag：4Byte，可选的标记位。可以用于ASBR之间的通信。一个比较常见的例子是，在OSPF自治系统的两个边界路由器上进行路由引入时，通过对引入的路由进行标记，可以很方便地进行路由过滤。</p>
<p>▫Referenced Link State ID：4Byte，若Referenced LS Type不为0，则该字段存在，表示引用链路状态ID。</p>
</blockquote>
<h3 id="新增Type8：Link-LSA"><a href="#新增Type8：Link-LSA" class="headerlink" title="新增Type8：Link-LSA"></a>新增Type8：Link-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/19.png"></p>
<blockquote>
<p>•OSPFv3的Link-LSA字段解释：</p>
<ul>
<li>Rtr Pri：1Byte，该路由器在该链路上的优先级(Router Priority)。</li>
<li>Options：3Byte，提供给Network-LSA的Options。</li>
<li>Number of Prefixes：4Byte，该LSA中携带的IPv6地址前缀个数。</li>
<li>PrefixLength、PrefixOptions和Address Prefix为描述前缀的三元组，与Inter-Area-Prefix-LSA中该字段含义相同。</li>
</ul>
</blockquote>
<h3 id="新增Type9：Intra-Area-Prefix-LSA"><a href="#新增Type9：Intra-Area-Prefix-LSA" class="headerlink" title="新增Type9：Intra-Area-Prefix-LSA"></a>新增Type9：Intra-Area-Prefix-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/20.png"></p>
<blockquote>
<p>OSPFv3的Intra-Area-Prefix-LSA字段解释：</p>
<p>▫Number of Prefixes：4Byte，该LSA中携带的IPv6地址前缀个数。必要的话，可以通过多个Intra-Area-Prefix-LSA来携带前缀，这样可以控制LSA的长度。 </p>
<p>▫Referenced LS type：4Byte，表明这个LSA是参考一个Router-LSA，还是一个Network-LSA。</p>
<ul>
<li><p>1：表示参考一个Router-LSA</p>
</li>
<li><p>2：表示参考一个Network-LSA。 </p>
</li>
</ul>
<p>▫Referenced Link State ID：4Byte。</p>
<ul>
<li><p>设为0：当这个LSA是参考一个Router-LSA时。</p>
</li>
<li><p>设为该链路的DR的Interface ID：当这个LSA是参考一个Network-LSA时。 </p>
</li>
</ul>
<p>▫Referenced Advertising Router：4Byte。</p>
<ul>
<li><p>设为这个路由器的Router ID：当这个LSA是参考一个Router-LSA时。</p>
</li>
<li><p>设为该链路的DR的Router ID：当这个LSA是参考一个Network-LSA时。 </p>
</li>
</ul>
<p>▫PrefixLength、PrefixOptions和Address Prefix为描述前缀的三元组，与Inter-Area-Prefix-LSA中该字段含义相同。</p>
<p>▫Metric：2Byte，前缀开销值。与Router-LSA的接口开销值相同单位。</p>
<p>在OSPFv3中，当一条链路或它的前缀发生变化时，相连的路由器会发送一个Intra-Area-Prefix-LSA。但是，这条LSA不会触发SPF计算。</p>
</blockquote>
<h3 id="OSPFv3的LSA举例"><a href="#OSPFv3的LSA举例" class="headerlink" title="OSPFv3的LSA举例"></a>OSPFv3的LSA举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/21.png"></p>
<blockquote>
<p>•如图所示：R1、R2、R3和R4运行OSPFv3路由协议，且均部署在骨干区域。</p>
<p>•网络稳定后，查看R2的LSDB，可以查看到该路由器的Router-LSA（Type1）、Network-LSA（Type2）、Link-LSA（Type8）和Intra-Area-Prefix-LSA（Type9）。</p>
</blockquote>
<h3 id="Link-LSA举例"><a href="#Link-LSA举例" class="headerlink" title="Link-LSA举例"></a>Link-LSA举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/22.png"></p>
<blockquote>
<p>•输出信息解释：</p>
<p>▫LS age：LSA的老化时间。</p>
<p>▫LS Type：LSA的类型。有如下类型：</p>
<ul>
<li>Router-LSA、Network-LSA、Inter-Area-Prefix-LSA、Inter-Area-Router-LSA、AS-external-LSA、NSSA-LSA、Link-LSA、Intra-Area-Prefix-LSA</li>
</ul>
<p>▫Link State ID：LSA报文头中的链路状态ID。</p>
<p>▫Originating Router：产生LSA的路由器。</p>
<p>▫LS Seq Number：LSA序列号（来自LSA报头）。</p>
<p>▫Checksum：LSA的校验和。</p>
<p>▫Length：LSA的长度。</p>
<p>▫Priority：该Link对应接口的优先级。</p>
<p>▫Options：该Link的Option值。</p>
<p>▫Link-Local Address：链路本地地址。</p>
<p>▫Number of Prefixes：该LSA中包含的IPv6前缀数目。</p>
<p>▫Prefix：IPv6前缀。</p>
<p>▫Prefix Options：前缀Option值。</p>
</blockquote>
<h3 id="Intra-Area-Prefix-LSA举例"><a href="#Intra-Area-Prefix-LSA举例" class="headerlink" title="Intra-Area-Prefix-LSA举例"></a>Intra-Area-Prefix-LSA举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/23.png"></p>
<h2 id="OSPFv3的基本配置"><a href="#OSPFv3的基本配置" class="headerlink" title="OSPFv3的基本配置"></a>OSPFv3的基本配置</h2><h3 id="OSPFv3的基础配置命令-1"><a href="#OSPFv3的基础配置命令-1" class="headerlink" title="OSPFv3的基础配置命令 (1)"></a>OSPFv3的基础配置命令 (1)</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/24.png"></p>
<blockquote>
<p>•OSPFv3的配置命令与配置方式与OSPFv2类似，其他配置命令不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
</blockquote>
<h3 id="OSPFv3的基础配置命令-2"><a href="#OSPFv3的基础配置命令-2" class="headerlink" title="OSPFv3的基础配置命令 (2)"></a>OSPFv3的基础配置命令 (2)</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/25.png"></p>
<h3 id="检查OSPFv3基本功能的配置结果"><a href="#检查OSPFv3基本功能的配置结果" class="headerlink" title="检查OSPFv3基本功能的配置结果"></a>检查OSPFv3基本功能的配置结果</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/26.png"></p>
<blockquote>
<p>•[Huawei] <strong>display</strong> <strong>ospfv3</strong> [ <em>process-id</em> ] <strong>lsdb</strong> [ <strong>area</strong> <em>area-id</em> ] [ <strong>originate-router</strong> <em>advertising-router-id</em> | <strong>self-originate</strong> ] [ { <strong>router</strong> | <strong>network</strong> | <strong>inter-router</strong> [ <strong>asbr-router</strong> <em>asbr-router-id</em> ] | { <strong>inter-prefix</strong> | <strong>nssa</strong> } [ <em>ipv6-address</em> <em>prefix-length</em> ] | <strong>link</strong> | <strong>intra-prefix</strong> | <strong>grace</strong> } [ <em>link-state-id</em> ] ]</p>
<ul>
<li><p><em>process-id</em>：OSPFv3进程号。整数形式，取值范围是1～65535。</p>
</li>
<li><p><strong>area</strong> <em>area-id</em>：区域的标识。可以是十进制整数或IPv4地址格式。如果是十进制整数，取值范围是0～4294967295。如果是IPv4地址格式，取值是点分十进制。</p>
</li>
<li><p><strong>external</strong>：显示数据库中AS-external LSA的信息。</p>
</li>
<li><p><strong>inter-prefix</strong>：显示数据库中Inter-Area-Prefix LSA的信息。</p>
</li>
<li><p><strong>inter-router</strong>：显示数据库中Inter-Area-Router LSA的信息。</p>
</li>
<li><p><strong>intra-prefix</strong>：显示数据库中Intra-Area-Prefix LSA的信息。</p>
</li>
<li><p><strong>nssa</strong>：显示数据库中NSSA LSA的信息。</p>
</li>
<li><p><strong>link</strong>：显示数据库中Link-LSA的信息。</p>
</li>
<li><p><strong>network</strong>：显示数据库中Network-LSA的信息。</p>
</li>
<li><p><strong>router</strong>：显示数据库中Router-LSA的信息。</p>
</li>
<li><p><em>link-state-id</em>：链路状态ID。点分十进制格式。</p>
</li>
<li><p><strong>originate-router</strong> <em>advertising-router-id</em>：指定发布LSA的路由器的Router ID。点分十进制格式。</p>
</li>
<li><p><strong>asbr-router</strong> <em>asbr-router-id</em>：指定ASBR路由器的Router ID。点分十进制格式。</p>
</li>
<li><p><strong>self-originate</strong>：显示数据库中由本路由器发布的LSA信息。</p>
</li>
<li><p><em>ipv6-address prefix-length</em>：指定IPv6目的地址及前缀长度。</p>
<ul>
<li><em>ipv6-address</em>是32位16进制数，格式为X:X:X:X:X:X:X:X。</li>
<li><em>prefix-length</em>是整数形式，取值范围是0～128。</li>
</ul>
</li>
</ul>
<p>•[Huawei] <strong>display</strong> <strong>ospfv3</strong> [ <em>process-id</em> ] <strong>routing</strong> [ <em>ipv6-address</em> <em>prefix-length</em> | <strong>abr-routes</strong> | <strong>asbr-routes</strong> | <strong>intra-routes</strong> | <strong>inter-routes</strong> | <strong>ase-routes</strong> | <strong>nssa-routes</strong> | [ <strong>statistics</strong> ] ]</p>
<ul>
<li><em>process-id</em>：OSPFv3进程号。整数形式，取值范围是1～65535。</li>
<li><em>ipv6-address</em>：指定IPv6地址。32位16进制数，格式为X:X:X:X:X:X:X:X。</li>
<li><em>prefix-length</em>：指定前缀长度。整数形式，取值范围是0～128。</li>
<li><strong>abr-routes</strong>：显示OSPFv3中所有ABR的路由信息。</li>
<li><strong>asbr-routes</strong>：显示OSPFv3中所有ASBR的路由信息。</li>
<li><strong>intra-routes</strong>：显示OSPFv3中区域内路由的统计信息。</li>
<li><strong>inter-routes</strong>：显示OSPFv3中区域间路由的统计信息。</li>
<li><strong>ase-routes</strong>：显示OSPFv3中AS外部路由的统计信息。**</li>
<li>nssa-routes<strong>：显示OSPFv3中NSSA区域路由的统计信息。</strong></li>
<li>statistics：显示OSPFv3中所有路由表的统计信息。</li>
</ul>
</blockquote>
<h3 id="OSPF双栈配置举例"><a href="#OSPF双栈配置举例" class="headerlink" title="OSPF双栈配置举例"></a>OSPF双栈配置举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/27.png"></p>
<h3 id="部署IPv4网络"><a href="#部署IPv4网络" class="headerlink" title="部署IPv4网络"></a>部署IPv4网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/28.png"></p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/29.png"></p>
<h3 id="部署IPv6网络"><a href="#部署IPv6网络" class="headerlink" title="部署IPv6网络"></a>部署IPv6网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/30.png"></p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/31.png"></p>
<h3 id="查看OSPFv3网络的邻居信息"><a href="#查看OSPFv3网络的邻居信息" class="headerlink" title="查看OSPFv3网络的邻居信息"></a>查看OSPFv3网络的邻居信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/32.png"></p>
<blockquote>
<p>•可以通过<strong>display</strong> <strong>ospf peer</strong>查看OSPFv2的邻居信息。</p>
<p>•对比OSPFv2和OSPFv3的邻居信息，发现选出的DR和BDR是一致的，说明DR选举方式相同。</p>
</blockquote>
<h3 id="查看OSPFv3网络的路由信息"><a href="#查看OSPFv3网络的路由信息" class="headerlink" title="查看OSPFv3网络的路由信息"></a>查看OSPFv3网络的路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/33.png"></p>
<blockquote>
<p>•可以通过<strong>display ospf routing</strong>查看OSPFv2的路由信息。</p>
<p>•对比OSPFv2和OSPFv3的路由信息，发现到“同一”网段的路径一致，说明路由计算方式相同。</p>
</blockquote>
<h3 id="查看OSPFv3网络LSDB信息"><a href="#查看OSPFv3网络LSDB信息" class="headerlink" title="查看OSPFv3网络LSDB信息"></a>查看OSPFv3网络LSDB信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/34.png"></p>
<blockquote>
<p>•可以通过<strong>display ospf</strong> <strong>lsdb</strong>查看OSPFv2的LSDB信息，可以看到有Type1、Type2和Type3三种LSA。</p>
</blockquote>
<h1 id="3-IS-IS-IPv6-原理与配置"><a href="#3-IS-IS-IPv6-原理与配置" class="headerlink" title="3.IS-IS (IPv6)原理与配置"></a>3.IS-IS (IPv6)原理与配置</h1><h2 id="IS-IS-IPv6-概述"><a href="#IS-IS-IPv6-概述" class="headerlink" title="IS-IS (IPv6)概述"></a>IS-IS (IPv6)概述</h2><p>•IS-IS最初是为OSI网络设计的一种基于链路状态协议的动态路由协议。之后为了提供对IPv4的路由支持，扩展应用到IPv4网络，称为集成IS-IS。</p>
<p>•IS-IS报文有以下几种类型：Hello PDU（Protocol Data Unit）、LSP和SNP。</p>
<ul>
<li>报文格式为：</li>
</ul>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/35.png"></p>
<ul>
<li>IS-IS报文中的变长字段部分是多个TLV（Type-Length-Value）三元组，使用TLV结构构建报文使IS-IS更具灵活性和扩展性，增加新特性只需要增加新TLV即可。</li>
</ul>
<p>•为了支持IPv6路由的处理和计算，IS-IS新增了两个TLV（Type-Length-Value）和一个NLPID（Network Layer Protocol Identifier，网络层协议标识符）。</p>
<h2 id="新增TLV"><a href="#新增TLV" class="headerlink" title="新增TLV"></a>新增TLV</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/36.png"></p>
<blockquote>
<p>•232号TLV（IPv6 Interface Address）字段解释：</p>
<p>▫Type：8bit，TLV类型，此时值为232（0xE8）。</p>
<p>▫Length：8bit，TLV的Value部分长度。</p>
<p>▫Interface Address：128bit，IPv6地址。</p>
<p>•236号TLV（IPv6 Reachability）字段解释：</p>
<p>▫Type：8bit，TLV类型，此时值为236（0xEC）。</p>
<p>▫Length：8bit，TLV的Value部分长度。</p>
<p>▫Metric：32bit，度量值。</p>
<p>▫U：1bit，Up/Down位，标识这个前缀是否是从高Level通告下来的。</p>
<p>▫X：1bit，External Original位，标识这个前缀是否是从其他路由协议中引入的。</p>
<p>▫S：1bit，Sub-TLV Present位，子TLV标识位（可选）。</p>
<p>▫R：5bit，Reserve位，保留位。</p>
<p>▫Prefix Length：8bit，前缀长度。</p>
<p>▫Prefix：IPv6地址前缀。</p>
<p>▫Sub-TLV Length：8bit，子TLV长度。若S位置1，则存在。</p>
<p>▫Sub-TLV：子TLV。若S位置1，则存在。</p>
</blockquote>
<h2 id="129号TLV中新增NLPID"><a href="#129号TLV中新增NLPID" class="headerlink" title="129号TLV中新增NLPID"></a>129号TLV中新增NLPID</h2><p>•为了支持IPv6路由的处理和计算，IS-IS在129号TLV中新增了一个NLPID。</p>
<p>•129号TLV（Protocol Supported）</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/37.png"></p>
<p>如果IS-IS支持IPv6，那么向外发布IPv6路由时必须携带NLPID值。</p>
<h2 id="IS-IS多拓扑技术背景"><a href="#IS-IS多拓扑技术背景" class="headerlink" title="IS-IS多拓扑技术背景"></a>IS-IS多拓扑技术背景</h2><p>缺省情况下，在运行IS-IS的网络环境中，IPv4和IPv6的混合拓扑被看成是一个集成的拓扑，IS-IS针对IPv4和IPv6经计算形成相同的最短路径树。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/38.png"></p>
<blockquote>
<p>•IS-IS单拓扑的不足之处：</p>
<p>​    ▫网络部署不适合拓扑分离。</p>
<p>​    ▫为维护相同的拓扑，所有接口都必须同时运行IS-IS（IPv4）和IS-IS（IPv6），部署不够灵活。</p>
<p>​    ▫不能使用IPv4区域来连接不同的IPv6区域，即无法通过IPv4网络解决IPv6孤岛问题。</p>
</blockquote>
<h2 id="IS-IS多拓扑概述"><a href="#IS-IS多拓扑概述" class="headerlink" title="IS-IS多拓扑概述"></a>IS-IS多拓扑概述</h2><p>•IS-IS多拓扑（Multi-Topology，MT）特性是指在一个IS-IS自治域内运行多个独立的IP拓扑。例如IPv4拓扑和IPv6拓扑，而不是将它们视为一个集成的单一拓扑。这有利于IS-IS在路由计算中根据实际组网情况来单独考虑IPv4和IPv6网络。根据链路所支持的IP协议类型，不同拓扑运行各自的SPF计算，实现网络的相互屏蔽。</p>
<p>•IS-IS多拓扑的实现过程</p>
<p>​    ▫建立拓扑：通过报文交互建立邻居，从而建立多拓扑。</p>
<p>​    ▫SPF计算：在不同的拓扑上分别进行SPF计算。</p>
<h2 id="IS-IS多拓扑原理"><a href="#IS-IS多拓扑原理" class="headerlink" title="IS-IS多拓扑原理"></a>IS-IS多拓扑原理</h2><p>•IS-IS定义了新的TLV，该TLV中包含接口所属拓扑信息（MT信息）。MT信息的传播，使得网络按不同的拓扑分别进行SPF计算，最终实现拓扑分离。</p>
<p>•229号多拓扑TLV：</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/39.png"></p>
<blockquote>
<p>•IS-IS为了支持多拓扑特性，定义了多种TLV，包括：多拓扑TLV、多拓扑中间系统TLV、多拓扑可达的IPv4前缀TLV和多拓扑可达的IPv6前缀TLV。其中本课程将对多拓扑TLV进行讲解，其他内容不详细展开。</p>
<p>•多拓扑TLV：</p>
<ul>
<li><p>多拓扑TLV仅包含在IIH报文和LSP的0分片报文中。</p>
</li>
<li><p>预留的MT ID字段：</p>
<ul>
<li>MT ID=0，用于标准IPv4拓扑。</li>
<li>MT ID=2，预留给IPv6拓扑。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="IS-IS-IPv6-的基础配置命令"><a href="#IS-IS-IPv6-的基础配置命令" class="headerlink" title="IS-IS (IPv6)的基础配置命令"></a>IS-IS (IPv6)的基础配置命令</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/40.png"></p>
<blockquote>
<p>•IS-IS（IPv6）的基础配置命令与配置方式与IS-IS（IPv4）一致，其他配置命令不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
<p>•[Huawei-isis-1] <strong>ipv6</strong> <strong>enable</strong> [ <strong>topology</strong> { <strong>ipv6</strong> | <strong>standard</strong> } ]</p>
<ul>
<li><strong>topology</strong>：用于指定网络的拓扑类型。</li>
<li><strong>ipv6</strong>：指定拓扑类型为IPv6拓扑，即在IPv6拓扑上使能IS-IS进程的IPv6。网络中的链路可以配置成IPv4或IPv6，但SPF计算在各自的拓扑中单独进行。</li>
<li><strong>standard</strong>：指定拓扑类型为标准模式，即在集成拓扑上使能IS-IS进程的IPv6。网络管理员必须保证网络中所有的链路支持一致的拓扑模式。缺省情况下，使能IPv6选择standard参数。</li>
</ul>
<p>•[ Huawei-GigabitEthernet0/0/1] <strong>isis</strong> <strong>ipv6</strong> <strong>cost</strong> { <em>cost</em> | <strong>maximum</strong> } [ <strong>level-1</strong> | <strong>level-2</strong> ]</p>
<ul>
<li><p><em>cost</em>：指定IPv6接口的链路开销值。整数形式，取值范围根据开销类型而定。</p>
<ul>
<li>当开销类型为narrow、narrow-compatible或compatible时，取值范围是1～63。</li>
<li>当开销类型为wide或wide-compatible时，取值范围是1～16777214。</li>
<li>缺省值为10。</li>
</ul>
</li>
<li><p><strong>maximum</strong>：指定接口的链路开销值为16777215。</p>
</li>
<li><p><strong>level-1</strong>：指定配置level-1链路的开销值。如果不指定配置链路开销的接口级别，则同时为Level-1和Level-2级别的接口设置链路开销。</p>
</li>
<li><p><strong>level-2</strong>：指定配置level-2链路的开销值。如果不指定配置链路开销的接口级别，则同时为Level-1和Level-2级别的接口设置链路开销。</p>
</li>
</ul>
</blockquote>
<h2 id="检查IS-IS-IPv6-基本功能的配置结果"><a href="#检查IS-IS-IPv6-基本功能的配置结果" class="headerlink" title="检查IS-IS (IPv6)基本功能的配置结果"></a>检查IS-IS (IPv6)基本功能的配置结果</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/41.png"></p>
<h2 id="IS-IS双栈配置举例"><a href="#IS-IS双栈配置举例" class="headerlink" title="IS-IS双栈配置举例"></a>IS-IS双栈配置举例</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/42.png"></p>
<h3 id="部署IPv4网络-1"><a href="#部署IPv4网络-1" class="headerlink" title="部署IPv4网络"></a>部署IPv4网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/43.png"></p>
<h3 id="部署IPv6网络-1"><a href="#部署IPv6网络-1" class="headerlink" title="部署IPv6网络"></a>部署IPv6网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/44.png"></p>
<h3 id="查看IS-IS-IPv4-网络路由信息"><a href="#查看IS-IS-IPv4-网络路由信息" class="headerlink" title="查看IS-IS (IPv4)网络路由信息"></a>查看IS-IS (IPv4)网络路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/45.png"></p>
<h3 id="查看IS-IS-IPv6-网络路由信息"><a href="#查看IS-IS-IPv6-网络路由信息" class="headerlink" title="查看IS-IS (IPv6)网络路由信息"></a>查看IS-IS (IPv6)网络路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/46.png"></p>
<h1 id="4-BGP4-原理与配置"><a href="#4-BGP4-原理与配置" class="headerlink" title="4.BGP4+原理与配置"></a>4.BGP4+原理与配置</h1><h2 id="BGP4-概述"><a href="#BGP4-概述" class="headerlink" title="BGP4+概述"></a>BGP4+概述</h2><p>•传统的BGP-4只能管理IPv4单播路由信息，BGP多协议扩展（MultiProtocol BGP，MP-BGP）提供了对多种网络层协议的支持。目前的MP-BGP，使用扩展属性和地址族来实现对IPv6、组播和VPN相关内容的支持，BGP协议原有的报文机制和路由机制并没有改变。</p>
<p>•其中，MP-BGP对IPv6单播网络的支持特性称为BGP4+。BGP4+为IPv6单播网络建立独立的拓扑结构，并将路由信息储存在独立的路由表中，保持单播IPv4网络和单播IPv6网络之间路由信息相互隔离。</p>
<blockquote>
<p>•为了实现对IPv6协议的支持，BGP需要将IPv6协议的信息反映到NLRI属性中。</p>
</blockquote>
<h2 id="MP-BGP支持的地址族"><a href="#MP-BGP支持的地址族" class="headerlink" title="MP-BGP支持的地址族"></a>MP-BGP支持的地址族</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/47.png"></p>
<h2 id="BGP路径属性"><a href="#BGP路径属性" class="headerlink" title="BGP路径属性"></a>BGP路径属性</h2><p>•BGP的Update报文在对等体之间传递路由信息，可以用于发布和撤销路由。</p>
<p>•Update报文格式：</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/48.png"></p>
<p>•BGP4+中引入了两个NLRI属性，分别是：</p>
<ul>
<li><p>MP_REACH_NLRI：Multiprotocol Reachable NLRI，多协议可达NLRI。用于发布可达路由及下一跳信息。</p>
</li>
<li><p>MP_UNREACH_NLRI：Multiprotocol Unreachable NLRI，多协议不可达NLRI。用于撤销不可达路由。</p>
</li>
</ul>
<blockquote>
<p>•Update报文：</p>
<ul>
<li>一个Update报文可以通告具有相同路径属性的多条路由，这些路由保存在NLRI（Network Layer Reachable Information，网络层可达信息）中。同时Update还可以携带多条不可达路由，用于告知对方撤销路由，这些保存在Withdrawn Routes字段中。</li>
</ul>
</blockquote>
<h2 id="NLRI属性"><a href="#NLRI属性" class="headerlink" title="NLRI属性"></a>NLRI属性</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/49.png"></p>
<blockquote>
<p>•MP_REACH_NLRI字段解释：</p>
<ul>
<li>地址族信息（Address Family Information）：由2Byte的地址族标识（Address Family Identifier，AFI）和1Byte的子地址族标识（Subsequent Address Family Identifier，SAFI）组成。</li>
<li>下一跳长度（Length of Next Hop Network Address）：1Byte，表示下一跳地址的长度，通常情况下为16。</li>
<li>下一跳地址（Network Address of Next Hop）：长度由上一个字段决定，一般情况下为全球单播地址。</li>
<li>保留字段（Reserved）：1Byte，必须为0 。</li>
<li>网络层可达信息（Network Layer Reachability Information）：表示含有匹配相同属性的路由信息。当此字段为0时，表示为缺省路由。</li>
</ul>
<p>•MP_UNREACH_NLRI字段解释：</p>
<ul>
<li>撤销路由（Withdrawn Routes）：表示撤销的路由条目。格式为&lt;掩码长度，路由前缀&gt; ，当此掩码长度为0时，表示为缺省路由。</li>
</ul>
</blockquote>
<h2 id="BGP4-的基础配置命令"><a href="#BGP4-的基础配置命令" class="headerlink" title="BGP4+的基础配置命令"></a>BGP4+的基础配置命令</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/50.png"></p>
<blockquote>
<p>•BGP4+的基础配置命令与配置方式与BGP一致，其他配置命令不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
<p>•[Huawei-bgp] <strong>ipv6-family</strong> [ <strong>unicast</strong> | <strong>vpnv6</strong> | <strong>vpn-instance</strong> <em>vpn*</em>-instance-name* ]</p>
<ul>
<li><strong>unicast</strong>：进入IPv6单播地址族视图。</li>
<li><strong>vpnv6</strong>：进入BGP-VPNv6地址族视图。</li>
<li><strong>vpn-instance</strong> <em>vpn-instance-name</em>：将指定的VPN实例与IPv6地址族进行关联，进入BGP-VPN实例IPv6地址族视图。字符串形式，区分大小写，不支持空格，长度范围是1～31。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
</ul>
<p>•[Huawei-bgp-af-ipv6] <strong>network</strong> <em>ipv6-address</em> <em>prefix-length</em> [ <strong>route-policy</strong> <em>route-policy-name</em> ]</p>
<ul>
<li><p><em>ipv6-address</em>：指定BGP发布的IPv6网络地址。32位16进制数，格式为X:X:X:X:X:X:X:X。</p>
</li>
<li><p><em>prefix-length</em>：指定BGP发布的IPv6网络地址的前缀长度。整数形式，取值范围是0～128。</p>
</li>
<li><p><strong>route-policy</strong> <em>route-policy-name</em>：指定发布路由应用的Route-Policy。字符串形式，区分大小写，不支持空格，长度范围是1～40。当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
</li>
</ul>
</blockquote>
<h2 id="检查BGP4-基本功能的配置结果"><a href="#检查BGP4-基本功能的配置结果" class="headerlink" title="检查BGP4+基本功能的配置结果"></a>检查BGP4+基本功能的配置结果</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/51.png"></p>
<h2 id="BGP双栈配置举例"><a href="#BGP双栈配置举例" class="headerlink" title="BGP双栈配置举例"></a>BGP双栈配置举例</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/52.png"></p>
<h3 id="部署IPv4网络-2"><a href="#部署IPv4网络-2" class="headerlink" title="部署IPv4网络"></a>部署IPv4网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/53.png"></p>
<h3 id="部署IPv6网络-2"><a href="#部署IPv6网络-2" class="headerlink" title="部署IPv6网络"></a>部署IPv6网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/54.png"></p>
<h3 id="查看BGP对等体信息"><a href="#查看BGP对等体信息" class="headerlink" title="查看BGP对等体信息"></a>查看BGP对等体信息</h3><p>•通过<strong>display</strong> <strong>bgp</strong> <strong>[ipv6] peer</strong>，分别查看IPv4和IPv6网络中的BGP对等体信息。</p>
<p>•发现除建立对等体的地址不同，其他信息基本一致。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/55.png"></p>
<h3 id="查看BGP4-路由信息"><a href="#查看BGP4-路由信息" class="headerlink" title="查看BGP4+路由信息"></a>查看BGP4+路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/56.png"></p>
<h3 id="查看BGP4-中的NLRI属性"><a href="#查看BGP4-中的NLRI属性" class="headerlink" title="查看BGP4+中的NLRI属性"></a>查看BGP4+中的NLRI属性</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/57.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）以下LSA，属于OSPFv3的有哪些？(   )</p>
<p><strong>A.Router-LSA</strong></p>
<p><strong>B.Network-LSA</strong></p>
<p>C.Network-Summary-LSA</p>
<p><strong>D.Link-LSA</strong></p>
<p>2.（判断题）IS-IS支持IPv4网络和IPv6网络分别计算自己的最短路径树。(   )</p>
<p><strong>A.正确</strong></p>
<p>B.错误</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•通过IPv6静态路由能够满足网络互通要求，但随着网络的增大，就需要借助动态路由协议。因此要求动态路由协议能够支持IPv6，并能够携带IPv6地址进行路由通告。</p>
<p>•IETF为了支持IPv6网络，对OSPFv2进行了增强与改进，创建了一个新的协议：OSPFv3。</p>
<p>•IS-IS则是利用自己扩展性强的特点，通过新增TLV，实现对IPv6的支持。</p>
<p>•同样的，BGP利用自己的扩展路径属性以及多协议地址族实现对IPv6的支持。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="url">IPadv-BGP高级特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T12:22:57+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•在大型网络中通常会部署BGP，相比于IGP，BGP拥有更加灵活的路由控制能力。每一条BGP路由都可以携带多个路径属性，针对其属性也有特有的路由匹配工具，包括：AS_Path Filter和Community Filter。根据实际组网需求，可以实施路由策略，控制路由的接收和发布。</p>
<p>•同时，为了提升网络性能，BGP提供了各种高级特性以及多种组网部署方案。</p>
<p>•本课程将介绍BGP路由控制的原理与配置，介绍常用的BGP高级特性，包括：ORF、对等体组、安全特性，还会介绍BGP路由反射器的组网部署方式。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫在配置AS_Path Filter和Community Filter过程中使用正则表达式</p>
<p>▫使用AS_Path Filter和Community Filter实现BGP路由控制</p>
<p>▫应用BGP的ORF功能、对等体组功能</p>
<p>▫实现BGP安全的基本配置</p>
<p>▫描述BGP路由反射器的组网方式</p>
<h1 id="1-BGP路由控制"><a href="#1-BGP路由控制" class="headerlink" title="1.BGP路由控制"></a>1.BGP路由控制</h1><h2 id="BGP路由控制概述"><a href="#BGP路由控制概述" class="headerlink" title="BGP路由控制概述"></a>BGP路由控制概述</h2><p>BGP路由控制包括控制路由的发布和接收。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/1.png"></p>
<blockquote>
<p>•如图所示：</p>
<ul>
<li>R1和R2在AS101中，建立IBGP邻居关系；R3和R4在AS102中，分别与R2建立EBGP邻居关系。</li>
<li>R1有三个直连网段Net1、Net2和Net3，并将三个网段通告进BGP路由中。</li>
<li>在R2可以通过BGP路由控制，过滤Net2的路由，则R2的BGP路由表中就没有Net2的路由条目。</li>
<li>在R3和R4可以通过BGP路由控制，分别修改Net1和Net3的路由属性，控制路由优选，使AS102中设备访问Net1优选R3作为出口设备，访问Net3优选R4作为出口设备。</li>
</ul>
<p>•说明：ACL、IP Prefix List、Filter-Policy、Route-Policy和BGP路径属性等内容本课程不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
</blockquote>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>•正则表达式是按照一定的模板来匹配字符串的公式，由普通字符（例如字符a到z）和特殊字符组成。</p>
<p>•普通字符：匹配的对象是普通字符本身。</p>
<ul>
<li><p>包括所有的大写和小写字母、数字、标点符号以及一些特殊符号。</p>
</li>
<li><p>例如：a匹配abc中的a，10匹配10.113.25.155中的10，@匹配<a href="mailto:&#120;&#120;&#x78;&#x40;&#x78;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;">&#120;&#120;&#x78;&#x40;&#x78;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;</a>中的@。</p>
</li>
</ul>
<p>•特殊字符：配合普通字符匹配复杂或特殊的字符串组合。</p>
<ul>
<li>位于普通字符之前或之后用来限制或扩充普通字符的独立控制字符或占位符。</li>
<li>用来描述它前面的字符的重复使用方式。</li>
<li>限定一个完整的范围。</li>
</ul>
<blockquote>
<p>•正则表达式一般具有以下功能：</p>
<p>▫检查字符串中符合某个规则的子字符串，并可以获取该子字符串。</p>
<p>▫根据匹配规则对字符串进行替换操作。</p>
</blockquote>
<h2 id="特殊字符举例-1"><a href="#特殊字符举例-1" class="headerlink" title="特殊字符举例 (1)"></a>特殊字符举例 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/2.png"></p>
<blockquote>
<p>•说明：圆括号()可以用来定义操作符的范围和优先度。例如，gr(a|e)y等价于gray|grey。</p>
</blockquote>
<h2 id="特殊字符举例-2"><a href="#特殊字符举例-2" class="headerlink" title="特殊字符举例 (2)"></a>特殊字符举例 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/3.png"></p>
<blockquote>
<p>•思考题：</p>
<p>•类型1：</p>
<p>▫**^a.$**：匹配一个以字符a开始，以任意单一字符结束的字符串，如a0，a!，ax等。</p>
<p>▫**^100_**：匹配以100为起始的字符串，如：100、100 200、100 300 400等。</p>
<p>▫**^100$**：只匹配100。</p>
<p>▫**100$|400$**：匹配以100或400结束的字符串，如：100、1400、300 400等。</p>
<p>▫**^(65000)$**：只匹配(65000)。</p>
<p>•类型2：</p>
<p>▫<strong>abc*d</strong>：匹配c字符0次或多次，如：abd、abcd、abccd、abcccd、abccccdef等。</p>
<p>▫<strong>abc+d</strong>：匹配c字符1次或多次，如：abcd、abccd、abcccd、abccccdef等。</p>
<p>▫<strong>abc?d</strong>：匹配c字符0次或1次，如：abd、abcd、abcdef等。</p>
<p>▫<strong>a(bc)?d</strong>：匹配bc字符串0次或1次，如：ad、abcd、aaabcdef等。</p>
<p>•类型3：</p>
<p>▫**[abcd]**：匹配abcd中任意一个字符，即只要出现了a、b、c、d中的任意字符即可，如：ax、b！、abc、d0等。</p>
<p>▫**[a-c 1-2]$**：匹配以字符a、b、c、1、2结束的字符串，如：a、a1、62、xb、7ac等。</p>
<p>▫**[^act]$**：匹配不以字符a、c、t结束的字符串，如：ax、b！、d等。</p>
<p>▫**[123].[7-9]**：匹配如：1 7、2x9、348等。</p>
</blockquote>
<h2 id="路由匹配工具：AS-Path-Filter"><a href="#路由匹配工具：AS-Path-Filter" class="headerlink" title="路由匹配工具：AS_Path Filter"></a>路由匹配工具：AS_Path Filter</h2><p>•AS_Path Filter是将BGP中的AS_Path属性作为匹配条件的过滤器，利用BGP路由携带的AS_Path列表对路由进行过滤。</p>
<p>•在不希望接收某些AS的路由时，可以利用AS_Path Filter对携带这些AS号的路由进行过滤，从而实现拒绝某些路由。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/4.png"></p>
<blockquote>
<p>•AS_Path属性是BGP的公认必遵属性，所有的BGP路由都必须携带该属性。这个属性记录了BGP路由在传递过程中所经过的所有AS的号码。</p>
<p>•AS_Path属性值可以是0个、1个或多个AS号码的集合。</p>
</blockquote>
<h2 id="使用正则表达式匹配AS-Path"><a href="#使用正则表达式匹配AS-Path" class="headerlink" title="使用正则表达式匹配AS_Path"></a>使用正则表达式匹配AS_Path</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/5.png"></p>
<h2 id="AS-Path-Filter的基础配置命令"><a href="#AS-Path-Filter的基础配置命令" class="headerlink" title="AS_Path Filter的基础配置命令"></a>AS_Path Filter的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/6.png"></p>
<blockquote>
<p>•在同一个过滤器编号下，可以定义多条过滤规则（permit或deny模式）。在匹配过程中，这些规则之间是“或”的关系，即只要路由信息通过其中一项规则，就认为通过由该过滤器编号标识的这组AS_Path Filter。</p>
<p>•命令：[Huawei] <strong>ip as-path-filter</strong> { <em>as-path-filter-number</em> | <em>as-path-filter-name</em> } { <strong>deny</strong> | <strong>permit</strong> } <em>regular-expression</em></p>
<ul>
<li><em>as-path-filter-number</em>：指定的AS路径过滤器号。整数形式，取值范围1~256。</li>
<li><em>as-path-filter-name</em>：指定的AS路径过滤器名称。字符串形式，区分大小写，不支持空格，长度范围是1~51，且不能都是数字。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
<li><strong>deny</strong>：指定AS路径过滤器的匹配模式为拒绝。</li>
<li><strong>permit</strong>：指定AS路径过滤器的匹配模式为允许。</li>
<li><em>regular-expression</em>：指定AS路径正则表达式。字符串形式，支持空格，取值范围是1~255个字符。</li>
</ul>
<p>•AS路径过滤器的默认行为是deny，即路由如果没有在某一次过滤中被permit则最终不能通过该过滤器的过滤。如果一个过滤器中的所有过滤规则都是deny，则没有路由能通过该过滤器的过滤，这种情况下需要在多次（或一次）deny之后设置一次permit，允许其余所有路由通过过滤器的过滤。</p>
</blockquote>
<h2 id="AS-Path-Filter的配置举例-1"><a href="#AS-Path-Filter的配置举例-1" class="headerlink" title="AS_Path Filter的配置举例 (1)"></a>AS_Path Filter的配置举例 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/7.png"></p>
<h2 id="AS-Path-Filter的配置举例-2"><a href="#AS-Path-Filter的配置举例-2" class="headerlink" title="AS_Path Filter的配置举例 (2)"></a>AS_Path Filter的配置举例 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/8.png"></p>
<h2 id="查看AS-Path-Filter相关信息"><a href="#查看AS-Path-Filter相关信息" class="headerlink" title="查看AS_Path Filter相关信息"></a>查看AS_Path Filter相关信息</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/9.png"></p>
<h2 id="路由匹配工具：Community-Filter"><a href="#路由匹配工具：Community-Filter" class="headerlink" title="路由匹配工具：Community Filter"></a>路由匹配工具：Community Filter</h2><p>•Community Filter与Community属性配合使用，可以在不便使用IP Prefix List和AS_Path Filter时，降低路由管理难度。</p>
<p>•团体属性过滤器有两种类型：</p>
<p>​    ▫基本Community Filter。匹配团体号或公认Community属性。</p>
<p>​    ▫高级Community Filter。使用正则表达式匹配团体号。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/10.png"></p>
<blockquote>
<p>•Community属性为可选过渡属性，可以标识具有相同特征的路由，而不用考虑零散路由前缀和繁多的AS号。即可以将某些路由分配特定的Community属性值，之后就可以基于Community值而不是网络号/掩码来匹配路由并执行相应的路由策略。</p>
</blockquote>
<h2 id="Community属性"><a href="#Community属性" class="headerlink" title="Community属性"></a>Community属性</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/11.png"></p>
<h2 id="设置Community的基础配置命令"><a href="#设置Community的基础配置命令" class="headerlink" title="设置Community的基础配置命令"></a>设置Community的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/12.png"></p>
<blockquote>
<p>•命令：[Huawei-route-policy] <strong>apply community</strong> { <em>community-number</em> | <em>aa:nn</em> | <strong>internet</strong> | <strong>no-advertise</strong> | <strong>no-export</strong> | <strong>no-export-subconfed</strong> } [ <strong>additive</strong> ]</p>
<p>▫<em>community-number</em> | <em>aa:nn</em>：指定团体属性中的团体号。一条命令中最多可以配置32个团体号。整数形式，community-number的取值范围是0<del>4294967295，aa和nn的取值范围都是0</del>65535。</p>
<p>▫<strong>internet</strong>：表示可以向任何对等体发送匹配的路由。缺省情况下，所有的路由都属于Internet团体。</p>
<p>▫<strong>no-advertise</strong>：表示不向任何对等体发送匹配的路由。即收到具有此属性的路由后，不能发布给任何其他的BGP对等体。</p>
<p>▫<strong>no-export</strong>：表示不向AS外发送匹配的路由，但发布给其它子自治系统。即收到具有此属性的路由后，不能发布到本地AS之外。</p>
<p>▫<strong>no-export-subconfed</strong>：表示不向AS外发送匹配的路由，也不发布给其它子自治系统，即收到具有此属性的路由后，不能发布给任何其他的子自治系统。</p>
<p>▫<strong>additive</strong>：表示追加路由的团体属性。</p>
</blockquote>
<h2 id="Community-Filter的基础配置命令-1"><a href="#Community-Filter的基础配置命令-1" class="headerlink" title="Community Filter的基础配置命令 (1)"></a>Community Filter的基础配置命令 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/13.png"></p>
<blockquote>
<p>•命令：[Huawei] <strong>ip community-filter</strong> { <strong>basic</strong> <em>comm-filter-name</em> | <em>basic-<strong>comm</strong>-filter-num</em> } { <strong>permit</strong> | <strong>deny</strong> } [ <em>community-number</em> | <em>aa:nn</em> | <strong>internet</strong> | <strong>no-export-subconfed</strong> | <strong>no-advertise</strong> | <strong>no-export</strong> ]</p>
<p>▫<strong>basic</strong> <em>comm-filter-name</em>：指定基本团体属性过滤器名称。字符串形式，区分大小写，取值范围是1~51个字符，且不能都是数字。</p>
<p>▫<em>basic-<strong>comm</strong>-filter-num</em>：指定基本团体属性过滤器号。整数形式，取值范围1~99。</p>
<p>▫<strong>deny</strong>：指定团体属性过滤器的匹配模式为拒绝。</p>
<p>▫<strong>permit</strong>：指定团体属性过滤器的匹配模式为允许。</p>
<p>▫<em>community-number</em>：指定团体号。整数形式，取值范围0~4294967295。</p>
<p>▫<em>aa:nn</em>：指定团体号。一条命令最多可以指定20个团体属性号。aa和nn都是整数形式，取值范围都是0~65535。</p>
<p>▫<strong>internet</strong>：表示可以向任何对等体发送匹配的路由。</p>
<p>▫<strong>no-export-subconfed</strong>：指定不向自治系统外部通告路由。如果使用了联盟，则不会向联盟中的其他子自治系统通告路由。</p>
<p>▫<strong>no-advertise</strong>：指定不通告给其他对等体。</p>
<p>▫<strong>no-export</strong>：指定不向自治系统外部通告路由。如果使用了联盟，则不向联盟外部通告路由，但会通告给联盟中的其他子自治系统。</p>
<p>•命令：[Huawei] <strong>ip community-filter</strong> { <strong>advanced</strong> <em>comm*</em>-filter-name* | <em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em> } { <strong>permit</strong> | <strong>deny</strong> } <em>regular-expression</em></p>
<p>▫<strong>advanced</strong> <em>comm*</em>-filter-name*：指定高级团体属性过滤器名称。字符串形式，区分大小写，取值范围是1~51个字符，且不能都是数字。</p>
<p>▫<em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em>：指定高级团体属性过滤器号。整数形式，取值范围100~199。</p>
<p>▫<em>regular-expression</em>：指定团体属性正则表达式。字符串形式，支持空格，区分大小写，取值范围是1~255。</p>
</blockquote>
<h2 id="Community-Filter的基础配置命令-2"><a href="#Community-Filter的基础配置命令-2" class="headerlink" title="Community Filter的基础配置命令 (2)"></a>Community Filter的基础配置命令 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/14.png"></p>
<blockquote>
<p>•命令：[Huawei-route-policy] <strong>if-match community-filter</strong> { <em>basic-<strong>comm</strong>-filter-num</em> [ <strong>whole-match</strong> ] | <em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em> }</p>
<p>•命令：[Huawei-route-policy] <strong>if-match community-filter</strong> <em>comm-filter-name</em> [ <strong>whole-match</strong> ]</p>
<ul>
<li><em>basic-<strong>comm</strong>-filter-num</em>：指定基本团体属性过滤器号。整数形式，取值范围是1~99。</li>
<li><em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em>：指定高级团体属性过滤器号。整数形式，取值范围是100~199。</li>
<li><em>comm-filter-name</em>：指定团体属性过滤器名称。字符串形式，区分大小写，不支持空格，长度范围是1~51，且不能都是数字。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
<li><strong>whole-match</strong>：表示完全匹配，即所有的团体都必须出现。仅对基本团体属性过滤器生效。</li>
</ul>
</blockquote>
<h2 id="Community-Filter的配置举例"><a href="#Community-Filter的配置举例" class="headerlink" title="Community Filter的配置举例"></a>Community Filter的配置举例</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/15.png"></p>
<h2 id="配置Community属性-1"><a href="#配置Community属性-1" class="headerlink" title="配置Community属性 (1)"></a>配置Community属性 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/16.png"></p>
<blockquote>
<p>•命令：[R1] <strong>route-policy</strong> Community <strong>permit node</strong> 20</p>
<p>•通过配置该命令允许10.1.2.2/32路由被正常通告。</p>
</blockquote>
<h2 id="配置Community属性-2"><a href="#配置Community属性-2" class="headerlink" title="配置Community属性 (2)"></a>配置Community属性 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/17.png"></p>
<h2 id="配置Community属性-3"><a href="#配置Community属性-3" class="headerlink" title="配置Community属性 (3)"></a>配置Community属性 (3)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/18.png"></p>
<h2 id="配置Community-Filter-1"><a href="#配置Community-Filter-1" class="headerlink" title="配置Community Filter (1)"></a>配置Community Filter (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/19.png"></p>
<h2 id="配置Community-Filter-2"><a href="#配置Community-Filter-2" class="headerlink" title="配置Community Filter (2)"></a>配置Community Filter (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/20.png"></p>
<h2 id="配置Community-Filter-3"><a href="#配置Community-Filter-3" class="headerlink" title="配置Community Filter (3)"></a>配置Community Filter (3)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/21.png"></p>
<h1 id="2-BGP特性介绍"><a href="#2-BGP特性介绍" class="headerlink" title="2.BGP特性介绍"></a>2.BGP特性介绍</h1><h2 id="邻居按需发布路由"><a href="#邻居按需发布路由" class="headerlink" title="邻居按需发布路由"></a>邻居按需发布路由</h2><p>•如果设备希望只接收自己需要的路由，但对端设备又无法针对每个与它连接的设备维护不同的出口策略。此时，可以通过配置BGP基于前缀的ORF（Outbound Route Filters，出口路由过滤器）来满足两端设备的需求。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/22.png"></p>
<h2 id="ORF的基础配置命令"><a href="#ORF的基础配置命令" class="headerlink" title="ORF的基础配置命令"></a>ORF的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/23.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp-af-ipv4] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> } <strong>ip-prefix</strong> <em>ip-prefix-name</em> { <strong>import</strong> | <strong>export</strong> }</p>
<p>​    ▫<strong>import</strong>：对由指定对等体（组）接收的路由应用过滤策略。</p>
<p>​    ▫<strong>export</strong>：对向指定对等体（组）发送的路由应用过滤策略。</p>
<p>•命令：[Huawei-bgp] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> } <strong>capability-advertise</strong> <strong>orf</strong> [ <strong>non-standard-compatible</strong> ] <strong>ip-prefix</strong> { <strong>both</strong> | <strong>receive</strong> | <strong>send</strong> } [ <strong>standard-match</strong> ]</p>
<p>​    ▫<strong>non-standard-compatible</strong>：指定与非标准设备兼容。</p>
<p>​    ▫<strong>both</strong>：表示允许发送和接收ORF报文。</p>
<p>​    ▫<strong>receive</strong>：表示只允许接收ORF报文。</p>
<p>​    ▫<strong>send</strong>：表示只允许发送ORF报文。</p>
<p>​    ▫<strong>standard-match</strong>：指定按照RFC标准规定的前缀匹配规则来匹配路由。</p>
</blockquote>
<h2 id="ORF配置举例"><a href="#ORF配置举例" class="headerlink" title="ORF配置举例"></a>ORF配置举例</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/24.png"></p>
<h2 id="查看ORF配置"><a href="#查看ORF配置" class="headerlink" title="查看ORF配置"></a>查看ORF配置</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/25.png"></p>
<h2 id="BGP对等体组"><a href="#BGP对等体组" class="headerlink" title="BGP对等体组"></a>BGP对等体组</h2><p>•对等体组（Peer Group）是一些具有某些相同策略的对等体的集合。当一个对等体加入对等体组中时，该对等体将获得与所在对等体组相同的配置。当对等体组的配置改变时，组内成员的配置也相应改变。</p>
<p>•在大型BGP网络中，对等体的数量会很多，其中很多对等体具有相同的策略，在配置时会重复使用一些命令，利用对等体组可以简化配置。</p>
<blockquote>
<p>•对等体组中的单个对等体也可以配置自己的发布路由与接收路由的策略。</p>
</blockquote>
<h2 id="BGP对等体组的基础配置命令"><a href="#BGP对等体组的基础配置命令" class="headerlink" title="BGP对等体组的基础配置命令"></a>BGP对等体组的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/26.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp] <strong>group</strong> <em>group-name</em> [ <strong>external</strong> | <strong>internal</strong> ]</p>
<p>​    ▫<em>group-name</em>：指定对等体组的名称。字符串形式，区分大小写，不支持空格，长度范围是1~47。当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
<p>​    ▫<strong>external</strong>：表示创建EBGP对等体组。</p>
<p>​    ▫<strong>internal</strong>：表示创建IBGP对等体组。</p>
</blockquote>
<h2 id="BGP对等体组配置举例"><a href="#BGP对等体组配置举例" class="headerlink" title="BGP对等体组配置举例"></a>BGP对等体组配置举例</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/27.png"></p>
<blockquote>
<p>•如图所示：假设AS102内，通过静态路由或OSPF实现AS102内部网络可达，配置省略。</p>
</blockquote>
<h2 id="查看BGP对等体组配置"><a href="#查看BGP对等体组配置" class="headerlink" title="查看BGP对等体组配置"></a>查看BGP对等体组配置</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/28.png"></p>
<h2 id="BGP安全性"><a href="#BGP安全性" class="headerlink" title="BGP安全性"></a>BGP安全性</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/29.png"></p>
<h2 id="BGP认证"><a href="#BGP认证" class="headerlink" title="BGP认证"></a>BGP认证</h2><p>BGP认证分为MD5认证和Keychain认证，对BGP对等体关系进行认证可以预防非法BGP邻居建立。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/30.png"></p>
<blockquote>
<p>•BGP使用TCP作为传输协议，只要TCP数据包的源地址、目的地址、源端口、目的端口和TCP序号是正确的，BGP就会认为这个数据包有效，但数据包的大部分参数对于攻击者来说是不难获得的。为了保证BGP免受攻击，可以在BGP邻居之间使用MD5认证或者Keychain认证来降低被攻击的可能性。</p>
<ul>
<li><p>MD5算法配置简单，配置后生成单一密码，需要人为干预才可以更换密码。</p>
</li>
<li><p>Keychain具有一组密码，可以根据配置自动切换，但是配置过程较为复杂，适用于对安全性能要求比较高的网络。</p>
</li>
</ul>
<p>•注意：BGP的MD5认证与BGP的Keychain认证互斥。</p>
</blockquote>
<h2 id="BGP的GTSM"><a href="#BGP的GTSM" class="headerlink" title="BGP的GTSM"></a>BGP的GTSM</h2><p>BGP的GTSM功能检测IP报文头中的TTL（Time-to-Live）值是否在一个预先设置好的特定范围内，并对不符合TTL值范围的报文进行丢弃，这样就避免了网络攻击者模拟“合法”BGP报文攻击设备。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/31.png"></p>
<blockquote>
<p>•如图所示：如果没有使能BGP的GTSM功能，设备收到大量非法BGP报文后，发现是发送给本机的报文，会直接上送控制层面处理。这时将会因为控制层面处理大量攻击报文，导致设备CPU占用率高，系统异常繁忙。</p>
</blockquote>
<h2 id="BGP认证的基础配置命令"><a href="#BGP认证的基础配置命令" class="headerlink" title="BGP认证的基础配置命令"></a>BGP认证的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/32.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> | <em>ipv6-address</em> } <strong>keychain</strong> <em>keychain-name</em></p>
<p>▫<em>keychain-name</em>：指定Keychain名称。字符串形式，长度范围是1~47，不区分大小写。字符不包括问号和空格，但是当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
</blockquote>
<h2 id="GTSM功能的基础配置命令"><a href="#GTSM功能的基础配置命令" class="headerlink" title="GTSM功能的基础配置命令"></a>GTSM功能的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/33.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> | <em>ipv6-address</em> } <strong>valid-ttl-hops</strong> [ <em>hops</em> ]</p>
<ul>
<li><em>hops</em>：指定需要检测的TTL跳数值。整数形式，取值范围是1~255，缺省值是255。如果配置为hops，则被检测的报文的TTL值有效范围为[255–hops+1, 255]</li>
</ul>
<p>•命令：[Huawei] <strong>gtsm</strong> <strong>default-action</strong> { <strong>drop</strong> | <strong>pass</strong> }</p>
<ul>
<li><p><strong>drop</strong>：未匹配GTSM策略的报文不能通过过滤，报文被丢弃。</p>
</li>
<li><p><strong>pass</strong>：未匹配GTSM策略的报文可以通过过滤。</p>
</li>
</ul>
<p>•命令：[Huawei] <strong>gtsm</strong> <strong>log drop-packet</strong> <strong>all</strong></p>
<ul>
<li><strong>all</strong>：所有单板。</li>
</ul>
</blockquote>
<h2 id="GTSM配置举例-1"><a href="#GTSM配置举例-1" class="headerlink" title="GTSM配置举例 (1)"></a>GTSM配置举例 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/34.png"></p>
<blockquote>
<p>•如图所示：</p>
<p>▫假设AS101内，通过静态路由或OSPF实现AS101内部网络可达，配置省略。</p>
<p>▫R1通告Loopback0接口地址到BGP中。</p>
</blockquote>
<h2 id="GTSM配置举例-2"><a href="#GTSM配置举例-2" class="headerlink" title="GTSM配置举例 (2)"></a>GTSM配置举例 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/35.png"></p>
<h2 id="查看GTSM配置"><a href="#查看GTSM配置" class="headerlink" title="查看GTSM配置"></a>查看GTSM配置</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/36.png"></p>
<h1 id="3-BGP路由反射器组网方式"><a href="#3-BGP路由反射器组网方式" class="headerlink" title="3.BGP路由反射器组网方式"></a>3.BGP路由反射器组网方式</h1><h2 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h2><p>引入路由反射器，可以简化IBGP全互联的需求，也可以减轻网络和CPU的负担。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/37.png"></p>
<blockquote>
<p>•路由反射器相关角色：</p>
<p>▫RR：允许把从IBGP对等体学到的路由反射到其他IBGP对等体的BGP设备，类似OSPF网络中的DR。</p>
<p>▫Client：与RR形成反射邻居关系的IBGP设备。在AS内部客户机只需要与RR直连。</p>
<p>▫Non-Client：既不是RR也不是客户机的IBGP设备。在AS内部非客户机与RR之间，以及所有的非客户机之间仍然必须建立全互联关系。</p>
<p>▫Originator（始发者）：在AS内部始发路由的设备。Originator_ID属性用于防止集群内产生路由环路。</p>
<p>▫Cluster（集群）：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路。</p>
<p>•将一台BGP路由器指定为RR的同时，还需要指定其Client。至于Client本身，无需做任何配置，它并不知晓网络中存在RR。</p>
<p>•RR发布路由规则：</p>
<ul>
<li>从非客户机IBGP对等体学到的路由，发布给此RR的所有客户机。</li>
<li>从客户机学到的路由，发布给此RR的所有非客户机和客户机。</li>
<li>从EBGP对等体学到的路由，发布给所有的非客户机和客户机。</li>
</ul>
</blockquote>
<h2 id="常见组网：备份RR组网"><a href="#常见组网：备份RR组网" class="headerlink" title="常见组网：备份RR组网"></a>常见组网：备份RR组网</h2><p>•为增加网络的可靠性，防止单点故障对网络造成影响，有时需要在一个集群中配置一个以上的RR。</p>
<p>•转发路径上的路由器与所有RR均建立IBGP关系，任意一个RR均有完整的BGP路由。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/38.png"></p>
<h2 id="常见组网：多集群RR组网-1"><a href="#常见组网：多集群RR组网-1" class="headerlink" title="常见组网：多集群RR组网 (1)"></a>常见组网：多集群RR组网 (1)</h2><p>•一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。</p>
<p>•当RR所处的网络层相同时，可以将不同集群的RR全互联，形成同级RR。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/39.png"></p>
<h2 id="常见组网：多集群RR组网-2"><a href="#常见组网：多集群RR组网-2" class="headerlink" title="常见组网：多集群RR组网 (2)"></a>常见组网：多集群RR组网 (2)</h2><p>•一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。</p>
<p>•当RR所处的网络层不同时，可以将较低网络层次的RR配成客户机，形成分级RR。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/40.png"></p>
<blockquote>
<p>•分级RR与单级RR的路由发布规则相同。</p>
<p>•分级RR设计需要考虑两个因素：</p>
<ul>
<li>顶层全互联的拓扑大小：如果IBGP全互联数量已经多到难以管理了，则可考虑引入RR分级部署。</li>
<li>可替代路径的数量：该因素影响负载分担和资源消耗。越多的层次越会减少负载分担链路的数量，但需要的路由器资源更少。</li>
</ul>
</blockquote>
<h2 id="单集群问题"><a href="#单集群问题" class="headerlink" title="单集群问题"></a>单集群问题</h2><p>为了在基于RR的架构中提供所期望的冗余，正确的集群划分是非常重要的。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/41.png"></p>
<h2 id="多集群设计"><a href="#多集群设计" class="headerlink" title="多集群设计"></a>多集群设计</h2><p>多集群设计不仅提供了针对链路失效的物理冗余，同时提供了针对客户机与RR之间的IBGP会话失效的逻辑冗余。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/42.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选题）命令**“ip as-path-filter 1 permit ^(100|200)$**”中匹配到的AS_Path是什么？(   )</p>
<p>A.AS_Path 100</p>
<p>B.AS_Path 200</p>
<p>C.AS_Path 100 200</p>
<p><strong>D.AS_Path 100 或 AS_Path 200</strong></p>
<p>2.（判断题）BGP的GTSM功能，可以预防非法BGP邻居建立。(   )</p>
<p>A.正确</p>
<p><strong>B.错误</strong></p>
<p>3.（判断题）BGP的备份RR组网中，主备RR收到对方反射的路由会丢弃，避免路由环路。(   )</p>
<p><strong>A.正确</strong></p>
<p>B.错误</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•AS_Path Filter和Community Filter都是BGP专有的路由匹配工具，可以使用这两种工具匹配AS_Path属性或Community属性来匹配BGP路由，再与路由策略相结合，从而实现BGP的路由控制。</p>
<p>•BGP还支持各种高级特性，包括：通过ORF功能实现邻居按需发布路由，通过对等体组简化配置，通过BGP安全特性预防非法邻居建立以及非法BGP报文攻击。</p>
<p>•BGP通过RR打破了IBGP水平分割规则，简化了IBGP全互联的需求，也减轻了网络和CPU的负担。常见的RR组网方式包括：备份RR组网和多集群RR组网。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url">IPadv-MPLSVPN部署与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-23T15:17:09+08:00">
                2021-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•BGP/MPLS IP VPN因其支持地址空间重叠、组网方式灵活、可扩展性好，并能够方便地支持MPLS TE等一系列优点，已经在广域IP承载网络得到了广泛的应用。</p>
<p>•针对不同客户的业务需求以及组网情况，MPLS VPN的部署方式不尽相同。</p>
<p>•本课程将介绍几种常见的MPLS VPN应用场景与这些场景下MPLS VPN的部署方法，此外还将介绍OSPF对MPLS VPN的扩展特性与功能。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述MPLS VPN的应用场景与组网类型</p>
<p>▫部署MPLS VPN的Intranet方案</p>
<p>▫部署MPLS VPN的Hub&amp;Spoke方案</p>
<p>▫描述OSPF对MPLS VPN扩展功能与特性</p>
<h1 id="1-MPLS-VPN应用与组网概述"><a href="#1-MPLS-VPN应用与组网概述" class="headerlink" title="1.MPLS VPN应用与组网概述"></a>1.MPLS VPN应用与组网概述</h1><h2 id="MPLS-VPN典型应用"><a href="#MPLS-VPN典型应用" class="headerlink" title="MPLS VPN典型应用"></a>MPLS VPN典型应用</h2><p>•目前，MPLS VPN的主要应用包括企业互连和虚拟业务网络。</p>
<p>▫企业互连应用：可通过MPLS VPN将分布在各地的分支机构、出差员工和合作伙伴的IP网络连接在一起；</p>
<p>▫虚拟业务网络：可在同一物理网络上运行多种业务，如VoIP、IPTV等，为每个业务建立一个VPN，实现业务隔离。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/1.png"></p>
<blockquote>
<p>•MPLS VPN的主要优点包括但不限于以下几项：</p>
<ul>
<li>可以实现“一点接入，全网连通”，支持异种介质的互连。而不像传统专线那样在每一对用户设备间采用同样的介质连接，可方便地提供普遍服务。</li>
<li>可以实现“弹性带宽”，采用流量监管技术，在保证用户基本带宽的同时，对突发流量尽力而为，同时基本带宽也可以“软扩容”，即根据用户的需求在一个范围内连续选择。</li>
<li>在资源隔离或隧道绑定的MPLS VPN技术保证下，充分保证每个VPN的专有带宽，满足各类业务有不同的用户，不同的流量模型，不同的QoS要求。</li>
</ul>
</blockquote>
<h2 id="MPLS-VPN基本组网-Intranet"><a href="#MPLS-VPN基本组网-Intranet" class="headerlink" title="MPLS VPN基本组网 - Intranet"></a>MPLS VPN基本组网 - Intranet</h2><p>当采用Intranet组网方案时，一个VPN中的所有用户形成闭合用户群，相互之间能够进行流量转发，VPN中的用户不能与任何本VPN以外的用户通信，其站点通常是属于同一个组织。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/2.png"></p>
<h2 id="MPLS-VPN基本组网-Extranet"><a href="#MPLS-VPN基本组网-Extranet" class="headerlink" title="MPLS VPN基本组网 - Extranet"></a>MPLS VPN基本组网 - Extranet</h2><p>当采用Extranet组网方案时，VPN用户可将部分站点中的网络资源给其他VPN用户进行访问。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/3.png"></p>
<h2 id="MPLS-VPN基本组网-Hub-amp-Spoke-1"><a href="#MPLS-VPN基本组网-Hub-amp-Spoke-1" class="headerlink" title="MPLS VPN基本组网 - Hub&amp;Spoke (1)"></a>MPLS VPN基本组网 - Hub&amp;Spoke (1)</h2><p>当采用Hub&amp;Spoke方案时，可以将多个站点中的一个站点设置为Hub站点，其余站点为Spoke站点。站点间的互访必须通过Hub站点，通过Hub站点集中管控站点间的数据传输。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/4.png"></p>
<h2 id="MPLS-VPN基本组网-Hub-amp-Spoke-2"><a href="#MPLS-VPN基本组网-Hub-amp-Spoke-2" class="headerlink" title="MPLS VPN基本组网 - Hub&amp;Spoke (2)"></a>MPLS VPN基本组网 - Hub&amp;Spoke (2)</h2><p>从Site1到Site2的路由发布过程如下：</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/5.png"></p>
<h2 id="MCE组网"><a href="#MCE组网" class="headerlink" title="MCE组网"></a>MCE组网</h2><p>•当一个私网需要根据业务或者网络划分VPN时，不同VPN用户间的业务需要完全隔离。此时，为每个VPN单独配置一台CE将增加用户的设备开支和维护成本。</p>
<p>•具有MCE（Multi-VPN-Instance，CE多实例CE）功能的CE设备可以在MPLS VPN组网应用中承担多个VPN实例的CE功能，减少用户网络设备的投入。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/6.png"></p>
<h2 id="MPLS-VPN跨域组网"><a href="#MPLS-VPN跨域组网" class="headerlink" title="MPLS VPN跨域组网"></a>MPLS VPN跨域组网</h2><p>•随着MPLS VPN解决方案的广泛应用，服务的终端用户的规格和范围也在增长，在一个企业内部的站点数目越来越大，某个地理位置与另外一个服务提供商相连的需求变得非常的普遍，例如国内运营商的不同城域网之间，或相互协作的运营商的骨干网之间都存在着跨越不同自治系统（AS，Autonomous System）的情况。</p>
<p>•一般的MPLS VPN体系结构都是在一个AS内运行，任何VPN的路由信息都是只能在一个AS内按需扩散。AS之间的MPLS VPN部署需要通过跨域（Inter-AS） MPLS VPN解决方案来实现。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/7.png"></p>
<blockquote>
<p>•RFC2547中提出了三种跨域VPN解决方案，分别是：</p>
<ul>
<li>跨域VPN-OptionA（Inter-Provider Backbones Option A）方式：需要跨域的VPN在ASBR（AS Boundary Router）间通过专用的接口管理自己的VPN路由，也称为VRF-to-VRF；</li>
<li>跨域VPN-OptionB（Inter-Provider Backbones Option B）方式：ASBR间通过MP-EBGP发布标签VPN-IPv4路由，也称为EBGP redistribution of labeled VPN-IPv4 routes；</li>
<li>跨域VPN-OptionC（Inter-Provider Backbones Option C）方式：PE间通过Multi-hop MP-EBGP发布标签VPN-IPv4路由，也称为Multihop EBGP redistribution of labeled VPN-IPv4 routes。</li>
</ul>
<p>•更多跨域MPLS VPN相关内容，请参考HCIE-Datacom相关课程。</p>
</blockquote>
<h1 id="2-MPLS-VPN典型场景部署介绍"><a href="#2-MPLS-VPN典型场景部署介绍" class="headerlink" title="2.MPLS VPN典型场景部署介绍"></a>2.MPLS VPN典型场景部署介绍</h1><h2 id="Intranet场景"><a href="#Intranet场景" class="headerlink" title="Intranet场景"></a>Intranet场景</h2><h3 id="部署Intranet场景的MPLS-VPN"><a href="#部署Intranet场景的MPLS-VPN" class="headerlink" title="部署Intranet场景的MPLS VPN"></a>部署Intranet场景的MPLS VPN</h3><p>•如图所示，客户X及Y各自有2个站点，现需要通过MPLS VPN实现站点之间的互联，分别对应VPNX和VPNY；</p>
<p>•互联接口、AS号及IP地址信息，CE与PE通过如图的协议或方法交换路由信息；</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/8.png"></p>
<blockquote>
<p>•注：本课程仅讨论非跨域的MPLS VPN部署场景。</p>
</blockquote>
<h3 id="部署思路"><a href="#部署思路" class="headerlink" title="部署思路"></a>部署思路</h3><p>1.MPLS VPN骨干网配置</p>
<p>1.1 IGP配置，实现骨干网的IP连通性。</p>
<p>1.2 MPLS与MPLS LDP配置，建立MPLS LSP公网隧道，传输VPN数据。</p>
<p>1.3 MP-BGP配置，建立后续传递VPNv4路由的MP-BGP对等体关系。</p>
<p>2.VPN用户接入配置</p>
<p>2.1 创建VPN实例并配置参数（RT、RD）</p>
<p>2.2 将接口加入VPN实例</p>
<p><strong>2.3</strong> <strong>配置PE与CE之间的路由交换</strong></p>
<h3 id="PE-CE之间部署OSPF-1"><a href="#PE-CE之间部署OSPF-1" class="headerlink" title="PE-CE之间部署OSPF (1)"></a>PE-CE之间部署OSPF (1)</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/9.png"></p>
<h3 id="PE-CE之间部署OSPF-2"><a href="#PE-CE之间部署OSPF-2" class="headerlink" title="PE-CE之间部署OSPF (2)"></a>PE-CE之间部署OSPF (2)</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/10.png"></p>
<h3 id="PE-CE之间部署静态路由"><a href="#PE-CE之间部署静态路由" class="headerlink" title="PE-CE之间部署静态路由"></a>PE-CE之间部署静态路由</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/11.png"></p>
<h3 id="PE-CE之间部署EBGP"><a href="#PE-CE之间部署EBGP" class="headerlink" title="PE-CE之间部署EBGP"></a>PE-CE之间部署EBGP</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/12.png"></p>
<h3 id="特殊场景下的BGP配置-AS号替换"><a href="#特殊场景下的BGP配置-AS号替换" class="headerlink" title="特殊场景下的BGP配置 - AS号替换"></a>特殊场景下的BGP配置 - AS号替换</h3><p>在MPLS VPN场景中，若PE与CE之间运行EBGP交互路由信息，则可能会出现两个站点的AS号相同的情况。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/13.png"></p>
<h3 id="特殊场景下的BGP配置-SoO"><a href="#特殊场景下的BGP配置-SoO" class="headerlink" title="特殊场景下的BGP配置 - SoO"></a>特殊场景下的BGP配置 - SoO</h3><p>•在CE多归属场景，若使能了BGP的AS号替换功能，可能会引起路由环路，需要SoO（Site of Origin）特性来避免环路。</p>
<ul>
<li><p>CE1与CE3处于同一个VPN站点1，CE2位于站点Site2，Site1和Site2站点所在的AS号都为65001。PE与CE之间运行的都是EBGP路由协议，为了Site 1和Site 2之间的路由可以正常学习，需要在PE1和PE2上配置AS号替换功能。</p>
</li>
<li><p>CE1传递站点内的路由给PE1，PE1传递该路由给CE3，由于配置AS号替换，CE3会接收该路由，可能会导致产生路由环路。</p>
</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/14.png"></p>
<blockquote>
<p>•注：192.168.100.1和192.168.200.1分别是CE1和CE3上和PE1建立BGP对等体的接口地址。</p>
</blockquote>
<h3 id="PE-CE之间部署IS-IS"><a href="#PE-CE之间部署IS-IS" class="headerlink" title="PE-CE之间部署IS-IS"></a>PE-CE之间部署IS-IS</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/15.png"></p>
<h2 id="Hub-amp-Spoke场景"><a href="#Hub-amp-Spoke场景" class="headerlink" title="Hub&amp;Spoke场景"></a>Hub&amp;Spoke场景</h2><h3 id="部署Hub-amp-Spoke场景的MPLS-VPN"><a href="#部署Hub-amp-Spoke场景的MPLS-VPN" class="headerlink" title="部署Hub&amp;Spoke场景的MPLS VPN"></a>部署Hub&amp;Spoke场景的MPLS VPN</h3><p>•Hub&amp;Spoke有以下组网方案：</p>
<p>​    ▫方式一：Hub-CE与Hub-PE，Spoke-PE与Spoke-CE使用EBGP</p>
<p>​    ▫方式二：Hub-CE与Hub-PE，Spoke-PE与Spoke-CE使用IGP</p>
<p>​    ▫方式三：Hub-CE与Hub-PE使用EBGP，Spoke-PE与Spoke-CE使用IGP</p>
<p>•<strong>无法</strong>通过Hub-CE与Hub-PE使用IGP，Spoke-PE与Spoke-CE使用EBGP来部署Hub&amp;Spoke组网的MPLS VPN。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/16.png"></p>
<h3 id="VRF配置"><a href="#VRF配置" class="headerlink" title="VRF配置"></a>VRF配置</h3><p>•Spoke-PE上创建一个VPN实例，RT配置如图。</p>
<p>•Hub-PE上创建VPN_in和VPN_out两个VPN实例，分别用于从Spoke-PE接收私网路由或向Spoke-PE发布私网路由，RT配置如图。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/17.png"></p>
<h3 id="方式一部署-路由发布过程"><a href="#方式一部署-路由发布过程" class="headerlink" title="方式一部署 - 路由发布过程"></a>方式一部署 - 路由发布过程</h3><p>•Spoke-CE与Spoke-PE之间通过EBGP交互路由信息，建立EBGP连接后，把相关的路由发布到BGP即可。</p>
<p>•Hub-PE与Hub-CE之间建立两条EBGP连接，分别用来发布和接收私网路由。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/18.png"></p>
<blockquote>
<p>•以路由从Spoke-CE1发布到Spoke-CE2为例，大体过程如下：</p>
<p>1.Spoke-CE1通过EBGP将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将该路由发布给Hub-PE。</p>
<p>3.Hub-PE通过VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表，并通过EBGP发布给Hub-CE。</p>
<p>4.Hub-CE通过EBGP连接学习到该路由，并通过另一个EBGP连接将该路由发布给Hub-PE的VPN实例（VPN_out）。</p>
<p>5.Hub-PE发布携带VPN_out的Export Target属性的路由给所有Spoke-PE。</p>
<p>6.Spoke-PE2通过EBGP将该路由发布给Spoke-CE2。</p>
</blockquote>
<h3 id="方式一部署-Hub-PE与Hub-CE间配置"><a href="#方式一部署-Hub-PE与Hub-CE间配置" class="headerlink" title="方式一部署 - Hub-PE与Hub-CE间配置"></a>方式一部署 - Hub-PE与Hub-CE间配置</h3><p>•Hub-PE通过VPN_in对应的EBGP连接将从Spoke站点学习的路由发布到Hub站点。</p>
<p>•Hub-CE通过VPN_out对应的EBGP将这些路由发布到Spoke站点。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/19.png"></p>
<h3 id="方式二部署-路由发布过程"><a href="#方式二部署-路由发布过程" class="headerlink" title="方式二部署 - 路由发布过程"></a>方式二部署 - 路由发布过程</h3><p>•以选用OSPF作为IGP协议为例：</p>
<p>▫Spoke-CE与Spoke-PE之间通过OSPF（进程100）邻居关系交互路由信息。</p>
<p>▫Hub-PE通过两个OSPF进程与Hub-CE建立OSPF邻居，分别负责私网路由的发送和接收。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/20.png"></p>
<blockquote>
<p>•以路由从Spoke-CE1发布到Spoke-CE2为例，大体过程如下：</p>
<p>1.Spoke-CE1通过OSPF100将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将路由发布给Hub-PE。</p>
<p>3.Hub-PE通过VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表；通过将BGP引入OSPF100的配置进而将从Spoke-PE1传递来的路由发布给Hub-CE。</p>
<p>4.Hub-CE通过OSPF100接收该路由；并通过配置路由引入将路由发布到OSPF200，OSPF200再将路由发布给Hub-PE。</p>
<p>5.Hub-PE的BGP-VPN实例（VPN_out）引入OSPF200多实例的路由，将携带Export Target属性的路由发布给所有Spoke-PE。</p>
<p>6.Spoke-PE2通过OSPF100将该路由发布给Spoke-CE2。</p>
</blockquote>
<h3 id="方式二部署-Hub-PE与Hub-CE间配置"><a href="#方式二部署-Hub-PE与Hub-CE间配置" class="headerlink" title="方式二部署 - Hub-PE与Hub-CE间配置"></a>方式二部署 - Hub-PE与Hub-CE间配置</h3><p>•Hub-PE通过VPN_in对应的OSPF（进程100）将从Spoke站点学习的路由发布到Hub站点。</p>
<p>•Hub-CE通过VPN_out对应的OSPF（进程200）将这些路由发布到Hub-PE，进而发布给所有Spoke站点。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/21.png"></p>
<h3 id="方式三部署-路由发布过程"><a href="#方式三部署-路由发布过程" class="headerlink" title="方式三部署 - 路由发布过程"></a>方式三部署 - 路由发布过程</h3><p>•以选用OSPF作为IGP协议为例，Spoke-CE与Spoke-PE之间通过OSPF（进程100）邻居关系交互路由信息。</p>
<p>•Hub-PE与Hub-CE之间建立两条EBGP连接，分别用来发布和接收私网路由，Hub-PE与Hub-CE的配置与方式一相同。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/22.png"></p>
<blockquote>
<p>•以路由从Spoke-CE1发布到Spoke-CE2为例，大体过程如下：</p>
<p>1.Spoke-CE1通过OSPF100将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将路由发布给Hub-PE。</p>
<p>3.Hub-PE通过VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表，并通过EBGP发布给Hub-CE。</p>
<p>4.Hub-CE通过EBGP连接学习到该路由，并通过另一个EBGP连接将该路由发布给Hub-PE的VPN实例（VPN_out）。</p>
<p>5.Hub-PE发布携带VPN_out的Export Target属性的路由给Spoke-PE2。</p>
<p>6.Spoke-PE2通过OSPF100将该路由发布给Spoke-CE2。</p>
</blockquote>
<h3 id="为什么没有方式四？"><a href="#为什么没有方式四？" class="headerlink" title="为什么没有方式四？"></a>为什么没有方式四？</h3><p>•<strong>无法</strong>通过Hub-CE与Hub-PE使用IGP，Spoke-PE与Spoke-CE使用EBGP来部署Hub&amp;Spoke组网的MPLS VPN</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/23.png"></p>
<blockquote>
<p>•以从Spoke-CE1向Spoke-CE2发布路由（目的地址为192.168.1.0/24）为例，大体过程如下：</p>
<p>1.Spoke-CE1通过EBGP将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将路由发布给Hub-PE。</p>
<p>3.Hub-PE通过BGP-VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表；并通过OSPF100多实例发布给Hub-CE。</p>
<p>4.Hub-CE通过OSPF100学习到该路由；并通过OSPF200将路由发布给Hub-PE。</p>
<p>5.Hub-PE的BGP-VPN实例（VPN_out）引入OSPF200多实例路由，并将携带VPN_out的Export Target属性的路由发布给所有Spoke-PE。</p>
<p>6.Spoke-PE2的VPN实例根据Import Target属性引入该路由；Spoke-PE2通过EBGP发布给本地Spoke-CE2。</p>
<p>•Hub-PE的BGP-VPN实例（VPN_out）通过Export Target属性将路由发布给Spoke-PE2的同时，也会将该路由发布给Spoke-PE1。此时，这条路由是Hub-PE通过IGP（OSPF200多实例）引入的，由于IGP路由不携带AS-PATH属性，AS_Path为空；而原来从Spoke-CE1来的192.168.1.0/24路由，其AS_Path不为空，所以从Hub-PE返回的路由会优于从Spoke-CE1来的路由。这样会引起路由振荡，其过程如下：</p>
<p>1.Spoke-CE1发来的路由因为AS_Path变成非最佳路由</p>
<p>2.Spoke-PE1发布Update撤销路由的报文给Hub-PE来撤销192.168.1.0/24路由</p>
<p>3.Hub-PE（通过撤销相应的OSPF LSA）撤销发给Hub-CE的路由</p>
<p>4.Hub-CE（原理同上）撤销发给Hub-PE的路由</p>
<p>5.Hub-PE发布Update撤销路由撤销发给Spoke-PE1的路由</p>
<p>•于是在Spoke-PE1上从Spoke-CE1来的路由又变成最佳路由。Spoke-PE1又通过IBGP将路由发布给Hub-PE。Hub-PE又会返回该路由，从Spoke-CE1来的路由又变成非最佳路由。如此反复。</p>
</blockquote>
<h1 id="3-OSPF-VPN拓展"><a href="#3-OSPF-VPN拓展" class="headerlink" title="3.OSPF VPN拓展"></a>3.OSPF VPN拓展</h1><h2 id="OSPF与BGP互操作"><a href="#OSPF与BGP互操作" class="headerlink" title="OSPF与BGP互操作"></a>OSPF与BGP互操作</h2><h3 id="MPLS-VPN中的OSPF-BGP"><a href="#MPLS-VPN中的OSPF-BGP" class="headerlink" title="MPLS VPN中的OSPF/BGP"></a>MPLS VPN中的OSPF/BGP</h3><p>•当PE-CE间部署OSPF交互路由信息时，若在PE上使用标准BGP/OSPF过程（简称为BGP/OSPF互操作）互来传递路由信息，则远端PE在将BGP引入VPN实例的OSPF进程时，会直接产生Type5 LSA，不同站点都会将其他站点的路由视为自治系统外部路由（AS_external）。</p>
<p>•为了解决标准BGP/OSPF的互操作导致的OSPF路由信息丢失的问题，BGP和OSPF都做了相应的拓展。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/24.png"></p>
<blockquote>
<p>•在实际应用中，如果两个要互通的Site都在相同的AS内，那么每个Site都应该将另一个Site的路由看成区域间路由，而不是AS外部路由。</p>
</blockquote>
<h3 id="BGP扩展团体属性"><a href="#BGP扩展团体属性" class="headerlink" title="BGP扩展团体属性"></a>BGP扩展团体属性</h3><p>•为了保留OSPF的路由信息，BGP新增了部分可携带OSPF路由信息的团体属性：</p>
<ul>
<li><p>Domain ID：域标识符用来标识和区分不同的域。</p>
</li>
<li><p>Route Type：包含被引入到BGP的OSPF路由的 Area-ID 以及Route Type</p>
<ul>
<li>Area-ID：PE 的VPN实例的OSPF进程与CE建立邻接关系的区域号</li>
<li>Route Type：被引入的 OSPF 路由的类型<ul>
<li>1 或 2：表示路由的类型为区域内部路由， 也就是 PE 根据 Type-1 及 Type-2 LSA 所计算出来的路由。</li>
<li>3：表示路由的类型为区域间路由。</li>
<li>5：表示路由的类型为 OSPF 外部路由，也就是 PE 通过 Type-5 LSA 计算得出的路由。当 Route-Type 字段的值为 5 时， Area-ID 字段的值需为 0.0.0.0。</li>
<li>7：表示路由的类型为 NSSA 路由，也就是 PE 通过 Type-7 LSA 计算得出的路由。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Domain-ID"><a href="#Domain-ID" class="headerlink" title="Domain ID"></a>Domain ID</h3><p>•在PE上将OSPF引入BGP时，PE将根据本地的配置为BGP路由增加域ID属性，域ID作为BGP的扩展团体属性传播。</p>
<p>•在PE将BGP路由引入OSPF时，若BGP路由携带的Domain ID与本地相同，则认为两个站点属于同一个OSPF路由域。若不相同，则认为不在同一个路由域。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/27.png"></p>
<blockquote>
<p>•Domain ID需要在绑定到VRF的OSPF进程视图下使用命令<strong>domain-id</strong>配置。</p>
<ul>
<li><p>缺省情况下，Domain ID的值为0（NULL）。如果不同OSPF域都使用NULL作为Domain ID，将无法区分OSPF域，因此它们之间的路由将被当作区域内路由。</p>
</li>
<li><p>如果一个OSPF域配置了非0（即非NULL）的Domain ID，NULL不再是该OSPF域的Domain ID。</p>
</li>
</ul>
<p>•建议与同一个VPN相关的所有OSPF实例都使用相同的Domain ID，或者都使用缺省的Domain ID。</p>
</blockquote>
<h3 id="Domain-ID与Route-Type"><a href="#Domain-ID与Route-Type" class="headerlink" title="Domain ID与Route Type"></a>Domain ID与Route Type</h3><p>根据BGP路由中的Domain ID与Route Type属性，PE将产生不同类型的OSPF LSA类型发布到VRF的OSPF进程中</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/28.png"></p>
<h2 id="OSPF防环"><a href="#OSPF防环" class="headerlink" title="OSPF防环"></a>OSPF防环</h2><h3 id="Type3路由防环-案例"><a href="#Type3路由防环-案例" class="headerlink" title="Type3路由防环 - 案例"></a>Type3路由防环 - 案例</h3><p>•如图是Type3 LSA路由产生环路的一个例子：</p>
<p>​    ▫其中站点1和站点2都属于VPN1。</p>
<p>​    ▫站点1通过OSPF Area0接入骨干网的PE1；</p>
<p>​    ▫站点2通过OSPF Area0分别接入骨干网的PE2和PE3（双归属负载分担场景）。</p>
<blockquote>
<p>•环路产生过程如下：</p>
<p>1.Site1的CE1通过Type3 LSA发布到192.168.1.0/24的路由给PE1。</p>
<p>2.PE1向BGP引入OSPF VPN1进程，通过MP-IBGP将该路由发布给PE2和PE3。</p>
<p>3.由于PE2上配置了BGP到OSPF的路由引入，故PE2将产生Type3 LSA给CE2，CE2将来自PE2的Type3 LSA发布给PE3。</p>
<p>4.此时PE3收到两条到达192.168.1.0/24的路由：一条是PE1发布的，另一条是PE2上路由引入产生的。由于缺省情况下，IGP（OSPF）路由优先级高于IBGP路由，PE3将选择OSPF路由。</p>
<p>5.PE3将优选的学自OSPF通过MP-IBGP发布给PE1。</p>
<p>▫此时，PE1上存在两条到达目的地192.168.1.0/24网段的路由，一条通过OSPF学习自CE1，另一条通过MP-IBGP学习自PE3。可能会导致以下问题：</p>
<ul>
<li>PE1撤销192.168.1.0/24这条路由，但由于PE1与PE2之间的链路阻塞，BGP Update（撤销报文）无法及时发送给PE2，导致PE3发给PE1的路由依然存在（正常情况下会随着PE1发送给PE2的Update报文被撤销），PE1上到达目的地192.168.1.0/24的下一跳为PE3。此时路由环路产生。</li>
<li>若PE1上MP-IBGP的路由优先级高于OSPF，则PE1会优选PE3通告的BGP路由，此时PE1需要撤销发给PE2的BGP路由，导致PE3撤销发布给PE1的路由，PE1上的OSPF再次被优选。如此反复，形成路由震荡。</li>
</ul>
</blockquote>
<h3 id="Type3路由防环-DN位"><a href="#Type3路由防环-DN位" class="headerlink" title="Type3路由防环 - DN位"></a>Type3路由防环 - DN位</h3><p>•为了防止3类LSA环路，OSPF多实例进程使用LSA Options域中一个原先未使用的比特作为标志位，称为DN位。使用DN位可以防止Type3 LSA环路。</p>
<p>•PE路由器的OSPF实例进程在进行SPF计算时，忽略DN置位的Type3 LSA。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/29.png"></p>
<h3 id="Type5-7路由防环-案例"><a href="#Type5-7路由防环-案例" class="headerlink" title="Type5/7路由防环 - 案例"></a>Type5/7路由防环 - 案例</h3><p>•如图是Type5 LSA路由产生环路的一个例子：</p>
<p>​    ▫其中站点1和站点2都属于VPN1。</p>
<p>​    ▫站点1通过EBGP接入骨干网的PE1；</p>
<p>​    ▫站点2通过OSPF分别接入骨干网的PE2和PE3。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/30.png"></p>
<blockquote>
<p>•环路产生过程如下：</p>
<p>1.CE1通过EBGP发布到192.168.1.0/24的路由给PE1，AS_Path为65001。</p>
<p>2.PE1通过MP-IBGP将该路由发布给PE2和PE3。</p>
<p>3.PE2在OSPF VPN1实例进程中引入BGP路由，发布到192.168.1.0/24的Type5 LSA给CE2；</p>
<p>4.CE2将该Type5 LSA发布给PE3。</p>
<p>5.PE3将优选择OSPF路由（OSPF优先级高于IBGP），并通过MP-IBGP发布Update消息给PE1。</p>
<p>6.PE1收到PE3发送的MP-IBGP Update消息。由于其中的路由是PE3的BGP引入的IGP（OSPF）路由，其AS_Path为空，因此PE3发布的MP-IBGP路由优先级比从CE1发布的EBGP路由优先级高，PE1将优选用PE3发布的路由。</p>
<p>7.此时形成一条路由环路：PE3—&gt;CE2—&gt;PE2—&gt;PE1—&gt;PE3。</p>
<p>•由于PE1不再优选CE1学来的路由，故PE1会撤销发给PE2的路由，PE2中的OSPF VPN实例进程进程中也要对应撤销引入的BGP路由，继而CE2、PE3都相继撤销该OSPF路由。PE3向PE1发布的BGP路由也被撤销，在PE1上，从CE1学来的路由又变成最优路由。这样，形成了路由振荡。</p>
<p>•Type7 LSA环路的产生和消除的过程与Type5类似，此处不再赘述。</p>
</blockquote>
<h3 id="Type5-7路由防环-VPN-Route-Tag"><a href="#Type5-7路由防环-VPN-Route-Tag" class="headerlink" title="Type5/7路由防环 - VPN Route Tag"></a>Type5/7路由防环 - VPN Route Tag</h3><p>•可以使用VPN Route Tag（VPN路由标记）来防止此5类或7类路由环路。</p>
<p>•PE在根据收到的BGP的私网路由生成5/7类LSA时，携带VPN路由标记。当PE发现LSA的VPN路由标记和本地配置的一样，就会忽略这条LSA，因此可以避免上述环路。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/31.png"></p>
<blockquote>
<p>•VPN路由标记不在BGP的扩展团体属性中传递，只是本地概念，只在收到BGP路由并且产生OSPF LSA的PE设备上有意义。</p>
<p>•缺省情况下，VPN的路由标记是根据BGP的AS号计算得到的。如果没有配置BGP，则默认值为0。</p>
<p>•可以通过指令<strong>route-tag</strong>配置VPN的路由标记。</p>
</blockquote>
<h2 id="OSPF-sham-link"><a href="#OSPF-sham-link" class="headerlink" title="OSPF sham link"></a>OSPF sham link</h2><h3 id="Sham-link的应用场景"><a href="#Sham-link的应用场景" class="headerlink" title="Sham link的应用场景"></a>Sham link的应用场景</h3><p>•通常情况下，BGP对等体之间通过BGP扩展团体属性在MPLS VPN骨干网上承载路由信息。另一端PE上运行的OSPF可利用这些信息来生成PE到CE的Type 3 LSA，这些路由是区域间路由（Inter_Area route）。</p>
<p>•若在CE1和CE2之间增加一条后门（Backdoor）链路，并且直接运行OSPF交互路由。通过后门链路学习到的路由类型为区域内路由（Intra_Area route）。</p>
<p>•由于区域内路由优于区域间路由，故后门链路会被优选，若想实现后门链路作为备份链路，可采用sham link实现。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/32.png"></p>
<h3 id="Sham-link的工作机制"><a href="#Sham-link的工作机制" class="headerlink" title="Sham link的工作机制"></a>Sham link的工作机制</h3><p>•Sham link在两台PE之间创建了一条区域内链路。当LSA在伪装链路中泛洪，所有的OSPF路由类型都不会改变，不会转换成LSA3或者LSA5的类型。</p>
<p>•Sham link被看成是两个VPN实例之间的链路，链路的两端是PE上的端点地址，分别作为建立连接时的源和目的地址。伪连接的源地址和目的地址使用32位掩码的Loopback接口地址，该Loopback接口需要绑定到VPN实例中，并通过BGP发布。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/33.png"></p>
<blockquote>
<p>•同一个OSPF进程的多条Sham link可以共用端点地址，但不同OSPF进程不能拥有两条端点地址完全相同的Sham link。</p>
</blockquote>
<h3 id="Sham-link的配置示例"><a href="#Sham-link的配置示例" class="headerlink" title="Sham link的配置示例"></a>Sham link的配置示例</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/34.png"></p>
<blockquote>
<p>•在配置Sham link时可以指定Sham link的路由开销。缺省值为1。</p>
</blockquote>
<h3 id="sham-link的配置验证"><a href="#sham-link的配置验证" class="headerlink" title="sham link的配置验证"></a>sham link的配置验证</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/35.png"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>1.（多选题）在MPLS VPN组网中，当PE向OSPF引入从其他PE学习来的VPN路由时，可能会产生以下哪几类LSA（    ）。</p>
<p>A.Type 1 LSA</p>
<p><strong>B.Type 3 LSA</strong></p>
<p><strong>C.Type 5 LSA</strong></p>
<p><strong>D.Type 7 LSA</strong></p>
<p>2.（判断）CE通过BGP传递路由给PE时，可能会携带SoO属性。（    ）。</p>
<p>A. 正确</p>
<p><strong>B. 错误</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•MPLS VPN在针对不同类型的场景下有不同的组网方案，常见的有Intranet组网、Extranet组网以及Hub&amp;Spoke组网。此外，根据MPLS VPN骨干网是否跨域又可以分为跨域组网和单域组网。</p>
<p>•PE-CE之间进行路由信息交互时，可以使用静态路由、OSPF、IS-IS或BGP中的任何一种。其中OSPF为MPLS VPN做了许多扩展特性，如：</p>
<p>​    ▫Domain ID：用来区分VPN实例中引入的路由是否来自同一个OSPF域</p>
<p>​    ▫DN位：用来防止因为3类LSA产生的路由环路</p>
<p>​    ▫VPN Route Tag：用来方式因为5类或7类LSA产生的路由环路</p>
<p>​    ▫sham link：用于特殊场景下的OSPF路由选路控制</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/" itemprop="url">IPadv-MPLSVPN原理与配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-23T14:29:37+08:00">
                2021-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•VPN（Virtual Private Network，虚拟专用网络）指的是在一个公共网络中实现虚拟的专用网络，从而使得用户能够基于该专用网络实现通信的技术。</p>
<p>•MPLS VPN也是VPN技术中的一种。需要强调的是，本课程所介绍的MPLS VPN指的是BGP/MPLS IP VPN，这是一种被业界广泛使用的三层VPN。</p>
<p>•本课程将介绍MPLS VPN的基本概念、工作过程以及典型配置方法。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述MPLS VPN的模型</p>
<p>▫描述MPLS VPN中的基本概念</p>
<p>▫描述MPLS VPN路由传递和标签分发</p>
<p>▫描述MPLS VPN数据转发流程</p>
<p>▫执行MPLS VPN的基本配置</p>
<h1 id="1-MPLS-VPN概述"><a href="#1-MPLS-VPN概述" class="headerlink" title="1.MPLS VPN概述"></a>1.MPLS VPN概述</h1><h2 id="MPLS-VPN定义"><a href="#MPLS-VPN定义" class="headerlink" title="MPLS VPN定义"></a>MPLS VPN定义</h2><p>•BGP/MPLS IP VPN网络一般由<strong>运营商</strong>搭建，<strong>VPN用户购买</strong>VPN服务来实现用户网络之间的路由传递、数据互通等。</p>
<p>•MPLS VPN使用<strong>BGP</strong>在运营商骨干网（<strong>IP网络</strong>）上发布VPN路由，使用<strong>MPLS</strong>在运营商骨干网上转发VPN报文。BGP/MPLS IP VPN又被简称为MPLS VPN，是一种常见的L3VPN（Layer 3 VPN）技术。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p>
<h2 id="MPLS-VPN网络架构"><a href="#MPLS-VPN网络架构" class="headerlink" title="MPLS VPN网络架构"></a>MPLS VPN网络架构</h2><p>•MPLS VPN网络架构由三部分组成：CE（Customer Edge）、PE（Provider Edge）和P（Provider），其中PE和P是运营商设备，CE是MPLS VPN用户设备。</p>
<p>•站点（site）就是MPLS VPN的用户，由CE和其他用户设备构成。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p>
<blockquote>
<p>•CE：用户网络边缘设备，有接口直接与运营商网络相连。CE可以是路由器或交换机，也可以是一台主机。通常情况下，CE“感知”不到VPN的存在，也不需要支持MPLS。</p>
<p>•PE：运营商边缘路由器，是运营商网络的边缘设备，与CE直接相连。在MPLS网络中，对VPN的所有处理都发生在PE上，对PE性能要求较高。</p>
<p>•P：运营商网络中的骨干路由器，不与CE直接相连。P设备只需要具备基本MPLS转发能力，不维护VPN相关信息。</p>
<p>•站点的含义可以从下述几个方面理解：</p>
<ul>
<li><p>站点是指相互之间具备IP连通性的一组IP系统，并且这组IP系统的IP连通性不需通过运营商网络实现。</p>
</li>
<li><p>站点的划分是根据设备的拓扑关系，而不是地理位置。如图所示，公司A的X省网络和公司A的Y省网络需要通过运营商的骨干网进行互联，所以它们被划分为两个站点。若在当前X省网络和Y省网络的CE之间增加一条物理专线，不需要通过运营商网络就可以互通，那么这两张网络就是一个站点。</p>
</li>
</ul>
<p>•站点与VPN的关系：</p>
<ul>
<li><p>对于多个连接到同一服务提供商网络的站点，通过制定策略，可以将它们划分为不同的集合，只有属于相同集合的站点之间才能通过服务提供商网络互访，这种集合就是VPN。</p>
</li>
<li><p>一个Site中的设备可以属于多个VPN，换言之，一个Site可以属于多个VPN。</p>
</li>
</ul>
<p>•注：也有可能出现站点为一台主机的情况，此时该主机就是CE设备。本课程仅讨论站点是一个或多个子网，用路由器或交换机作为CE的情况。</p>
</blockquote>
<h2 id="MPLS-VPN技术架构"><a href="#MPLS-VPN技术架构" class="headerlink" title="MPLS VPN技术架构"></a>MPLS VPN技术架构</h2><p>•MPLS VPN不是单一的一种VPN技术，是多种技术结合的综合解决方案，主要包含下列技术：</p>
<p>​    ▫MP-BGP：负责在PE与PE之间传递站点内的路由信息。</p>
<p>​    ▫LDP：负责PE与PE之间的隧道建立</p>
<p>​    ▫VRF：负责PE的VPN用户管理。</p>
<p>​    ▫静态路由、IGP、BGP：负责PE与CE之间的路由信息交换。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p>
<blockquote>
<p>•MP-BGP（MultiProtocol BGP）：拓展的BGP协议，可提供对多种地址族的支持，后续课程将会详细介绍。</p>
</blockquote>
<h2 id="为什么要选择MPLS-VPN"><a href="#为什么要选择MPLS-VPN" class="headerlink" title="为什么要选择MPLS VPN"></a>为什么要选择MPLS VPN</h2><p>•对VPN客户而言：</p>
<ul>
<li>“感知”不到VPN的存在，不需要部署和维护VPN，降低企业运维难度和成本。</li>
<li>一般部署在运营商的MPLS VPN专网上，有一定的安全性保障。</li>
</ul>
<p>•对于运营商而言：</p>
<ul>
<li>MPLS在无连接的IP网络中增加了面向连接的控制平面，为IP网络增添了管理和运营的手段。</li>
<li>支持地址空间重叠、支持重叠VPN、组网方式灵活、可扩展性好。</li>
<li>能够方便地支持MPLS TE合理调控现有网络资源，最大限度的节省运营商成本。</li>
</ul>
<blockquote>
<p>•MPLS TE（MPLS Traffic Engineering，MPLS流量工程）：基于一定约束条件LSP隧道，并将流量引入到这些隧道中进行转发，使网络流量按照指定的路径进行传输。可以在不进行硬件升级的情况下对现有网络资源进行合理调配和利用，并对网络流量提供带宽和QoS保证，最大限度的节省成本。</p>
</blockquote>
<h2 id="MPLS-VPN常见组网"><a href="#MPLS-VPN常见组网" class="headerlink" title="MPLS VPN常见组网"></a>MPLS VPN常见组网</h2><p>•根据VPN用户的需求不同，可采用以下几种常见的组网方案：</p>
<ul>
<li>Intranet：一个VPN中的所有用户形成闭合用户群，同一VPN站点之间可以互访，不同VPN站点间不能互访。</li>
<li>Extranet：适用于一个VPN用户希望提供部分本VPN的站点资源给其他VPN的用户访问的场景。</li>
<li>Hub&amp;Spoke：如果希望在VPN中设置中心访问控制设备，其它用户的互访都通过中心访问控制设备进行，可采用Hub&amp;Spoke组网方案。</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p>
<blockquote>
<p>•Intranet组网是最简单也是最典型的MPLS VPN组网方案，后续课程将基于该组网方案对MPLS VPN技术原理展开介绍。</p>
</blockquote>
<h1 id="2-MPLS-VPN路由交互"><a href="#2-MPLS-VPN路由交互" class="headerlink" title="2.MPLS VPN路由交互"></a>2.MPLS VPN路由交互</h1><h2 id="MPLS-VPN路由发布概述"><a href="#MPLS-VPN路由发布概述" class="headerlink" title="MPLS VPN路由发布概述"></a>MPLS VPN路由发布概述</h2><p>•若想实现同一个VPN的不同站点之间的通信，首先需要完成不同站点之间的路由交互。在基本MPLS VPN组网中，VPN路由信息的发布涉及CE和PE，P路由器只维护骨干网的路由，不需要了解任何VPN路由信息。VPN路由信息的发布过程包括三部分：</p>
<p>​    ▫本地CE到入口PE</p>
<p>​    ▫入口PE到出口PE</p>
<p>​    ▫出口PE到远端CE</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/5.png"></p>
<h2 id="CE与PE之间的路由信息交换"><a href="#CE与PE之间的路由信息交换" class="headerlink" title="CE与PE之间的路由信息交换"></a>CE与PE之间的路由信息交换</h2><p>•如图，客户X和客户Y属于不同的VPN，分别拥有两个站点，现需要实现站点间的路由信息交互。</p>
<p>•CE与PE之间可以使用静态路由、OSPF、IS-IS或BGP交换路由信息。无论使用哪种路由协议，CE和PE之间交换的都是<strong>标准的IPv4</strong>路由。</p>
<p>•本地CE到入口PE和出口PE到远端CE的路由信息交换原理完全相同。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/6.png"></p>
<h2 id="入口PE到出口PE路由传递-1"><a href="#入口PE到出口PE路由传递-1" class="headerlink" title="入口PE到出口PE路由传递 (1)"></a>入口PE到出口PE路由传递 (1)</h2><p>PE在接收到CE传递来的路由之后，需要独立保存不同VPN的路由，且需要解决不同的客户使用重叠IP地址空间的问题。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/7.png"></p>
<blockquote>
<p>•VPN是一种私有网络，不同的VPN独立管理自己的地址范围，也称为地址空间（address space）。不同VPN的地址空间可能会在一定范围内重合，例如图中用户X和用户Y都使用192.168.1.0/24网段地址，这就发生了地址空间的重叠（address spaces overlapping）。以下两种情况允许VPN使用重叠的地址空间：</p>
<ul>
<li><p>两个VPN没有共同的站点；</p>
</li>
<li><p>两个VPN有共同的站点，但此共同站点中的设备不与两个VPN中使用重叠地址空间的设备互访。</p>
</li>
</ul>
</blockquote>
<h2 id="VRF"><a href="#VRF" class="headerlink" title="VRF"></a>VRF</h2><p>•VRF（Virtual Routing and Forwarding，虚拟路由转发），又称VPN实例，是MPLS VPN架构中的关键技术，每个VPN实例使用独立的路由转发表项，实现VPN之间的逻辑隔离。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/8.png"></p>
<h2 id="RD"><a href="#RD" class="headerlink" title="RD"></a>RD</h2><p>•PE收到不同VPN的CE发来的IPv4地址前缀，本地根据VPN实例配置去区分这些地址前缀。但是VPN实例只是一个<strong>本地</strong>的概念，PE无法将VPN实例信息传递到对端PE，故有了RD（Route Distinguisher，路由标识符）。</p>
<p>▫RD长8字节，用于区分使用相同地址空间的IPv4前缀。</p>
<p>▫PE从CE接收到IPv4路由后，在IPv4前缀前加上RD，转换为<strong>全局唯一</strong>的<strong>VPN-IPv4</strong>路由。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/9.png"></p>
<blockquote>
<p>•配置RD时，只需要指定RD的Administrator子字段和Assigned Number子字段。</p>
<p>•RD的配置格式有四种，常用的两种如下：</p>
<p>​    ▫16bits自治系统号:32bits用户自定义数字（例如：100:1）。</p>
<p>​    ▫32bits IPv4地址:16bits用户自定义数字（例如：172.1.1.1:1）。</p>
<p>•RD的结构使得每个运营商可以独立地分配RD，但为了在某些应用场景下保证路由正常，必须保证RD全局唯一。</p>
</blockquote>
<h2 id="VPN-IPv4地址"><a href="#VPN-IPv4地址" class="headerlink" title="VPN-IPv4地址"></a>VPN-IPv4地址</h2><p>VPN-IPv4地址又被称为VPNv4地址：VPNv4地址共有12个字节，包括8字节的路由标识符RD（Route Distinguisher）和4字节的IPv4地址前缀。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/10.png"></p>
<h2 id="入口PE到出口PE路由传递-2"><a href="#入口PE到出口PE路由传递-2" class="headerlink" title="入口PE到出口PE路由传递 (2)"></a>入口PE到出口PE路由传递 (2)</h2><p>•PE之间建立BGP邻居关系，并通过BGP进行路由传递。为什么采用BGP呢？</p>
<p>▫BGP使用TCP作为其传输层协议，提高了协议的可靠性。可以跨路由器的两个PE设备之间直接交换路由。</p>
<p>▫BGP拓展性强，为PE间传播VPN路由提供了便利。</p>
<p>▫PE之间需要传送的路由条目可能较大，BGP只发送更新的路由，提高传递路由数量的同时不占用过多链路带宽。</p>
<p>•传统的BGP-4<strong>不支持</strong>处理VPNv4路由。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/11.png"></p>
<h2 id="MP-BGP"><a href="#MP-BGP" class="headerlink" title="MP-BGP"></a>MP-BGP</h2><p>•为了正确处理VPN路由，MPLS VPN使用RFC2858（Multiprotocol Extensions for BGP-4）中规定的MP-BGP，即BGP-4的多协议扩展。</p>
<p>•MP-BGP采用地址族（Address Family）来区分不同的网络层协议，既可以支持传统的IPv4地址族，又可以支持其它地址族（比如VPN-IPv4地址族、IPv6地址族等）。</p>
<p>•MP-BGP新增了两种路径属性：</p>
<ul>
<li><p>MP_REACH_NLRI：Multiprotocol Reachable NLRI，多协议可达NLRI。用于发布可达路由及下一跳信息。</p>
</li>
<li><p>MP_UNREACH_NLRI：Multiprotocol Unreachable NLRI，多协议不可达NLRI。用于撤销不可达路由。</p>
</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/12.png"></p>
<blockquote>
<p>•NLRI：Network Layer Reachability Information，网络层可达信息。</p>
<p>•关于地址族的一些取值请参考RFC3232（Assigned Numbers）。</p>
<p>•MP_REACH_NLRI用于发布可达路由及下一跳信息。该属性由一个或多个三元组&lt;地址族信息、下一跳信息、网络可达性信息&gt;组成，格式如下：</p>
<p>▫地址族信息（Address Family Information）域：由2字节的地址族标识AFI（Address Family Identifier）和1字节的子地址族标识SAFI（Subsequent Address Family Identifier）组成。</p>
<p>▪AFI标识网络层协议，对应RFC3232的“Address Family Number”所定义的地址族值。例如IPv4的值是1，IPv6的值是2。</p>
<p>▪SAFI表示NLRI的类型。AFI值为1，SAFI值为128表示NLRI中的地址为MPLS-labeled VPN-IPv4地址。</p>
<ul>
<li><p>下一跳信息（Next Hop Network Address Information）域：由一字节的下一跳网络地址长度和可变长度的下一跳网络地址组成。</p>
</li>
<li><p>网络层可达性信息（NLRI）域：由一个或多个三元组&lt;长度、标签、前缀&gt;组成，该部分内容将在后面的课程里详细介绍。</p>
</li>
</ul>
<p>•MP_UNREACH_NLRI用于通知对等体删除不可达的路由。该属性的格式如下：</p>
<ul>
<li><p>地址族标识AFI：与MP_REACH_NLRI属性中的相同。</p>
</li>
<li><p>子地址族标识SAFI：与MP_REACH_NLRI属性中的相同，表示NLRI的类型。</p>
</li>
<li><p>撤销路由（Withdrawn Routes）：不可达路由列表，也是由一个或多个NLRI组成。BGP发言者可以通过在撤销路由域中携带与之前发布的可达路由中相同的NLRI来撤销路由。</p>
</li>
</ul>
<p>•MP-BGP的报文类型、VPNv4路由发布策略仍与普通BGP相同。</p>
</blockquote>
<h2 id="入口PE到出口PE路由传递-3"><a href="#入口PE到出口PE路由传递-3" class="headerlink" title="入口PE到出口PE路由传递 (3)"></a>入口PE到出口PE路由传递 (3)</h2><p>•MP-BGP将VPNv4传递到远端PE之后，远端PE需要将VPNv4路由导入正确的VPN实例。</p>
<p>•MPLS VPN使用32位的BGP扩展团体属性－VPN Target（也称为Route Target）来控制VPN路由信息的发布与接收。</p>
<p>•本地PE在发布VPNv4路由前附上RT属性，对端RT在接到到VPNv4路由后根据RT将路由导入对应的VPN实例。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/13.png"></p>
<h2 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h2><p>•在PE上，每一个VPN实例都会与<strong>一个或多个</strong>VPN Target属性绑定，有两类VPN Target属性：</p>
<ul>
<li><p>Export Target（ERT）：本地PE从直接相连站点学到IPv4路由后，转换为VPN IPv4路由，并为这些路由添加Export Target属性。Export Target属性作为BGP的扩展团体属性随路由发布。</p>
</li>
<li><p>Import Target（IRT）：PE收到其它PE发布的VPN-IPv4路由时，检查其Export Target属性。当此属性与PE上某个VPN实例的Import Target匹配时，PE就把路由加入到该VPN实例的路由表。</p>
</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/14.png"></p>
<blockquote>
<p>•与RD相同，RT由Type、Administrator和Assigned Number三个字段构成，长度也是8字节。 </p>
<p>•配置VPN-Target时，只需要指定VPN-Target的Administrator子字段和Assigned Number子字段。VPN-Target的配置格式与RD格式一致。</p>
</blockquote>
<h2 id="入口PE到出口PE路由传递-4"><a href="#入口PE到出口PE路由传递-4" class="headerlink" title="入口PE到出口PE路由传递 (4)"></a>入口PE到出口PE路由传递 (4)</h2><p>•PE根据VPNv4路由所携带的RT将路由导入正确的VPN实例之后，VPNv4路由的RD值剥除，将<strong>IPv4路由</strong>通告给相应的客户的CE设备。</p>
<p>•站点B和站点D的CE设备就能学习到去往各自远端站点的路由。同理，通过一系列的操作，可以实现同一用户（同一VPN）不同站点之间的路由互通。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/20.png"></p>
<h2 id="数据转发时遇到的问题"><a href="#数据转发时遇到的问题" class="headerlink" title="数据转发时遇到的问题"></a>数据转发时遇到的问题</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/21.png"></p>
<h2 id="通过标签解决问题"><a href="#通过标签解决问题" class="headerlink" title="通过标签解决问题"></a>通过标签解决问题</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/22.png"></p>
<h2 id="入口PE到出口PE路由传递-5"><a href="#入口PE到出口PE路由传递-5" class="headerlink" title="入口PE到出口PE路由传递 (5)"></a>入口PE到出口PE路由传递 (5)</h2><p>•PE和P设备之间运行LDP，交换公网标签，建立PE之间的LSP隧道（公网隧道）。</p>
<p>•入口PE在通过MP-BGP传递VPNv4路由时，会携带私网标签，用于区分不同VPN的数据。</p>
<p>•出口PE在接收到VPNv4路由后，需要执行私网路由交叉和隧道迭代来选择路由。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/23.png"></p>
<blockquote>
<p>•PE上分配私网标签的方法有如下两种：</p>
<ul>
<li>基于路由的MPLS标签分配：为VPN路由表的每一条路由分配一个标签（one label per route）。这种方式的缺点是：当路由数量比较多时，设备入标签映射表ILM（Incoming Label Map）需要维护的表项也会增多，从而提高了对设备容量的要求。</li>
<li>基于VPN实例的MPLS标签分配：为整个VPN实例分配一个标签，该VPN实例里的所有路由都共享一个标签。使用这种分配方法的好处是节约了标签。</li>
</ul>
<p>•私网路由交叉：VPNv4路由与本地VPN实例的VPN-Target进行匹配的过程称为私网路由交叉。PE在收到VPNv4路由后，既不进行优选，也不检查隧道是否存在，直接将其与本地的VPN实例进行交叉。</p>
<p>•隧道迭代：为了将私网流量通过公网传递到另一端，需要有一条公网隧道承载这个私网流量。因此私网路由交叉完成后，需要根据目的IPv4前缀进行路由迭代，即该IPv4路由的下一跳有对应的LSP存在；只有隧道迭代成功，该路由才被放入对应的VPN实例路由表。</p>
</blockquote>
<h2 id="MPLS-VPN中的路由交互全过程"><a href="#MPLS-VPN中的路由交互全过程" class="headerlink" title="MPLS VPN中的路由交互全过程"></a>MPLS VPN中的路由交互全过程</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/24.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>•在MPLS VPN中，PE与CE，PE与PE之间需要进行VPN路由信息的传递。</p>
<ul>
<li>PE与CE之间可以采用BGP、IGP以及静态路由方式交互<strong>IPv4</strong>路由信息。</li>
<li>PE与PE之间通过MP-BGP交互<strong>VPNv4</strong>路由信息，包含<ul>
<li>RD：与IPv4前缀组合组成VPNv4前缀。</li>
<li>RT：用于控制PE之间路由信息的接收和发布。</li>
<li>标签：数据转发时的内层（私网）标签，在PE上用来区分不同VPN的数据。</li>
</ul>
</li>
</ul>
<h1 id="3-MPLS-VPN报文转发"><a href="#3-MPLS-VPN报文转发" class="headerlink" title="3.MPLS VPN报文转发"></a>3.MPLS VPN报文转发</h1><h2 id="报文转发过程"><a href="#报文转发过程" class="headerlink" title="报文转发过程"></a>报文转发过程</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/25.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/26.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/27.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/28.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/29.png"></p>
<h1 id="4-MPLS-VPN配置与实现"><a href="#4-MPLS-VPN配置与实现" class="headerlink" title="4.MPLS VPN配置与实现"></a>4.MPLS VPN配置与实现</h1><h2 id="配置命令-VPN实例配置"><a href="#配置命令-VPN实例配置" class="headerlink" title="配置命令 - VPN实例配置"></a>配置命令 - VPN实例配置</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/30.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/31.png"></p>
<h2 id="配置命令-MP-BGP配置"><a href="#配置命令-MP-BGP配置" class="headerlink" title="配置命令 - MP-BGP配置"></a>配置命令 - MP-BGP配置</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/32.png"></p>
<h2 id="配置命令-PE与CE间路由配置"><a href="#配置命令-PE与CE间路由配置" class="headerlink" title="配置命令 - PE与CE间路由配置"></a>配置命令 - PE与CE间路由配置</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/33.png"></p>
<h2 id="MPLS-VPN配置示例-背景介绍"><a href="#MPLS-VPN配置示例-背景介绍" class="headerlink" title="MPLS VPN配置示例 - 背景介绍"></a>MPLS VPN配置示例 - 背景介绍</h2><p>•客户X及Y各自有2个站点，现需要通过MPLS VPN实现站点之间的互联，分别对应VPNX和VPNY；</p>
<p>•互联接口、AS号及IP地址信息如图；</p>
<p>•客户X站点与PE之间采用OSPF交互路由信息，客户Y站点与PE之间采用BGP交互路由信息。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/34.png"></p>
<h2 id="MPLS-VPN配置示例-配置思路"><a href="#MPLS-VPN配置示例-配置思路" class="headerlink" title="MPLS VPN配置示例 - 配置思路"></a>MPLS VPN配置示例 - 配置思路</h2><p>1.MPLS VPN骨干网配置</p>
<p>​    1.1 IGP配置，实现骨干网的IP连通性。</p>
<p>​    1.2 MPLS与MPLS LDP配置，建立MPLS LSP公网隧道，传输VPN数据。</p>
<p>​    1.3 MP-BGP配置，建立后续传递VPNv4路由的MP-BGP对等体关系。</p>
<p>2.VPN用户接入配置</p>
<p>​    2.1 创建VPN实例并配置参数（RT、RD）</p>
<p>​    2.2 将接口加入VPN实例</p>
<p>​    2.3 配置PE与CE之间的路由交换</p>
<h2 id="MPLS-VPN配置示例-数据规划"><a href="#MPLS-VPN配置示例-数据规划" class="headerlink" title="MPLS VPN配置示例 - 数据规划"></a>MPLS VPN配置示例 - 数据规划</h2><p>•MPLS骨干网采用单区域OSPF实现路由互通，所有PE和P互联接口均使能MPLS LDP功能。</p>
<p>•PE上的VPN相关配置如表格：</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/35.png"></p>
<h2 id="MPLS-VPN骨干网配置"><a href="#MPLS-VPN骨干网配置" class="headerlink" title="MPLS VPN骨干网配置"></a>MPLS VPN骨干网配置</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/36.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/37.png"></p>
<blockquote>
<p>•缺省情况下，只有BGP-IPv4单播地址族的对等体是自动使能的。即在BGP视图下配置peer as-number命令后，系统会自动配置相应的peer enable命令。其他地址族视图下都必须手动使能。</p>
</blockquote>
<h2 id="MPLS-VPN骨干网配置-配置验证"><a href="#MPLS-VPN骨干网配置-配置验证" class="headerlink" title="MPLS VPN骨干网配置 - 配置验证"></a>MPLS VPN骨干网配置 - 配置验证</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/38.png"></p>
<h2 id="VPN用户接入配置"><a href="#VPN用户接入配置" class="headerlink" title="VPN用户接入配置"></a>VPN用户接入配置</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/39.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/40.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/41.png"></p>
<h2 id="配置验证"><a href="#配置验证" class="headerlink" title="配置验证"></a>配置验证</h2><p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/42.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/43.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/44.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选）MP-BGP在传递VPNv4路由时，携带哪种Route Target ？ （ ）</p>
<p><strong>A. Export RT</strong></p>
<p>B. Implied RT</p>
<p>C. Import RT</p>
<p>D. Extended RT</p>
<p>2.（多选）基本MPLS VPN组网中，需要对VPN实例做哪些配置（ ）</p>
<p><strong>A.Import RT</strong></p>
<p><strong>B.Export RT</strong></p>
<p><strong>C.配置RD</strong></p>
<p><strong>D.配置与VPN实例绑定的接口</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•MPLS VPN网络一般由运营商搭建，用于向不同的客户提供VPN服务，使得用户的路由和数据能够通过该网络进行传递，且不同的用户之间的路由和数据完全隔离，互不影响。</p>
<p>•MPLS VPN控制层面：</p>
<p>​    ▫通过VRF和RD隔离不同用户的私网路由信息并构建唯一的VPNv4路由</p>
<p>​    ▫通过RT值控制VPNv4路由的发布和接收</p>
<p>​    ▫通过MP-BGP传递VPNv4路由前缀、标签以及RT等信息</p>
<p>​    ▫通过MPLS LDP构建公网标签转发路径</p>
<p>•MPLS转发层面：通过内外两层标签进行数据转发，内层标签区分私网数据，外层标签穿通公网网络。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/" itemprop="url">IPadv-MPLSLDP原理与配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-23T13:37:44+08:00">
                2021-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•MPLS是一种根根据标签报文中携带的短而定长的标签来转发数据的技术。</p>
<p>•MPLS的一个基本概念就是两台LSR必须对在它们之间转发的数据的标签使用上“达成共识”。LSR之间可以运行标签分发协议（Label Distribution Protocol，LDP）来告知其他LSR本设备上的标签绑定信息，从而实现标签报文的正确转发。</p>
<p>•本课程将介绍LDP基本工作原理与特性，以及LDP的基本配置。</p>
<blockquote>
<p>•本课程的标签分发协议特指由RFC3036首次定义的标签分发协议，当前该标准已被RFC5036废弃。</p>
<p>•除了LDP外，标签分发协议也可以指MP-BGP、RSVP等可执行标签分发的一类协议。</p>
</blockquote>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述LDP的基本概念及工作机制</p>
<p>▫描述MPLS标签分发控制模式、通告模式及保留模式</p>
<p>▫实现LDP的基础配置</p>
<h1 id="1-LDP基本概念"><a href="#1-LDP基本概念" class="headerlink" title="1.LDP基本概念"></a>1.LDP基本概念</h1><h2 id="LDP协议概述"><a href="#LDP协议概述" class="headerlink" title="LDP协议概述"></a>LDP协议概述</h2><p>•LDP是MPLS的一种控制协议，相当于传统网络中的信令协议，负责FEC的分类、标签的分配以及LSP的建立和维护等操作。LDP规定了标签分发过程中的各种消息以及相关处理过程。</p>
<p>•LDP的工作过程主要分为两部分：</p>
<p>​    1.LSR之间建立LDP会话。</p>
<p>​    2.LSR之间基于LDP会话动态交换标签与FEC的映射信息，并根据标签信息建立LSP。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p>
<h2 id="LDP会话、LDP邻接体、LDP对等体"><a href="#LDP会话、LDP邻接体、LDP对等体" class="headerlink" title="LDP会话、LDP邻接体、LDP对等体"></a>LDP会话、LDP邻接体、LDP对等体</h2><p>•LSR之间交互标签绑定消息之前必须建立LDP会话。LDP会话可以分为：</p>
<p>​    ▫本地LDP会话（Local LDP Session）：建立会话的两个LSR之间是直连的；</p>
<p>​    ▫远程LDP会话（Remote LDP Session）：建立会话的两个LSR之间可以是直连的，也可以是非直连的。</p>
<p>•两台LSR之间交互Hello消息之后，即建立起邻接体（Adjacency）关系；</p>
<p>•在建立邻接体关系的基础上，两台LSR之间交互LDP会话消息，建立起LDP会话，两台设备之间形成LDP对等体关系；</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p>
<h2 id="LSR-ID与LDP-ID"><a href="#LSR-ID与LDP-ID" class="headerlink" title="LSR ID与LDP ID"></a>LSR ID与LDP ID</h2><p>•每一台运行了LDP的LSR除了必须配置LSR ID，还必须拥有LDP ID。</p>
<ul>
<li><p>LDP ID的长度为48bit，由32bit的LSR ID与16bit的标签空间标识符（Label Space ID）构成。</p>
</li>
<li><p>LDP ID以“LSR ID : 标签空间标识”的形式呈现。例如2.2.2.2:0。</p>
</li>
</ul>
<p>•标签空间标识一般存在两种形态：</p>
<ul>
<li><p>值为0：表示基于设备（或基于平台）的标签空间；</p>
</li>
<li><p>值非0：表示基于接口的标签空间。</p>
</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p>
<blockquote>
<p>•在本课程中，均使用基于设备（或基于平台）的标签空间。</p>
</blockquote>
<h2 id="LDP消息"><a href="#LDP消息" class="headerlink" title="LDP消息"></a>LDP消息</h2><p>运行LDP协议的LSR之间通过交换LDP消息来实现邻居发现、会话建立与维护以及标签管理等功能。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p>
<blockquote>
<p>•按照消息的功能，LDP消息一共可以分为四大类型：发现消息（Discovery Message），会话消息（Session Message），通告消息（Advertisement Message）和通知消息（Notification Message）。</p>
<p>▫发现消息：用来宣告和维护网络中一个LSR的存在；用于通告和维护网络中LSR的存在，如Hello报文。</p>
<p>▫会话消息：用于建立、维护和终止LDP对等体之间的会话，如Initialization报文、KeepAlive报文。</p>
<p>▫通告消息：用来生成、改变和删除FEC的标签映射；</p>
<p>▫通知消息：用来宣告告警和错误信息。</p>
<p>•LDP消息承载在UDP或TCP之上，端口号均为646 。其中发现消息用来发现邻居，承载在UDP报文上。其他消息的传递要求可靠而有序，所以LDP使用TCP建立会话，会话、通告和通知消息都基于TCP传递。</p>
</blockquote>
<h2 id="LDP报文封装"><a href="#LDP报文封装" class="headerlink" title="LDP报文封装"></a>LDP报文封装</h2><p>•LDP协议报文包括了LDP头部和LDP消息两部分。</p>
<p>​    ▫LDP头部中携带了LDP版本、报文长度等信息；</p>
<p>​    ▫LDP消息中携带了消息类型、消息长度等信息。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/5.png"></p>
<blockquote>
<p>•LDP头部长度为10Byte，包括Version，PDU Length和LDP Identifier三部分。</p>
<ul>
<li>Version占用2Byte，表示LDP版本号，当前版本号为1。</li>
<li>PDU Length占用2Byte，以字节为单位表示除了Version和PDU Length以外的其他部分的总长度。</li>
<li>LDP Identifier，即LDP ID，长度6Byte，其中前4Byte用来唯一标识一个LSR，后2Byte用来表示LSR的标签空间。</li>
</ul>
<p>•LDP消息包含五个部分。</p>
<ul>
<li>U占用1个bit，为Unknown Message bit。当LSR收到一个无法识别的消息时，该消息的U=0时，LSR会返回给该消息的生成者一个通告，当U=1时，忽略该无法识别的消息，不发送通告给生成者。</li>
<li>Message Length占用2个bytes，以字节为单位表示Message ID、Mandatory Parameters和Optional Parameters的总长度。</li>
<li>Message ID占用32个bit，用来标识一个消息。</li>
<li>Mandatory Parameters和Optional Parameters分别为可变长的该消息的必须的参数和可选的参数。</li>
<li>Message Type表示具体的消息类型，目前LDP定义的常用的消息有Notification，Hello，Initialization，KeepAlive，Address，Address Withdraw，Label Mapping，Label Request，Label Abort Request，Label Withdraw，Label Release。</li>
</ul>
</blockquote>
<h1 id="2-LDP工作原理"><a href="#2-LDP工作原理" class="headerlink" title="2.LDP工作原理"></a>2.LDP工作原理</h1><h2 id="LDP会话建立"><a href="#LDP会话建立" class="headerlink" title="LDP会话建立"></a>LDP会话建立</h2><h3 id="LDP会话状态机"><a href="#LDP会话状态机" class="headerlink" title="LDP会话状态机"></a>LDP会话状态机</h3><p>LDP使用5种状态描述LDP会话状态机。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/6.png"></p>
<blockquote>
<p>•LDP Session协商过程可以通过状态机来描述。如图所示，有5种状态。分别是Non-Existent，Initialized，OpenRec，OpenSent，Operational。</p>
<p>▫Non-Existent状态：该状态为LDP Session最初的状态，在此状态双方发送HELLO消息，选举主动方，在收到TCP连接建立成功事件的触发后变为Initialized状态。</p>
<p>▫Initialized状态：该状态下分为主动方和被动方两种情况，主动方将主动发送Initialization消息，转向OpenSent 状态，等待回应的Initialization消息；被动方在此状态等待主动方发给自己的Initialization消息，如果收到的Initialization消息的参数可以接受，则发送Initialization和KeepAlive转向OpenRec状态。主动方和被动方在此状态下收到任何非Initialization消息或等待超时时，都会转向Non-Existent状态。</p>
<p>▫OpenSent 状态：此状态为主动方发送Initialization消息后的状态，在此状态等待被动方回答Initialization消息和KeepAlive消息，如果收到的Initialization消息中的参数可以接受则转向OpenRec状态，如果参数不能接受或Initialization消息超时则断开TCP连接转向Non-Existent状态。</p>
<p>▫OpenRec状态：在此状态不管主动方还是被动方都是发出KeepAlive后的状态，在等待对方回应KeepAlive，只要收到KeepAlive消息就转向Operational状态；如果收到其它消息或KeepAlive超时则转向Non-Existent状态。</p>
<p>▫Operational状态：该状态是LDP Session成功建立的标志。在此状态下可以发送和接收所有其它的LDP消息。在此状态如果KeepAlive超时或收到致命错误的Notification消息（Shutdown消息）或者自己主动发送Shutdown消息主动结束会话，都会转向Non-Existent状态。</p>
<p>•LDP状态切换信息可以通过指令<strong>debug</strong> <strong>mpls</strong> <strong>ldp</strong> <strong>session</strong>看到。</p>
</blockquote>
<h3 id="LDP会话建立-发现阶段与TCP连接建立"><a href="#LDP会话建立-发现阶段与TCP连接建立" class="headerlink" title="LDP会话建立 - 发现阶段与TCP连接建立"></a>LDP会话建立 - 发现阶段与TCP连接建立</h3><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/7.png"></p>
<blockquote>
<p>•除了基本发现机制外，可以通过拓展发现机制发现非直连的远端邻接体，该内容不属于课程的重点，详细内容可以查阅RFC5036相关内容。</p>
<p>•LDP的传输地址用于与邻居建立TCP连接。</p>
<ul>
<li>两台LSR之间在建立LDP会话之前，需要先建立TCP连接，以便进行LDP协议报文的交换。</li>
<li>设备的传输地址被包含在LDP Hello报文中，LSR通过Hello报文知晓邻居的传输地址。</li>
<li>在使用Hello报文发现邻居并且知道了对方的传输地址后，邻居之间就会开始尝试TCP三次握手（基于传输地址），并且交互LDP的初始化报文、标签映射报文等，这些报文都使用双方的传输地址作为源、目的IP地址。</li>
<li>LSR必须拥有到达邻居的传输地址的路由。</li>
<li>缺省情况下，公网的LDP传输地址等于设备的LSR ID，私网的传输地址等于接口的主IP地址。 </li>
<li>在接口视图下，使用<strong>mpls</strong> <strong>ldp</strong> <strong>transport-address</strong>命令，可以修改传输地址。</li>
</ul>
</blockquote>
<h3 id="LDP会话建立-会话建立与保持"><a href="#LDP会话建立-会话建立与保持" class="headerlink" title="LDP会话建立 - 会话建立与保持"></a>LDP会话建立 - 会话建立与保持</h3><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/8.png"></p>
<h3 id="LDP邻居状态"><a href="#LDP邻居状态" class="headerlink" title="LDP邻居状态"></a>LDP邻居状态</h3><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/9.png"></p>
<h3 id="LDP会话状态"><a href="#LDP会话状态" class="headerlink" title="LDP会话状态"></a>LDP会话状态</h3><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/10.png"></p>
<blockquote>
<p>•LDP会话的状态：</p>
<p>▫NonExistent：表示LDP会话的最初状态。在此状态双方互相发送Hello消息，在收到TCP连接建立成功事件的触发后变为Initialized状态。 </p>
<p>▫Initialized：表示LDP会话处于初始化状态。</p>
<p>▫Open Sent：表示LDP会话进入初始化状态后，主动方给被动方发送了Initialized消息，并等待对方的回应。</p>
<p>▫Open Recv：表示LDP会话进入初始化状态后，当双方都收到了对方发送的KeepAlive消息后，LDP会话进入Operational状态。 </p>
<p>▫Operational：表示LDP会话建立成功。</p>
</blockquote>
<h2 id="LDP标签分发"><a href="#LDP标签分发" class="headerlink" title="LDP标签分发"></a>LDP标签分发</h2><h3 id="标签的发布和管理"><a href="#标签的发布和管理" class="headerlink" title="标签的发布和管理"></a>标签的发布和管理</h3><p>•在MPLS网络中，下游LSR决定标签和FEC的绑定关系，并将这种绑定关系发布给上游LSR。</p>
<p>•LDP通过发送标签请求和标签映射消息，在LDP对等体之间通告FEC和标签的绑定关系来建立LSP</p>
<p>•标签的发布和管理由标签发布方式、标签分配控制方式和标签保持方式来决定。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/11.png"></p>
<h3 id="上游与下游"><a href="#上游与下游" class="headerlink" title="上游与下游"></a>上游与下游</h3><p>•MPLS根据数据的转发方向确定上、下游关系。标签报文从上游LSR发出，被下游LSR接收并处理。</p>
<p>•如图所示，对于到达192.168.3.0/24的LSP而言，R3是R2的下游LSR，R1是R2的上游LSR。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/12.png"></p>
<h3 id="标签发布方式-DU模式"><a href="#标签发布方式-DU模式" class="headerlink" title="标签发布方式 - DU模式"></a>标签发布方式 - DU模式</h3><p>•DU模式</p>
<ul>
<li><p>对于一个特定的FEC，LSR无需从上游获得标签请求消息即进行标签分配与分发。</p>
</li>
<li><p>LSR会主动将自己为FEC捆绑的标签通告给上游邻居，无需邻居先发起请求再通告。</p>
</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/13.png"></p>
<blockquote>
<p>•标签分配：LSR从本地标签空间中取出一个标签与FEC绑定。</p>
<p>•标签分发：LSR将标签与FEC的绑定关系通知给上游LSR。</p>
<p>•标签发布方式为DU时，系统默认支持LDP为所有对等体分标签，即每个节点都可以向所有的对等体发布标签映射关系，不再区分上下游关系。因为在只给上游对等体分标签情况下，发送标签映射消息的时候，要根据路由信息对会话的上下游关系进行确认。</p>
</blockquote>
<h3 id="标签发布方式-DoD模式"><a href="#标签发布方式-DoD模式" class="headerlink" title="标签发布方式 - DoD模式"></a>标签发布方式 - DoD模式</h3><p>•DoD模式</p>
<p>​    ▫对于一个特定的FEC，LSR获得标签请求消息之后才进行标签分配与分发。</p>
<p>​    ▫一般情况下，对特定FEC的访问需求会触发标签请求消息。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/14.png"></p>
<blockquote>
<p>•只有上游邻居向自己请求标签映射时，LSR才会通告标签映射给该邻居</p>
</blockquote>
<h3 id="标签分配控制方式-独立模式"><a href="#标签分配控制方式-独立模式" class="headerlink" title="标签分配控制方式 - 独立模式"></a>标签分配控制方式 - 独立模式</h3><p>独立（Independent）模式</p>
<p>▫本地LSR可以自主地分配一个标签绑定到某个FEC，并通告给上游LSR，而无需等待下游的标签。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/15.png"></p>
<blockquote>
<p>•标签分配控制方式需要与标签发布方式结合使用：</p>
<ul>
<li><p>在使用DU作为标签分发方式的情况下，如图所示，R2和R3对192.168.4.0/24这条FEC，可以在上游LSR无请求，且自身没有收到下游LSR的标签绑定信息的情况下，主动向上游LSR通告标签绑定信息。</p>
</li>
<li><p>采用DoD作为标签发布方式时，如图所示，R2和R3对192.168.4.0/24这条FEC，只要收到上游LSR的标签请求消息，可以在自身没有收到下游LSR的标签绑定信息的情况下，向上游LSR通告标签绑定信息。</p>
</li>
</ul>
</blockquote>
<h3 id="标签分配控制方式-有序模式"><a href="#标签分配控制方式-有序模式" class="headerlink" title="标签分配控制方式 - 有序模式"></a>标签分配控制方式 - 有序模式</h3><p>•有序（Ordered）模式</p>
<p>▫对于LSR上某个FEC的标签映射，只有当该LSR已经具有此FEC下一跳的标签映射消息、或者该LSR就是此FEC的出节点时，该LSR才可以向上游发送此FEC的标签映射。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/16.png"></p>
<blockquote>
<p>•当标签控制方式为Ordered，只有当LSR收到特定FEC下一跳发送的特定FEC标签映射消息或者LSR是LSP的出口节点时，LSR才可以向上游发送标签映射消息。</p>
<ul>
<li><p>当标签分发方式为DU时，如图所示，对于192.168.4.0/24这条FEC，不论上游LSR是否有请求，必须收到下游LSR对此FEC的标签绑定信息才向上游LSR发布标签绑定信息，所以必须由Egress LSR，也就是R4作为LSP建立的“起点”。</p>
</li>
<li><p>当标签发布方式采用DoD时，如图所示，对于192.168.4.0/24这条FEC，只有收到上游LSR请求的请求，且自身已经收到下游LSR的标签绑定信息的情况下，才向上游LSR通告标签绑定信息。因此，必须由Ingress LSR（R1）发起请求，逐跳请求到Egress LSR（R4），最终由R4开始，向上游建立LSP。</p>
</li>
</ul>
</blockquote>
<h3 id="标签保留-自由模式"><a href="#标签保留-自由模式" class="headerlink" title="标签保留 - 自由模式"></a>标签保留 - 自由模式</h3><p>自由（Liberal）模式</p>
<p>▫LSR收到的标签映射可能来自下一跳，也可能来自非下一跳。</p>
<p>▫对于从邻居LSR收到的标签映射，无论邻居LSR是不是自己的下一跳都保留。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/17.png"></p>
<blockquote>
<p>•当基于IP网络部署MPLS时，LSR根据IP路由表判断接收到的标签映射是否来自下一跳。</p>
<p>•Liberal方式的最大优点在于路由发生变化时能够快速建立新的LSP进行数据转发，因为Liberal方式保留了所有的标签。缺点是需要分发和维护不必要的标签映射。</p>
<ul>
<li><p>DU标签分发方式下，如果采用Liberal保持方式，则R3保留所有LDP邻居 R2和R5发来的关于192.168.1.0/24这个FEC的标签，无论该R2和R5是否是IP路由表中到达192.168.1.0/24的下一跳。</p>
</li>
<li><p>DoD标签分发方式下，如果采用Liberal保持方式， LSR会向所有LDP邻居请求标签。但通常来说，DoD分发方式都会和Conservative保持方式搭配使用。</p>
</li>
</ul>
</blockquote>
<h3 id="标签保留-保守模式"><a href="#标签保留-保守模式" class="headerlink" title="标签保留 - 保守模式"></a>标签保留 - 保守模式</h3><p>•保守（Conservative）模式</p>
<p>▫对于从邻居LSR收到的标签映射，只有当邻居LSR是自己的下一跳时才保留。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/18.png"></p>
<blockquote>
<p>•Conservative方式的优点在于只需保留和维护用于转发数据的标签，以达到节约标签的目的。</p>
<ul>
<li>当使用DU标签分发方式时，LSR可能从多个LDP邻居收到到同一网段的标签映射消息，如图中R3会分别从R2和R5收到网段192.168.1.0/24的标签映射消息。如果采用Conservative保持方式，则R3只保留下一跳R2发来的标签，丢弃非下一跳R5发来的标签。</li>
<li>当使用DoD标签分发方式时， LSR根据路由信息只向它的下一跳请求标签。</li>
</ul>
<p>•当网络拓扑变化引起下一跳邻居改变时：</p>
<ul>
<li>使用自由标签保持方式，LSR可以直接利用原来非下一跳邻居发来的标签，迅速重建LSP，但需要更多的内存和标签空间。</li>
<li>使用保守标签保持方式，LSR只保留来自下一跳邻居的标签，节省了内存和标签空间，但LSP的重建会比较慢。</li>
<li>保守标签保持方式通常与DoD方式一起，用于标签空间有限的LSR。</li>
</ul>
</blockquote>
<h3 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性"></a>PHP特性</h3><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/19.png"></p>
<p>•PHP（Penultimate Hop Popping，次末跳弹出），如果激活了PHP特性，那么egress节点在为本地路由分配标签的时候，会分配一个特殊标签—<strong>3</strong>，该标签被称为隐式空标签（Implicit NULL Label）。当LSR转发一个标签报文时，如果发现对应的出标签值为3，则LSR会将栈顶标签弹出，并将里面所封装的数据转发给下游LSR。</p>
<blockquote>
<p>•在标签发布时，R3为作为192.168.3.0/24这条FEC的Egress LSR。分配标签时，R3为该FEC分配了标签3，并将该标签绑定信息通告给R2。</p>
<p>•在数据转发时，R2作为到达192.168.3.0的次末跳（倒数第二跳），发现出标签值为3，于是将标签头部弹出，将IP报文转发给R3，而R3则仅需执行一次查询操作（查询FIB表）即可获得相应的转发信息，转发效率得到了提升。</p>
</blockquote>
<h3 id="隐式空标签与显式空标签-1"><a href="#隐式空标签与显式空标签-1" class="headerlink" title="隐式空标签与显式空标签 (1)"></a>隐式空标签与显式空标签 (1)</h3><p>•缺省情况下，Egress节点向倒数第二跳分配隐式空标签（implicit-null），即特殊标签3。</p>
<p>•但在部署QoS的场景下，标签被弹出后，其中的优先级也会一并丢失。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/20.png"></p>
<h3 id="隐式空标签与显式空标签-2"><a href="#隐式空标签与显式空标签-2" class="headerlink" title="隐式空标签与显式空标签 (2)"></a>隐式空标签与显式空标签 (2)</h3><p>•显式空标签机制，Egress节点向倒数第二跳分配特殊标签0。</p>
<p>•R3在转发标签报文时，若出标签封装为0，则不会将标签头部弹出，标签头部中的QoS信息得以保存。R4在收到带0标签的报文的时候，直接弹出标签，不用去查找ILM表项。</p>
<p>•缺省情况下，Egress分配的是隐式空标签，通过label advertise explicit-null使能Egress节点向倒数第二跳分配显式空标签。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/21.png"></p>
<blockquote>
<p>•在MPLS视图下，执行命令<strong>label advertise</strong> { <strong>explicit-null</strong> | <strong>implicit-null</strong> | <strong>non-null</strong> }，配置向倒数第二跳分配的标签。</p>
<p>•根据参数的不同，可以配置Egress向倒数第二跳分配不同的标签。</p>
<p>▫缺省情况下，使用的是<strong>implicit-null</strong>，Egress向倒数第二跳节点分配隐式空标签，值为3。</p>
<p>▫如果配置的是<strong>explicit-null</strong>，Egress节点向倒数第二跳分配显式空标签，值为0。当需要支持MPLS QoS属性时，可以选用<strong>explicit-null</strong>。</p>
<p>▫如果配置的是<strong>non-null</strong>，Egress向倒数第二跳正常分配标签，即分配的标签值不小于16。</p>
</blockquote>
<h2 id="LDP工作过程详解"><a href="#LDP工作过程详解" class="headerlink" title="LDP工作过程详解"></a>LDP工作过程详解</h2><h3 id="组网介绍"><a href="#组网介绍" class="headerlink" title="组网介绍"></a>组网介绍</h3><p>•网络中已经部署OSPF路由协议且各设备之间能够正常学习到对方的路由信息。</p>
<p>•已在各设备及相应接口上激活MPLS及LDP，且在相邻的设备之间已正常建立本地LDP会话。</p>
<p>•所有LSR均采用DU + Independent +Liberal方式。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/22.png"></p>
<blockquote>
<p>•华为设备目前缺省模式为下游自主方式（DU）＋ 有序标签分配控制方式（Ordered）＋ 自由标签保持方式（Liberal）。</p>
<p>•对于从R1进入，到达192.168.4.0/24的数据，R1为Ingress LSR，R4为Egress LSR。</p>
</blockquote>
<h3 id="标签分发-Egress-LSR"><a href="#标签分发-Egress-LSR" class="headerlink" title="标签分发 - Egress LSR"></a>标签分发 - Egress LSR</h3><p>•R4直连网段192.168.4.0/24，R4将主动为到达该网段的路由分配标签，如1041，并主动通过LDP协议报文将标签映射通告给LDP对等体R2和R3。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/23.png"></p>
<blockquote>
<p>•注：缺省情况下，根据32位的主机IP路由触发LDP建立LSP。可以通过手工配置触发非32位路由的LSP建立。</p>
</blockquote>
<h3 id="标签分发-Transit-LSR"><a href="#标签分发-Transit-LSR" class="headerlink" title="标签分发 - Transit LSR"></a>标签分发 - Transit LSR</h3><p>•以R2为例，在其路由表中，192.168.4.0/24路由的下一跳为R4，当它从R4收到关于192.168.4.0/24的标签映射通告时，由于该通告来自下游LDP邻居，因此这将触发它自己为该路由分配标签1021，并将标签映射通告给LDP邻居（如R1）。R3同理。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/24.png"></p>
<h3 id="标签分发-Ingress-LSR"><a href="#标签分发-Ingress-LSR" class="headerlink" title="标签分发 - Ingress LSR"></a>标签分发 - Ingress LSR</h3><p>•R1收到LDP邻居R2及R3通告过来的关于192.168.4.0/24路由的标签映射后，将这两个标签都<strong>存储</strong>起来，但是由于在自己的路由表中，到达192.168.4.0/24的下一跳是R2，因此当前它只会<strong>使用</strong>R2所通告的标签1021。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/25.png"></p>
<blockquote>
<p>•注：当R2发生故障时，OSPF路由将会重新收敛，此时R1的路由表中192.168.4.0/24路由的下一跳将会切换至R3，此时R1将启用R3所通告的、关于192.168.4.0/24的标签。</p>
</blockquote>
<h3 id="标签转发-Ingress-LSR"><a href="#标签转发-Ingress-LSR" class="headerlink" title="标签转发 - Ingress LSR"></a>标签转发 - Ingress LSR</h3><p>R1作为Ingress LSR，需要对接收的IP报文执行Push操作压入标签，并进行标签转发。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/26.png"></p>
<blockquote>
<p>•当R1收到发往192.168.4.1的IP报文时，首先在其FIB表中查询该目的IP地址，它发现所匹配的表项的Tunnel ID为非0，因此继续在NHLFE中查询该Tunnel ID，然后意识到需要将对该IP报文压入标签并进行标签转发，出接口为GE0/0/0、下一跳为R2、出站标签为1021，于是为报文插入标签头部并转发出去。</p>
</blockquote>
<h3 id="标签转发-Transit-LSR"><a href="#标签转发-Transit-LSR" class="headerlink" title="标签转发 - Transit LSR"></a>标签转发 - Transit LSR</h3><p>•R2作为Transit LSR，需要对接收的IP报文执行Swap操作交换标签，并进行标签转发。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/27.png"></p>
<blockquote>
<p>•当R2收到携带1021标签的标签报文时，查询ILM，根据ILM对应到NHLFE中的表项。于是，R2对该标签报文通过swap操作将标签更换为1041，并从相应的接口转发出去。</p>
</blockquote>
<h3 id="标签转发-Egress-LSR"><a href="#标签转发-Egress-LSR" class="headerlink" title="标签转发 - Egress LSR"></a>标签转发 - Egress LSR</h3><p>R4作为Egress LSR，需要对接收的IP报文执行Pop操作交换标签，并进行IP转发。</p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/28.png"></p>
<blockquote>
<p>•当R4收到携带1041标签的标签报文时，查询ILM，根据ILM查询到操作为Pop。于是，R4对该标签报文通过Pop操作将最外层标签剥离，此时该报文已经变成了标准IP报文，R4将对该IP报文执行标准的IP转发流程。</p>
<p>•R4在转发该报文时分别查询了LFIB和FIB表，作为最后Egress LSR，其存在转发效率提升的可能性，怎么做？</p>
</blockquote>
<h3 id="在MPLS中，运行LDP协议的LSR的操作小结"><a href="#在MPLS中，运行LDP协议的LSR的操作小结" class="headerlink" title="在MPLS中，运行LDP协议的LSR的操作小结"></a>在MPLS中，运行LDP协议的LSR的操作小结</h3><p>•LSR首先通过运行IGP协议（例如OSPF、IS-IS等）来构建路由表、FIB表；</p>
<p>•LDP根据相应的模式，为路由表中的路由前缀（FEC）分配标签；</p>
<p>•LDP根据相应的模式，将自己为路由前缀分配的标签，通过LDP标签映射报文通告给LDP邻居；</p>
<p>•LSR将自己为路由前缀分配的标签，以及LDP邻居为该路由前缀通告的标签存储起来，并与出接口、下一跳地址等信息形成关联（标签转发表项）；</p>
<p>•当LSR转发到达目的网络的标签报文时，所使用的出站标签总是下游LDP邻居所通告的标签，此处所指的下游邻居，是设备的路由表中到达该目的网络的下一跳设备。</p>
<h1 id="3-LDP基础配置"><a href="#3-LDP基础配置" class="headerlink" title="3.LDP基础配置"></a>3.LDP基础配置</h1><h2 id="LDP基本配置命令-1"><a href="#LDP基本配置命令-1" class="headerlink" title="LDP基本配置命令 (1)"></a>LDP基本配置命令 (1)</h2><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/29.png"></p>
<h2 id="LDP基本配置命令-2"><a href="#LDP基本配置命令-2" class="headerlink" title="LDP基本配置命令 (2)"></a><strong>LDP基本配置命令 (2)</strong></h2><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/30.png"></p>
<blockquote>
<p>•BGP路由也可以触发LDP LSP的建立，但此部分内容不在本课程的讨论范围内。</p>
</blockquote>
<h2 id="LDP基本配置命令-3"><a href="#LDP基本配置命令-3" class="headerlink" title="LDP基本配置命令 (3)"></a>LDP基本配置命令 (3)</h2><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/31.png"></p>
<h2 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h2><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/32.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/33.png"></p>
<p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/34.png"></p>
<h2 id="检查配置-查看LSP"><a href="#检查配置-查看LSP" class="headerlink" title="检查配置 - 查看LSP"></a>检查配置 - 查看LSP</h2><p><img src="/2021/06/23/IPadv-MPLSLDP%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/35.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选）以下哪条命令用于查看已经为特定FEC分配的标签？（    ）</p>
<p>A、display mpls ldp</p>
<p>B、display mpls ldp interface</p>
<p><strong>C、display mpls lsp</strong></p>
<p>D、display mpls ldp session</p>
<p>2.（单选）华为设备默认的标签发布方式、标签分配控制方式和标签保持方式的组合是（   ）</p>
<p>A、DU + Independent + Conservative</p>
<p><strong>B、DU + Ordered+ Liberal</strong></p>
<p>C、DoD + Independent+ Liberal</p>
<p>D、DoD + Ordered + Conservative</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•MPLS体系有多种标签分配协议，LDP标签分配协议是这些协议中使用较广的一种。</p>
<p>•LDP是LSR之间协商标签含义的过程。LDP协议使用发现、会话、通告、通知四类报文进行会话的建立和标签的分发。</p>
<p>•LDP通过标签发布方式、标签分配控制方式和标签保持方式来决定标签的发布和管理。华为数通产品默认的方式为：下游自主标签发布方式+有序标签分配控制方式+自由标签保持方式。</p>
<p>•利用LDP可以实现将网络层的路由信息直接映射到标签信息，进而建立起标签交换路径（LSP）。LSR之间将依据本地转发表中对应于一个特定FEC的入标签、下一跳节点、出标签等信息连接在一起，从而形成跨越整个MPLS域的标签交换路径。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
