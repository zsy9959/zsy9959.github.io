<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/" itemprop="url">IE-OSPF双栈原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-04T14:54:19+08:00">
                2021-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>LSA头部信息，除Hello报文外，其它的OSPF报文都携带LSA信息。</p>
<ul>
<li>LS age：此字段表示LSA已经生存的时间，单位是秒。</li>
<li>Option：该字段指出了部分OSPF域中LSA能够支持的可选性能。</li>
<li>LS type：此字段标识了LSA的格式和功能。常用的LSA类型有五种。</li>
<li>Link State ID：根据LSA的不用而不同。</li>
<li>Advertising Router：始发LSA的路由器的ID。</li>
<li>Sequence Number：当LSA每次新的实例产生时，这个序列号就会增加。这个更新可以帮助其他路由器识别最新的LSA实例。</li>
<li>Checksum：关于LSA的全部信息的校验和。因为Age字段，所以校验和会随着老化时间的增大而每次都需要重新进行计算。</li>
<li>Length：是一个包含LSA头部在内的LSA的长度。</li>
</ul>
</li>
<li><p>Router-LSA，Router-LSA必须描述始发路由器所有接口或链路。</p>
<ul>
<li>Link State ID：是指始发路由器的路由器ID。</li>
<li>Flag：<ul>
<li>V：设置为1时，说明始发路由器是一条或者多条具有完全邻接关系的虚链路的一个端点。</li>
<li>E：当始发路由器是一个ASBR路由器时，该为置为1。</li>
<li>B：当始发路由器是一个ABR路由器时，该为置为1。</li>
</ul>
</li>
<li>Number of links：表明一个LSA所描述的路由器链路数量。</li>
<li>Link Type：<ul>
<li>值为1表示为点到点网络，常见的PPP链路需要使用点到点网络描述。</li>
<li>值为2表示连接一个transit网络，有至少两台路由器的广播型网段或NBMA网段就是一种Transit网段。</li>
<li>值为3表示连接stubnet网络，一般该网络上不存在邻居关系，如只有一个出口的以太网或回环接口。</li>
<li>值为4表示虚链路。</li>
</ul>
</li>
<li>Link ID：<ul>
<li>Link Type为1时该值表示邻居路由器的路由器ID。</li>
<li>Link Type为2时该值表示DR路由器的接口的IP地址。</li>
<li>Link Type为3时该值表示IP网络或子网地址。</li>
<li>Link Type为4时该值表示邻居路由器的路由器ID。</li>
</ul>
</li>
<li>Link Data：<ul>
<li>Link Type为1时该值表示和网络相连的始发路由器接口的IP地址。</li>
<li>Link Type为2时该值表示和网络相连的始发路由器接口的IP地址。</li>
<li>Link Type为3时该值表示网络的子网掩码。</li>
<li>Link Type为4时该值表示始发路由器的虚链路接口的IP地址。</li>
</ul>
</li>
<li>ToS，暂不支持。</li>
<li>Metric：是指一条链路或接口的代价。</li>
</ul>
</li>
<li><p>Network-LSA</p>
<ul>
<li>Link State ID：是指DR路由器的接口地址。</li>
<li>Network Mask：指定这个网络上使用的地址或者子网的掩码。</li>
<li>Attached router：列出该多路访问网络上与DR形成完全邻接关系且包括DR本身的所有路由器的路由器ID。</li>
</ul>
</li>
<li><p>Network-summary-LSA和ASBR-summary-LSA</p>
<ul>
<li>Link State ID：对于3类LSA来说，表示所通告的网络或子网的IP地址。对于4类LSA来说表示所通告的ASBR路由器的路由器ID。</li>
<li>Network Mask：对于3类LSA来说，表示所通告的网络的子网掩码。对于4类LSA来说，该字段没有实际意义，一般置为0.0.0.0。</li>
<li>Metric：始发路由器到目的地址的路由的代价。</li>
</ul>
</li>
<li><p>AS-external-LSA</p>
<ul>
<li>Link State ID：表示所通告的网络或子网的IP地址。</li>
<li>Network Mask:指所通告的网络的子网掩码。</li>
<li>E：用来指定这条路由使用的外部度量的类型。如果该E bit设置为1,那么度量类型就是E2;如果该E bit设置为0,那么度量类型就是E1。</li>
<li>Metric：指路由的代价。由ASBR设定。</li>
<li>Forwarding Address：是指到达所通告的目的地的数据包应该被转发到的地址。如果转发地址是0.0.0.0,那么数据包将被转发到始发ASBR上。</li>
<li>External Route Tag:标记外部路由。</li>
</ul>
</li>
<li><p>NSSA LSA</p>
<ul>
<li>Forwarding Address：如果所引入外部路由的下一跳在OSPF路由域内，则Forwarding Address直接设置为所引入外部路由的下一跳；如果所引入外部路由的下一跳不在OSPF路由域内，则Forwarding Address设置为该ASBR上某个OSPF路由域内的Stub网段（例如Loopback0接口）的接口IP地址，有多个Stub网段时选IP地址最大者。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/7.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li>Option字段解释：<ul>
<li>DN：用来避免在MPLS VPN中出现环路。当PE向CE发送3类、5类和7类LSA时需要设置DN位，其他PE路由器从CE接收到该LSA时，不能够在它的OSPF路由计算中使用该LSA。</li>
<li>O：该字段指出始发路由器支持Opaque LSA（类型9、类型10和类型11）。</li>
<li>DC位：当始发路由器支持按需链路上的OSPF的能力时，该位将被设置。</li>
<li>EA：当始发路由器具有接收和转发External-Attributes-LSA（type8 LSA）的能力时，该位被置位。</li>
<li>N位：只用在Hello数据包中。N=1表明路由器支持7类LSA。N=0表明该路由器将不接收和发送NSSA LSA。</li>
<li>P位：只用在NSSA LSA。该位将告诉NSSA区域的ABR路由器将7类LSA转换为5类LSA。</li>
<li>MC位：当始发路由器支持转发组播数据包的能力时，该位将被置位。</li>
<li>E位：当始发路由器具有接收AS-external-LSA（type5 LSA）的能力时，该位被置位。在所有5类LSA和始发于骨干区域以及非末节区域的LSA中，该位置为1。而始发于末节区域的LSA中，该位置为0。如果Hello报文中该位被置位则表明该接口具有接收和发送5类LSA的能力。</li>
<li>MT位：表示始发路由器支持多拓扑OSPF。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li><p>快速收敛：</p>
<ul>
<li>I-SPF改进了这个算法，除了第一次计算时需要计算全部节点外，每次只计算受到影响的节点，而最后生成的最短路径树SPT与原来的算法所计算的结果相同，大大降低了CPU的占用率，提高了网络收敛速度。</li>
<li>PRC的原理与I-SPF相同，都是只对发生变化的路由进行重新计算。不同的是，PRC不需要计算节点路径，而是根据I-SPF算出来的SPT来更新路由。在路由计算中，叶子代表路由，节点则代表路由器。SPT变化和叶子变化都会引起路由信息的变化，但两者不存在依赖关系，PRC根据SPT或叶子的不同情况进行相应的处理：<ul>
<li>SPT变化，PRC处理变化节点上的所有叶子的路由信息。</li>
<li>SPT没有变化，PRC不会处理节点的路由信息。</li>
<li>叶子变化，PRC处理变化的叶子的路由信息。</li>
<li>叶子没有变化，PRC不会处理叶子的路由信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>智能定时器，OSPF智能定时器分别对路由计算、LSA的产生、LSA的接收进行控制，加速网络收敛。OSPF智能定时器可以通过以下两种方式来加速网络收敛：</p>
<ul>
<li><p>在频繁进行路由计算的网络中，OSPF智能定时器根据用户的配置和指数衰减技术动态调整两次路由计算的时间间隔，减少路由计算的次数，从而减少CPU的消耗，待网络拓扑稳定后再进行路由计算。</p>
</li>
<li><p>在不稳定网络中，当路由器由于拓扑的频繁变化需要产生或接收LSA时，OSPF智能定时器可以动态调整时间间隔，在时间间隔之内不产生LSA或对接受到的LSA不进行处理，从而减少整个网络无效LSA的产生和传播。</p>
</li>
<li><p>智能定时器对路径计算的作用：</p>
<ul>
<li><p>根据本地维护的链路状态数据库LSDB，运行OSPF协议的路由器通过SPF算法计算出以自己为根的最短路径树，并根据这一最短路径树决定到目的网络的下一跳。通过调节SPF的计算间隔，可以抑制网络频繁变化可能导致的占用过多带宽资源和路由器资源。</p>
</li>
<li><p>在特定组网环境下（例如对路由收敛时间要求较高的环境），可以指定以毫秒为单位的时间间隔，用来增加路由计算的频度，从而加快路由的收敛。</p>
</li>
<li><p>当OSPF的链路状态数据库（LSDB）发生改变时，需要重新计算最短路径。如果网络频繁变化，由于不断的计算最短路径，会占用大量系统资源，影响路由器的效率。通过配置智能定时器，设置合理的SPF计算的间隔时间，可以避免占用过多的路由器内存和带宽资源。</p>
</li>
<li><p>使能智能定时器后：</p>
<p>​    初次计算SPF的间隔时间由start-interval参数指定。</p>
<p>​    第n（n≥2）次计算SPF的间隔时间为hold-interval×2(n-1)。</p>
<p>当hold-interval×2(n-1)达到指定的最长间隔时间max-interval时，OSPF连续三次计算SPF的时间间隔都是最长间隔时间，之后，再次返回步骤1，按照初始间隔时间start-interval计算SPF。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>按优先级收敛：</p>
<ul>
<li>可以通过IP前缀列表等将特定路由过滤出来，通过对不同的路由配置不同的收敛优先级，达到重要的路由先收敛的目的，提高网络的可靠性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li><p>通过设置路由器上非缺省外部路由数量的上限，来避免数据库超限。OSPF网络中所有路由器都必须配置相同的上限值。这样，只要路由器上外部路由的数量达到该上限，路由器就进入Overflow状态，并同时启动超限状态定时器（默认超时时间为5秒），路由器在定时器超过5秒后自动退出超限状态。</p>
</li>
<li><p>OSPF Database Overflow过程：</p>
<ul>
<li>进入Overflow状态时，路由器删除所有自己产生的非缺省外部路由。</li>
<li>处于Overflow状态中时，路由器不产生非缺省外部路由；丢弃新收到的非缺省外部路由且不回复确认报文；当超限状态定时器超时，检查外部路由数量是否仍然超过上限，如果超限则重启定时器，如果没有则退出超限状态。</li>
<li>退出Overflow状态时，路由器删除超限状态定时器；产生非缺省外部路由；接收新收到的非缺省外部路由并回复确认报文；准备下一次进入超限状态。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/12.png"></p>
<blockquote>
<ul>
<li><p>OSPF 缺省路由通常应用于下面两种情况：</p>
<ul>
<li>由区域边界路由器（ABR）发布 Type3 缺省 Summary LSA，用来指导区域内设备进行区域之间报文的转发。</li>
<li>由自治系统边界路由器（ASBR）发布 Type5 外部缺省 ASE LSA，或者 Type7 外部缺省NSSA LSA，用来指导自治系统（AS）内设备进行自治系统外报文的转发。</li>
</ul>
</li>
<li><p>OSPF 缺省路由的发布原则如下：</p>
<ul>
<li>OSPF 路由器只有具有对外的出口时，才能够发布缺省路由 LSA。</li>
<li>如果 OSPF 路由器已经发布了缺省路由 LSA，那么不再学习其它路由器发布的相同类型缺省路由。即路由计算时不再计算其它路由器发布的相同类型的缺省路由 LSA，但数据库中存有对应 LSA。</li>
<li>外部缺省路由的发布如果要依赖于其它路由，那么被依赖的路由不能是本 OSPF 路由域内的路由，即不是本进程 OSPF 学习到的路由。因为外部缺省路由的作用是用于指导报文的域外转发，而本 OSPF 路由域的路由的下一跳都指向了域内，不能满足指导报文域外转发的要求。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li><p>OSPF 支持使用路由策略对路由信息进行过滤。缺省情况下， OSPF 不进行路由过滤。</p>
</li>
<li><p>OSPF 可以使用的路由策略包括 route-policy，filter，filter-policy，filter-lsa-out，访问控制列表（access-list），地址前缀列表（prefix-list）。 </p>
</li>
<li><p>OSPF 路由过滤可以应用于以下几个方面： </p>
<ul>
<li>路由引入的过滤：<ul>
<li>OSPF可以引入其它路由协议学习到的路由。在引入时可以通过配置路由策略来过滤路由，只引入满足条件的路由。</li>
<li>可以在OSPF 路由表中被发布出去</li>
</ul>
</li>
<li>3类LSA学习、发布的过滤：<ul>
<li>通过filter import、filter export命令在 ABR上对进入或离开本区域的3型LSA 进行过滤。该配置只在ABR上有效（只有ABR才能发布3型LSA）。 </li>
<li>5、7类LSA生成的过滤：</li>
<li>OSPF 引入外部路由后会生成5、7型LSA。可以通过filter-policy export来对5、7型LSA的生成进行过滤。该过滤规则只在 ASBR 上配置才有效。</li>
</ul>
</li>
</ul>
</li>
<li><p>接口视图下的LSA过滤。通过ospf filter-lsa-out命令， 匹配除Grace LSA外的所有LSA、3、5、7型LSA，并匹配ACL规定的路由前缀时，实现LSA的通告过滤。</p>
</li>
<li><p>路由计算的过滤：</p>
<ul>
<li>通过filter-policy import过滤规则，可以设置 OSPF对数据库中的区域内、区域间、外部LSA计算为路由条目时进行过滤。<br> 该过滤只作用于路由表项的添加与否，即只有通过过滤的路由才被添加到本地路由表中，产生该路由的LSA仍然会在OSPF自治系统内扩散。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/14.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>OSPF支持的网络类型有P2P网络、P2MP网络、NBMA网络和广播网络；IS-IS仅支持P2P网络和广播网络。</li>
<li>OSPF工作在IP之上，协议号为89。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/16.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>OSPF建立邻居需要检查Hello报文中的掩码、认证、hello/dead时间间隔、区域等信息。而IS-IS形成邻居关系条件比较宽松。</li>
<li>OSPF P2P链路建立邻居关系需要三次握手。IS-IS则不要三次握手，但是华为设备缺省情况下使能IS-IS P2P网络三次握手功能，以保证邻居建立的可靠性。</li>
<li>IS-IS邻居关系分为层1和层2。</li>
<li>OSPF依据优先级和router-id选举DR/BDR，且选举结束后，不可抢占。在OSPF中，所有DRother与DR/BDR形成完全邻接关系，DRother间形成2-way即不完全邻接关系。OSPF中，如果优先级为0，则表示该路由器不参与DR/BDR选举。</li>
<li>IS-IS选举DIS依据优先级和MAC地址，可以抢占。在IS-IS中，所有路由器均形成邻接关系。IS-IS中，如果优先级为0，则表示该路由器也会参与DIS选举，只是优先级比较低。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>IS-IS LSP种类较少，但是扩展性较强，主要通过LSP携带的TLV字段进行功能扩展。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>OSPF开销是基于带宽的；IS-IS理论上开销类型分为四种，包括缺省开销、时延开销、代价开销、差错开销，但在实现上只采用缺省开销。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/19.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/21.png"></p>
<blockquote>
<p>默认情况下，OSPF不检查DD报文中的MTU。</p>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/25.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/27.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/28.png"></p>
<blockquote>
<ul>
<li>IPv6中重点强调了一个“链路（link）”的概念，在IPv6中，一个链路上可以分配多个IP子网，也就是IPv6前缀。和IPv4中不同的是，同一个链路上的两个节点即使不具有相同的IPv6前缀，也可以直接通过这个链路通信。这一点极大地改变了OSPF的行为。</li>
<li>OSPFv3是基于链路运行的，而不是以前的基于IP子网的运行。在OSPFv3中我们更多的是使用“链路”和“前缀”这两个术语。但这两个概念是分离的，没有必然的对应关系。同一链路上的两个节点不必具有相同的前缀。所以在讨论路由协议时，OSPFv2的术语“网络”和“子网”在这里应该用“链路”替换掉。同样，一个OSPF接口现在是连接到一个链路上，而不再是一个IP子网上了。OSPF协议分组的接收以及Hello分组和LSA的格式也因此做出了相应的修改。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/29.png"></p>
<blockquote>
<ul>
<li><p>一个路由器可以学习到这个链路上相连的所有其它路由器的链路本地地址，并使用这些链路本地地址作为下一跳来转发报文。</p>
</li>
<li><p>IPv6在RFC2373中定义了链路本地（link-local）地址用于一个单一链路上，其目的是完成邻居发现（neighbor discovery）和自动配置（auto-configuration）等功能。IPv6路由器不转发源地址为link-local类型的分组。Link-local单播地址范围为IPv6地址范围FE80/10。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/30.png"></p>
<blockquote>
<ul>
<li><p>Router A、 Router B、 Router C和Router D连接到同一个广播网上，它们共享同一条链路且都能建立邻居关系，通过在Router A的Eth1/1、 Router B的Eth1/1、Router C的Eth1/2上指定实例1、在Router A的Eth1/1、 Router B的Eth1/1、 RouterD的Eth1/3上指定实例2，实现了Router A、 Router B和Router C可以建立邻居关系， Router A、 Router B和Router D可以建立邻居关系。</p>
</li>
<li><p>这是通过在OSPFv3报文头中添加Instance ID字段来实现的。如果接口配置的Instance ID与接收的OSPF v3报文的Instance ID不匹配，则丢弃该报文，从而无法建立起邻居关系。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/31.png"></p>
<blockquote>
<ul>
<li>OSPFv3协议一般自身不再提供认证功能，而是通过使用IPv6提供的安全机制来保证自身报文的合法性。所以， OSPFv2报文中的认证字段，在OSPFv3报文头中被取消。 </li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/33.png"></p>
<blockquote>
<ul>
<li><p>与OSPFv2一样， OSPFv3的五种报文都有同样的报文头，只是报文中的字段有些不同。</p>
</li>
<li><p>OSPFv3的LSU和LSAck报文与OSPFv2相比没有什么变化，但OSPFv3的报文头、 Hello、 DD以及LSR报文中的字段与OSPFv2略有不同，报文的改变包括以下几点：</p>
<ul>
<li>版本号从 2 升级到 3。</li>
<li>报文头的不同：与 OSPFv2 报文头相比， OSPFv3 报文头长度只有 16 字节，去掉了认证字段但加了 Instance ID 字段。 Instance ID 字段用来支持在同一条链路上运行多个实例，且只在链路本地范围内有效，如果路由器接收到的 Hello 报文的 Instance ID 与当前接口配置的 Instance ID 不同，将无法建立邻居关系。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li><p>Hello 报文的不同：与 OSPFv2 Hello 报文相比， OSPFv3 Hello 报文去掉了网络掩码字段，增加了 Interface ID 字， 用来标识发送该 Hello 报文的接口ID。 </p>
</li>
<li><p>Instance ID:  4字节。报文发送者的发送接口标识，仅用来区分同一路由器上的不同接口，不包含地址信息。</p>
</li>
<li><p>Rtr Pri:  1字节。路由器优先级，优先级高者成为DR。</p>
</li>
<li><p>Options: 3字节。 OSPFv3中将Options字段扩展为24位。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/35.png"></p>
<blockquote>
<ul>
<li><p>在OSPFv2中， Option字段出现在每一个Hello报文、 DD报文以及每一个LSA中。</p>
</li>
<li><p>在 OSPFv3中， Option字段只在 Hello报文、 DD报文、 Router LSA、 Network LSA、 Inter Area Router LSA以及Link LSA中出现。 </p>
</li>
<li><p>从上图可以看出，与OSPFv2相比， OSPFv3的Option字段增加了R比特、 V比特。</p>
<ul>
<li>R 比特：用来标识设备是否是具备转发能力的路由器。如果 R 比特置 0，宣告该节点的路由信息将不会参加路由计算，如果当前设备是一个不想转发非本地地址的报文，可以将 R 比特置 0。</li>
<li>V6 比特：如果 V6 比特置 0，该路由器或链路也不会参加IPv6路由计算。</li>
<li>E: 如果为0，不支持AS-External-LSA洪泛；</li>
<li>MC: 与多播相关；</li>
<li>N: 是否在NSSA (Not So Stub Area)区域；</li>
<li>DC: 是否支持按需拨号。</li>
</ul>
</li>
<li><p>Options字段的各位的匹配情况会产生不同影响：</p>
<ul>
<li>阻止邻居的建立，例如Hello报文中的选项不匹配。</li>
<li>阻止LSA的洪泛，例如E-Bit，如果为0，不洪泛AS-External-LSA。</li>
<li>阻止LSA参加路由计算，例如V6-Bit，如果为0，该Router不参加IPv6路由计算。</li>
<li>Options字段使OSPF路由器能支持可选的能力，并且与其它路由器互相通告其能力。通过这种机制，具有不同能力的路由器可以在一个OSPF路由域中混合工作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>OSPFv2中的LS Type长度为8比特，指定LSA的类型； OSPFv3的LSA Type字段由OSPFv2的8比特扩充为16比特。<ul>
<li>U 位：描述了路由器收到一个类型未知的 LSA 时如何处理，取值为 0 表示把类型未知 LSA 当成具有链路本地范围的 LSA 一样处理，取值为 1 表示按照S2/S1 位标识的泛洪范围来处理。 </li>
<li>S2/S1 位：共同标识 LSA 的泛洪范围，取值 00 表示 LSA 只在产生该 LSA 的本地链路上泛洪；取值 01 表示 LSA 的泛洪范围为产生该 LSA 的路由器所在区域；取值 10 表示 LSA 将在整个自治系统内进行泛洪；取值 11 保留。</li>
<li>LSA Function Code： LSA 类型编码，描述 LSA 的类型。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/37.png"></p>
<blockquote>
<ul>
<li><p>在OSPFv2中，收到类型未知的LSA将直接丢弃。 </p>
</li>
<li><p>OSPFv3在LSA的LS Type字段中增加了一个U比特位来位标识对未知类型LSA的处理方式： </p>
<ul>
<li>如果 U 比特置 1，则对于未知类型的 LSA 按照 LSA 中的 LS Type 字段描述的泛洪范围进行泛洪；</li>
<li>如果 U 比特置 0，对于未知类型的 LSA 仅在链路范围内泛洪。</li>
</ul>
</li>
<li><p>LSA的泛洪范围已经被明确地定义在LSA的LS Type字段，目前，有三种LSA泛洪范围。 </p>
<ul>
<li>链路本地范围(Link-local Scope)。<ul>
<li>LSA 只在本地链路上泛洪，不会超出这个范围， Link-LSA(新增)。</li>
</ul>
</li>
<li>区域范围(Area Scope)。<ul>
<li> Router-LSA, Network-LSA, Inter-Area-Prefix-LSA, Inter-Area-Router-LSA, Intra-Area-Prefix-LSA(新增)都是区域范围泛洪的 LSA。 </li>
</ul>
</li>
<li>自治系统范围(AS Scope)。<ul>
<li>LSA 将被泛洪到整个路由域，AS-External-LSA。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/38.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/39.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/40.png"></p>
<blockquote>
<ul>
<li>OSPFv3新增了Link-LSA和Intra Area Prefix LSA。<ul>
<li>Router LSA 不再包含地址信息，使能 OSPFv3 的路由器为它所连接的每条链路产生单独的 Link-LSA，将当前接口的链路本地地址以及路由器在这条链路上的一系列 IPv6 地址信息向该链路上的所有其它路由器通告。</li>
<li>Router LSA 和 Network LSA 中不再包含路由信息，这两类 LSA 中所携带的路由信息由 Intra Area Prefix LSA 来描述，该类 LSA 用来公告一个或多个IPv6 地址前缀。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li><p>在OSPFv2中，使用“IP网段＋掩码”来表示前缀信息，而且两段信息在不同LSA中的位置还各不相同，结构很不清晰。在OSPFv3的LSA中，使用专门的三元组（Prefix-Length, PrefixOptions, Prefix）来表示前缀信息。由LSA公告的每个前缀都拥有一个自己的PrefixOptions 字段。</p>
</li>
<li><p>Prefix-Length</p>
<ul>
<li>1字节。前缀的bit位长度，对于缺省路由该字段取值为0。</li>
<li>PrefixOptions，1字节。前缀信息的选项，用来描述前缀的某些特殊属性字段，格式如下：</li>
<li>NU位：非单播位。如果设置为1，则这个前缀不会纳入IPv6单播路由计算中。</li>
<li>LA位：本地地址位。如果设置为1，则这个前缀是路由器的一个接口地址。</li>
<li>MC位：组播位。如果设置为1，则这个前缀应该纳入组播计算中，否则不纳入组播计算。</li>
<li>P位：传播位。如果一个NSSA区域的前缀需要被ABR传播出去，就需要设置这一位。</li>
</ul>
</li>
<li><p>Prefix</p>
<ul>
<li>长度不定，为4字节的倍数。用于表示前缀的IPv6网络地址信息。</li>
</ul>
</li>
<li><p>Prefix-length可变，但必须是32bit（4字节）的整数倍，可用0来填充。因此它的长度可能是0、4、8、12、16字节。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/42.png"></p>
<blockquote>
<ul>
<li>W：用于组播路由；</li>
<li>V：该路由器为虚连接的一端；</li>
<li>E：该路由器为ASBR；</li>
<li>B：该路由器为ABR。</li>
<li>Type：1字节。路由器的该链路的链路类型；</li>
<li>Metric：2字节。数据报文从此接口发出时的cost值；</li>
<li>Interface ID：4字节。接口ID，用于标识接口，无地址含义。</li>
<li>Neighbor Interface ID：4字节。邻居接口ID。</li>
<li>Neighbor Router ID：4字节。邻居Router ID。 </li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/43.png"></p>
<blockquote>
<ul>
<li>Router-LSA具有区域泛洪范围，用于描述该路由器在某个区域内的所有连接，而且只描述建立了邻接关系的连接（邻居为full状态）。这意味着Stub类型的链路不在这里描述了（在OSPFv2中用链路类型3描述）。另外，如果是点到多点链路的话，需要为每个邻居都产生一个描述。由于每个链路描述的长度固定，因此可以通过LSA头中的LSA长度来确定Router-LSA中的Link数。</li>
<li> 一个Router-LSA可以包含多个链路描述（link description）。同一个路由器可以生成多个Router-LSA，通过Link State ID进行区分。在SPF计算时，对于同一个路由器产生的多个Router-LSA必须合在一起参与运算。</li>
<li>OSPFv3的Router-LSA中不再包含前缀信息，仅仅描述了拓扑连接情况。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/44.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/45.png"></p>
<blockquote>
<ul>
<li><p>Options：3字节。含义见第36页。该字段实际上是该链路上所有路由器的Link-LSA的Options字段的集合，也即是它们的能力集合。</p>
</li>
<li><p>Attached Router：</p>
<ul>
<li>每个路由器4字节。该链路上所有与DR有Full关系的路由器的Router ID。</li>
<li>OSPFv3的Network-LSA具有区域泛洪范围，由DR生成。它的Link State ID为DR的Interface ID，而且将OSPFv2中的掩码字段取消了，所以它不再包含前缀信息，而仅仅描述了拓扑连接情况。</li>
<li>另外，由于其中的Options字段为链路上所有路由器的能力集合，因此DR的能力大小并不会影响其他路由器的LSA传播。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/46.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/47.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/48.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/49.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/50.png"></p>
<blockquote>
<ul>
<li>OSPFv3的Intra-Area-Prefix-LSA具有区域泛洪范围，用于发布区域内前缀信息。根据所参考的LSA不同可分为以下两种情况：<ul>
<li>参考Router-LSA，由各路由器分别生成，用于发布点到点链路的前缀信息以及Stub网络的前缀信息；</li>
<li>参考Network-LSA，由DR生成，用于发布该链路对应网络上的所有前缀信息，这些前缀来自链路上所有路由器各自生成的Link-LSA。但是，Link-LSA中的本地链路地址信息、NU或LA位置1的前缀除外。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/51.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/52.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/53.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/54.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/55.png"></p>
<blockquote>
<ul>
<li>Metric：20bit。表示ABR到达该前缀描述的路由的cost值。</li>
<li>前缀信息：描述前缀的Prefix三元组。</li>
<li>在OSPFv2中，使用LSA头里面的Link State ID字段来表示网络地址，掩码包含在LSA内容里。</li>
<li>OSPFv3的Inter-Area-Prefix-LSA中，LSA头里的Link State ID不再包含前缀信息，仅仅是一个32位的编号，用于区分同一路由器产生的不同LSA，所有前缀均通过Prefix三元组来描述。</li>
<li>Inter-Area-Prefix-LSA具有区域泛洪范围，由ABR生成。每个Inter-Area-Prefix-LSA包含一条地址前缀信息，且不能包含本地链路地址信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/56.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/57.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/58.png"></p>
<blockquote>
<ul>
<li>Options：3字节，并非生成LSA的路由器的能力描述，而是描述了目的ASBR的能力。</li>
<li> Metric：3字节，表示ABR到目的ASBR路由器的cost值。</li>
<li> Destination Router ID：4字节，目的ASBR路由器的Router ID。</li>
<li>在OSPFv2中，使用LSA头里面的Link State ID字段来表示目的ASBR的Router ID。OSPFv3的Inter-Area-Router-LSA中，LSA头里的Link State ID不再有具体含义，仅仅是一个32位的编号，用于区分同一路由器产生的不同LSA。</li>
<li>Inter-Area-Router-LSA具有区域泛洪范围，由ABR生成。每个Inter-Area-Router-LSA包含一条目的ASBR信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/59.png"></p>
<blockquote>
<ul>
<li><p>E：外部路由的Metric类型。如果设置为1，表示此为2类外部路由，其Metric不随着路由的传递而增长。如果设置为0，表示此为1类外部路由，其Metric随着路由的传递而增长。</p>
</li>
<li><p>F：如果设置为1，则表示后面的Forwarding Address可选字段存在。</p>
</li>
<li><p>T：如果设置为1，则表示后面的External Route Tag可选字段存在。</p>
</li>
<li><p>前缀信息：描述前缀的Prefix三元组。</p>
</li>
<li><p>Ref LS Type：2字节。如果非0，则表示后面的Referenced Link State ID可选字段存在。</p>
</li>
<li><p>Forwarding Address：16字节。可选的128位IPv6地址。当前面的F位为1时存在。表示到达目的的数据应该转发到这个地址。在公告路由器不是最优的下一跳的时候可以使用。</p>
</li>
<li><p>External Route Tag：4字节。可选的标记位。可以用于ASBR之间的通信。一个比较常见的例子是，在OSPF自治系统的两个边界路由器上进行路由分发时，通过对引入的路由进行标记，可以很方便地进行路由过滤。</p>
</li>
<li><p>Referenced Link State ID：4字节。当前面的Ref LS Type字段非0时存在。如果存在，说明此条外部路由有一些相关信息需要参考另外一个LSA。被参考的LSA由以下字段值确定：</p>
<ul>
<li>其LS type等于此AS-external-LSA的Referenced LS Type；</li>
<li>其Link State ID等于此AS-external-LSA的Referenced Link State ID；</li>
<li>其Advertising Router等于此ASexternal-LSA的Advertising Router。</li>
<li>这种参考能力是为未来的扩展准备的，目前并没有使用。</li>
</ul>
</li>
<li><p>在OSPFv2中，使用LSA头里面的Link State ID字段来表示网络地址，掩码包含在LSA内容里。</p>
</li>
<li><p>OSPFv3的AS-external-LSA中，LSA头里的Link State ID不再包含前缀信息，仅仅是一个32位的编号，用于区分同一路由器产生的不同LSA，所有前缀均通过Prefix三元组来描述。</p>
</li>
<li><p>AS-external-LSA具有AS泛洪范围，由ASBR生成。每个AS-external-LSA包含一条地址前缀信息，且不能包含本地链路地址信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/60.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/61.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/62.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/63.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/64.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/65.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/66.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/67.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/68.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/69.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/70.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/71.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/72.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/73.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/74.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/" itemprop="url">IE-IPv6基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-26T17:30:23+08:00">
                2021-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/1.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/2.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/3.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/4.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<ul>
<li><p>ICANN(the Internet Corporation for Assigned Names and Numbers)是Internet的中心管理机构。</p>
</li>
<li><p>并不是所有的地址都会被分配。一些地址被预留，用于广播、测试、私有网络使用等。这些地址被称为专用地址(special-use address)。你可以查询RFC5735来了解哪些地址是专用地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/6.png"></p>
<blockquote>
<ul>
<li><p>实践证明IPv4是一个非常成功的协议，它本身也经受住了Internet从数目很少的计算机发展到目前上亿台计算机互联的考验。但该协议是几十年前基于当时的网络规模而设计的。在今天看来，IPv4的设计者们对于Internet的估计和预想显得很不充分。随着Internet的扩张和新应用的不断推出，IPv4越来越显示出它的局限性。</p>
</li>
<li><p>Internet规模的快速扩大是当时完全没有预料到的，特别是近十年来，更是爆炸式增长，已经走进了千家万户，人们的日常生活已经离不开它了。但也就是这种快速发展，出现了迫在眉睫的IP地址空间耗尽问题。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/7.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/8.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/9.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/10.png"></p>
<blockquote>
<p>IPv6特点：</p>
<ul>
<li>地址空间，IPv6地址采用128比特标识。128位的地址结构使IPv6理论上可以拥有（43亿×43亿×43亿×43亿）个地址。近乎无限的地址空间是IPv6的最大优势。</li>
<li>报文结构，IPv6使用了新的协议头格式，也就是说IPv6数据包有全新的报文头，而并不是仅仅简单地将IPv4报文头中的地址部分增加到128bits而已。在IPv6中，报文头包括固定头部和扩展头部，一些非根本性的和可选择的字段被移到了IPv6协议头之后的扩展协议头中。这使得网络中的中间路由器在处理IPv6协议头时，有更高的效率。</li>
<li>实现自动配置和重新编址，IPv6协议内置支持通过地址自动配置方式使主机自动发现网络并获取IPv6地址，大大提高了内部网络的可管理性。</li>
<li>支持层次化网络结构，巨大的地址空间使得IPv6可以方便的进行层次化网络部署。层次化的网络结构可以方便的进行路由聚合，提高了路由转发效率。</li>
<li>支持端对端安全，IPv6中，网络层支持IPSec的认证和加密，支持端到端的安全。</li>
<li>更好的支持QoS，IPv6在包头中新定义了一个叫做流标签的特殊字段。IPv6的流标签字段使得网络中的路由器可以对属于一个流的数据包进行识别并提供特殊处理。用这个标签，路由器可以不打开传送的内层数据包就可以识别流，这就使得即使数据包有效载荷已经进行了加密，仍然可以实现对QoS的支持。</li>
<li>支持移动特性，由于采用了Routing header和Destination option header等扩展报头，使得IPv6提供了内置的移动性。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<ul>
<li><p>IPv6数据包由一个IPv6报头、多个扩展报头和一个上层协议数据单元组成。</p>
</li>
<li><p>IPv6基本报头（IPv6 Header）</p>
<ul>
<li>每一个IPv6数据包都必须包含报头，其长度固定为40bytes。</li>
<li>基本报头提供报文转发的基本信息，会被转发路径上面的所有路由器解析。</li>
</ul>
</li>
<li><p>上层协议数据单元（Upper Layer Protocol Data Unit）</p>
<ul>
<li>上层协议数据单元一般由上层协议包头和它的有效载荷构成，有效载荷可以是一个ICMPv6报文、一个TCP报文或一个UDP报文。</li>
</ul>
</li>
<li><p>IPv6报头格式中主要字段解释如下：</p>
<ul>
<li>Version：版本号，长度为4bit。对于IPv6，该值为6。</li>
<li>Traffic Class：流类别，长度为8bit。等同于IPv4中的ToS字段，表示IPv6数据报的类或优先级，主要应用于QoS。</li>
<li>Flow Label：流标签，长度为20bit。IPv6中的新增字段，用于区分实时流量，不同的流标签+源地址可以唯一确定一条数据流，中间网络设备可以根据这些信息更加高效率的区分数据流。</li>
<li>Payload Length：有效载荷长度，长度为16bit。有效载荷是指紧跟IPv6报头的数据报的其它部分（即扩展报头和上层协议数据单元）。</li>
<li>Next Header：下一个报头，长度为8bit。</li>
<li>Hop Limit：跳数限制，长度为8bit。该字段类似于IPv4中的Time to Live字段，它定义了IP数据报所能经过的最大跳数。每经过一个路由器，该数值减去1，当该字段的值为0时，数据报将被丢弃。</li>
<li>Source Address：源地址，长度为128bit。表示发送方的地址。</li>
<li>Destination Address：目的地址，长度为128bit。表示接收方的地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/12.png"></p>
<blockquote>
<ul>
<li>在IPv4中，IPv4报头包含可选字段Options，内容涉及security、Timestamp、Record route等，这些Options可以将IPv4报头长度从20字节扩充到60字节。在转发过程中，处理携带这些Options的IPv4报文会占用路由器很大的资源，因此实际中也很少使用。</li>
<li>IPv6将这些Options从IPv6基本报头中剥离，放到了扩展报头中，扩展报头被置于IPv6报头和上层协议数据单元之间。一个IPv6报文可以包含0个、1个或多个扩展报头，仅当需要路由器或目的节点做某些特殊处理时，才由发送方添加一个或多个扩展头。与IPv4不同，IPv6扩展头长度任意，不受40字节限制，这样便于日后扩充新增选项，这一特征加上选项的处理方式使得IPv6选项能得以真正的利用。但是为了提高处理选项头和传输层协议的性能，扩展报头总是8字节长度的整数倍。当使用多个扩展报头时，前面报头的Next Header字段指明下一个扩展报头的类型，这样就形成了链状的报头列表。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/13.png"></p>
<blockquote>
<p>说明：</p>
<ul>
<li><p>路由设备转发时根据基本报头中Next Header值来决定是否要处理扩展头，并不是所有的扩展报头都需要被转发路由设备查看和处理的。</p>
</li>
<li><p>除了目的选项扩展报头可能在一个IPv6报文中出现一次或两次（一次在路由扩展报头之前，另一次在上层协议数据报文之前），其余扩展报头只能出现一次。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/14.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/15.png"></p>
<blockquote>
<ul>
<li>IPv4地址分为：单播地址、组播地址、广播地址。而IPv6中没有广播地址，增加了任播地址。也就是说IPv6地址被分为：单播地址、组播地址、任播地址。<ul>
<li>单播地址用于标识一个接口，发往该目的地址的报文会被送到被标识的接口；</li>
<li>组播地址用于标识多个接口，发往该目的地址的报文会被送到被标识的所有接口；</li>
<li>任播地址用于标识多个接口，发往该目的地址的报文会被送到被标识的所有接口中最近的一个接口上。实际上任播地址与单播地址使用同一个地址空间，也就是说，由路由器决定数据包是做任播转发还是单播转发。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/16.png"></p>
<blockquote>
<ul>
<li>全球单播地址是带有全球单播前缀的IPv6地址，其作用类似于IPv4中的公网地址。这种类型的地址允许路由前缀的聚合，从而限制了全球路由表项的数量。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/17.png"></p>
<blockquote>
<ul>
<li>链路本地地址是IPv6中的应用范围受限制的地址类型，只能在连接到同一本地链路的节点之间使用。它使用了特定的本地链路前缀FE80::/10（最高10位值为1111111010），同时将接口标识添加在后面作为地址的低64比特。</li>
<li>当一个节点启动IPv6协议栈时，启动时节点的每个接口会自动配置一个链路本地地址（其固定的前缀+EUI-64规则形成的接口标识）。这种机制使得两个连接到同一链路的IPv6节点不需要做任何配置就可以通信。所以链路本地地址广泛应用于邻居发现，无状态地址配置等应用。</li>
<li>以链路本地地址为源地址或目的地址的IPv6报文不会被路由设备转发到其他链路。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/18.png"></p>
<blockquote>
<ul>
<li><p>唯一本地地址是另一种应用范围受限的地址，它仅能在一个站点内使用。由于本地站点地址的废除（RFC3879），唯一本地地址被用来代替本地站点地址（RFC4193）。</p>
</li>
<li><p>唯一本地地址的作用类似于IPv4中的私网地址，任何没有申请到提供商分配的全球单播地址的组织机构都可以使用唯一本地地址。唯一本地地址只能在本地网络内部被路由转发而不会在全球网络中被路由转发。</p>
</li>
<li><p>字段解释：</p>
<ul>
<li>Prefix：前缀；固定为FC00::/7。</li>
<li>L：L标志位；值为1代表该地址为在本地网络范围内使用的地址；值为0被保留，用于以后扩展。</li>
<li>Global ID：全球唯一前缀；通过伪随机方式产生（RFC4193）。</li>
<li>Subnet ID：子网ID；划分子网使用。</li>
<li>Interface ID：接口标识。</li>
</ul>
</li>
<li><p>唯一本地地址具有如下特点：</p>
<ul>
<li>具有全球唯一的前缀（虽然随机方式产生，但是冲突概率很低）。</li>
<li>可以进行网络之间的私有连接，而不必担心地址冲突等问题。</li>
<li>具有知名前缀（FC00::/7），方便边缘路由器进行路由过滤。</li>
<li>如果出现路由泄漏，该地址不会和其他地址冲突，不会造成Internet路由冲突。</li>
<li>应用中，上层应用程序将这些地址看作全球单播地址对待。</li>
<li>独立于互联网服务提供商ISP（Internet Service Provider）。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/19.png"></p>
<blockquote>
<ul>
<li><p>未指定地址</p>
<ul>
<li>IPv6中的未指定地址即 0:0:0:0:0:0:0:0/128 或者::/128。该地址可以表示某个接口或者节点还没有IP地址，可以作为某些报文的源IP地址（例如在NS报文的重复地址检测中会出现）。源IP地址是::的报文不会被路由设备转发。</li>
</ul>
</li>
<li><p>环回地址</p>
<ul>
<li>IPv6中的环回地址即 0:0:0:0:0:0:0:1/128 或者::1/128。环回与IPv4中的127.0.0.1作用相同，主要用于设备给自己发送报文。该地址通常用来作为一个虚接口的地址（如Loopback接口）。实际发送的数据包中不能使用环回地址作为源IP地址或者目的IP地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/20.png"></p>
<blockquote>
<ul>
<li><p>对于IPv6 单播地址来说，如果地址的前三bit不是000，则接口标识必须为64位，如果地址的前三位是000，则没有此限制。</p>
</li>
<li><p>接口ID的长度为64bit，用于标识链路上的接口。在每条链路上，接口ID必须唯一。接口ID有许多用途，最常见的用于就是黏贴在链路本地地址前缀后面，形成接口的链路本地地址。或者在无状态自动配置中，黏贴在获取到的IPv6全局单播地址前缀后面，构成接口的全局单播地址。</p>
</li>
<li><p>IEEE EUI-64规范</p>
<ul>
<li>这种由MAC地址产生IPv6地址接口ID的方法可以减少配置的工作量，尤其是当采用无状态地址自动配置时（后面会介绍），只需要获取一个IPv6前缀就可以与接口ID形成IPv6地址。</li>
<li>使用这种方式最大的缺点就是某些恶意者可以通过二层MAC推算出三层IPv6地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/21.png"></p>
<blockquote>
<ul>
<li><p>假设一个接口的MAC地址如上图所示，那么采用EUI-64规范，接口可根据该MAC地址计算得到接口ID，由于MAC地址全局唯一，因此该接口ID也相应的具备全局唯一性。计算过程如下。</p>
</li>
<li><p>将48bit的MAC地址对半劈开，然后插入“FFFE”，再对从左数起的第7位，也就是U/L位取反，即可得到对应的接口ID。</p>
</li>
<li><p>在单播MAC地址中，第1个Byte的第7bit是U/L（Universal/Local，也称为G/L，其中G表示Global）位，用于表示MAC地址的唯一性。如果U/L=0，则该MAC地址是全局管理地址，是由拥有OUI的厂商所分配的MAC地址；如果U/L=1，则是本地管理地址，是网络管理员基于业务目的自定义的MAC地址。</p>
</li>
<li><p>而在在EUI-64接口ID中，第7bit的含义与MAC地址正好相反，0表示本地管理，1表示全球管理，所以使用EUI-64格式的接口ID，U/L位为1，则地址是全球唯一的，如果为0，则为本地唯一。这就是为什么要反转该位。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/22.png"></p>
<blockquote>
<ul>
<li><p>IPv6的组播与IPv4相同，用来标识一组接口，一般这些接口属于不同的节点。一个节点可能属于0到多个组播组。发往组播地址的报文被组播地址标识的所有接口接收。</p>
</li>
<li><p>Flags 永久标志：</p>
<ul>
<li>0000：永久多播地址。</li>
<li>0001：临时多播地址。</li>
<li>（注：前3bits 保留为0）。</li>
</ul>
</li>
<li><p>Scope 应用范围：</p>
<ul>
<li>0001：本地接口范围，单个接口范围有效，仅用于Loopback。</li>
<li>0010：本地链路范围。</li>
<li>0100：本地管理范围，管理员配置的。</li>
<li>0101：本地站点范围。</li>
<li>1000：本地组织范围，属于同一个组织的多个站点范围。</li>
<li>1110：全局范围。</li>
</ul>
</li>
<li><p>Group ID：</p>
<ul>
<li>组播组ID。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/23.png"></p>
<blockquote>
<ul>
<li>类似于IPv4，IPv6同样有一些特殊的组播地址，这些地址由特别的含义，这里举几个例子（还有很多类似的特殊地址）：<ul>
<li>FF01::1（节点本地范围组播地址）</li>
<li>FF02::1（链路本地范围所有节点组播地址）</li>
<li>FF01::2（节点本地范围所有路由器组播地址）</li>
<li>FF02::2（链路本地范围所有路由器组播地址）</li>
<li>FF05::2（站点本地范围所有路由器组播地址）</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/24.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/25.png"></p>
<blockquote>
<ul>
<li><p>当一个节点具有了单播或任播地址，就会对应生成一个与之相对应的被请求节点组播地址，并且加入这个组播组。一个单播地址或任播地址对应一个被请求节点组播地址。该地址主要用于地址解析、邻居发现机制和地址重复检测等功能。</p>
</li>
<li><p>被请求节点组播地址由固定前缀FF02::1:FF00:0/104和对应IPv6地址的最后24bit组成。被请求节点组播地址的有效范围为本地链路范围。</p>
</li>
<li><p>被请求节点组播地址的作用究竟是什么呢？举个非常简单的例子，回顾一下IPv4中的ARP，这个协议主要用于地址解析，当设备需要解析某个IP地址对应的MAC地址时，就会发送一个广播ARP Request帧，之所以要发送广播帧，是因为它要确保广播域内所有节点都能收到。然而除了目标节点之外，该帧对于其他节点而言是个困扰，因为它们不得不去解析这个帧（一直解析到ARP载荷），这个动作将会浪费设备的资源。</p>
</li>
<li><p>在IPv6中，ARP及广播都被取消，当设备需要请求某个IPv6地址对应的MAC地址时，设备依然需要发送请求报文，但是该报文是一个组播报文，其目的IPv6地址是目标IPv6单播地址对应的被请求节点组播地址，而目的MAC地址则是该组播地址对应的组播MAC地址。由于只有目标节点才会侦听这个被请求节点组播地址，因此当其他设备收到该帧时，这些设备可以通过目的MAC地址、在网卡层面就判断出不需要处理它并将帧丢弃。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/26.png"></p>
<blockquote>
<ul>
<li>这是IPv6特有的地址类型，它用来标识一组网络接口（通常属于不同的节点）。目标地址是任播地址的数据包将发送给其中路由意义上最近的一个网络接口。适合于“One-to-One-of-Many”（一对组中的一个）的通讯场合。接收方只需要是一组接口中的一个即可，如移动用户上网就需要因地理位置的不同，而接入离用户最近的一个接收站，这样才可以使移动用户在地理位置上不受太多的限制。</li>
<li>任播地址从单播地址空间中进行分配，使用单播地址的任何格式。因而，从语法上，任播地址与单播地址没有区别。被分配具有任播地址的节点必须得到明确的配置，从而知道它是一个任播地址。目前，任播地址仅被用做目标地址，且仅分配给路由器。</li>
<li>在RFC3513中定义了子网路由器任播地址（Subnet-Router anycast Address），其接口ID为全0。</li>
<li>发往该任播地址的报文会被发送到任播地址所代表子网（子网路由器任播地址的前缀）内的某一台路由器，该路由器是离得最“近”的一台。所谓最近一般是路由的概念。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/27.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/28.png"></p>
<blockquote>
<ul>
<li>ICMPv6的协议类型号（即IPv6报文中的Next Header字段的值）为58。</li>
<li>在IPv4中，Internet控制报文协议（ICMP）向源节点报告关于向目的地传输IP数据包过程中的错误和信息。它为诊断、信息和管理目的定义了一些消息，如：目的不可达、数据包超长、超时、回应请求和回应应答等。在IPv6中，ICMPv6除了提供ICMPv4常用的功能之外，还有其它的一些机制需要ICMPv6消息，诸如邻居发现、无状态地址配置（包括重复地址检测）、路径MTU发现等等。</li>
<li>所以ICMPv6是一个非常重要的协议。它是理解IPv6中其它机制的基础。</li>
<li>报文解释：<ul>
<li>Type：表明消息的类型，0至127表示差错报文类型，128至255表示消息报文类型。</li>
<li>Code：表示此消息类型细分的类型。</li>
<li>Checksum：表示ICMPv6报文的校验和。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/29.png"></p>
<blockquote>
<ul>
<li><p>目标不可达（Destination Unreachable）。</p>
<ul>
<li>当数据包无法被转发到目标节点或上层协议时，路由器或目标节点发送ICMPv6目标不可达差错报文。在目标不可达报文中，类型（Type）字段值为1，代码（Code）字段值为0-4，每一个代码值都定义了具体含义（RFC2463）：<ul>
<li>0：没有到达目标的路由。</li>
<li>1：与目标的通信被管理策略禁止。</li>
<li>2：未指定。</li>
<li>3：地址不可达。</li>
<li>4：端口不可达。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据包超长（Packet Too Big）。</p>
<ul>
<li>如果由于出口链路的MTU小于IPv6数据包的长度而导致数据包无法转发，路由器就会发送数据包超长报文。该报文被用于IPv6路径MTU发现的处理 。数据包超长报文的类型字段值为2，代码字段值为0。</li>
</ul>
</li>
<li><p>超时（Time Exceeded）。</p>
<ul>
<li>当路由器收到一个IPv6报头中的跳限制（Hop Limit）字段值为0的数据包时，会丢弃该数据包并向源发送ICMPv6超时报文。在超时报文中，类型字段的值为3，代码字段的值为0或1：<ul>
<li>0：在传输中超越了跳限制。</li>
<li>1：分片重组超时。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/31.png"></p>
<blockquote>
<p>1.路由器发现：该功能帮助设备发现链路上的路由器，并获得路由器通告的信息。</p>
<p>2.无状态自动配置：无状态自动配置是IPv6的一个亮点功能，它使得IPv6主机能够非常便捷地连入到IPv6网络中，即插即用，无需手工配置繁冗的IPv6地址，无需部署应用服务器（例如DHCP服务器）为主机分发地址。无状态自动配置机制使用到了ICMPv6中的路由器请求报文（RS）及路由器通告报文（RA）。</p>
<p>3.重复地址检测：重复地址检测是一个非常重要的机制，一个IPv6地址必须经历重复地址检测并通过检测之后才能够启用。重复地址检测用于发现链路上是否存在IPv6地址冲突。</p>
<p>4.地址解析：在IPv6中，取消了IPv4中的ARP协议，使用NDP所定义的邻居请求报文（NS）及邻居通告报文（NA）来实现地址解析功能。</p>
<p>5.邻居的状态跟踪：IPv6定义了节点之间邻居的状态机，同时还维护邻居IPv6地址与二层地址如MAC的映射关系，相应的表项存储于设备的IPv6邻居表中。</p>
<p>6.前缀重编址：IPv6路由器能够通过ICMPv6的路由器通告报文（RA）向链路上通告IPv6前缀信息。通过这种方式，主机能够从RA中所包含的前缀信息自动构建自己的IPv6单播地址。当然这些自动获取的地址是有生存时间的。通过在RA中通告IPv6地址前缀，并且灵活地设定地址的生存时间，能够实现网络中IPv6新、老前缀的平滑过渡，而无需在主机终端上消耗大量的手工劳动重新配置地址。</p>
<p>7.路由器重定向：路由器向一个IPv6节点发送ICMPv6的重定向消息，通知它在相同的本地链路上有一个更好的、到达目的地的下一跳。IPv6中的重定向功能与IPv4中的是一样的。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/32.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/33.png"></p>
<blockquote>
<p>在IPv4中，可以通过ARP就可以由IP地址解析到链路层地址，ARP协议是工作在第二层。在IPv6中在邻居发现协议（RFC2461）中定义地址解析的，其中使用了ICMPv6的报文，在三层完成地址解析，主要带来以下几个好处：</p>
<p>1.加强了介质独立性：这就意味着我们无需为每一个链路层定义一个新的地址解析协议，在每一个链路层都使用相同的地址解析协议；</p>
<p>2.可以利用三层安全机制：ARP欺骗（如伪造ARP应答以盗窃数据流）是IPv4中的一个很大的安全问题，在第三层实现地址解析，可以利用三层标准的安全认证机制（例如IPSEC）解决这个问题；</p>
<p>3.ARP请求报文使用广播，会泛滥到整个二层网络中每台主机是公认的一个IPv4性能问题。在第三层实现地址解析可以将地址解析请求仅仅发送到待解析地址所属的“Solicited-node”组播组即可。采用组播的传送方式，大大减轻了性能压力。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/34.png"></p>
<blockquote>
<ul>
<li><p>地址解析过程中使用了两种ICMPv6报文：邻居请求（Neighbor Solicitation）和邻居通告（Neighbor Advertisement）。</p>
</li>
<li><p>邻居请求 Neighbor Solicitation</p>
<ul>
<li>ICMP的Type为135，Code为0；</li>
<li>Target Address是需要解析的IPv6地址，因此该处不准出现组播地址。</li>
<li>邻居请求发送者的链路层地址会被放在Options字段中。</li>
</ul>
</li>
<li><p>邻居通告 Neighbor Advertisement</p>
<ul>
<li>ICMP Type为136，Code为0；</li>
<li>R标志（Router flag）表示发送者是否为路由器，如果1则表示是；</li>
<li>S标志（Solicited flag）表示发送邻居通告是否是响应某个邻居请求，如果1则表示是；</li>
<li>O标志（Overide flag）表示邻居通告中的消息是否覆盖已有的条目信息，如果1则表示是；</li>
<li>Traget Address表示所携带的链路层地址对应的IPv6地址。</li>
<li>被请求的链路层地址被放在Options字段中，其格式仍然采用TLV格式，具体可以参考RFC2463 。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/35.png"></p>
<blockquote>
<ul>
<li>有了NS和NA两种报文，两台主机如何获取对方的链路层地址呢？</li>
<li>在上图所示的场景中，PC1要请求PC2的2001::2这个地址对应的MAC地址，PC1将发送一个NS报文达到这个目的。这个NS报文的源地址是2001::1，目的地址则是2001::2对应的被请求节点组播地址。</li>
<li>然后IPv6数据包又被封装上数据帧的头部，其中源MAC地址是PC1的MAC地址，目的MAC地址则是2001::2这个目标地址对应的被请求节点组播地址映射得到的MAC地址，这是一个组播MAC地址。</li>
<li>这样就完成了一个双向交互链路层地址的过程。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/36.png"></p>
<blockquote>
<ul>
<li><p>除R2外的其他节点也会收到这个数据帧，在读取数据帧头的时候发现目的MAC地址是一个组播MAC地址，而该组播MAC地址在本地并不侦听，因此在网卡层面就将数据帧丢弃而不再往报文里看了。</p>
</li>
<li><p>PC2收到这个数据帧后，由于本地网卡接收目的MAC地址为3333-FF00-0002的数据帧，因此在对数据帧做校验之后从帧头的类型字段得知里头是个IPv6报文，于是将帧头拆掉，把IPv6报文上送IPv6协议栈处理。IPv6协议栈从报文的IPv6头部中的目的IPv6地址得知这个数据包是发往一个被请求节点组播地址FF02::1:FF00:2，而本地网卡加入了这个组播组。接着，从IPv6包头的NextHeader字段得知IPv6包头后面封装着一个ICMPv6的报文，因此将IPv6包头拆除，将ICMPv6报文交给ICMPv6协议去处理。最后ICMPv6发现这是个NS报文，要请求自己2001::2对应的MAC地址，于是回送一个NA报文给PC1，在该报文中就包含着PC2的MAC地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/37.png"></p>
<blockquote>
<p>l在windows7操作系统里，可以使用netsh interface ipv6 show neighbors命令查看邻居缓存的内容。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/38.png"></p>
<blockquote>
<ul>
<li>前面简单地讲述了如何进行地址解析的，但是实际的通讯过程中不仅仅是地址解析这么简单，而是需要维护一张邻居表，每个邻居都有相应的状态，状态之间可以迁移。</li>
<li>RFC2461中定义了5种状态：INCOMPLETE、REACHABLE、STALE、DELAY、PROBE。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/39.png"></p>
<blockquote>
<ul>
<li>邻居状态的迁移是比较复杂的，此处不会做详细地介绍，下面以A、B两个节点之间相互通讯过程的A节点的邻居状态变化，假设A、B两个节点之前没有任何通讯：</li>
</ul>
<p>1.A先发送NS，并生成邻居缓存条目，状态为Incomplete；</p>
<p>2.若B回复NA，则Incomplete-&gt;Reachable，否则10s后Incomplete-&gt;Empty，即删除条目；</p>
<p>3.经过ReachableTime（默认30s），条目状态Reachable-&gt;Stale；</p>
<p>4.或者在Reachable状态，收到B的非请求NA，且链路层地址不同，则马上-&gt;Stale；</p>
<p>5.在Stale状态若A需要向B发送数据，则Stale-&gt;Delay，同时发送NS请求；</p>
<p>6.在Delay_First_Probe_Time（默认5秒）后，Delay-&gt;Probe，其间若有NA应答，则Delay-&gt;Reachable；</p>
<p>7.在Probe状态，每隔RetransTimer（默认1秒）发送单播NS，发送MAX_UNICAST_SOLICIT个后再等RestransTimer，有应答则-&gt;Reachable，否则进入Empty，即删除表项。</p>
<ul>
<li><p>从以上的机制可以看出IPv6的邻居关系优于IPv4的ARP，IPv6的邻居关系维护机制确保通讯发起之前邻居是可达的，而ARP本身是做不到的，仅仅通过老化机制来实现。</p>
</li>
<li><p>关于邻居状态的维护以及状态迁移可以参考RFC2461。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/40.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/41.png"></p>
<blockquote>
<ul>
<li>在上图中，R2已是在线的设备，该设备已经使用了如图所示的地址，现在我们为R1新配置IPv6的地址2001::FFFF/64，观察一下会发生什么事情。R1的接口配置2001::FFFF/64地址后，该地址立即进入tentative状态，此时仍然是不可用的，除非该地址通过DAD检测。</li>
</ul>
<p>1.R1向链路上以组播的方式发送一个NS报文，该NS的源IPv6地址为“::”，目的IPv6地址为要进行DAD检测的2001::FFFF对应的被请求节点组播地址，也就是FF02::1:FF00:FFFF。这个NS里包含着要做DAD检测的目标地址2001::FFFF。</p>
<p>2.链路上的节点都会收到这个组播的NS报文，没有配置2001::FFFF的节点接口由于没有加入该地址对应的被请求节点组播组，因此在收到这个NS的时候默默丢弃。而R2在收到这个NS后，由于它的接口配置了2001::FFFF地址，因此接口会加入组播组FF02::1:FF00:FFFF，而此刻所收到的报文又是以该地址为目的地址，因此它会解析该报文，它发现对方进行DAD的目标地址与自己本地接口地址相同，于是立即回送一个NA报文，该报文的目的地址是FF02::1，也就是所有节点组播地址，同时在报文内写入目标地址2001::FFFF，以及自己接口的MAC地址。</p>
<p>3.当R1收到这个NA后，它就知道2001::FFFF在链路上已经有人在用了，因此将该地址标记为Duplicate（重复的），该地址将不能用于通信。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/42.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/44.png"></p>
<blockquote>
<ul>
<li><p>使用IPv6地址无状态自动配置后，设备的IPv6地址无需进行手工配置，即插即用，减轻网络管理的负担。</p>
</li>
<li><p>大致的工作过程如下：</p>
<p>1.主机根据本地接口ID自动产生网卡的链路本地地址。</p>
<p>2.主机对链路本地地址进行DAD检测， 如果该地址不存在冲突则可以启用。</p>
<p>3.主机发送RS报文尝试在链路上发现IPv6路由器，该报文的源地址为主机的链路本地地址。</p>
<p>4.路由器回复RA报文（携带IPv6前缀信息，路由器在未收到RS时也能够配置主动发出RA报文）。</p>
<p>5.主机根据路由器回应的RA报文，获得IPv6地址前缀信息，使用该地址前缀，加上本地产生的接口ID，形成单播IPv6地址。</p>
<p>6.主机对生成的IPv6地址进行DAD检测，如果没有检测到冲突，那么该地址才能够启用。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/45.png"></p>
<blockquote>
<ul>
<li><p>路由器发现功能用来发现与本地链路相连的设备，并获取与地址自动配置相关的前缀和其他配置参数。</p>
</li>
<li><p>经过前面的介绍，我们已经知道IPv6地址支持无状态自动配置，即主机通过路由器发送的RA报文获取网络前缀信息，然后主机自己生成地址的接口标识部分，并自动配置IPv6地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/46.png"></p>
<blockquote>
<ul>
<li>主机如何获知网络的前缀（实际上不仅仅前缀前缀信息，还有其它的信息）呢？主要通过两个途径：被动接收到网络上路由器通告（Router Advertisement），从通告中获得；主动发送路由器请求（Router Solicitation），路由器回应路由器通告后，主机从通告中获得。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/47.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/48.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/49.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/50.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/51.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/52.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/53.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/54.png"></p>
<blockquote>
<ul>
<li>经常网关路由器发现报文从其它网关路由器转发更好，它就会发送重定向报文告知报文的发送者，让报文发送者选择另一个网关路由器。<ul>
<li>报文格式中Type为137，Code为0；</li>
<li>Target Address是更好的路径下一跳地址；</li>
<li>Destination Address是需要重定向转发的报文的目的地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/55.png"></p>
<blockquote>
<ul>
<li><p>下面是一个具体的例子，假设主机A想与主机B通讯，主机A的默认网关路由器是RTA，那么当A发送报文给B时报文会被送到RTA。</p>
</li>
<li><p>RTA接收到A发送的报文以后会发现实际上主机A直接发送给路由器RTB更好，它将发送一个ICMPv6重定向报文给主机A，其中Target Address为RTB，Destination Address为主机B。</p>
</li>
<li><p>主机A接收到了重定向报文之后，会在默认路由表中添加一个主机路由，以后发往主机B的报文就直接给RTB。</p>
</li>
<li><p>这就是重定向的一个简单过程，其中会有个问题：RTA如何知道去往主机B的路径通过RTB更好呢？其实这个很简单，因为RTA会发现报文进入的接口就是报文路由得出接口，也就是说发往主机B的路由实际上只是在RTA上转了一圈出来了，然后转发到RTB，据此，RTA能判断出直接给RTB是更好的路径。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/56.png"></p>
<blockquote>
<ul>
<li><p>前面学习的关于IPv6报文转发相关知识的时候知道，IPv6报文在转发的过程中是不进行分片操作的，当然也不进行分片报文的整合工作。IPv6报文仅在源节点进行分片，在目的节点进行组装。那么这会产生一个问题，源节点将报文到底分成多大的呢？很简单，为了所有的报文都能在路径上畅通无阻，那么分片的报文大小不能超过路径上最小的MTU，也就是PMTU——路径MTU。</p>
</li>
<li><p>RFC1981中定义了PMTU发现的机制，它是通过ICMPv6的Packet Too Big报文来完成的。首先源节点假设PMTU就是其出接口的MTU，发出报文，当转发路径上存在一个小于当前假设的PMTU时，就会向源节点发送Packet Too Big报文，并且携带自己的MTU值，此后源节点将PMTU的假设值更改为新收到的MTU值。如此反复，直到报文到达目的地之后，源节点就能知道到达某个目的地的PMTU了。</p>
</li>
<li><p>假设源到目的要先后经过4条链路，链路地MTU分别是1500、1500、1400、1300，当源发送一个分片报文的时候，首先分成1500大小的片，当到达1400的出接口时，路由器就会返回Packet Too Big错误，同时携带1400的MTU值。源接收到之后就会重新分成1400大小的片，当到达1300的出接口时，同样返回Packet Too Big错误，携带1300的MTU值。之后源重新分成1300的报文，最终到达目的地，这样就找到了该路径的PMTU。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/57.png"></p>
<blockquote>
<ul>
<li><p>值得注意的是，只有数据包超过路径上的最小MTU时，PMTU发现机制才有意义，因为如果报文很小，小于路径最小的MTU，就不可能产生Packet Too Big报文。</p>
</li>
<li><p>由于IPv6要求链路层所支持的最小MTU为1280，所以PMTU的值不会小于1280。而最大的PMTU一般由链路层决定，如果链路层是一个隧道，那么支持的PMTU可能很大。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/58.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/59.png"></p>
<blockquote>
<ul>
<li><p>IPv6与IPv4共存技术：</p>
<ul>
<li>双协议栈：<ul>
<li>IPv6节点同时支持IPv6和IPv4协议栈。</li>
</ul>
</li>
<li>隧道：<ul>
<li>IPv6报文作为IPv4的载荷，由IPv4 Internet中连接多个IPv6孤岛。</li>
</ul>
</li>
</ul>
</li>
<li><p>IPv6与IPv4互通技术：</p>
<ul>
<li>提供IPv6与IPv4互相访问的技术。</li>
<li>适用于IPv6 Internet与IPv4 Internet共存，而两者又有互相通讯的需求。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/60.png"></p>
<blockquote>
<ul>
<li><p>双栈技术是IPv4向IPv6过渡的一种有效的技术。网络中的节点同时支持IPv4和IPv6协议栈，源节点根据目的节点的不同选用不同的协议栈，而网络设备根据报文的协议类型选择不同的协议栈进行处理和转发。双栈可以在一个单一的设备上实现，也可以是一个双栈骨干网。对于双栈骨干网，其中的所有设备必须同时支持IPv4/IPv6协议栈，连接双栈网络的接口必须同时配置IPv4地址和IPv6地址。</p>
</li>
<li><p>所谓的双栈就是主机或者网络设备同时支持IPv4及IPv6双协议栈，如果节点支持双栈，那么它能够同时使用V4和V6的协议栈、同时处理IPv4及IPv6的数据。在双栈设备上，上层应用会优先选择IPv6协议栈，而不是IPv4。 比如，一个同时支持v4和v6的应用请求通过DNS请求地址，会先请求AAAA记录，如果没有，则再请求A记录。双栈是V4、V6并存及IPv6过渡技术的基础。<br> 就拿上图来说，路由器就是一个双栈设备，默认情况下路由器本身就已经支持IPv4，接口上也配置了IPv4的地址，已经能够正常转发IPv4的报文，此刻在激活路由器的IPv6数据转发能力，再为接口分配IPv6的单播地址，那么这个接口又有了IPv6数据转发能力。当然，此时对于路由器而言，IPv4及IPv6协议栈互不干扰，独立工作。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/61.png"></p>
<blockquote>
<ul>
<li><p>如果一个边界设备要与多个设备建立手动隧道，就需要在设备上配置多个隧道，配置比较麻烦。所以手动隧道通常用于两个边界路由器之间，为两个IPv6网络提供连接。</p>
</li>
<li><p>手动隧道优缺点</p>
<ul>
<li>优点：可以用于任何IPv6穿越IPv4的环境，通用性好。</li>
<li>缺点：必须手工配置。</li>
</ul>
</li>
<li><p>转发机制</p>
<ul>
<li>IPv6 over IPv4手动隧道转发机制为：当隧道边界设备的IPv6侧收到一个IPv6报文后， 根据IPv6报文的目的地址查找IPv6路由转发表，如果该报文是从此虚拟隧道接口转发出去，则根据隧道接口配置的隧道源端和目的端的IPv4地址进行封装。封装后的报文变成一个IPv4报文，交给IPv4协议栈处理。报文通过IPv4网络转发到隧道的终点。隧道终点收到一个隧道协议报文后，进行隧道解封装。并将解封装后的报文交给IPv6协议栈处理。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/62.png"></p>
<blockquote>
<ul>
<li><p>IPv6 over IPv4 GRE隧道使用标准的GRE隧道技术提供了点到点连接服务，需要手工指定隧道的端点地址。GRE隧道本身并不限制被封装的协议和传输协议，一个GRE隧道中被封装的协议可以是协议中允许的任意协议（可以是IPv4、IPv6、OSI、MPLS等）。</p>
</li>
<li><p>IPv6 over IPv4 GRE隧道在边界路由器上的传输机制和IPv6 over IPv4手动隧道相同。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/63.png"></p>
<blockquote>
<ul>
<li><p>6to4隧道也属于一种自动隧道，隧道也是使用内嵌在IPv6地址中的IPv4地址建立的。与IPv4兼容自动隧道不同，6to4自动隧道支持Router到Router、Host到Router、Router到Host、 Host到Host。</p>
</li>
<li><p>地址格式：</p>
<ul>
<li>FP：可聚合全球单播地址的格式前缀（Format Prefix），其值为001。</li>
<li>TLA：顶级聚合标识符（Top Level Aggregator），有13个比特位，其二进制值为0 0000 0000 0010。</li>
<li>SLA：站点级聚合标识符（Site Level Aggregator）。</li>
</ul>
</li>
<li><p>6to4地址可以表示为2002::/16，而一个6to4网络可以表示为2002:IPv4地址::/48。6to4地址的网络前缀长度为64bit，其中前48bit（2002: a.b.c.d）被分配给路由器上的IPv4地址决定了，用户不能改变，而后16位（SLA）是由用户自己定义的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/64.png"></p>
<blockquote>
<ul>
<li>一个IPv4地址只能用于一个6to4隧道的源地址，如果一个边界路由器连接了多个6to4网络使用同样的IPv4地址做为隧道的源地址，则使用6to4地址中的SLA ID来区分，但他们共用一个隧道。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/65.png"></p>
<blockquote>
<ul>
<li><p>普通IPv6网络需要与6to4网络通过IPv4网络互通，这可以通过6to4中继路由器方式实现。所谓6to4中继，就是通过6to4隧道转发的IPv6报文的目的地址不是6to4地址，但转发的下一跳是6to4地址，该下一跳为路由器我们称之为6to4中继。隧道的IPv4目的地址依然从下一跳的6to4地址中获得。</p>
</li>
<li><p>如果6to4网络2中的主机要与IPv6网络互通，在其边界路由器上配置路由指向的下一跳为6to4中继路由器的6to4地址，中继路由器的6to4地址是与中继路由器的6to4隧道的源地址相匹配的。6to4网络2中去往普通IPv6网络的报文都会按照路由表指示的下一跳发送到6to4中继路由器。6to4中继路由器再将此报文转发到纯IPv6网络中去。当报文返回时，6to4中继路由器根据返回报文的目的地址（为6to4地址）进行IPv4报文头封装，数据就能够顺利到达6to4网络中了。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/66.png"></p>
<blockquote>
<ul>
<li><p>ISATAP（Intra-Site Automatic Tunnel Addressing Protocol）是另外一种自动隧道技术。ISATAP隧道同样使用了内嵌IPv4地址的特殊IPv6地址形式，只是和6to4不同的是，6to4是使用IPv4地址做为网络前缀，而ISATAP用IPv4地址做为接口标识。</p>
</li>
<li><p>地址描述</p>
</li>
<li><p>如果IPv4地址是全局唯一的，则u位为1，否则u位为0。g位是IEEE 群体/个体标志。由于ISATAP是通过接口标识来表现的，所以，ISATAP地址有全局单播地址、链路本地地址、ULA地址、组播地址等形式。ISATAP地址的前64位是通过向ISATAP路由器发送请求来得到的，它可以进行地址自动配置。在ISATAP隧道的两端设备之间可以运行ND协议。ISATAP隧道将IPv4网络看作一个非广播的点到多点的链路（NBMA）。</p>
</li>
<li><p>转发过程描述：</p>
</li>
<li><p>在IPv4网络内部有两个双栈主机PC2和PC3，它们分别有一个私网IPv4地址。要使其具有ISATAP功能，需要进行如下操作：</p>
<ul>
<li>首先配置ISATAP隧道接口，这时会根据IPv4地址生成ISATAP类型的接口ID。</li>
<li>根据接口ID生成一个ISATAP链路本地IPv6地址，生成链路本地地址以后，主机就有了在本地链路上进行IPv6通信的能力。</li>
<li>进行自动配置，主机获得IPv6全球单播地址、ULA地址等。</li>
<li>当主机与其它IPv6主机进行通讯时，从隧道接口转发，将从报文的下一跳IPv6地址中取出IPv4地址作为IPv4封装的目的地址。如果目的主机在本站点内，则下一跳就是目的主机本身，如果目的主机不在本站点内，则下一跳为ISATAP路由器的地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/67.png"></p>
<blockquote>
<ul>
<li>当IPv4网络的节点需要直接与IPv6网络的节点进行通信时，默认情况下当然是行不通的，因为两个协议栈无法兼容。但是借助一台设备，由该设备来实现IPv6与IPv4的互转，那么上述通信需求就可以实现了。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/68.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/69.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/70.png"></p>
<blockquote>
<ul>
<li><p>设置对GRE报文头进行校验是一个可选的操作步骤。如果设置了对GRE报文头进行校验，则发送端根据GRE报文头和净荷信息计算校验和，然后将包含校验和的报文转发到对端。接收端收到报文后，计算接收报文的校验和，并将该校验和与报文中的校验和进行比较。如果结果一致，那么它将会继续处理此报文，否则将其丢弃。如果本端配置了校验和，但是对端没有配置校验和，那么本端不会对接收的报文进行校验和验证。</p>
</li>
<li><p>设置GRE报文头的关键字也是一个可选的操作步骤。如果设置了GRE报文头中的KEY字段，接收端将会检查接收的GRE报文头的关键字，如果与本端配置的关键字完全相同，表明验证成功，接受该报文，否则丢弃该报文。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/71.png"></p>
<blockquote>
<p>命令含义：</p>
<ul>
<li>interface tunnel命令用来创建一个Tunnel接口，并进入该Tunnel接口视图。</li>
<li>tunnel-protocol gre指定Tunnel为手动隧道模式。</li>
<li>source { ipv4-address | interface-type interface-number }指定Tunnel的源接口。</li>
<li>destination { ipv4-address }指定Tunnel的目的接口。</li>
<li>ipv6 address { ipv6-address prefix-length }设置Tunnel接口的IPv6地址。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/72.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/73.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/74.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/" itemprop="url">IE-WAN技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-20T22:22:43+08:00">
                2021-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/1.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/2.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/3.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/4.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/5.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/6.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/7.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/8.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/9.png"></p>
<blockquote>
<p>lT: 表示双绞线；</p>
<p>lTX：表示2对高质量的双绞线；</p>
<p>lFX：表示2根光纤。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/10.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/11.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/12.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/13.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/14.png"></p>
<blockquote>
<p>lOC-n: Optical Carrier level n（光载体等级）是光纤传输的一种单位，最小的单位为OC-1，其传输数据量约为51.84 Mbps。</p>
<p>lSTM: Synchronous Transport Module，同步传输模块。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/15.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/16.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/17.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/18.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/19.png"></p>
<blockquote>
<ul>
<li><p>PPP共定义了三个协议组件，分别是数据封装方式，链路控制协议（Link Control Protocol，LCP）和网络层控制协议（Network Control Protocol，NCP）。</p>
</li>
<li><p>数据封装方式定义了如何封装多种类型的上层协议数据包。</p>
</li>
<li><p>为了能适应多种多样的链路类型，PPP定义了链路控制协议LCP。LCP可以自动检测链路环境，如是否存在环路；协商链路参数，如最大数据包长度，使用何种认证协议等等。与其他数据链路层协议相比，PPP协议的一个重要特点是可以提供认证功能，链路两端可以协商使用何种认证协议并实施认证过程，只有认证成功才会建立连接。这个特点使PPP协议适合运营商用来接入分散的用户。</p>
</li>
<li><p>PPP定义了一组网络层控制协议NCP，每一个协议对应一种网络层协议，用于协商网络层地址等参数，例如IPCP用于协商控制IP，IPXCP用于协商控制IPX协议等。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/20.png"></p>
<blockquote>
<p>PPP报文封转格式</p>
<ul>
<li><p>Flag域</p>
<ul>
<li>Flag域标识一个物理帧的起始和结束，该字节为0x7E。</li>
</ul>
</li>
<li><p>Address域</p>
<ul>
<li>Address域可以唯一标识对端。PPP协议是被运用在点对点的链路上，因此，使用PPP协议互连的两个通信设备无须知道对方的数据链路层地址。按照协议的规定将该字节填充为全1的广播地址，对于PPP协议来说，该字段无实际意义。</li>
</ul>
</li>
<li><p>Control域</p>
<ul>
<li>该字段默认值为0x03，表明为无序号帧，PPP默认没有采用序列号和确认来实现可靠传输。</li>
<li>Address和Control域一起标识此报文为PPP报文，即PPP报文头为FF03。</li>
</ul>
</li>
<li><p>Protocol域</p>
<ul>
<li>协议域可用来区分PPP数据帧中信息域所承载的数据报类型。</li>
</ul>
</li>
<li><p>Code域</p>
<ul>
<li>代码域的长度为一个字节，主要是用来标识LCP数据报文的类型。</li>
</ul>
</li>
<li><p>Identifier域</p>
<ul>
<li>标识域为1个字节，用来匹配请求和响应，当标识域值为非法时，该报文将被丢弃。</li>
<li>通常一个配置请求报文的ID是从0x01开始逐步加1的。当对端接收到该配置请求报文后，无论使用何种报文回应对方，但必须要求回应报文中的ID要与接收报文中的ID一致。</li>
</ul>
</li>
<li><p>Length域</p>
<ul>
<li>长度域的值就是该LCP报文的总字节数据。它是代码域、标志域、长度域和数据域四个域长度的总和。</li>
<li>长度域所指示字节数之外的字节将被当作填充字节而忽略掉，而且该域的内容不能超过MRU的值。</li>
</ul>
</li>
<li><p>Data域</p>
<ul>
<li>Type为协商选项类型。</li>
<li>Length为协商选项长度，它是指Data域的总长度，也就是包含Type、Length和Data。</li>
<li>Data为协商的选项具体内容。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/22.png"></p>
<blockquote>
<p>建链过程</p>
<ul>
<li>Dead：这是PPP工作开始和结束的阶段。当物理层变为可用状态（UP）之后，PPP进入Establish阶段。</li>
<li>Establish：PPP在此阶段使用LCP协商链路层参数。如果链路层参数协商不成功（FAIL），则PPP连接建立不成功，PPP退回到Dead阶段。如果链路层参数协商成功（OPENED），则PPP进入Authenticate阶段。</li>
<li>Authenticate：PPP在此阶段认证对端，如果认证失败（FAIL），则PPP进入Terminate阶段；如果认证成功（SUCCESS）或者没配置认证（NONE），则PPP进入Network阶段。</li>
<li>Network：PPP在此阶段使用NCP进行网络层参数协商，协商成功则PPP连接建立成功，开始传输网络层数据包。当上层协议认为应当关闭此连接（例如按需电路）或者管理员手工关闭PPP连接（CLOSING），则PPP进入Terminate阶段。</li>
<li>Terminate：PPP在此阶段使用LCP关闭PPP连接。PPP连接关闭（Down）后，PPP进入Dead阶段。</li>
</ul>
<p>注意：此处列出的是PPP的工作阶段，并非PPP的协议状态。由于PPP是由一组协议组成的，因此PPP本身没有协议状态。只有特定的的协议如LCP和NCP等才有协议状态和状态转换（协议状态机）。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/23.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/24.png"></p>
<blockquote>
<ul>
<li><p>LCP协议有3大类报文：</p>
<p>1.链路配置包，用于建立和配置链路：Configure-Request（匹配请求），Configure-Ack（匹配确认），Configure-Nak（匹配否认），和Configure-Reject（匹配拒绝）。</p>
<p>2.链路结束包，用于结束一个链路：Terminate-Request（终止请求） 和 Terminate-Ack（终止确认）。</p>
<p>3.链路维修包，用于管理和调试一个链路：Code-Reject（代码拒绝）, Protocol-Reject（协议拒绝）, Echo-Request（回波请求）, Echo-Reply（回波应答）, 和 Discard-Request（抛弃请求）。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/25.png"></p>
<blockquote>
<ul>
<li>用于协商的参数<ul>
<li>在VRP平台上，MRU参数使用接口上配置的最大传输单元（MTU）值来表示的。</li>
<li>常用的PPP认证协议有PAP和CHAP（后续章节介绍），一条PPP链路的两端可以使用不同的认证协议认证对端，但是被认证方必须支持认证方使用的认证协议并正确配置用户名和密码等认证信息。</li>
<li>LCP使用魔术字（Magic-Number）检测链路环路和其它异常情况。魔术字为随机产生的一个数字，随机机制需要保证两端产生相同魔术字的可能性几乎为0。</li>
<li>收到一个Configure-Request报文之后，其包含的魔术字需要和本地产生的魔术字做比较，如果不同，表示链路无环路，则使用Confugure-Ack报文确认（其他参数也协商成功），表示魔术字协商成功。在后续发送的报文中，如果报文含有魔术字字段，则该字段设置为协商成功的魔术字，LCP不再产生新的魔术字。</li>
<li>如果收到的Configure-Request报文和自身产生的魔术字相同，则发送一个Configure-Nak报文，携带一个新的魔术字。然后，不管新收到的Configure-Nak报文中是否携带相同的魔术字，LCP都发送一个新的Configure-Request报文，携带一个新的魔术字。如果链路有环路，则这个过程会不停的持续下去，如果链路没有环路，则报文交互会很快恢复正常。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/26.png"></p>
<blockquote>
<ul>
<li><p>链路协商成功</p>
<ul>
<li>如图所示，R1和R2使用串行链路相连，运行PPP。当物理层链路变为可用状态之后，R1和R2使用LCP协商链路参数。本例中，R1首先发送一个LCP报文。</li>
<li>R1向R2发送Configure-Request报文，此报文包含在发送者（R1）上配置的链路层参数，每个链路层参数使用“类型，长度，取值”的结构表示。</li>
<li>当R2收到此Configure-Request报文之后，如果R2能识别此报文中的所有链路层参数，并且认为每个参数的取值都是可以接受的，则向R1回应一个Configure-Ack报文。</li>
<li>在没有收到Configure-Ack报文的情况下，每隔3秒重传一次Configure-Request报文，如果连续10次发送Configure-Request报文仍然没有收到Configure-Ack报文，则认为对端不可用，停止发送Configure-Request报文。</li>
</ul>
</li>
<li><p>注：完成上述过程只是表明R2认为R1上的链路参数配置是可接受的。R2也需要向R1发送Configure-Request报文，使R1检测R2上的链路参数配置是不是可接受的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/27.png"></p>
<blockquote>
<ul>
<li>链路协商参数不成功</li>
<li>当R2收到R1发送的Configure-Request报文之后，如果R2能识别此报文中携带的所有链路层参数，但是认为部分或全部参数的取值不能接受，即参数的取值协商不成功，则R2需要向R1回应一个Configure-Nak报文。</li>
<li>在这个Configure-Nak报文中，只包含不能接受的那部分链路层参数列表，每一个包含在此报文中链路层参数的取值均被修改为此报文的发送者（R2）上可以接受的取值（或取值范围）。</li>
<li>在收到Configure-Nak报文之后，R1需要根据此报文中的链路层参数重新选择本地使用的相关参数，并重新发送一个Configure-Request。</li>
<li>连续五次协商仍然不成功的参数将被禁用，不再继续协商。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/28.png"></p>
<blockquote>
<ul>
<li>链路参数协商参数不能识别<ul>
<li>当R2收到R1发送的Configure-Request报文之后，如果R2不能识别此报文中携带的部分或全部链路层参数，则R2需要向R1回应一个Configure-Reject报文。</li>
<li>在此Configure-Reject报文中，只包含不被识别的那部分链路层参数列表。</li>
<li>在收到Configure-Reject报文之后，R1需要向R2重新发送一个Configure-Request报文，在新的Configure-Request报文中，不再包含不被对端（R2）识别的参数。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/29.png"></p>
<blockquote>
<ul>
<li>检测链路状态<ul>
<li>LCP建立连接之后，可以使用Echo-Request报文和Echo-Reply报文检测链路状态，收到一个Echo-Request报文之后应当回应一个Echo-Reply报文，表示链路状态正常。</li>
<li>VRP平台默认每隔10秒发送一次Echo-Request报文。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/30.png"></p>
<blockquote>
<ul>
<li>连接关闭<ul>
<li>认证不成功或者管理员手工关闭等原因可以使LCP关闭已经建立的连接。</li>
<li>LCP关闭连接使用Terminate-Request报文和Terminate-Ack报文，Terminate-Request报文用于请求对端关闭连接，一旦收到一个Terminate-Request报文，LCP必须回应一个Terminate-Ack报文确认连接关闭。</li>
<li>在没有收到Terminate-Ack报文的情况下，每隔3秒重传一次Terminate-Request报文，连续两次重传没有收到Terminate-Ack报文，则认为对端不可用，连接关闭。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/31.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/32.png"></p>
<blockquote>
<p>lPAP报文直接封装在PPP报文中。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/33.png"></p>
<blockquote>
<ul>
<li>PAP工作模式<ul>
<li>被认证方将配置的用户名和密码信息使用Authenticate-Request报文以明文方式发送给认证方，本例中，用户名为“huawei”，密码为“hello”；</li>
<li>认证方收到被认证方发送的用户名和密码信息之后，根据本地配置的用户名和密码数据库检查用户名和密码信息是否正确匹配，如果正确，则返回Authenticate-Ack报文，表示认证成功，如果不能正确匹配，则返回Authenticate-Nak报文，表示认证失败。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/34.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/35.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/36.png"></p>
<blockquote>
<ul>
<li><p>CHAP的认证过程需要三次报文的交互。为了匹配请求报文和回应报文，报文中含有Identifier字段，一次认证过程所使用的报文均使用相同的Identifier信息。CHAP单向验证过程分为两种情况：验证方配置了用户名和验证方没有配置用户名。推荐使用验证方配置用户名的方式，这样可以对验证方的用户名进行确认。</p>
</li>
<li><p>验证方配置了用户名的验证过程（即接口配置命令ppp chap user username）：</p>
<ul>
<li>验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge），并同时将本端的用户名附带上一起发送给被验证方。</li>
<li>被验证方接到验证方的验证请求后，先检查本端接口上是否配置了ppp chap password命令，如果配置了该命令，则被验证方将生成的密文（（Identifier＋密码＋随机数）的MD5）和自己的用户名发回验证方（Response）。如果接口上未配置ppp chap password命令，则根据此报文中验证方的用户名在本端的用户表查找该用户对应的密码，将密文（（Identifier＋密码＋随机数）的MD5）和被验证方自己的用户名发回验证方（Response）。</li>
<li>验证方将自己本身保存的密码、Identifier和随机数进行MD5算法，和收到respone中的密文进行比较，以验证认证是否正确。</li>
</ul>
</li>
<li><p>验证方没有配置用户名（即接口没有配置命令ppp chap user username）：</p>
<ul>
<li>验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge）。</li>
<li>被验证方接到验证方的验证请求后，利用Identifier、ppp chap password命令配置的CHAP密码和随机数进行MD5算法，将生成的密文和自己的用户名发回验证方（Response）。</li>
<li>验证方将自己本身保存的密码、Identifier和随机数进行MD5算法，和收到respone中的密文进行比较，以验证认证是否正确。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/37.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/38.png"></p>
<blockquote>
<ul>
<li><p>IPCP，用于协商控制IP参数，使PPP可用于传输IP数据包。</p>
</li>
<li><p>IPCP使用和LCP相同的协商机制、报文类型，但IPCP并非调用LCP，只是工作过程、报文等和LCP相同。</p>
<ul>
<li>两端配置的IP地址分别为12.1.1.1/24和12.1.1.2/24（两端IP地址即使不在同一网段也会通过IPCP协商）。</li>
<li>两端静态配置IP地址的时候协商过程如下：<ul>
<li>R1和R2都要发送Configure-Request报文，在此报文中包含本地配置的IP地址。</li>
<li>R1和R2接收到对端的Configure-Request报文之后，检查其中的IP地址，如果IP地址是一个合法的单播IP地址，而且和本地配置的IP地址不同（没有IP冲突），则认为对端可以使用该地址，回应一个Configure-Ack报文。</li>
<li>通过IPCP发送的信息，PPP链路的两端都可以知道对端使用的32位IP地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/39.png"></p>
<blockquote>
<ul>
<li><p>如图所示，R1配置为请求对端分配IP地址，R2配置IP地址12.1.1.2/24，并且启用R2给对端分配IP地址的能力，给R1分配IP地址12.1.1.1。</p>
</li>
<li><p>两端动态协商IP地址的过程如下：</p>
<ul>
<li>R1向R2发送一个Configure-Request报文，此报文中含有IP地址0.0.0.0，一个含有0.0.0.0的IP地址的Configure-Request报文表示向对端请求IP地址；</li>
<li>R2收到上述Configure-Request报文后，认为其中包含的地址（0.0.0.0）不合法，使用Configure-Nak回应一个新的IP地址12.1.1.1；</li>
<li>R1收到此Configure-Nak报文之后，更新本地IP地址，并重新发送一个Configure-Request报文，包含新的IP地址12.1.1.1；</li>
<li>R2收到Configure-Request报文后，认为其中包含的IP地址为合法地址，回应一个Configure-Ack报文；</li>
<li>同时，R2也要向R1发送Configure-Request报文请求使用地址12.1.1.2，R1认为此地址合法，回应Configure-Ack报文。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/40.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/41.png"></p>
<blockquote>
<p>MultiLink PPP允许将报文分片，分片将从多个点对点链路上送到同一个目的地。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/42.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/43.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>ppp authentication-mode命令用来设置本端PPP协议对对端设备的认证方式。</li>
<li>ppp chap user命令用来配置CHAP验证的用户名。</li>
<li>ppp chap password命令用来配置CHAP验证的口令。</li>
<li>ip address ppp-negotiate命令用来为本端接口配置IP地址可协商属性，使本端接口接受PPP协商产生的由对端分配的IP地址。</li>
<li>remote address命令用来配置为对端分配IP地址或指定地址池。</li>
</ul>
</li>
<li><p>ppp authentication-mode { chap | pap }</p>
<ul>
<li>chap：采用CHAP认证方式。</li>
<li>pap：采用PAP认证方式。</li>
</ul>
</li>
<li><p>ppp chap user username</p>
<ul>
<li>username：设置CHAP验证的用户名。</li>
</ul>
</li>
<li><p>ppp chap password { cipher | simple } password</p>
<ul>
<li>cipher：表示密码为密文显示。</li>
<li>simple：表示密码为明文显示。</li>
<li>password：设置CHAP认证的口令。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/44.png"></p>
<blockquote>
<ul>
<li>命令含义<ul>
<li>interface mp-group命令用来创建一个MP-Group类型的接口并进入MP-Group接口视图。</li>
<li>ppp mp mp-group命令用来将接口加入指定的MP-group，使该接口工作在MP方式。</li>
<li>restart命令用来重新启动当前接口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/45.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/46.png"></p>
<blockquote>
<ul>
<li>Trunk接口分为Eth-Trunk和IP-Trunk两种。<ul>
<li>Eth-Trunk只能由以太网链路构成。</li>
<li>IP-Trunk一般由POS接口构成。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/47.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/48.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/49.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/50.png"></p>
<blockquote>
<ul>
<li>PPPoE概述<ul>
<li>PPPoE利用以太网将大量主机组成网络，通过一个远端接入设备连入因特网，并运用PPP协议对接入的每个主机进行控制，具有适用范围广、安全性高、计费方便的特点。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/51.png"></p>
<blockquote>
<ul>
<li><p>PPPoE可分为三个阶段，即Discovery阶段、Session阶段和Terminate阶段。</p>
</li>
<li><p>Discovery阶段：</p>
<ul>
<li>PPPoE Client广播发送一个PADI（PPPoE Active Discovery Initial）报文，在此报文中包含PPPoE Client想要得到的服务类型信息。</li>
<li>所有的PPPoE Server收到PADI报文之后，将其中请求的服务与自己能够提供的服务进行比较，如果可以提供，则单播回复一个PADO（PPPoE Active Discovery Offer）报文。</li>
<li>根据网络的拓扑结构，PPPoE Client可能收到多个PPPoE Server发送的PADO报文，PPPoE Client选择最先收到的PADO报文对应的PPPoE Server做为自己的PPPoE Server，并单播发送一个PADR（PPPoE Active Discovery Request）报文。</li>
<li>PPPoE Server产生一个唯一的会话ID（Session ID），标识和PPPoE Client的这个会话，通过发送一个PADS（PPPoE Active Discovery Session-confirmation）报文把会话ID发送给PPPoE Client，会话建立成功后便进入PPPoE Session阶段。</li>
<li>完成后通信双方都会知道PPPoE的Session_ID及对方MAC，它们共同确定唯一的PPPoE Session。</li>
</ul>
</li>
<li><p>Seesion阶段：</p>
<ul>
<li>PPPoE Session上的PPP协商和普通的PPP协商方式一致。PPPoE Session的PPP协商成功后，就可以承载PPP数据报文。在PPPoE Session阶段所有的以太网数据包都是单播发送的。</li>
</ul>
</li>
<li><p>Terminate阶段：</p>
<ul>
<li>进入PPPoE Session阶段后，PPPoE Client和PPPoE Server都可以通过发送PADT报文的方式来结束PPPoE连接。PADT数据包可以在会话建立以后的任意时刻单播发送。在发送或接收到PADT后，就不允许再使用该会话发送PPP流量了。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/52.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/53.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/54.png"></p>
<blockquote>
<p>此例中，R1模拟PPPoE客户机PC进行PPPoE拨号上网，R4作为PPPoE Server对其进行验证和地址分配。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/55.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/" itemprop="url">IE-LAN技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-20T17:56:08+08:00">
                2021-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%871.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%872.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%873.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%874.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%875.png"></p>
<blockquote>
<p>MAC地址表的定义</p>
<ul>
<li>MAC地址表记录了交换机学习到的其他设备的MAC地址与接口的对应关系，以及接口所属VLAN等信息。设备在转发报文时，根据报文的目的MAC地址查询MAC地址表，如果MAC地址表中包含与报文目的MAC地址对应的表项，则直接通过该表项中的出接口转发该报文；如果MAC地址表中没有包含报文目的MAC地址对应的表项时，设备将采取广播方式在所属VLAN内除接收接口外的所有接口转发该报文。</li>
</ul>
<p>MAC地址表中的表项分为：动态表项、静态表项和黑洞表项。</p>
<ul>
<li><p>动态表项：由接口通过报文中的源MAC地址学习获得，表项可老化。在系统复位、接口板热插拔或接口板复位后，动态表项会丢失。可以通过查看动态MAC地址表项，可以判断两台相连设备之间是否有数据转发；也可以通过查看指定动态MAC地址表项的个数，可以获取接口下通信的用户数。</p>
</li>
<li><p>静态表项：由用户手工配置，并下发到各接口板，表项不可老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。一条静态MAC地址表项，只能绑定一个出接口。一个接口和MAC地址静态绑定后，不会影响该接口动态MAC地址表项的学习。通过绑定静态MAC地址表项，可以保证合法用户的使用，防止其他用户使用该MAC进行攻击。</p>
</li>
<li><p>黑洞表项：由用户手工配置，并下发到各接口板，表项不可老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。通过配置黑洞MAC地址表项，可以过滤掉非法用户。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%876.png"></p>
<blockquote>
<p>通过“display mac-address”命令，可以查看设备的mac表项，如图所示，mac表的组成可以分为动态、静态和黑洞。从表项中也可以看出，mac地址所对应的VLAN以及VSI。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%877.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%878.png"><br><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%879.png"></p>
<blockquote>
<ul>
<li><p>接口使能端口安全功能时，接口上之前学习到的动态MAC地址表项将被删除，之后学习到的MAC地址将变为安全动态MAC地址。</p>
</li>
<li><p>接口使能Sticky MAC功能时，接口上的安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>接口去使能端口安全功能时，接口上的安全动态MAC地址将被删除，重新学习动态MAC地址。</p>
</li>
<li><p>接口去使能Sticky MAC功能时，接口上的Sticky MAC地址，会转换为安全动态MAC地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8710.png"></p>
<blockquote>
<p>说明：</p>
<ul>
<li><p>接口使能Sticky MAC功能，安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>接口使能Sticky MAC功能，即使配置了port-security aging-time，Sticky MAC也不会被老化。</p>
</li>
<li><p>Sticky MAC地址表项，保存后重启设备不丢弃。</p>
</li>
</ul>
<p>端口安全的保护动作：</p>
<ul>
<li><p>Restrict：丢弃源MAC地址不存在的报文并上报告警。推荐使用restrict动作。</p>
</li>
<li><p>Protect：只丢弃源MAC地址不存在的报文，不上报告警。</p>
</li>
<li><p>Shutdown：接口状态被置为error-down，并上报告警。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8711.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8712.png"></p>
<blockquote>
<ul>
<li><p>如图所示，MAC地址为0011-0022-0034的表项，出接口由GE1/0/1刷新为GE1/0/2，这就是MAC地址漂移。设备出现MAC地址漂移时，设备CPU占用率会有不同程度的升高。正常情况下，网络中不会在短时间内出现大量MAC地址漂移的情况。出现这种现象一般都意味着网络中存在环路，可以通过查看告警信息和漂移记录，快速定位和排除环路。</p>
</li>
<li><p>网络中产生环路或非法用户进行网络攻击都会造成MAC地址发生漂移，导致MAC地址不稳定。在规划网络时，可以通过下面两种方式来避免这种情况：</p>
<ul>
<li>提高接口MAC地址学习优先级。当不同接口学到相同的MAC地址表项时，高优先级接口学到的MAC地址表项可以覆盖低优先级接口学到的MAC地址表项，防止MAC地址在接口间发生漂移。</li>
<li>不允许相同优先级的接口发生MAC地址表项覆盖。当伪造网络设备所连接口的优先级与安全的网络设备相同时，后学习到的伪造网络设备的MAC地址表项不会覆盖之前正确的表项。但如果网络设备下电，仍会学习到伪造网络设备的MAC地址，当网络设备再次上电时将无法学习到正确的MAC地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8713.png"></p>
<blockquote>
<ul>
<li><p>配置MAC地址漂移检测功能后，在发生MAC地址漂移时，可以上报包括MAC地址、VLAN，以及跳变的接口等信息的告警。其中跳变的接口即为可能出现环路的接口。网络管理员可以根据告警信息，手工排查网络中环路的源头，也可以使用MAC漂移检测提供的后续动作，使跳变的端口down或者VLAN从端口中退出，实现自动破环。</p>
</li>
<li><p>如图所示网络中，若SwitchC和SwitchD之间误接网线，则SwitchB、SwitchC、SwitchD之间形成环路。当SwitchA上Port1接口从网络中收到一个广播报文后转发给SwitchB，该报文经过环路，会被SwitchA上Port2接口收到。配置MAC地址漂移检测功能，SwitchA就会感知到MAC地址出接口跳变的现象。若连续出现此现象，SwitchA就会上报MAC漂移告警，提醒管理员进行维护。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8714.png"></p>
<blockquote>
<ul>
<li><p>接口配置不同的MAC地址学习优先级后，如果不同接口学到相同的MAC地址表项，那么高优先级接口学到的MAC地址表项可以覆盖低优先级接口学到的MAC地址表项，防止MAC地址发生漂移。</p>
</li>
<li><p>配置不允许相同优先级的接口发生MAC地址表项覆盖，也可以防止MAC地址漂移，提高网络的安全性。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8715.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8716.png"></p>
<blockquote>
<p>免费ARP有如下作用：</p>
<ul>
<li>IP地址冲突检测：当设备接口的协议状态变为Up时，设备主动对外发送免费ARP报文。正常情况下不会收到ARP应答，如果收到，则表明本网络中存在与自身IP地址重复的地址。如果检测到IP地址冲突，设备会周期性的广播发送免费ARP应答报文，直到冲突解除。</li>
<li>用于通告一个新的MAC地址：发送方更换了网卡，MAC地址变化了，为了能够在动态ARP表项老化前通告网络中其他设备，发送方可以发送一个免费ARP。</li>
<li>在VRRP备份组中用来通告主备发生变换：发生主备变换后，MASTER设备会广播发送一个免费ARP报文来通告发生了主备变换。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8717.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8718.png"></p>
<blockquote>
<ul>
<li><p>在STP和RSTP的算法中，所有VLAN共享一课生成树，会造成部分VLAN无法通信、次优路径、流量无法负载分担等问题。</p>
</li>
<li><p>为了弥补STP和RSTP的缺陷，IEEE于2002年发布的802.1S标准定义了MSTP。MSTP兼容STP和RSTP，既可以快速收敛，又提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8719.png"></p>
<blockquote>
<ul>
<li><p>所谓生成树实例就是多个VLAN的一个集合。通过将多个VLAN捆绑到一个实例，可以节省通信开销和资源占用率。MSTP各个实例拓扑的计算相互独立，在这些实例上可以实现负载均衡。可以把多个相同拓扑结构的VLAN映射到一个实例里，这些VLAN在端口上的转发状态取决于端口在对应MSTP实例的状态。</p>
</li>
<li><p>如图所示，MSTP通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。</p>
</li>
<li><p>经计算，最终生成两棵生成树：</p>
<ul>
<li>MSTI1以S4为根交换设备，转发VLAN2的报文。</li>
<li>MSTI2以S6为根交换设备，转发VLAN3的报文。</li>
</ul>
</li>
<li><p>这样所有VLAN内部可以互通，同时不同VLAN的报文沿不同的路径转发，实现了负载分担。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8720.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8721.png"></p>
<blockquote>
<ul>
<li><p>MST由交换网络中的多台交换设备以及它们间的网段所构成。MSTI是MST域下实例，一个MST域下可以有多个MSTI。</p>
</li>
<li><p>VLAN映射表描述了VLAN和MSTI之间的映射关系。如图2所示，MST Region4中，VLAN1映射到MSTI1，VLAN2映射到MSTI2，其余VLAN映射到MSTI3。</p>
</li>
<li><p>公共生成树CST是连接交换网络内所有MST域的一棵生成树。如果把每个MST域看作是一个节点，CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树。</p>
</li>
<li><p>内部生成树IST（Internal Spanning Tree）是各MST域内的一棵生成树。IST是一个特殊的MSTI，MSTI的ID为0，通常称为MSTI0。</p>
</li>
<li><p>SST（Single Spanning Tree）：运行STP或RSTP的交换设备只能属于一个生成树；MST域中只有一个交换设备，这个交换设备构成单生成树。</p>
</li>
<li><p>所有MST域的IST加上CST就构成一棵完整的生成树，即CIST。</p>
</li>
<li><p>域根（Regional Root）分为IST域根和MSTI域根。</p>
<ul>
<li>IST域根如图1所示，在MST域中IST生成树中距离总根最近的交换设备是IST域根。</li>
<li>一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI。MSTI域根是每个多生成树实例的树根。如图3所示，域中不同的MSTI有各自的域根。</li>
</ul>
</li>
<li><p>总根是CIST（Common and Internal Spanning Tree）的根桥。如图1中的S1。</p>
</li>
<li><p>主桥（Master Bridge）也就是IST Master，它是域内距离总根最近的交换设备。如图1中的黄色交换机。如果总根在MST域中，则总根为该域的主桥。</p>
</li>
<li><p>端口角色：同RSTP，MSTP中定义了根端口、指定端口、Alternate端口、Backup端口和边缘端口。</p>
</li>
<li><p>端口状态：同RSTP，MSTP定义的端口状态有Forwarding, Learning, Discarding。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8722.png"></p>
<blockquote>
<p>MSTI的特点：</p>
<ul>
<li>每个MSTI独立计算自己的生成树，互不干扰。</li>
<li>每个MSTI的生成树计算方法与STP基本相同。</li>
<li>每个MSTI的生成树可以有不同的根，不同的拓扑。</li>
<li>每个MSTI在自己的生成树内发送BPDU。</li>
<li>每个MSTI的拓扑通过命令配置决定。</li>
<li>每个端口在不同MSTI上的生成树参数可以不同。</li>
<li>每个端口在不同MSTI上的角色、状态可以不同。</li>
</ul>
<p>在运行MSTP协议的网络中，一个VLAN报文将沿着如下路径进行转发：</p>
<ul>
<li><p>在MST域内，沿着其对应的MSTI转发。</p>
</li>
<li><p>在MST域间，沿着CST转发。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8723.png"></p>
<blockquote>
<ul>
<li><p>如图所示，在MSTP中，P/A机制工作过程如下：</p>
<p>1.上游设备发送Proposal报文，请求进行快速迁移。下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口。</p>
<p>2.上游设备继续发送Agreement报文。下游设备接收到后，根端口转为Forwarding状态。</p>
<p>3.下游设备回应Agreement报文。上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</p>
</li>
<li><p>缺省情况下，华为数据通信设备使用增强的快速迁移机制。如果华为数据通信设备和其他制造商的设备进行互通，而其他制造商的设备P/A机制使用普通的快速迁移机制，此时，可在华为数据通信设备上通过设置P/A机制为普通的快速迁移机制，从而实现华为数据通信设备和其他制造商的设备进行互通。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8724.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8725.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8726.png"></p>
<blockquote>
<ul>
<li><p>如图所示，为园区网络CSS+iStack组网之一，其主要有简单、高效、可靠的特点。</p>
</li>
<li><p>简单</p>
<ul>
<li>各层设备均使用堆叠技术，逻辑设备少，网络拓扑简单，二层天然无环，无需部署xSTP破环协议。</li>
</ul>
</li>
<li><p>高效</p>
<ul>
<li>各层设备间使用Eth-Trunk链路聚合技术，负载分担算法灵活，链路利用率高。</li>
</ul>
</li>
<li><p>可靠</p>
<ul>
<li>服务器和主机可以配置多NIC网卡Teaming负载均衡或主备冗余链路提高服务器接入可靠性。</li>
<li>堆叠技术同链路聚合技术结合使用，各层物理设备形成双归接入组网，提高整网可靠性。</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><p>对设备性能要求较高，盒式设备堆叠台数过多，可能导致堆叠主的主控性能下降。</p>
</li>
<li><p>如果采用业务口堆叠或集群，会占用业务端口数。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8727.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8728.png"></p>
<blockquote>
<ul>
<li>通过交换机堆叠，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。<ul>
<li>高可靠性。堆叠系统多台成员交换机之间冗余备份；堆叠支持跨设备的链路聚合功能，实现跨设备的链路冗余备份。</li>
<li>强大的网络扩展能力。通过增加成员交换机，可以轻松的扩展堆叠系统的端口数、带宽和处理能力；同时支持成员交换机热插拔，新加入的成员交换机自动同步主交换机的配置文件和系统软件版本。</li>
<li>简化配置和管理。一方面，用户可以通过任何一台成员交换机登录堆叠系统，对堆叠系统所有成员交换机进行统一配置和管理；另一方面，堆叠形成后，不需要配置复杂的二层破环协议和三层保护倒换协议，简化了网络配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8729.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8730.png"></p>
<blockquote>
<ul>
<li><p>“系统自动完成堆叠”实际上可以细分为三步：</p>
<p>1.主交换机选举</p>
<p>​    ①运行状态比较，已经运行的交换机比处于启动状态的交换机优先竞争为主交换机。</p>
<p>​    ②堆叠优先级高的交换机优先竞争为主交换机。</p>
<p>​    ③堆叠优先级相同时，MAC地址小的交换机优先竞争为主交换机。</p>
<p>2.拓扑收集和备交换机选举</p>
<ul>
<li>主交换机选举完成后，主交换机会收集所有成员交换机的拓扑信息，根据拓扑信息计算出堆叠转发表项和破环点信息下发给堆叠中的所有成员交换机，并向所有成员交换机分配堆叠ID。之后进行备交换机的选举，作为主交换机的备份交换机。当除主交换机外其它交换机同时完成启动时：<ul>
<li>堆叠优先级最高的设备成为备交换机。</li>
<li>堆叠优先级相同时，MAC地址最小的成为备交换机。</li>
</ul>
</li>
</ul>
<p>3.稳定运行</p>
<ul>
<li>角色选举、拓扑收集完成之后，剩下的其他成员交换机作为从交换机加入堆叠，所有成员交换机会自动同步主交换机的系统软件和配置文件：<ul>
<li>堆叠具有自动加载系统软件的功能，待组成堆叠的成员交换机不需要具有相同软件版本，只需要版本间兼容即可。当备交换机或从交换机与主交换机的软件版本不一致时，备交换机或从交换机会自动从主交换机下载系统软件，然后使用新系统软件重启，并重新加入堆叠。</li>
<li>堆叠具有配置文件同步机制，备交换机或从交换机会将主交换机的配置文件同步到本设备并执行，以保证堆叠中的多台设备能够像一台设备一样在网络中工作，并且在主交换机出现故障之后，其余交换机仍能够正常执行各项功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8731.png"></p>
<blockquote>
<ul>
<li><p>物理成员端口</p>
<ul>
<li>成员交换机之间用于堆叠连接的物理端口。物理成员端口用于转发需要跨成员交换机的业务报文或成员交换机之间的堆叠协议报文。</li>
</ul>
</li>
<li><p>逻辑堆叠端口</p>
<ul>
<li>逻辑堆叠端口是专用于堆叠的逻辑端口，需要和物理成员端口绑定。堆叠的每台成员交换机上支持两个逻辑堆叠端口，分别为stack-port n/1和stack-port n/2，其中n为成员交换机的堆叠ID。</li>
</ul>
</li>
<li><p>业务口堆叠根据连接线缆的不同又可以分为：普通线缆堆叠和专用线缆堆叠。</p>
<ul>
<li>普通线缆堆叠<ul>
<li>普通堆叠线缆包括：光线缆、网线和高速电缆。使用普通线缆堆叠时，逻辑堆叠端口需要手动进行配置，否则无法组建堆叠。</li>
</ul>
</li>
<li>专用线缆堆叠<ul>
<li>专用堆叠线缆的两端区分主和备，带有Master标签的一端为主端，不带有标签的一端为备端。使用专用线缆堆叠时，专用堆叠线缆按照规则插入端口后，交换机就可以自动组建堆叠。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8732.png"></p>
<blockquote>
<ul>
<li><p>堆叠成员加入是指向已经稳定运行的堆叠系统添加一台新的交换机。</p>
</li>
<li><p>使能堆叠并配置好SWD的堆叠参数</p>
<ul>
<li>如果是业务口堆叠，新加入的交换机需要配置物理成员端口加入逻辑堆叠端口；并且链形连接时，当前堆叠系统链形两端（或一端）的成员交换机也需要配置物理成员端口加入逻辑堆叠口。</li>
<li>如果是堆叠卡堆叠，新加入的成员交换机需要使能堆叠功能。</li>
<li>为了便于管理，建议为新加入的交换机配置堆叠ID。如果不配置，堆叠系统会为其分配一个堆叠ID。</li>
</ul>
</li>
<li><p>将SWD连接到堆叠系统</p>
<ul>
<li>如果是链形连接，新加入的交换机建议添加到链形的两端，这样对现有的业务影响最小。</li>
<li>如果是环形连接，需要把当前环形拆成链形，然后在链形的两端添加设备。</li>
</ul>
</li>
<li><p>系统完成堆叠</p>
<p>1.新加入的交换机连线上电启动后，进行角色选举，新加入的交换机会选举为从交换机，堆叠系统中原有主备从角色不变。</p>
<p>2.角色选举结束后，主交换机更新堆叠拓扑信息，同步到其他成员交换机上，并向新加入的交换机分配堆叠ID（新加入的交换机没有配置堆叠ID或配置的堆叠ID与原堆叠系统的冲突时）。</p>
<p>3.新加入的交换机更新堆叠ID，并同步主交换机的配置文件和系统软件，之后进入稳定运行状态。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8733.png"></p>
<blockquote>
<ul>
<li><p>堆叠合并是指稳定运行的两个堆叠系统合并成一个新的堆叠系统。如图所示，两个堆叠系统的主交换机SWA和SWD通过竞争，选举出一个更优的作为新堆叠系统的主交换机。竞争成功的主交换机SWA所在的堆叠系统将保持原有主备从角色和配置不变，业务也不会受到影响；而另外一个堆叠系统的所有成员交换机SWD和SWE将重新启动，以从交换机的角色加入到新堆叠系统，其堆叠ID将由新主交换机重新分配，并将同步新主交换机的配置文件和系统软件，该堆叠系统的原有业务也将中断。</p>
</li>
<li><p>堆叠合并通常在以下两种情形下出现：</p>
<ul>
<li>堆叠链路或设备故障导致堆叠分裂，链路或设备故障恢复后，分裂的堆叠系统重新合并。</li>
<li>待加入堆叠系统的交换机配置了堆叠功能，在不下电的情况下，使用堆叠线缆连接到正在运行的堆叠系统。通常情况下，不建议使用该方式形成堆叠，因为在合并前过程中可能会导致正在运行的堆叠系统重启，影响业务运行。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8734.png"></p>
<blockquote>
<p>堆叠成员退出是指成员交换机从堆叠系统中离开。根据退出成员交换机角色的不同，对堆叠系统的影响也有所不同：</p>
<ul>
<li>当主交换机退出，备份交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，指定新的备交换机，之后进入稳定运行状态。</li>
<li>当备交换机退出，主交换机重新指定备交换机，重新计算堆叠拓扑并同步到其他成员交换机，之后进入稳定运行状态。</li>
<li>当从交换机退出，主交换机重新计算堆叠拓扑并同步到其他成员交换机，之后进入稳定运行状态。</li>
</ul>
<p>堆叠成员交换机退出的过程，主要就是拆除堆叠线缆和移除交换机的过程：</p>
<ul>
<li>对于环形堆叠：成员交换机退出后，为保证网络的可靠性还需要把退出交换机连接的两个端口通过堆叠线缆进行连接。</li>
<li>对于链形堆叠：拆除中间交换机会造成堆叠分裂。这时需要在拆除前进行业务分析，尽量减少对业务的影响。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8735.png"></p>
<blockquote>
<p>堆叠分裂是指稳定运行的堆叠系统中带电移出部分成员交换机，或者堆叠线缆多点故障导致一个堆叠系统变成多个堆叠系统。根据原堆叠系统主备交换机分裂后所处位置的不同，堆叠分裂可分为以下两类：</p>
<ul>
<li><p>堆叠分裂后，原主备交换机被分裂到同一个堆叠系统中：原主交换机会重新计算堆叠拓扑，将移出的成员交换机的拓扑信息删除，并将新的拓扑信息同步给其他成员交换机；而移出的成员交换机检测到堆叠协议报文超时，将自行复位，重新进行选举。</p>
</li>
<li><p>堆叠分裂后，原主备交换机被分裂到不同的堆叠系统中：原主交换机所在堆叠系统重新指定备交换机，重新计算拓扑信息并同步给其他成员交换机；原备交换机所在堆叠系统将发生备升主，原备交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，并指定新的备交换机。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8736.png"></p>
<blockquote>
<ul>
<li><p>由于堆叠系统中所有成员交换机都使用同一个IP地址和MAC地址（堆叠系统MAC），一个堆叠分裂后，可能产生多个具有相同IP地址和MAC地址的堆叠系统。为防止堆叠分裂后，产生多个具有相同IP地址和MAC地址的堆叠系统，引起网络故障，必须进行IP地址和MAC地址的冲突检查。多主检测MAD（Multi-Active Detection），是一种检测和处理堆叠分裂的协议。链路故障导致堆叠系统分裂后，MAD可以实现堆叠分裂的检测、冲突处理和故障恢复，降低堆叠分裂对业务的影响。</p>
</li>
<li><p>MAD检测方式有两种：直连检测方式和代理检测方式。在同一个堆叠系统中，两种检测方式互斥，不可以同时配置。</p>
</li>
<li><p>直连检测方式是指堆叠成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，堆叠系统正常运行时，不发送MAD报文；堆叠系统分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>通过中间设备直连：堆叠系统的所有成员交换机之间至少有一条检测链路与中间设备相连。</p>
</li>
<li><p>Full-mesh方式直连：堆叠系统的各成员交换机之间通过检测链路建立Full-mesh全连接，即每两台成员交换机之间至少有一条检测链路。</p>
</li>
<li><p>通过中间设备直连可以实现通过中间设备缩短堆叠成员交换机之间的检测链路长度，适用于成员交换机相距较远的场景。与通过中间设备直连相比，Full-mesh方式直连可以避免由中间设备故障导致的MAD检测失败，但是每两台成员交换机之间都建立全连接会占用较多的接口，所以该方式适用于成员交换机数目较少的场景。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8737.png"></p>
<blockquote>
<ul>
<li><p>代理检测方式是在堆叠系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求堆叠系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
</li>
<li><p>在代理检测方式中，堆叠系统正常运行时，堆叠成员交换机以30s为周期通过检测链路发送MAD报文。堆叠成员交换机对在正常工作状态下收到的MAD报文不做任何处理；堆叠分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>MAD冲突处理</p>
<ul>
<li>堆叠分裂后，MAD冲突处理机制会使分裂后的堆叠系统处于Detect状态或Recovery状态。Detect状态表示堆叠正常工作状态，Recovery状态表示堆叠禁用状态。</li>
<li>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在多个处于Detect状态的堆叠系统，这些堆叠系统之间相互竞争，竞争成功的堆叠系统保持Detect状态，竞争失败的堆叠系统会转入Recovery状态；并且在Recovery状态堆叠系统的所有成员交换机上，关闭除保留端口以外的其它所有物理端口，以保证该堆叠系统不再转发业务报文。</li>
</ul>
</li>
<li><p>MAD故障恢复</p>
</li>
<li><p>通过修复故障链路，分裂后的堆叠系统重新合并为一个堆叠系统。重新合并的方式有以下两种：</p>
<ul>
<li>堆叠链路修复后，处于Recovery状态的堆叠系统重新启动，与Detect状态的堆叠系统合并，同时将被关闭的业务端口恢复Up，整个堆叠系统恢复。</li>
<li>如果故障链路修复前，承载业务的Detect状态的堆叠系统也出现了故障。此时，可以先将Detect状态的堆叠系统从网络中移除，再通过命令行启用Recovery状态的堆叠系统，接替原来的业务，然后再修复原Detect状态堆叠系统的故障及链路故障。故障修复后，重新合并堆叠系统。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8738.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8739.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8740.png"></p>
<blockquote>
<ul>
<li><p>CSS与iStack的区别在于，一般框式交换机堆叠称为CSS，盒式交换机堆叠称为iStack，都可以称为堆叠。两者只是叫法和实现有些差异，但是功能是一样的。</p>
</li>
<li><p>通过交换机集群，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。</p>
<ul>
<li>高可靠性：集群系统两台成员交换机之间冗余备份，同时利用链路聚合功能实现跨设备的链路冗余备份。</li>
<li>强大的网络扩展能力：通过组建集群增加交换机，从而轻松的扩展端口数、带宽和处理能力。</li>
<li>简化配置和管理：集群建立后，两台物理设备虚拟成为一台设备，用户只需登录一台成员交换机即可对集群系统所有成员交换机进行统一配置和管理。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8741.png"></p>
<blockquote>
<p>不同于iStack可以多台设备堆叠，对于CSS集群，集群中只能有一主一备两台交换机。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8742.png"></p>
<blockquote>
<ul>
<li><p>集群建立时，成员交换机间相互发送集群竞争报文，通过竞争，一台成为主交换机，负责管理整个集群系统，另一台则成为备交换机。</p>
</li>
<li><p>角色选举</p>
<p>1.最先完成启动，并进入单框集群运行状态的交换机成为主交换机。</p>
<p>2.当两台交换机同时启动时，集群优先级高的交换机成为主交换机。</p>
<p>3.当两台交换机同时启动，且集群优先级又相同时，MAC地址小的交换机成为主交换机。</p>
<p>4.当两台交换机同时启动，且集群优先级和MAC都相同时，集群ID小的交换机成为主交换机。</p>
</li>
<li><p>版本同步</p>
<ul>
<li>集群具有自动加载系统软件的功能，待组成集群的成员交换机不需要具有相同的软件版本，只需要版本间兼容即可。当主交换机选举结束后，如果备交换机与主交换机的软件版本号不一致时，备交换机会自动从主交换机下载系统软件，然后使用新的系统软件重启，并重新加入集群。</li>
</ul>
</li>
<li><p>配置同步</p>
<ul>
<li>集群具有严格的配置文件同步机制，来保证集群中的多台交换机能够像一台设备一样在网络中工作。</li>
</ul>
</li>
<li><p>配置备份</p>
<ul>
<li>交换机从非集群状态进入集群状态后，会自动将原有的非集群状态下的配置文件加上.bak的扩展名进行备份，以便去使能集群功能后，恢复原有配置。例如，原配置文件扩展名为.cfg，则备份配置文件扩展名为.cfg.bak。去使能交换机集群功能时，用户如果希望恢复交换机的原有配置，可以更改备份配置文件名并指定其为下一次启动的配置文件，然后重新启动交换机，恢复原有配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8743.png"></p>
<blockquote>
<ul>
<li><p>物理成员端口</p>
<ul>
<li>成员交换机之间用于集群连接的普通业务口。物理成员端口用于转发需要跨成员交换机的业务报文或成员交换机之间的集群协议报文。</li>
</ul>
</li>
<li><p>逻辑集群端口</p>
<ul>
<li>逻辑集群端口是专用于集群的逻辑端口，需要和物理成员端口绑定。集群的每台成员交换机上支持两个逻辑集群端口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8744.png"></p>
<blockquote>
<ul>
<li><p>使能了集群功能的单台交换机即为单框集群。</p>
<ul>
<li>集群成员加入是指向稳定运行的单框集群系统中添加一台新的交换机。如图1所示，新交换机SwitchB将加入单框集群系统从而形成新的集群系统。原单框集群的交换机成为主交换机，新加入的交换机成为备交换机。</li>
</ul>
</li>
<li><p>集群加入通常在以下两种情形下出现：</p>
<ul>
<li>在建立集群时，先将一台交换机使能集群功能后重启，重启后这台交换机将进入单框集群状态。然后再使能另外一台交换机的集群功能后重启，则后启动的交换机则按照集群成员加入的流程加入集群系统，成为备交换机。</li>
<li>在稳定运行的两框集群场景中，将其中一台交换机重启，则这台交换机将以集群成员加入的流程重新加入集群系统，并成为备交换机。</li>
</ul>
</li>
<li><p>集群合并是指稳定运行的两个单框集群系统合并成一个新的集群系统。如图2所示，两个单框集群系统将自动选出一个更优的作为合并后集群系统的主交换机。被选为主交换机的配置不变，业务也不会受到影响，框内的备用主控板将重启。而备交换机将整框重启，以集群备的角色加入新的集群系统，并将同步主交换机的配置，该交换机原有的业务也将中断。</p>
</li>
<li><p>集群合并通常在以下两种情形下出现：</p>
<ul>
<li>将两台交换机分别使能集群功能后重启（重启后的两台交换机都属于单框集群），再使用集群线缆将两台交换机连接，之后会进入集群合并流程。</li>
<li>集群链路或设备故障导致集群分裂。故障恢复后，分裂后的两个单框集群系统重新合并。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8745.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8746.png"></p>
<blockquote>
<ul>
<li><p>由于集群系统中所有成员交换机都使用同一个IP地址和MAC地址（集群系统MAC），一个集群分裂后，由于这些成员交换机运行着相同的配置文件（即原集群系统的配置文件），就会产生两个具有相同IP地址和MAC地址的集群系统。为防止集群分裂后，产生两个具有相同IP地址和MAC地址的集群系统，引起网络故障，必须进行IP地址和MAC地址的冲突检查。</p>
</li>
<li><p>多主检测MAD（Multi-Active Detection），是一种检测和处理集群分裂的协议。链路故障导致集群系统分裂后，MAD可以实现集群分裂的检测、冲突处理和故障恢复，降低集群分裂对业务的影响。</p>
</li>
<li><p>MAD检测方式有两种：直连检测方式和代理检测方式。在同一个集群系统中，两种检测方式互斥，不可以同时配置。</p>
</li>
<li><p>直连检测方式是指集群成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，集群系统正常运行时，不发送MAD报文；集群系统分裂后，分裂后的两台交换机周期性地通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>直连检测的连接方式包括通过中间设备直连和集群成员交换机直接直连：</p>
<ul>
<li>通过中间设备直连：集群系统的成员交换机之间至少有一条检测链路与中间设备相连。此种方式适用于成员交换机相距较远的场景。</li>
<li>直接直连：集群成员交换机直接直连可以避免由中间设备故障导致MAD检测失败。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8747.png"></p>
<blockquote>
<ul>
<li><p>代理检测方式是在集群系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求集群系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
</li>
<li><p>在代理检测方式中，集群系统正常运行时，集群成员交换机以30s为周期通过检测链路发送MAD报文。集群成员交换机对在正常工作状态下收到的MAD报文不做任何处理；集群分裂后，分裂后的两台交换机周期性地通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>MAD冲突处理</p>
<ul>
<li>集群分裂后，MAD冲突处理机制会使分裂后的单框集群系统处于Detect状态或Recovery状态。Detect状态表示集群正常工作状态，Recovery状态表示集群禁用状态。</li>
<li>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在两个处于Detect状态的集群系统即两台交换机，此时会进行集群优先级比较（优先级相同比较MAC地址，MAC地址相同则比较集群ID），优先级高的交换机将成为主交换机继续正常工作，另一台交换机会转入Recovery状态；并且在Recovery状态的交换机上，关闭除保留端口以外的其它所有物理端口，以保证该交换机不再转发业务报文。</li>
</ul>
</li>
<li><p>MAD故障恢复</p>
</li>
<li><p>通过修复故障链路，分裂后的集群系统重新合并为一个集群系统。重新合并的方式有以下两种：</p>
<ul>
<li>集群链路修复后，处于Recovery状态的集群系统重新启动，与Detect状态的集群系统合并，同时将被关闭的业务端口恢复Up，整个集群系统恢复。</li>
<li>如果故障链路修复前，承载业务的Detect状态的集群系统也出现了故障。此时，可以先将Detect状态的集群系统从网络中移除，再通过命令行启用Recovery状态的集群系统，接替原来的业务，然后再修复原Detect状态集群系统的故障。故障修复后，重新合并集群系统。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8748.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8749.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8750.png"></p>
<blockquote>
<ul>
<li><p>链路聚合技术主要有以下三个优势：增加带宽、提高可靠性和负载分担。</p>
</li>
<li><p>链路聚合组和成员接口</p>
<ul>
<li>链路聚合组LAG是指将若干条以太链路捆绑在一起所形成的逻辑链路。组成Eth-Trunk接口的各个物理接口称为成员接口。</li>
</ul>
</li>
<li><p>活动接口和非活动接口、活动链路和非活动链路</p>
<ul>
<li>链路聚合组的成员接口存在活动接口和非活动接口两种。转发数据的接口称为活动接口，不转发数据的接口称为非活动接口。</li>
<li>活动接口对应的链路称为活动链路，非活动接口对应的链路称为非活动链路。</li>
</ul>
</li>
<li><p>活动接口数上限阈值</p>
<ul>
<li>当前活动链路数目达到上限阈值时，再向Eth-Trunk中添加成员接口，不会增加Eth-Trunk活动接口的数目，超过上限阈值的链路状态将被置为Down，作为备份链路。</li>
</ul>
</li>
<li><p>活动接口数下限阈值</p>
<ul>
<li>设置活动接口数下限阈值是为了保证最小带宽，当前活动链路数目小于下限阈值时，Eth-Trunk接口的状态转为Down。</li>
</ul>
</li>
<li><p>设备支持的链路聚合方式</p>
<ul>
<li>同板：是指链路聚合时，同一聚合组的成员接口分布在同一单板上。</li>
<li>跨板：是指链路聚合时，同一聚合组的成员接口分布在不同的单板上。</li>
<li>跨框：是指在集群场景下，成员接口分布在集群的各个成员设备上。</li>
<li>跨设备：是指E-Trunk基于LACP进行了扩展，能够实现多台设备间的链路聚合。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8751.png"></p>
<blockquote>
<ul>
<li><p>Eth-Trunk模块根据转发表转发数据帧的过程如下：</p>
<p>1.Eth-Trunk模块从MAC子层接收到一个数据帧后，根据负载分担方式提取数据帧的源MAC地址/IP地址或目的MAC地址/IP地址。</p>
<p>2.根据HASH算法进行计算，得到HASH-KEY值。</p>
<p>3.Eth-Trunk模块根据HASH-KEY值在转发表中查找对应的接口，把数据帧从该接口发送出去。</p>
</li>
<li><p>例如 ，某设备每Eth-Trunk支持最大加入接口数为8个，将接口1、2、3、4捆绑为一个Eth-Trunk接口，此时生成的转发表如图2所示。其中HASH-KEY值为0、1、2、3、4、5、6、7，对应的出接口号分别为1、2、3、4、1、2、3、4。</p>
</li>
<li><p>为了避免数据包乱序情况的发生，Eth-Trunk采用逐流负载分担的机制，其中如何转发数据则由于选择不同的负载分担方式而有所差别。</p>
</li>
<li><p>负载分担的方式主要包括以下几种，用户可以根据具体应用选择不同的负载分担方式。</p>
<ul>
<li>根据报文的源MAC地址进行负载分担；</li>
<li>根据报文的目的MAC地址进行负载分担；</li>
<li>根据报文的源IP地址进行负载分担；</li>
<li>根据报文的目的IP地址进行负载分担；</li>
<li>根据报文的源MAC地址和目的MAC地址进行负载分担；</li>
<li>根据报文的源IP地址和目的IP地址进行负载分担；</li>
<li>根据报文的VLAN、源物理端口等对L2、IPv4、IPv6和MPLS报文进行增强型负载分担。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8752.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8753.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8754.png"></p>
<blockquote>
<p>作为链路聚合技术，手工模式Eth-Trunk可以完成多个物理接口聚合成一个Eth-Trunk口来提高带宽，同时能够检测到同一聚合组内的成员链路有断路等有限故障，但是无法检测到链路层故障、链路错连等故障。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8755.png"></p>
<blockquote>
<ul>
<li><p>如图所示，两端设备均会收到对端发来的LACPDU报文。以DeviceB为例，当DeviceB收到DeviceA发送的报文时，DeviceB会查看并记录对端信息，然后比较系统优先级字段，如果DeviceA的系统优先级高于本端的系统优先级，则确定DeviceA为LACP主动端。如果DeviceA和DeviceB的系统优先级相同，比较两端设备的MAC地址，确定MAC地址小的一端为LACP主动端。</p>
</li>
<li><p>选出主动端后，两端都会以主动端的接口优先级来选择活动接口，如果主动端的接口优先级都相同则选择接口编号比较小的为活动接口。两端设备选择了一致的活动接口，活动链路组便可以建立起来，从这些活动链路中以负载分担的方式转发数据。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8756.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8757.png"></p>
<blockquote>
<ul>
<li><p>在设备集群情况下，为了保证流量的可靠传输，流量的出接口设置为Eth-Trunk接口。那么Eth-Trunk接口中必定存在跨框成员口。当集群设备转发流量时，Eth-Trunk接口通过HASH算法可能会选择跨框的成员口。由于集群设备间线缆带宽有限，跨框转发流量增加了集群设备之间的带宽承载压力，同时也降低了流量转发效率。为了解决这个问题，可以使能Eth-Trunk接口流量本地优先转发。</p>
</li>
<li><p>如图所示，DeviceB和DeviceC组成集群，集群设备和DeviceA之间用Eth-Trunk连接。通过在集群设备上部署接口流量本地优先转发功能，可实现：</p>
<ul>
<li>入本设备流量从本设备转发<ul>
<li>当Eth-Trunk接口在DeviceB有出接口且出接口无故障时，DeviceB的Eth-Trunk接口转发表中将只包含DeviceB的出接口。这样DeviceB到DeviceA的流量在通过HASH算法选择出接口时只能选中DeviceB的接口，流量从DeviceB本设备转发出去。</li>
</ul>
</li>
<li>入本设备流量跨框转发<ul>
<li>当Eth-Trunk接口在DeviceB本设备无出接口或者出接口全部故障时，DeviceB的Eth-Trunk转发表中将包含Eth-Trunk接口中所有可转发的出接口。这样DeviceB到DeviceA的流量在通过HASH算法选择出接口时将选中DeviceC上的出接口，流量将通过DeviceC跨框转发。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8758.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8759.png"></p>
<blockquote>
<ul>
<li><p>E-Trunk机制主要应用于CE双归接入VPLS、VLL、PWE3网络时，CE与PE间的链路保护以及对PE设备节点故障的保护。在没有使用E-Trunk前，CE通过Eth-Trunk链路只能单归到一个PE设备。如果Eth-Trunk出现故障或者PE设备故障，CE将无法与PE设备继续进行通信。使用E-Trunk后，CE可以双归到PE上，从而实现设备间保护。</p>
</li>
<li><p>如图，CE分别与PE1和PE2直连，PE1和PE2之间运行E-Trunk。PE侧，需要在PE1和PE2设备上分别创建ID相同的E-Trunk和Eth-Trunk，并将Eth-Trunk加入到E-Trunk。CE侧，在CE设备上配置LACP模式的Eth-Trunk，此Eth-Trunk分别与PE1和PE2设备相连。对CE设备而言，E-Trunk不可见。</p>
</li>
<li><p>PE1与PE2设备之间通过E-Trunk报文进行主备协商，确定E-Trunk的主备状态。正常情况下两台PE的协商结果是一个为主用一个为备用。PE设备上E-Trunk主备状态是根据报文中所携带的E-Trunk优先级和E-Trunk系统ID确定的。优先级的数值越小，优先级越高，优先级高的为主用。如果E-Trunk优先级相同，那么E-Trunk系统ID小的为主用。PE1为主，PE1的Eth-Trunk 10为主，链路状态为Up。PE2为备，PE2的Eth-Trunk 10为备，链路状态为Down。</p>
</li>
<li><p>如果CE到PE1间的链路出现故障：PE1会向对端发送E-Trunk报文，报文中携带PE1的Eth-Trunk 10故障的信息。PE2收到E-Trunk报文后，发现对端Eth-Trunk 10故障，则PE2设备上Eth-Trunk 10的状态将变为主。然后经过LACP协商，PE2设备上的Eth-Trunk 10的状态变为Up。这样PE2设备的Eth-Trunk状态变为Up，CE的流量会通过PE2转发，以达到对CE的流量进行保护的目的。</p>
</li>
<li><p>如果PE1设备出现故障：如果PE设备上配置了BFD，PE2检测到BFD会话状态为Down后，PE2设备从备用状态变为主用状态，PE2的Eth-Trunk 10状态也变为主。如果PE设备上没有配置BFD，PE2设备上的定时器超时后仍然没有收到PE1设备发送的E-Trunk报文，PE2设备从备用状态变为主用状态，PE2的Eth-Trunk 10状态也变为主。经过LACP协商，PE2设备上的Eth-Trunk 10的状态变为Up。CE的流量会通过PE2转发，以达到对CE的流量进行保护的目的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8760.png"></p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>如何清除MAC地址表项和ARP表项？</p>
<ul>
<li>清除所有动态MAC（系统视图）：undo mac-address dynamic </li>
<li>清除所有静态MAC（系统视图） ：undo mac-address static</li>
<li>删除一条静态ARP表项（系统视图）：undo arp static</li>
<li>删除多条ARP表项（用户视图）：reset arp</li>
</ul>
</li>
<li><p>MSTP域如何配置？</p>
<ul>
<li>MSTP的域信息在stp region-configuration视图下配置，同一个域中各台设备的域配置信息必须完全一致。存在任何一点差异，就不在同一个域中。MSTP可以配置的域信息有：<ul>
<li>Format selector：格式选择符，在命令行不能配置，默认为0；</li>
<li>Region name：域名，默认是桥MAC地址；</li>
<li>Revision level：修订级别，默认是0；</li>
<li>Instance/Vlans Mapped：实例和VLAN映射表，默认全部VLAN映射到实例0。</li>
</ul>
</li>
</ul>
</li>
<li><p>Eth-Trunk是否支持抢占功能？</p>
<ul>
<li>只有在LACP模式下，Eth-Trunk才支持优先级抢占功能，可以执行lacp preempt enable命令使能优先级抢占功能。在LACP模式下，当活动链路中出现故障链路时，系统会从备用链路中选择优先级最高的链路替代故障链路；如果被替代的故障链路恢复了正常，而且该链路的优先级又高于替代自己的链路，这种情况下，如果使能了LACP优先级抢占功能，高优先级链路会抢占低优先级链路，回切到活动状态。要求Eth-Trunk两端LACP抢占功能使能情况配置一致，即：统一使能或不使能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8761.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E5%89%B2%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E5%89%B2%E6%8E%A5/" itemprop="url">IPadv-网络割接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T13:47:55+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/" itemprop="url">IPadv-网络故障排除</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T13:47:46+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/" itemprop="url">IPadv-网络运维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T13:47:37+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/" itemprop="url">IPadv-IPv6路由</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T12:56:13+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/IPv6%E8%B7%AF%E7%94%B1.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•随着万物互联时代的到来，IPv4地址空间不足，IPv6取代IPv4势在必行。那么如何实现IPv6网络中各个节点之间的可达性呢？与IPv4网络相同，IPv6网络同样支持静态路由和动态路由协议。</p>
<p>•IPv6静态路由与IPv4静态路由在配置方式上颇为相似。为了实现对IPv6网络的支持，IETF制定了OSPFv3，同时对IS-IS、BGP做了扩展。</p>
<p>•本课程将介绍IPv6静态路由的概念及配置，还会介绍常见的IPv6动态路由协议，包括：OSPFv3，IS-IS（IPv6），以及BGP4+。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫实现IPv6静态路由的配置</p>
<p>▫分析OSPFv3与OSPFv2的不同点</p>
<p>▫实现OSPFv3的基本配置</p>
<p>▫描述IS-IS对IPv6的扩展</p>
<p>▫实现IS-IS（IPv6）的基本配置</p>
<p>▫描述BGP对IPv6的扩展</p>
<p>▫实现BGP4+的基本配置</p>
<h1 id="1-IPv6静态路由"><a href="#1-IPv6静态路由" class="headerlink" title="1.IPv6静态路由"></a>1.IPv6静态路由</h1><h2 id="IPv6静态路由"><a href="#IPv6静态路由" class="headerlink" title="IPv6静态路由"></a>IPv6静态路由</h2><p>•IPv6静态路由与IPv4静态路由类似，也需要管理员手工配置，适合于一些结构比较简单的IPv6网络。</p>
<p>•在创建IPv6静态路由时，可以同时指定出接口和下一跳，或者只指定出接口或只指定下一跳。</p>
<p>​    ▫对于点到点接口：指定出接口。</p>
<p>​    ▫对于广播类型接口：指定下一跳。</p>
<p>•IPv6静态路由负载分担和备份：</p>
<p>​    ▫在创建相同目的地址的多条IPv6静态路由时，如果指定相同优先级，则可实现负载分担，如果指定不同优先级，则可实现路由备份。</p>
<blockquote>
<p>•IPv6静态路由与IPv4静态路由之间的主要区别是目的地址和下一跳地址有所不同，IPv6静态路由使用的是IPv6地址，而IPv4静态路由使用IPv4地址。</p>
</blockquote>
<h2 id="IPv6静态路由的基础配置命令"><a href="#IPv6静态路由的基础配置命令" class="headerlink" title="IPv6静态路由的基础配置命令"></a>IPv6静态路由的基础配置命令</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/1.png"></p>
<blockquote>
<p>•[Huawei] <strong>ipv6</strong> <strong>route-static</strong> <em>dest-ipv6-address</em> <em>prefix-length</em> { <em>interface-type</em> <em>interface-number</em> [ <em>nexthop-ipv6-address</em> ] | <em>nexthop-ipv6-address</em> | <strong>vpn-instance</strong> <em>vpn-destination-name</em> <em>nexthop-ipv6-address</em> } [ <strong>preference</strong> <em>preference</em>]  [ <strong>permanent</strong> | <strong>inherit-cost</strong> ] [ <strong>description</strong> <em>text</em> ]</p>
<ul>
<li><strong>preference</strong> <em>preference</em>：指定路由优先级。整数形式，取值范围为1～255。缺省值是60。</li>
<li><strong>permanent</strong>：指定IPv6静态路由永久发布。</li>
<li><strong>inherit-cost</strong>：指定IPv6静态路由继承迭代路由的开销值。</li>
<li><strong>description</strong> <em>text</em>：指定静态路由的描述信息。字符串形式，支持空格，长度范围是1～80。</li>
</ul>
<p>•[Huawei] <strong>ipv6</strong> <strong>route-static</strong> <strong>vpn-instance</strong> <em>vpn-instance-name</em> <em>dest-ipv6-address</em> <em>prefix-length</em> { [ <em>interface-type</em> <em>interface-number</em> [ <em>nexthop-ipv6-address</em> ] ] | <em>nexthop-ipv6-address</em> [ <strong>public</strong> ] | <strong>vpn**</strong>-instance** <em>vpn*</em>-destination-name* <em>nexthop-ipv6-address</em> } [ <strong>preference</strong> <em>preference</em> ] [ <strong>permanent</strong> | <strong>inherit-cost</strong> ] [ <strong>description</strong> <em>text</em> ]</p>
<ul>
<li><strong>public</strong>：指定<em>nexthop-ipv6-address</em>是公网地址，而不是源VPN中的地址。</li>
</ul>
</blockquote>
<h2 id="IPv6静态路由配置举例"><a href="#IPv6静态路由配置举例" class="headerlink" title="IPv6静态路由配置举例"></a>IPv6静态路由配置举例</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/2.png"></p>
<h1 id="2-OSPFv3原理与配置"><a href="#2-OSPFv3原理与配置" class="headerlink" title="2.OSPFv3原理与配置"></a>2.OSPFv3原理与配置</h1><h2 id="OSPFv3的基本工作原理"><a href="#OSPFv3的基本工作原理" class="headerlink" title="OSPFv3的基本工作原理"></a>OSPFv3的基本工作原理</h2><h3 id="OSPFv3概述"><a href="#OSPFv3概述" class="headerlink" title="OSPFv3概述"></a>OSPFv3概述</h3><p>•OSPF是IETF定义的一种基于链路状态的内部网关路由协议。目前针对IPv4协议使用的是OSPF Version 2（OSPFv2），针对IPv6协议使用OSPF Version 3（OSPFv3）。</p>
<p>•OSPFv3的主要目的是开发一种独立于任何具体网络层的路由协议。为实现这一目的，OSPFv3的内部路由器信息被重新进行了设计。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/3.png"></p>
<h3 id="OSPFv3与OSPFv2的相同点"><a href="#OSPFv3与OSPFv2的相同点" class="headerlink" title="OSPFv3与OSPFv2的相同点"></a>OSPFv3与OSPFv2的相同点</h3><p>OSPF的基本运行机制没有改变，包括：</p>
<p>▫基本概念：</p>
<p>​    ▪区域划分及路由器类型</p>
<p>​    ▪路由计算影响参数：优先级、度量值</p>
<p>​    ▪支持的网络类型：Broadcast（广播类型）、NBMA、P2P（点到点类型）、P2MP（点到多点类型）</p>
<p>​    ▪报文类型：Hello报文、DD报文、LSR报文、LSU报文和LSAck报文</p>
<p>▫工作原理：</p>
<p>​    ▪邻居关系的建立及邻居状态的转换</p>
<p>​    ▪DR与BDR的选举</p>
<p>​    ▪LSA泛洪机制</p>
<p>​    ▪路由计算过程</p>
<blockquote>
<p>•相同点还包括：对特殊区域、虚连接、多进程的支持等。</p>
<p>•本课程对以上内容不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
</blockquote>
<h3 id="OSPFv3拓扑和路由器类型"><a href="#OSPFv3拓扑和路由器类型" class="headerlink" title="OSPFv3拓扑和路由器类型"></a>OSPFv3拓扑和路由器类型</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/4.png"></p>
<h3 id="OSPFv3的基本工作原理与OSPFv2相似"><a href="#OSPFv3的基本工作原理与OSPFv2相似" class="headerlink" title="OSPFv3的基本工作原理与OSPFv2相似"></a>OSPFv3的基本工作原理与OSPFv2相似</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/5.png"></p>
<h3 id="OSPFv3与OSPFv2的不同点"><a href="#OSPFv3与OSPFv2的不同点" class="headerlink" title="OSPFv3与OSPFv2的不同点"></a>OSPFv3与OSPFv2的不同点</h3><p>•OSPFv3基于链路运行以及拓扑计算，而不再是网段。</p>
<p>•OSPFv3支持一个链路上多个实例。</p>
<p>•OSPFv3报文和LSA中去掉了IP地址的意义，且重构了报文格式和LSA格式。</p>
<p>​    ▫OSPFv3报文和Router LSA/Network LSA中不包含IP地址。</p>
<p>​    ▫OSPFv3的LSA中定义了LSA的泛洪范围。</p>
<p>​    ▫OSPFv3中创建了新的LSA承载IPv6地址和前缀。</p>
<p>​    ▫OSPFv3邻居不再由IP地址标识，只由Router ID标识。</p>
<h3 id="唯一邻居标识：Router-ID"><a href="#唯一邻居标识：Router-ID" class="headerlink" title="唯一邻居标识：Router ID"></a>唯一邻居标识：Router ID</h3><p>OSPFv3通过Router ID来标识网络设备。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/6.png"></p>
<blockquote>
<p>•OSPFv2在Broadcast、NBMA、P2P和P2MP网络中是通过IPv4接口地址来标识邻居，而在虚连接网络中是通过Router ID来标识邻居。</p>
</blockquote>
<h3 id="OSPFv3基于链路运行"><a href="#OSPFv3基于链路运行" class="headerlink" title="OSPFv3基于链路运行"></a>OSPFv3基于链路运行</h3><p>OSPFv3是基于链路运行的，设备只要在同一链路，就可以建立邻居关系。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/7.png"></p>
<blockquote>
<p>•IPv6中重点强调了链路的概念，在IPv6中，一个链路上可以分配多个IP子网，也就是IPv6前缀。和IPv4不同的是，同一个链路上的两个节点即使不具有相同的IPv6前缀，也可以直接通过这个链路通信。这一点极大地改变了OSPF的行为。</p>
<p>•在OSPFv3中我们更多的是使用“链路”和“前缀”这两个术语。但这两个概念是分离的，没有必然的对应关系，所以在讨论路由协议时，OSPFv2的术语“网络”和“子网”在这里应该用“链路”替换掉。</p>
</blockquote>
<h3 id="链路支持多实例"><a href="#链路支持多实例" class="headerlink" title="链路支持多实例"></a>链路支持多实例</h3><p>•一个OSPFv3物理接口可以和多个实例绑定，并用不同的实例标识（Instance ID）区分，即OSPFv3的单个链路支持运行多个OSPFv3实例。</p>
<p>•这些运行在同一条物理链路上的多个OSPFv3实例，分别与链路对端设备建立邻居及发送报文，且互不干扰，这样可以充分共享同一链路资源。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/8.png"></p>
<blockquote>
<p>•多实例通过在OSPFv3报文头部增加一个Instance ID区别不同的实例来实现。一个分配了给定Instance ID的实例，将会丢弃那些与该Instance ID不匹配的OSPFv3报文。</p>
</blockquote>
<h3 id="OSPFv3对链路本地地址的使用"><a href="#OSPFv3对链路本地地址的使用" class="headerlink" title="OSPFv3对链路本地地址的使用"></a>OSPFv3对链路本地地址的使用</h3><p>•OSPFv3使用链路本地（FE80::/10）地址作为发送报文的源地址和路由的下一跳地址。</p>
<ul>
<li>使用链路本地地址来维持邻居关系，同步LSA数据库。</li>
<li>在虚连接上，必须使用全球单播地址或者站点本地地址作为OSPFv3协议报文的源地址。</li>
</ul>
<p>•优势：</p>
<ul>
<li>不需要配置IPv6全球单播地址，就可以得到OSPFv3拓扑，实现拓扑与地址分离。</li>
<li>OSPFv3报文不会被转发到始发链路范围之外，减少了报文不必要的泛洪，节省了带宽。</li>
</ul>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/9.png"></p>
<blockquote>
<p>•IPv6使用链路本地（Link-Local）地址在同一链路上发现邻居及自动配置。运行IPv6的路由器不转发目的地址为链路本地地址的IPv6报文，此类报文只在同一链路有效。</p>
<p>•OSPFv3是运行在IPv6上的路由协议，使用链路本地地址来发送OSPFv3报文。</p>
<ul>
<li><p>OSPFv3假定每个路由器在每个连接的链路上都已被分配链路本地地址，在除虚连接外的所有OSPFv3接口上使用接口关联的链路本地地址作为源地址发送OSPFv3报文。</p>
</li>
<li><p>路由器学习所有其他连接到该链路上的路由器的链路本地地址，并且使用这些地址作为下一跳进行报文转发。</p>
</li>
<li><p>注意：关于链路本地地址的描述仅出现在Link-LSA（链路LSA，OSPFv3新增LSA）中。</p>
</li>
</ul>
</blockquote>
<h3 id="OSPFv3报文"><a href="#OSPFv3报文" class="headerlink" title="OSPFv3报文"></a>OSPFv3报文</h3><p>•OSPFv3与OSPFv2有相同类型的报文：</p>
<p>​    ▫Hello报文、DD报文、LSR报文、LSU报文和LSAck报文。</p>
<p>•OSPFv3与OSPFv2使用相同的协议号89。</p>
<p>​    ▫OSPFv2：IPv4报文头部中的协议号（Protocol）为89。</p>
<p>​    ▫OSPFv3：IPv6报文头部中的下一报头号（Next Header）为89。</p>
<p>•OSPFv3与OSPFv2类似，使用组播地址作为OSPF报文目的地址。</p>
<p>​    ▫OSPFv2使用IPv4组播地址： </p>
<p>​        ▪OSPF IGP Routers：224.0.0.5；OSPF IGP DR ：224.0.0.6。</p>
<p>​    ▫OSPFv3使用IPv6组播地址：</p>
<p>​        ▪OSPF IGP Routers：FF02::5；OSPF IGP DR：FF02::6。</p>
<blockquote>
<p>•OSPFv3报文作用：</p>
<p>▫Hello报文：周期性发送，用来发现、建立和维持OSPFv3邻居关系。</p>
<p>▫DD报文：描述了本地LSDB的摘要信息，用于两台设备进行数据库同步。</p>
<p>▫LSR报文：用于向对方请求所需的LSA。设备只有在OSPFv3邻居双方成功交换DD报文后，才会向对方发出LSR报文。</p>
<p>▫LSU报文：向对方发送其所需的LSA。</p>
<p>▫LSAck报文：用来对收到的LSA进行确认。</p>
</blockquote>
<h3 id="OSPFv3报文头部"><a href="#OSPFv3报文头部" class="headerlink" title="OSPFv3报文头部"></a>OSPFv3报文头部</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/10.png"></p>
<blockquote>
<p>•Version：1Byte，版本，OSPF的版本号。对于OSPFv3来说，其值为3。 </p>
<p>•Type：1Byte，类型，OSPFv3报文的类型，有下面几种类型：</p>
<p>​    ▫1：Hello报文；</p>
<p>​    ▫2：DD报文；</p>
<p>​    ▫3：LSR报文；</p>
<p>​    ▫4：LSU报文；</p>
<p>​    ▫5：LSAck报文。</p>
<p>•Packet length：2Byte，OSPFv3报文的总长度，包括报文头在内，单位为字节。</p>
<p>•Router ID：4Byte，始发此报文的路由器的Router ID。</p>
<p>•Area ID：4Byte，发送该报文的所属区域。</p>
<p>•Checksum：2Byte，使用IPv6标准16位校验和。</p>
<p>•0：1Byte，保留字段，必须填0。 </p>
</blockquote>
<h3 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/11.png"></p>
<blockquote>
<p>•Rtr Pri：1Byte，Router Priority，DR优先级。默认为1。如果设置为0，则路由器不能参与DR或BDR的选举。 </p>
<p>•Options：3Byte，可选项。</p>
<ul>
<li>AT：1bit，表示是否支持OSPFv3认证。若AT=1，则在OSPFv3报文后增加认证尾部字段，包含认证信息。</li>
<li>DC：1bit，表示是否具有支持按需电路的能力。</li>
<li>R：1bit，指明始发路由器是否是一台有效的路由器。</li>
<li>NP：1bit，表示是否为NSSA区域。</li>
<li>MC：1bit，表示是否支持转发组播数据报文。</li>
<li>E：1bit，表示是否支持外部路由。</li>
<li>V6：1bit，表示是否参与IPv6路由计算。如果该位为0，表示该路由器或链路不参与IPv6路由计算。</li>
</ul>
<p>•HelloInterval：2Byte，发送Hello报文的时间间隔。</p>
<p>•RouterDeadInterval ：2Byte，失效时间。如果在此时间内未收到邻居发来的Hello报文，则认为邻居失效。</p>
<p>•Designated Router ID：4Byte，DR的Router ID。</p>
<p>•Backup Designated Router ID ：4Byte，BDR的Router ID。</p>
<p>•Neighbor ID：4Byte，邻居，以Router ID标识。</p>
<p>•说明：DD报文、LSR报文、LSU报文和LSAck报文格式与OSPFv2相比变化不大，本课程不再赘述。</p>
</blockquote>
<h3 id="OSPFv3的LSA头部"><a href="#OSPFv3的LSA头部" class="headerlink" title="OSPFv3的LSA头部"></a>OSPFv3的LSA头部</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/12.png"></p>
<blockquote>
<p>•LS Age：2Byte，LSA产生后所经过的时间，以秒为单位。无论LSA是在链路上传送，还是保存在LSDB中，其值都会在不停的增长。</p>
<p>•LS Type：2Byte，LSA的类型。该字段的高3位标识LSA的通用属性，剩下的比特位标识LSA的特定功能。</p>
<ul>
<li><p>U位标识了对未知LSA的处理方法，即标识了不识别LSA功能代码的路由器应如何处理LSA。</p>
<ul>
<li>0：把此LSA当作具有链路本地泛洪范围来对待，从而只能泛洪到本地链路上。</li>
<li>1：把此LSA当作类型已知的LSA来处理，也就是存储下来并泛洪出去。</li>
</ul>
</li>
<li><p>S2/S1位标识了LSA的泛洪范围。</p>
<ul>
<li>S2 S1=0 0：链路本地范围内，即只在始发链路上泛洪。</li>
<li>S2 S1=0 1：区域范围内，即泛洪到始发区域内的所有路由器。</li>
<li>S2 S1=1 0：AS范围内，即泛洪到本AS的所有路由器。</li>
<li>S2 S1=1 1：预留。</li>
</ul>
</li>
</ul>
<p>•Link State ID：4Byte，本地32位标识符，与IPv6地址无关，与LSA中的LS Type和Advertising Router一起在路由域中描述一个LSA。OSPFv3与OSPFv2相比，Link State ID不再包含地址信息。</p>
<p>•Advertising Router：4Byte，产生此LSA的路由器的Router ID。</p>
<p>•LS Sequence Number：4Byte，LSA的序列号。其他路由器根据这个值可以判断哪个LSA是最新的。</p>
<p>•LS Checksum：2Byte，除了LS Age外其它各域的校验和。</p>
<p>•Length：2Byte，LSA的总长度，包括LSA Header，以字节为单位。</p>
</blockquote>
<h3 id="OSPFv3的LSA类型"><a href="#OSPFv3的LSA类型" class="headerlink" title="OSPFv3的LSA类型"></a>OSPFv3的LSA类型</h3><p>•OSPFv3与OSPFv2相比，具有类似的LSA名称，但是功能略有区别。</p>
<p>•OSPFv3新增了两类LSA，包括：链路LSA和区域内前缀LSA。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/13.png"></p>
<blockquote>
<p>•如表中所示，OSPFv3的LS Type字段，U位缺省为0；除Type5和Type8的LSA外，其余的LSA泛洪范围都是区域范围内（S2 S1=0 1）。</p>
<ul>
<li>链路本地范围。LSA仅在本地链路上泛洪，包括：Link-LSA。</li>
<li>区域范围。LSA在单个OSPF区域内泛洪，包括：Router-LSA、Network-LSA、Inter-Area-Prefix-LSA、Inter-Area-Router-LSA、NSSA LSA和Intra-Area-Prefix-LSA。</li>
<li>AS范围。LSA在整个路由域（自治系统）中扩散，包括：AS-External-LSA。</li>
</ul>
</blockquote>
<h3 id="Type1：Router-LSA"><a href="#Type1：Router-LSA" class="headerlink" title="Type1：Router-LSA"></a>Type1：Router-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/14.png"></p>
<blockquote>
<p>•OSPFv3的Router-LSA字段解释：</p>
<p>▫W：Wild-Card Receiver，值为1时，表示该路由器支持组播路由。</p>
<p>▫V：Virtual Link，值为1时，表示产生此LSA的路由器是虚连接的一端。</p>
<p>▫E：External，值为1时，表示产生此LSA的路由器是ASBR。</p>
<p>▫B：Border，值为1时，表示产生此LSA的路由器是ABR。</p>
<p>▫Options：3Byte，可选项。</p>
<p>​    ▪DC：1bit，表示是否具有支持按需电路的能力。</p>
<p>​    ▪R：1bit，指明始发路由器是否是一台有效的路由器。</p>
<p>​    ▪NP：1bit，表示是否为NSSA区域。</p>
<p>​    ▪MC：1bit，表示是否支持转发组播数据报文。</p>
<p>​    ▪E：1bit，表示是否支持外部路由。</p>
<p>​    ▪V6：1bit，表示是否参与IPv6路由计算。如果该位为0，表示该路由器或链路不参与IPv6路由计算。</p>
<p>▫Link Type：1Byte，链路类型。</p>
<p>​    ▪1：点到点连接到另一台路由器。</p>
<p>​    ▪2：连接到一个传送网络（Transit Network）。</p>
<p>​    ▪3：保留。</p>
<p>​    ▪4：虚链路。</p>
<p>▫Metric：2Byte，流量出接口的开销值。</p>
</blockquote>
<h3 id="Type2：Network-LSA"><a href="#Type2：Network-LSA" class="headerlink" title="Type2：Network-LSA"></a>Type2：Network-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/15.png"></p>
<blockquote>
<p>•OSPFv3的Network-LSA字段解释：</p>
<p>​    ▫Options：与Router-LSA中的Options字段相同。</p>
</blockquote>
<h3 id="Type3：Inter-Area-Prefix-LSA"><a href="#Type3：Inter-Area-Prefix-LSA" class="headerlink" title="Type3：Inter-Area-Prefix-LSA"></a>Type3：Inter-Area-Prefix-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/16.png"></p>
<blockquote>
<p>•OSPFv3的Inter-Area-Prefix-LSA字段解释：</p>
<ul>
<li><p>Metric：3Byte，到目的地址的开销值。</p>
</li>
<li><p>PrefixOptions：由LSA公告的每个前缀都拥有一个自己的PrefixOptions字段。</p>
<ul>
<li>P位: 传播位。如果一个NSSA区域的前缀需要被ABR传播出去，就需要设置这一位。</li>
<li>MC位: 组播位。如果设置为1，则这个前缀应该纳入组播计算中，否则不纳入组播计算。</li>
<li>LA位: 本地地址位。如果设置为1，则这个前缀是路由器的一个接口地址。</li>
<li>NU位: 非单播位。如果设置为1，则这个前缀不会纳入IPv6单播路由计算中。</li>
</ul>
</li>
</ul>
<p>•注意：缺省路由的前缀长度为0。ABR也能够始发一个区域间Type3的LSA向一个末梢区域通告一条缺省路由。</p>
</blockquote>
<h3 id="Type4：Inter-Area-Router-LSA"><a href="#Type4：Inter-Area-Router-LSA" class="headerlink" title="Type4：Inter-Area-Router-LSA"></a>Type4：Inter-Area-Router-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/17.png"></p>
<blockquote>
<p>•OSPFv3的Inter-Area-Router-LSA字段解释：</p>
<p>​    ▫Options：Options字段描述的不是源路由器的能力，而是目的路由器所支持的能力，所以此字段值应该等于目的路由器的Router-LSA的Options字段值。</p>
<p>​    ▫Metric：3Byte，到目的地址的开销值。</p>
</blockquote>
<h3 id="Type5：AS-External-LSA"><a href="#Type5：AS-External-LSA" class="headerlink" title="Type5：AS-External-LSA"></a>Type5：AS-External-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/18.png"></p>
<blockquote>
<p>•OSPFv3的AS-External-LSA字段解释：</p>
<p>▫E：1bit，外部路由的Metric类型。</p>
<ul>
<li><p>如果设置为1，表示此为2类外部路由，其Metric不随着路由的传递而增长。</p>
</li>
<li><p>如果设置为0，表示此为1类外部路由，其Metric随着路由的传递而增长。</p>
</li>
</ul>
<p>▫F：1bit，如果设置为1，则表示后面的Forwarding Address可选字段存在。</p>
<p>▫T：1bit，如果设置为1，则表示后面的External Route Tag可选字段存在。</p>
<p>▫Metric：3Byte，到目的地址的开销值。</p>
<p>▫PrefixLength、PrefixOptions和Address Prefix为描述前缀的三元组，与Inter-Area-Prefix-LSA中该字段含义相同。</p>
<p>▫Forwarding Address：4Byte，可选的128位IPv6地址，当前面的F位为1时存在。表示到达目的的数据应该转发到这个地址。</p>
<p>▫External Route Tag：4Byte，可选的标记位。可以用于ASBR之间的通信。一个比较常见的例子是，在OSPF自治系统的两个边界路由器上进行路由引入时，通过对引入的路由进行标记，可以很方便地进行路由过滤。</p>
<p>▫Referenced Link State ID：4Byte，若Referenced LS Type不为0，则该字段存在，表示引用链路状态ID。</p>
</blockquote>
<h3 id="新增Type8：Link-LSA"><a href="#新增Type8：Link-LSA" class="headerlink" title="新增Type8：Link-LSA"></a>新增Type8：Link-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/19.png"></p>
<blockquote>
<p>•OSPFv3的Link-LSA字段解释：</p>
<ul>
<li>Rtr Pri：1Byte，该路由器在该链路上的优先级(Router Priority)。</li>
<li>Options：3Byte，提供给Network-LSA的Options。</li>
<li>Number of Prefixes：4Byte，该LSA中携带的IPv6地址前缀个数。</li>
<li>PrefixLength、PrefixOptions和Address Prefix为描述前缀的三元组，与Inter-Area-Prefix-LSA中该字段含义相同。</li>
</ul>
</blockquote>
<h3 id="新增Type9：Intra-Area-Prefix-LSA"><a href="#新增Type9：Intra-Area-Prefix-LSA" class="headerlink" title="新增Type9：Intra-Area-Prefix-LSA"></a>新增Type9：Intra-Area-Prefix-LSA</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/20.png"></p>
<blockquote>
<p>OSPFv3的Intra-Area-Prefix-LSA字段解释：</p>
<p>▫Number of Prefixes：4Byte，该LSA中携带的IPv6地址前缀个数。必要的话，可以通过多个Intra-Area-Prefix-LSA来携带前缀，这样可以控制LSA的长度。 </p>
<p>▫Referenced LS type：4Byte，表明这个LSA是参考一个Router-LSA，还是一个Network-LSA。</p>
<ul>
<li><p>1：表示参考一个Router-LSA</p>
</li>
<li><p>2：表示参考一个Network-LSA。 </p>
</li>
</ul>
<p>▫Referenced Link State ID：4Byte。</p>
<ul>
<li><p>设为0：当这个LSA是参考一个Router-LSA时。</p>
</li>
<li><p>设为该链路的DR的Interface ID：当这个LSA是参考一个Network-LSA时。 </p>
</li>
</ul>
<p>▫Referenced Advertising Router：4Byte。</p>
<ul>
<li><p>设为这个路由器的Router ID：当这个LSA是参考一个Router-LSA时。</p>
</li>
<li><p>设为该链路的DR的Router ID：当这个LSA是参考一个Network-LSA时。 </p>
</li>
</ul>
<p>▫PrefixLength、PrefixOptions和Address Prefix为描述前缀的三元组，与Inter-Area-Prefix-LSA中该字段含义相同。</p>
<p>▫Metric：2Byte，前缀开销值。与Router-LSA的接口开销值相同单位。</p>
<p>在OSPFv3中，当一条链路或它的前缀发生变化时，相连的路由器会发送一个Intra-Area-Prefix-LSA。但是，这条LSA不会触发SPF计算。</p>
</blockquote>
<h3 id="OSPFv3的LSA举例"><a href="#OSPFv3的LSA举例" class="headerlink" title="OSPFv3的LSA举例"></a>OSPFv3的LSA举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/21.png"></p>
<blockquote>
<p>•如图所示：R1、R2、R3和R4运行OSPFv3路由协议，且均部署在骨干区域。</p>
<p>•网络稳定后，查看R2的LSDB，可以查看到该路由器的Router-LSA（Type1）、Network-LSA（Type2）、Link-LSA（Type8）和Intra-Area-Prefix-LSA（Type9）。</p>
</blockquote>
<h3 id="Link-LSA举例"><a href="#Link-LSA举例" class="headerlink" title="Link-LSA举例"></a>Link-LSA举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/22.png"></p>
<blockquote>
<p>•输出信息解释：</p>
<p>▫LS age：LSA的老化时间。</p>
<p>▫LS Type：LSA的类型。有如下类型：</p>
<ul>
<li>Router-LSA、Network-LSA、Inter-Area-Prefix-LSA、Inter-Area-Router-LSA、AS-external-LSA、NSSA-LSA、Link-LSA、Intra-Area-Prefix-LSA</li>
</ul>
<p>▫Link State ID：LSA报文头中的链路状态ID。</p>
<p>▫Originating Router：产生LSA的路由器。</p>
<p>▫LS Seq Number：LSA序列号（来自LSA报头）。</p>
<p>▫Checksum：LSA的校验和。</p>
<p>▫Length：LSA的长度。</p>
<p>▫Priority：该Link对应接口的优先级。</p>
<p>▫Options：该Link的Option值。</p>
<p>▫Link-Local Address：链路本地地址。</p>
<p>▫Number of Prefixes：该LSA中包含的IPv6前缀数目。</p>
<p>▫Prefix：IPv6前缀。</p>
<p>▫Prefix Options：前缀Option值。</p>
</blockquote>
<h3 id="Intra-Area-Prefix-LSA举例"><a href="#Intra-Area-Prefix-LSA举例" class="headerlink" title="Intra-Area-Prefix-LSA举例"></a>Intra-Area-Prefix-LSA举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/23.png"></p>
<h2 id="OSPFv3的基本配置"><a href="#OSPFv3的基本配置" class="headerlink" title="OSPFv3的基本配置"></a>OSPFv3的基本配置</h2><h3 id="OSPFv3的基础配置命令-1"><a href="#OSPFv3的基础配置命令-1" class="headerlink" title="OSPFv3的基础配置命令 (1)"></a>OSPFv3的基础配置命令 (1)</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/24.png"></p>
<blockquote>
<p>•OSPFv3的配置命令与配置方式与OSPFv2类似，其他配置命令不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
</blockquote>
<h3 id="OSPFv3的基础配置命令-2"><a href="#OSPFv3的基础配置命令-2" class="headerlink" title="OSPFv3的基础配置命令 (2)"></a>OSPFv3的基础配置命令 (2)</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/25.png"></p>
<h3 id="检查OSPFv3基本功能的配置结果"><a href="#检查OSPFv3基本功能的配置结果" class="headerlink" title="检查OSPFv3基本功能的配置结果"></a>检查OSPFv3基本功能的配置结果</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/26.png"></p>
<blockquote>
<p>•[Huawei] <strong>display</strong> <strong>ospfv3</strong> [ <em>process-id</em> ] <strong>lsdb</strong> [ <strong>area</strong> <em>area-id</em> ] [ <strong>originate-router</strong> <em>advertising-router-id</em> | <strong>self-originate</strong> ] [ { <strong>router</strong> | <strong>network</strong> | <strong>inter-router</strong> [ <strong>asbr-router</strong> <em>asbr-router-id</em> ] | { <strong>inter-prefix</strong> | <strong>nssa</strong> } [ <em>ipv6-address</em> <em>prefix-length</em> ] | <strong>link</strong> | <strong>intra-prefix</strong> | <strong>grace</strong> } [ <em>link-state-id</em> ] ]</p>
<ul>
<li><p><em>process-id</em>：OSPFv3进程号。整数形式，取值范围是1～65535。</p>
</li>
<li><p><strong>area</strong> <em>area-id</em>：区域的标识。可以是十进制整数或IPv4地址格式。如果是十进制整数，取值范围是0～4294967295。如果是IPv4地址格式，取值是点分十进制。</p>
</li>
<li><p><strong>external</strong>：显示数据库中AS-external LSA的信息。</p>
</li>
<li><p><strong>inter-prefix</strong>：显示数据库中Inter-Area-Prefix LSA的信息。</p>
</li>
<li><p><strong>inter-router</strong>：显示数据库中Inter-Area-Router LSA的信息。</p>
</li>
<li><p><strong>intra-prefix</strong>：显示数据库中Intra-Area-Prefix LSA的信息。</p>
</li>
<li><p><strong>nssa</strong>：显示数据库中NSSA LSA的信息。</p>
</li>
<li><p><strong>link</strong>：显示数据库中Link-LSA的信息。</p>
</li>
<li><p><strong>network</strong>：显示数据库中Network-LSA的信息。</p>
</li>
<li><p><strong>router</strong>：显示数据库中Router-LSA的信息。</p>
</li>
<li><p><em>link-state-id</em>：链路状态ID。点分十进制格式。</p>
</li>
<li><p><strong>originate-router</strong> <em>advertising-router-id</em>：指定发布LSA的路由器的Router ID。点分十进制格式。</p>
</li>
<li><p><strong>asbr-router</strong> <em>asbr-router-id</em>：指定ASBR路由器的Router ID。点分十进制格式。</p>
</li>
<li><p><strong>self-originate</strong>：显示数据库中由本路由器发布的LSA信息。</p>
</li>
<li><p><em>ipv6-address prefix-length</em>：指定IPv6目的地址及前缀长度。</p>
<ul>
<li><em>ipv6-address</em>是32位16进制数，格式为X:X:X:X:X:X:X:X。</li>
<li><em>prefix-length</em>是整数形式，取值范围是0～128。</li>
</ul>
</li>
</ul>
<p>•[Huawei] <strong>display</strong> <strong>ospfv3</strong> [ <em>process-id</em> ] <strong>routing</strong> [ <em>ipv6-address</em> <em>prefix-length</em> | <strong>abr-routes</strong> | <strong>asbr-routes</strong> | <strong>intra-routes</strong> | <strong>inter-routes</strong> | <strong>ase-routes</strong> | <strong>nssa-routes</strong> | [ <strong>statistics</strong> ] ]</p>
<ul>
<li><em>process-id</em>：OSPFv3进程号。整数形式，取值范围是1～65535。</li>
<li><em>ipv6-address</em>：指定IPv6地址。32位16进制数，格式为X:X:X:X:X:X:X:X。</li>
<li><em>prefix-length</em>：指定前缀长度。整数形式，取值范围是0～128。</li>
<li><strong>abr-routes</strong>：显示OSPFv3中所有ABR的路由信息。</li>
<li><strong>asbr-routes</strong>：显示OSPFv3中所有ASBR的路由信息。</li>
<li><strong>intra-routes</strong>：显示OSPFv3中区域内路由的统计信息。</li>
<li><strong>inter-routes</strong>：显示OSPFv3中区域间路由的统计信息。</li>
<li><strong>ase-routes</strong>：显示OSPFv3中AS外部路由的统计信息。**</li>
<li>nssa-routes<strong>：显示OSPFv3中NSSA区域路由的统计信息。</strong></li>
<li>statistics：显示OSPFv3中所有路由表的统计信息。</li>
</ul>
</blockquote>
<h3 id="OSPF双栈配置举例"><a href="#OSPF双栈配置举例" class="headerlink" title="OSPF双栈配置举例"></a>OSPF双栈配置举例</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/27.png"></p>
<h3 id="部署IPv4网络"><a href="#部署IPv4网络" class="headerlink" title="部署IPv4网络"></a>部署IPv4网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/28.png"></p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/29.png"></p>
<h3 id="部署IPv6网络"><a href="#部署IPv6网络" class="headerlink" title="部署IPv6网络"></a>部署IPv6网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/30.png"></p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/31.png"></p>
<h3 id="查看OSPFv3网络的邻居信息"><a href="#查看OSPFv3网络的邻居信息" class="headerlink" title="查看OSPFv3网络的邻居信息"></a>查看OSPFv3网络的邻居信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/32.png"></p>
<blockquote>
<p>•可以通过<strong>display</strong> <strong>ospf peer</strong>查看OSPFv2的邻居信息。</p>
<p>•对比OSPFv2和OSPFv3的邻居信息，发现选出的DR和BDR是一致的，说明DR选举方式相同。</p>
</blockquote>
<h3 id="查看OSPFv3网络的路由信息"><a href="#查看OSPFv3网络的路由信息" class="headerlink" title="查看OSPFv3网络的路由信息"></a>查看OSPFv3网络的路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/33.png"></p>
<blockquote>
<p>•可以通过<strong>display ospf routing</strong>查看OSPFv2的路由信息。</p>
<p>•对比OSPFv2和OSPFv3的路由信息，发现到“同一”网段的路径一致，说明路由计算方式相同。</p>
</blockquote>
<h3 id="查看OSPFv3网络LSDB信息"><a href="#查看OSPFv3网络LSDB信息" class="headerlink" title="查看OSPFv3网络LSDB信息"></a>查看OSPFv3网络LSDB信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/34.png"></p>
<blockquote>
<p>•可以通过<strong>display ospf</strong> <strong>lsdb</strong>查看OSPFv2的LSDB信息，可以看到有Type1、Type2和Type3三种LSA。</p>
</blockquote>
<h1 id="3-IS-IS-IPv6-原理与配置"><a href="#3-IS-IS-IPv6-原理与配置" class="headerlink" title="3.IS-IS (IPv6)原理与配置"></a>3.IS-IS (IPv6)原理与配置</h1><h2 id="IS-IS-IPv6-概述"><a href="#IS-IS-IPv6-概述" class="headerlink" title="IS-IS (IPv6)概述"></a>IS-IS (IPv6)概述</h2><p>•IS-IS最初是为OSI网络设计的一种基于链路状态协议的动态路由协议。之后为了提供对IPv4的路由支持，扩展应用到IPv4网络，称为集成IS-IS。</p>
<p>•IS-IS报文有以下几种类型：Hello PDU（Protocol Data Unit）、LSP和SNP。</p>
<ul>
<li>报文格式为：</li>
</ul>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/35.png"></p>
<ul>
<li>IS-IS报文中的变长字段部分是多个TLV（Type-Length-Value）三元组，使用TLV结构构建报文使IS-IS更具灵活性和扩展性，增加新特性只需要增加新TLV即可。</li>
</ul>
<p>•为了支持IPv6路由的处理和计算，IS-IS新增了两个TLV（Type-Length-Value）和一个NLPID（Network Layer Protocol Identifier，网络层协议标识符）。</p>
<h2 id="新增TLV"><a href="#新增TLV" class="headerlink" title="新增TLV"></a>新增TLV</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/36.png"></p>
<blockquote>
<p>•232号TLV（IPv6 Interface Address）字段解释：</p>
<p>▫Type：8bit，TLV类型，此时值为232（0xE8）。</p>
<p>▫Length：8bit，TLV的Value部分长度。</p>
<p>▫Interface Address：128bit，IPv6地址。</p>
<p>•236号TLV（IPv6 Reachability）字段解释：</p>
<p>▫Type：8bit，TLV类型，此时值为236（0xEC）。</p>
<p>▫Length：8bit，TLV的Value部分长度。</p>
<p>▫Metric：32bit，度量值。</p>
<p>▫U：1bit，Up/Down位，标识这个前缀是否是从高Level通告下来的。</p>
<p>▫X：1bit，External Original位，标识这个前缀是否是从其他路由协议中引入的。</p>
<p>▫S：1bit，Sub-TLV Present位，子TLV标识位（可选）。</p>
<p>▫R：5bit，Reserve位，保留位。</p>
<p>▫Prefix Length：8bit，前缀长度。</p>
<p>▫Prefix：IPv6地址前缀。</p>
<p>▫Sub-TLV Length：8bit，子TLV长度。若S位置1，则存在。</p>
<p>▫Sub-TLV：子TLV。若S位置1，则存在。</p>
</blockquote>
<h2 id="129号TLV中新增NLPID"><a href="#129号TLV中新增NLPID" class="headerlink" title="129号TLV中新增NLPID"></a>129号TLV中新增NLPID</h2><p>•为了支持IPv6路由的处理和计算，IS-IS在129号TLV中新增了一个NLPID。</p>
<p>•129号TLV（Protocol Supported）</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/37.png"></p>
<p>如果IS-IS支持IPv6，那么向外发布IPv6路由时必须携带NLPID值。</p>
<h2 id="IS-IS多拓扑技术背景"><a href="#IS-IS多拓扑技术背景" class="headerlink" title="IS-IS多拓扑技术背景"></a>IS-IS多拓扑技术背景</h2><p>缺省情况下，在运行IS-IS的网络环境中，IPv4和IPv6的混合拓扑被看成是一个集成的拓扑，IS-IS针对IPv4和IPv6经计算形成相同的最短路径树。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/38.png"></p>
<blockquote>
<p>•IS-IS单拓扑的不足之处：</p>
<p>​    ▫网络部署不适合拓扑分离。</p>
<p>​    ▫为维护相同的拓扑，所有接口都必须同时运行IS-IS（IPv4）和IS-IS（IPv6），部署不够灵活。</p>
<p>​    ▫不能使用IPv4区域来连接不同的IPv6区域，即无法通过IPv4网络解决IPv6孤岛问题。</p>
</blockquote>
<h2 id="IS-IS多拓扑概述"><a href="#IS-IS多拓扑概述" class="headerlink" title="IS-IS多拓扑概述"></a>IS-IS多拓扑概述</h2><p>•IS-IS多拓扑（Multi-Topology，MT）特性是指在一个IS-IS自治域内运行多个独立的IP拓扑。例如IPv4拓扑和IPv6拓扑，而不是将它们视为一个集成的单一拓扑。这有利于IS-IS在路由计算中根据实际组网情况来单独考虑IPv4和IPv6网络。根据链路所支持的IP协议类型，不同拓扑运行各自的SPF计算，实现网络的相互屏蔽。</p>
<p>•IS-IS多拓扑的实现过程</p>
<p>​    ▫建立拓扑：通过报文交互建立邻居，从而建立多拓扑。</p>
<p>​    ▫SPF计算：在不同的拓扑上分别进行SPF计算。</p>
<h2 id="IS-IS多拓扑原理"><a href="#IS-IS多拓扑原理" class="headerlink" title="IS-IS多拓扑原理"></a>IS-IS多拓扑原理</h2><p>•IS-IS定义了新的TLV，该TLV中包含接口所属拓扑信息（MT信息）。MT信息的传播，使得网络按不同的拓扑分别进行SPF计算，最终实现拓扑分离。</p>
<p>•229号多拓扑TLV：</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/39.png"></p>
<blockquote>
<p>•IS-IS为了支持多拓扑特性，定义了多种TLV，包括：多拓扑TLV、多拓扑中间系统TLV、多拓扑可达的IPv4前缀TLV和多拓扑可达的IPv6前缀TLV。其中本课程将对多拓扑TLV进行讲解，其他内容不详细展开。</p>
<p>•多拓扑TLV：</p>
<ul>
<li><p>多拓扑TLV仅包含在IIH报文和LSP的0分片报文中。</p>
</li>
<li><p>预留的MT ID字段：</p>
<ul>
<li>MT ID=0，用于标准IPv4拓扑。</li>
<li>MT ID=2，预留给IPv6拓扑。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="IS-IS-IPv6-的基础配置命令"><a href="#IS-IS-IPv6-的基础配置命令" class="headerlink" title="IS-IS (IPv6)的基础配置命令"></a>IS-IS (IPv6)的基础配置命令</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/40.png"></p>
<blockquote>
<p>•IS-IS（IPv6）的基础配置命令与配置方式与IS-IS（IPv4）一致，其他配置命令不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
<p>•[Huawei-isis-1] <strong>ipv6</strong> <strong>enable</strong> [ <strong>topology</strong> { <strong>ipv6</strong> | <strong>standard</strong> } ]</p>
<ul>
<li><strong>topology</strong>：用于指定网络的拓扑类型。</li>
<li><strong>ipv6</strong>：指定拓扑类型为IPv6拓扑，即在IPv6拓扑上使能IS-IS进程的IPv6。网络中的链路可以配置成IPv4或IPv6，但SPF计算在各自的拓扑中单独进行。</li>
<li><strong>standard</strong>：指定拓扑类型为标准模式，即在集成拓扑上使能IS-IS进程的IPv6。网络管理员必须保证网络中所有的链路支持一致的拓扑模式。缺省情况下，使能IPv6选择standard参数。</li>
</ul>
<p>•[ Huawei-GigabitEthernet0/0/1] <strong>isis</strong> <strong>ipv6</strong> <strong>cost</strong> { <em>cost</em> | <strong>maximum</strong> } [ <strong>level-1</strong> | <strong>level-2</strong> ]</p>
<ul>
<li><p><em>cost</em>：指定IPv6接口的链路开销值。整数形式，取值范围根据开销类型而定。</p>
<ul>
<li>当开销类型为narrow、narrow-compatible或compatible时，取值范围是1～63。</li>
<li>当开销类型为wide或wide-compatible时，取值范围是1～16777214。</li>
<li>缺省值为10。</li>
</ul>
</li>
<li><p><strong>maximum</strong>：指定接口的链路开销值为16777215。</p>
</li>
<li><p><strong>level-1</strong>：指定配置level-1链路的开销值。如果不指定配置链路开销的接口级别，则同时为Level-1和Level-2级别的接口设置链路开销。</p>
</li>
<li><p><strong>level-2</strong>：指定配置level-2链路的开销值。如果不指定配置链路开销的接口级别，则同时为Level-1和Level-2级别的接口设置链路开销。</p>
</li>
</ul>
</blockquote>
<h2 id="检查IS-IS-IPv6-基本功能的配置结果"><a href="#检查IS-IS-IPv6-基本功能的配置结果" class="headerlink" title="检查IS-IS (IPv6)基本功能的配置结果"></a>检查IS-IS (IPv6)基本功能的配置结果</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/41.png"></p>
<h2 id="IS-IS双栈配置举例"><a href="#IS-IS双栈配置举例" class="headerlink" title="IS-IS双栈配置举例"></a>IS-IS双栈配置举例</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/42.png"></p>
<h3 id="部署IPv4网络-1"><a href="#部署IPv4网络-1" class="headerlink" title="部署IPv4网络"></a>部署IPv4网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/43.png"></p>
<h3 id="部署IPv6网络-1"><a href="#部署IPv6网络-1" class="headerlink" title="部署IPv6网络"></a>部署IPv6网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/44.png"></p>
<h3 id="查看IS-IS-IPv4-网络路由信息"><a href="#查看IS-IS-IPv4-网络路由信息" class="headerlink" title="查看IS-IS (IPv4)网络路由信息"></a>查看IS-IS (IPv4)网络路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/45.png"></p>
<h3 id="查看IS-IS-IPv6-网络路由信息"><a href="#查看IS-IS-IPv6-网络路由信息" class="headerlink" title="查看IS-IS (IPv6)网络路由信息"></a>查看IS-IS (IPv6)网络路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/46.png"></p>
<h1 id="4-BGP4-原理与配置"><a href="#4-BGP4-原理与配置" class="headerlink" title="4.BGP4+原理与配置"></a>4.BGP4+原理与配置</h1><h2 id="BGP4-概述"><a href="#BGP4-概述" class="headerlink" title="BGP4+概述"></a>BGP4+概述</h2><p>•传统的BGP-4只能管理IPv4单播路由信息，BGP多协议扩展（MultiProtocol BGP，MP-BGP）提供了对多种网络层协议的支持。目前的MP-BGP，使用扩展属性和地址族来实现对IPv6、组播和VPN相关内容的支持，BGP协议原有的报文机制和路由机制并没有改变。</p>
<p>•其中，MP-BGP对IPv6单播网络的支持特性称为BGP4+。BGP4+为IPv6单播网络建立独立的拓扑结构，并将路由信息储存在独立的路由表中，保持单播IPv4网络和单播IPv6网络之间路由信息相互隔离。</p>
<blockquote>
<p>•为了实现对IPv6协议的支持，BGP需要将IPv6协议的信息反映到NLRI属性中。</p>
</blockquote>
<h2 id="MP-BGP支持的地址族"><a href="#MP-BGP支持的地址族" class="headerlink" title="MP-BGP支持的地址族"></a>MP-BGP支持的地址族</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/47.png"></p>
<h2 id="BGP路径属性"><a href="#BGP路径属性" class="headerlink" title="BGP路径属性"></a>BGP路径属性</h2><p>•BGP的Update报文在对等体之间传递路由信息，可以用于发布和撤销路由。</p>
<p>•Update报文格式：</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/48.png"></p>
<p>•BGP4+中引入了两个NLRI属性，分别是：</p>
<ul>
<li><p>MP_REACH_NLRI：Multiprotocol Reachable NLRI，多协议可达NLRI。用于发布可达路由及下一跳信息。</p>
</li>
<li><p>MP_UNREACH_NLRI：Multiprotocol Unreachable NLRI，多协议不可达NLRI。用于撤销不可达路由。</p>
</li>
</ul>
<blockquote>
<p>•Update报文：</p>
<ul>
<li>一个Update报文可以通告具有相同路径属性的多条路由，这些路由保存在NLRI（Network Layer Reachable Information，网络层可达信息）中。同时Update还可以携带多条不可达路由，用于告知对方撤销路由，这些保存在Withdrawn Routes字段中。</li>
</ul>
</blockquote>
<h2 id="NLRI属性"><a href="#NLRI属性" class="headerlink" title="NLRI属性"></a>NLRI属性</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/49.png"></p>
<blockquote>
<p>•MP_REACH_NLRI字段解释：</p>
<ul>
<li>地址族信息（Address Family Information）：由2Byte的地址族标识（Address Family Identifier，AFI）和1Byte的子地址族标识（Subsequent Address Family Identifier，SAFI）组成。</li>
<li>下一跳长度（Length of Next Hop Network Address）：1Byte，表示下一跳地址的长度，通常情况下为16。</li>
<li>下一跳地址（Network Address of Next Hop）：长度由上一个字段决定，一般情况下为全球单播地址。</li>
<li>保留字段（Reserved）：1Byte，必须为0 。</li>
<li>网络层可达信息（Network Layer Reachability Information）：表示含有匹配相同属性的路由信息。当此字段为0时，表示为缺省路由。</li>
</ul>
<p>•MP_UNREACH_NLRI字段解释：</p>
<ul>
<li>撤销路由（Withdrawn Routes）：表示撤销的路由条目。格式为&lt;掩码长度，路由前缀&gt; ，当此掩码长度为0时，表示为缺省路由。</li>
</ul>
</blockquote>
<h2 id="BGP4-的基础配置命令"><a href="#BGP4-的基础配置命令" class="headerlink" title="BGP4+的基础配置命令"></a>BGP4+的基础配置命令</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/50.png"></p>
<blockquote>
<p>•BGP4+的基础配置命令与配置方式与BGP一致，其他配置命令不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
<p>•[Huawei-bgp] <strong>ipv6-family</strong> [ <strong>unicast</strong> | <strong>vpnv6</strong> | <strong>vpn-instance</strong> <em>vpn*</em>-instance-name* ]</p>
<ul>
<li><strong>unicast</strong>：进入IPv6单播地址族视图。</li>
<li><strong>vpnv6</strong>：进入BGP-VPNv6地址族视图。</li>
<li><strong>vpn-instance</strong> <em>vpn-instance-name</em>：将指定的VPN实例与IPv6地址族进行关联，进入BGP-VPN实例IPv6地址族视图。字符串形式，区分大小写，不支持空格，长度范围是1～31。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
</ul>
<p>•[Huawei-bgp-af-ipv6] <strong>network</strong> <em>ipv6-address</em> <em>prefix-length</em> [ <strong>route-policy</strong> <em>route-policy-name</em> ]</p>
<ul>
<li><p><em>ipv6-address</em>：指定BGP发布的IPv6网络地址。32位16进制数，格式为X:X:X:X:X:X:X:X。</p>
</li>
<li><p><em>prefix-length</em>：指定BGP发布的IPv6网络地址的前缀长度。整数形式，取值范围是0～128。</p>
</li>
<li><p><strong>route-policy</strong> <em>route-policy-name</em>：指定发布路由应用的Route-Policy。字符串形式，区分大小写，不支持空格，长度范围是1～40。当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
</li>
</ul>
</blockquote>
<h2 id="检查BGP4-基本功能的配置结果"><a href="#检查BGP4-基本功能的配置结果" class="headerlink" title="检查BGP4+基本功能的配置结果"></a>检查BGP4+基本功能的配置结果</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/51.png"></p>
<h2 id="BGP双栈配置举例"><a href="#BGP双栈配置举例" class="headerlink" title="BGP双栈配置举例"></a>BGP双栈配置举例</h2><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/52.png"></p>
<h3 id="部署IPv4网络-2"><a href="#部署IPv4网络-2" class="headerlink" title="部署IPv4网络"></a>部署IPv4网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/53.png"></p>
<h3 id="部署IPv6网络-2"><a href="#部署IPv6网络-2" class="headerlink" title="部署IPv6网络"></a>部署IPv6网络</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/54.png"></p>
<h3 id="查看BGP对等体信息"><a href="#查看BGP对等体信息" class="headerlink" title="查看BGP对等体信息"></a>查看BGP对等体信息</h3><p>•通过<strong>display</strong> <strong>bgp</strong> <strong>[ipv6] peer</strong>，分别查看IPv4和IPv6网络中的BGP对等体信息。</p>
<p>•发现除建立对等体的地址不同，其他信息基本一致。</p>
<p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/55.png"></p>
<h3 id="查看BGP4-路由信息"><a href="#查看BGP4-路由信息" class="headerlink" title="查看BGP4+路由信息"></a>查看BGP4+路由信息</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/56.png"></p>
<h3 id="查看BGP4-中的NLRI属性"><a href="#查看BGP4-中的NLRI属性" class="headerlink" title="查看BGP4+中的NLRI属性"></a>查看BGP4+中的NLRI属性</h3><p><img src="/2021/06/30/IPadv-IPv6%E8%B7%AF%E7%94%B1/57.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（多选题）以下LSA，属于OSPFv3的有哪些？(   )</p>
<p><strong>A.Router-LSA</strong></p>
<p><strong>B.Network-LSA</strong></p>
<p>C.Network-Summary-LSA</p>
<p><strong>D.Link-LSA</strong></p>
<p>2.（判断题）IS-IS支持IPv4网络和IPv6网络分别计算自己的最短路径树。(   )</p>
<p><strong>A.正确</strong></p>
<p>B.错误</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•通过IPv6静态路由能够满足网络互通要求，但随着网络的增大，就需要借助动态路由协议。因此要求动态路由协议能够支持IPv6，并能够携带IPv6地址进行路由通告。</p>
<p>•IETF为了支持IPv6网络，对OSPFv2进行了增强与改进，创建了一个新的协议：OSPFv3。</p>
<p>•IS-IS则是利用自己扩展性强的特点，通过新增TLV，实现对IPv6的支持。</p>
<p>•同样的，BGP利用自己的扩展路径属性以及多协议地址族实现对IPv6的支持。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="url">IPadv-BGP高级特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T12:22:57+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•在大型网络中通常会部署BGP，相比于IGP，BGP拥有更加灵活的路由控制能力。每一条BGP路由都可以携带多个路径属性，针对其属性也有特有的路由匹配工具，包括：AS_Path Filter和Community Filter。根据实际组网需求，可以实施路由策略，控制路由的接收和发布。</p>
<p>•同时，为了提升网络性能，BGP提供了各种高级特性以及多种组网部署方案。</p>
<p>•本课程将介绍BGP路由控制的原理与配置，介绍常用的BGP高级特性，包括：ORF、对等体组、安全特性，还会介绍BGP路由反射器的组网部署方式。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫在配置AS_Path Filter和Community Filter过程中使用正则表达式</p>
<p>▫使用AS_Path Filter和Community Filter实现BGP路由控制</p>
<p>▫应用BGP的ORF功能、对等体组功能</p>
<p>▫实现BGP安全的基本配置</p>
<p>▫描述BGP路由反射器的组网方式</p>
<h1 id="1-BGP路由控制"><a href="#1-BGP路由控制" class="headerlink" title="1.BGP路由控制"></a>1.BGP路由控制</h1><h2 id="BGP路由控制概述"><a href="#BGP路由控制概述" class="headerlink" title="BGP路由控制概述"></a>BGP路由控制概述</h2><p>BGP路由控制包括控制路由的发布和接收。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/1.png"></p>
<blockquote>
<p>•如图所示：</p>
<ul>
<li>R1和R2在AS101中，建立IBGP邻居关系；R3和R4在AS102中，分别与R2建立EBGP邻居关系。</li>
<li>R1有三个直连网段Net1、Net2和Net3，并将三个网段通告进BGP路由中。</li>
<li>在R2可以通过BGP路由控制，过滤Net2的路由，则R2的BGP路由表中就没有Net2的路由条目。</li>
<li>在R3和R4可以通过BGP路由控制，分别修改Net1和Net3的路由属性，控制路由优选，使AS102中设备访问Net1优选R3作为出口设备，访问Net3优选R4作为出口设备。</li>
</ul>
<p>•说明：ACL、IP Prefix List、Filter-Policy、Route-Policy和BGP路径属性等内容本课程不再赘述，详细内容请参考《HCIP-Datacom-Core Technology》课程。</p>
</blockquote>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>•正则表达式是按照一定的模板来匹配字符串的公式，由普通字符（例如字符a到z）和特殊字符组成。</p>
<p>•普通字符：匹配的对象是普通字符本身。</p>
<ul>
<li><p>包括所有的大写和小写字母、数字、标点符号以及一些特殊符号。</p>
</li>
<li><p>例如：a匹配abc中的a，10匹配10.113.25.155中的10，@匹配<a href="mailto:&#120;&#120;&#x78;&#x40;&#x78;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;">&#120;&#120;&#x78;&#x40;&#x78;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;</a>中的@。</p>
</li>
</ul>
<p>•特殊字符：配合普通字符匹配复杂或特殊的字符串组合。</p>
<ul>
<li>位于普通字符之前或之后用来限制或扩充普通字符的独立控制字符或占位符。</li>
<li>用来描述它前面的字符的重复使用方式。</li>
<li>限定一个完整的范围。</li>
</ul>
<blockquote>
<p>•正则表达式一般具有以下功能：</p>
<p>▫检查字符串中符合某个规则的子字符串，并可以获取该子字符串。</p>
<p>▫根据匹配规则对字符串进行替换操作。</p>
</blockquote>
<h2 id="特殊字符举例-1"><a href="#特殊字符举例-1" class="headerlink" title="特殊字符举例 (1)"></a>特殊字符举例 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/2.png"></p>
<blockquote>
<p>•说明：圆括号()可以用来定义操作符的范围和优先度。例如，gr(a|e)y等价于gray|grey。</p>
</blockquote>
<h2 id="特殊字符举例-2"><a href="#特殊字符举例-2" class="headerlink" title="特殊字符举例 (2)"></a>特殊字符举例 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/3.png"></p>
<blockquote>
<p>•思考题：</p>
<p>•类型1：</p>
<p>▫**^a.$**：匹配一个以字符a开始，以任意单一字符结束的字符串，如a0，a!，ax等。</p>
<p>▫**^100_**：匹配以100为起始的字符串，如：100、100 200、100 300 400等。</p>
<p>▫**^100$**：只匹配100。</p>
<p>▫**100$|400$**：匹配以100或400结束的字符串，如：100、1400、300 400等。</p>
<p>▫**^(65000)$**：只匹配(65000)。</p>
<p>•类型2：</p>
<p>▫<strong>abc*d</strong>：匹配c字符0次或多次，如：abd、abcd、abccd、abcccd、abccccdef等。</p>
<p>▫<strong>abc+d</strong>：匹配c字符1次或多次，如：abcd、abccd、abcccd、abccccdef等。</p>
<p>▫<strong>abc?d</strong>：匹配c字符0次或1次，如：abd、abcd、abcdef等。</p>
<p>▫<strong>a(bc)?d</strong>：匹配bc字符串0次或1次，如：ad、abcd、aaabcdef等。</p>
<p>•类型3：</p>
<p>▫**[abcd]**：匹配abcd中任意一个字符，即只要出现了a、b、c、d中的任意字符即可，如：ax、b！、abc、d0等。</p>
<p>▫**[a-c 1-2]$**：匹配以字符a、b、c、1、2结束的字符串，如：a、a1、62、xb、7ac等。</p>
<p>▫**[^act]$**：匹配不以字符a、c、t结束的字符串，如：ax、b！、d等。</p>
<p>▫**[123].[7-9]**：匹配如：1 7、2x9、348等。</p>
</blockquote>
<h2 id="路由匹配工具：AS-Path-Filter"><a href="#路由匹配工具：AS-Path-Filter" class="headerlink" title="路由匹配工具：AS_Path Filter"></a>路由匹配工具：AS_Path Filter</h2><p>•AS_Path Filter是将BGP中的AS_Path属性作为匹配条件的过滤器，利用BGP路由携带的AS_Path列表对路由进行过滤。</p>
<p>•在不希望接收某些AS的路由时，可以利用AS_Path Filter对携带这些AS号的路由进行过滤，从而实现拒绝某些路由。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/4.png"></p>
<blockquote>
<p>•AS_Path属性是BGP的公认必遵属性，所有的BGP路由都必须携带该属性。这个属性记录了BGP路由在传递过程中所经过的所有AS的号码。</p>
<p>•AS_Path属性值可以是0个、1个或多个AS号码的集合。</p>
</blockquote>
<h2 id="使用正则表达式匹配AS-Path"><a href="#使用正则表达式匹配AS-Path" class="headerlink" title="使用正则表达式匹配AS_Path"></a>使用正则表达式匹配AS_Path</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/5.png"></p>
<h2 id="AS-Path-Filter的基础配置命令"><a href="#AS-Path-Filter的基础配置命令" class="headerlink" title="AS_Path Filter的基础配置命令"></a>AS_Path Filter的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/6.png"></p>
<blockquote>
<p>•在同一个过滤器编号下，可以定义多条过滤规则（permit或deny模式）。在匹配过程中，这些规则之间是“或”的关系，即只要路由信息通过其中一项规则，就认为通过由该过滤器编号标识的这组AS_Path Filter。</p>
<p>•命令：[Huawei] <strong>ip as-path-filter</strong> { <em>as-path-filter-number</em> | <em>as-path-filter-name</em> } { <strong>deny</strong> | <strong>permit</strong> } <em>regular-expression</em></p>
<ul>
<li><em>as-path-filter-number</em>：指定的AS路径过滤器号。整数形式，取值范围1~256。</li>
<li><em>as-path-filter-name</em>：指定的AS路径过滤器名称。字符串形式，区分大小写，不支持空格，长度范围是1~51，且不能都是数字。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
<li><strong>deny</strong>：指定AS路径过滤器的匹配模式为拒绝。</li>
<li><strong>permit</strong>：指定AS路径过滤器的匹配模式为允许。</li>
<li><em>regular-expression</em>：指定AS路径正则表达式。字符串形式，支持空格，取值范围是1~255个字符。</li>
</ul>
<p>•AS路径过滤器的默认行为是deny，即路由如果没有在某一次过滤中被permit则最终不能通过该过滤器的过滤。如果一个过滤器中的所有过滤规则都是deny，则没有路由能通过该过滤器的过滤，这种情况下需要在多次（或一次）deny之后设置一次permit，允许其余所有路由通过过滤器的过滤。</p>
</blockquote>
<h2 id="AS-Path-Filter的配置举例-1"><a href="#AS-Path-Filter的配置举例-1" class="headerlink" title="AS_Path Filter的配置举例 (1)"></a>AS_Path Filter的配置举例 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/7.png"></p>
<h2 id="AS-Path-Filter的配置举例-2"><a href="#AS-Path-Filter的配置举例-2" class="headerlink" title="AS_Path Filter的配置举例 (2)"></a>AS_Path Filter的配置举例 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/8.png"></p>
<h2 id="查看AS-Path-Filter相关信息"><a href="#查看AS-Path-Filter相关信息" class="headerlink" title="查看AS_Path Filter相关信息"></a>查看AS_Path Filter相关信息</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/9.png"></p>
<h2 id="路由匹配工具：Community-Filter"><a href="#路由匹配工具：Community-Filter" class="headerlink" title="路由匹配工具：Community Filter"></a>路由匹配工具：Community Filter</h2><p>•Community Filter与Community属性配合使用，可以在不便使用IP Prefix List和AS_Path Filter时，降低路由管理难度。</p>
<p>•团体属性过滤器有两种类型：</p>
<p>​    ▫基本Community Filter。匹配团体号或公认Community属性。</p>
<p>​    ▫高级Community Filter。使用正则表达式匹配团体号。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/10.png"></p>
<blockquote>
<p>•Community属性为可选过渡属性，可以标识具有相同特征的路由，而不用考虑零散路由前缀和繁多的AS号。即可以将某些路由分配特定的Community属性值，之后就可以基于Community值而不是网络号/掩码来匹配路由并执行相应的路由策略。</p>
</blockquote>
<h2 id="Community属性"><a href="#Community属性" class="headerlink" title="Community属性"></a>Community属性</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/11.png"></p>
<h2 id="设置Community的基础配置命令"><a href="#设置Community的基础配置命令" class="headerlink" title="设置Community的基础配置命令"></a>设置Community的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/12.png"></p>
<blockquote>
<p>•命令：[Huawei-route-policy] <strong>apply community</strong> { <em>community-number</em> | <em>aa:nn</em> | <strong>internet</strong> | <strong>no-advertise</strong> | <strong>no-export</strong> | <strong>no-export-subconfed</strong> } [ <strong>additive</strong> ]</p>
<p>▫<em>community-number</em> | <em>aa:nn</em>：指定团体属性中的团体号。一条命令中最多可以配置32个团体号。整数形式，community-number的取值范围是0<del>4294967295，aa和nn的取值范围都是0</del>65535。</p>
<p>▫<strong>internet</strong>：表示可以向任何对等体发送匹配的路由。缺省情况下，所有的路由都属于Internet团体。</p>
<p>▫<strong>no-advertise</strong>：表示不向任何对等体发送匹配的路由。即收到具有此属性的路由后，不能发布给任何其他的BGP对等体。</p>
<p>▫<strong>no-export</strong>：表示不向AS外发送匹配的路由，但发布给其它子自治系统。即收到具有此属性的路由后，不能发布到本地AS之外。</p>
<p>▫<strong>no-export-subconfed</strong>：表示不向AS外发送匹配的路由，也不发布给其它子自治系统，即收到具有此属性的路由后，不能发布给任何其他的子自治系统。</p>
<p>▫<strong>additive</strong>：表示追加路由的团体属性。</p>
</blockquote>
<h2 id="Community-Filter的基础配置命令-1"><a href="#Community-Filter的基础配置命令-1" class="headerlink" title="Community Filter的基础配置命令 (1)"></a>Community Filter的基础配置命令 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/13.png"></p>
<blockquote>
<p>•命令：[Huawei] <strong>ip community-filter</strong> { <strong>basic</strong> <em>comm-filter-name</em> | <em>basic-<strong>comm</strong>-filter-num</em> } { <strong>permit</strong> | <strong>deny</strong> } [ <em>community-number</em> | <em>aa:nn</em> | <strong>internet</strong> | <strong>no-export-subconfed</strong> | <strong>no-advertise</strong> | <strong>no-export</strong> ]</p>
<p>▫<strong>basic</strong> <em>comm-filter-name</em>：指定基本团体属性过滤器名称。字符串形式，区分大小写，取值范围是1~51个字符，且不能都是数字。</p>
<p>▫<em>basic-<strong>comm</strong>-filter-num</em>：指定基本团体属性过滤器号。整数形式，取值范围1~99。</p>
<p>▫<strong>deny</strong>：指定团体属性过滤器的匹配模式为拒绝。</p>
<p>▫<strong>permit</strong>：指定团体属性过滤器的匹配模式为允许。</p>
<p>▫<em>community-number</em>：指定团体号。整数形式，取值范围0~4294967295。</p>
<p>▫<em>aa:nn</em>：指定团体号。一条命令最多可以指定20个团体属性号。aa和nn都是整数形式，取值范围都是0~65535。</p>
<p>▫<strong>internet</strong>：表示可以向任何对等体发送匹配的路由。</p>
<p>▫<strong>no-export-subconfed</strong>：指定不向自治系统外部通告路由。如果使用了联盟，则不会向联盟中的其他子自治系统通告路由。</p>
<p>▫<strong>no-advertise</strong>：指定不通告给其他对等体。</p>
<p>▫<strong>no-export</strong>：指定不向自治系统外部通告路由。如果使用了联盟，则不向联盟外部通告路由，但会通告给联盟中的其他子自治系统。</p>
<p>•命令：[Huawei] <strong>ip community-filter</strong> { <strong>advanced</strong> <em>comm*</em>-filter-name* | <em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em> } { <strong>permit</strong> | <strong>deny</strong> } <em>regular-expression</em></p>
<p>▫<strong>advanced</strong> <em>comm*</em>-filter-name*：指定高级团体属性过滤器名称。字符串形式，区分大小写，取值范围是1~51个字符，且不能都是数字。</p>
<p>▫<em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em>：指定高级团体属性过滤器号。整数形式，取值范围100~199。</p>
<p>▫<em>regular-expression</em>：指定团体属性正则表达式。字符串形式，支持空格，区分大小写，取值范围是1~255。</p>
</blockquote>
<h2 id="Community-Filter的基础配置命令-2"><a href="#Community-Filter的基础配置命令-2" class="headerlink" title="Community Filter的基础配置命令 (2)"></a>Community Filter的基础配置命令 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/14.png"></p>
<blockquote>
<p>•命令：[Huawei-route-policy] <strong>if-match community-filter</strong> { <em>basic-<strong>comm</strong>-filter-num</em> [ <strong>whole-match</strong> ] | <em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em> }</p>
<p>•命令：[Huawei-route-policy] <strong>if-match community-filter</strong> <em>comm-filter-name</em> [ <strong>whole-match</strong> ]</p>
<ul>
<li><em>basic-<strong>comm</strong>-filter-num</em>：指定基本团体属性过滤器号。整数形式，取值范围是1~99。</li>
<li><em>adv*</em>-<strong>comm</strong>-filter-*<em>num</em>：指定高级团体属性过滤器号。整数形式，取值范围是100~199。</li>
<li><em>comm-filter-name</em>：指定团体属性过滤器名称。字符串形式，区分大小写，不支持空格，长度范围是1~51，且不能都是数字。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
<li><strong>whole-match</strong>：表示完全匹配，即所有的团体都必须出现。仅对基本团体属性过滤器生效。</li>
</ul>
</blockquote>
<h2 id="Community-Filter的配置举例"><a href="#Community-Filter的配置举例" class="headerlink" title="Community Filter的配置举例"></a>Community Filter的配置举例</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/15.png"></p>
<h2 id="配置Community属性-1"><a href="#配置Community属性-1" class="headerlink" title="配置Community属性 (1)"></a>配置Community属性 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/16.png"></p>
<blockquote>
<p>•命令：[R1] <strong>route-policy</strong> Community <strong>permit node</strong> 20</p>
<p>•通过配置该命令允许10.1.2.2/32路由被正常通告。</p>
</blockquote>
<h2 id="配置Community属性-2"><a href="#配置Community属性-2" class="headerlink" title="配置Community属性 (2)"></a>配置Community属性 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/17.png"></p>
<h2 id="配置Community属性-3"><a href="#配置Community属性-3" class="headerlink" title="配置Community属性 (3)"></a>配置Community属性 (3)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/18.png"></p>
<h2 id="配置Community-Filter-1"><a href="#配置Community-Filter-1" class="headerlink" title="配置Community Filter (1)"></a>配置Community Filter (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/19.png"></p>
<h2 id="配置Community-Filter-2"><a href="#配置Community-Filter-2" class="headerlink" title="配置Community Filter (2)"></a>配置Community Filter (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/20.png"></p>
<h2 id="配置Community-Filter-3"><a href="#配置Community-Filter-3" class="headerlink" title="配置Community Filter (3)"></a>配置Community Filter (3)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/21.png"></p>
<h1 id="2-BGP特性介绍"><a href="#2-BGP特性介绍" class="headerlink" title="2.BGP特性介绍"></a>2.BGP特性介绍</h1><h2 id="邻居按需发布路由"><a href="#邻居按需发布路由" class="headerlink" title="邻居按需发布路由"></a>邻居按需发布路由</h2><p>•如果设备希望只接收自己需要的路由，但对端设备又无法针对每个与它连接的设备维护不同的出口策略。此时，可以通过配置BGP基于前缀的ORF（Outbound Route Filters，出口路由过滤器）来满足两端设备的需求。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/22.png"></p>
<h2 id="ORF的基础配置命令"><a href="#ORF的基础配置命令" class="headerlink" title="ORF的基础配置命令"></a>ORF的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/23.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp-af-ipv4] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> } <strong>ip-prefix</strong> <em>ip-prefix-name</em> { <strong>import</strong> | <strong>export</strong> }</p>
<p>​    ▫<strong>import</strong>：对由指定对等体（组）接收的路由应用过滤策略。</p>
<p>​    ▫<strong>export</strong>：对向指定对等体（组）发送的路由应用过滤策略。</p>
<p>•命令：[Huawei-bgp] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> } <strong>capability-advertise</strong> <strong>orf</strong> [ <strong>non-standard-compatible</strong> ] <strong>ip-prefix</strong> { <strong>both</strong> | <strong>receive</strong> | <strong>send</strong> } [ <strong>standard-match</strong> ]</p>
<p>​    ▫<strong>non-standard-compatible</strong>：指定与非标准设备兼容。</p>
<p>​    ▫<strong>both</strong>：表示允许发送和接收ORF报文。</p>
<p>​    ▫<strong>receive</strong>：表示只允许接收ORF报文。</p>
<p>​    ▫<strong>send</strong>：表示只允许发送ORF报文。</p>
<p>​    ▫<strong>standard-match</strong>：指定按照RFC标准规定的前缀匹配规则来匹配路由。</p>
</blockquote>
<h2 id="ORF配置举例"><a href="#ORF配置举例" class="headerlink" title="ORF配置举例"></a>ORF配置举例</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/24.png"></p>
<h2 id="查看ORF配置"><a href="#查看ORF配置" class="headerlink" title="查看ORF配置"></a>查看ORF配置</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/25.png"></p>
<h2 id="BGP对等体组"><a href="#BGP对等体组" class="headerlink" title="BGP对等体组"></a>BGP对等体组</h2><p>•对等体组（Peer Group）是一些具有某些相同策略的对等体的集合。当一个对等体加入对等体组中时，该对等体将获得与所在对等体组相同的配置。当对等体组的配置改变时，组内成员的配置也相应改变。</p>
<p>•在大型BGP网络中，对等体的数量会很多，其中很多对等体具有相同的策略，在配置时会重复使用一些命令，利用对等体组可以简化配置。</p>
<blockquote>
<p>•对等体组中的单个对等体也可以配置自己的发布路由与接收路由的策略。</p>
</blockquote>
<h2 id="BGP对等体组的基础配置命令"><a href="#BGP对等体组的基础配置命令" class="headerlink" title="BGP对等体组的基础配置命令"></a>BGP对等体组的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/26.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp] <strong>group</strong> <em>group-name</em> [ <strong>external</strong> | <strong>internal</strong> ]</p>
<p>​    ▫<em>group-name</em>：指定对等体组的名称。字符串形式，区分大小写，不支持空格，长度范围是1~47。当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
<p>​    ▫<strong>external</strong>：表示创建EBGP对等体组。</p>
<p>​    ▫<strong>internal</strong>：表示创建IBGP对等体组。</p>
</blockquote>
<h2 id="BGP对等体组配置举例"><a href="#BGP对等体组配置举例" class="headerlink" title="BGP对等体组配置举例"></a>BGP对等体组配置举例</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/27.png"></p>
<blockquote>
<p>•如图所示：假设AS102内，通过静态路由或OSPF实现AS102内部网络可达，配置省略。</p>
</blockquote>
<h2 id="查看BGP对等体组配置"><a href="#查看BGP对等体组配置" class="headerlink" title="查看BGP对等体组配置"></a>查看BGP对等体组配置</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/28.png"></p>
<h2 id="BGP安全性"><a href="#BGP安全性" class="headerlink" title="BGP安全性"></a>BGP安全性</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/29.png"></p>
<h2 id="BGP认证"><a href="#BGP认证" class="headerlink" title="BGP认证"></a>BGP认证</h2><p>BGP认证分为MD5认证和Keychain认证，对BGP对等体关系进行认证可以预防非法BGP邻居建立。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/30.png"></p>
<blockquote>
<p>•BGP使用TCP作为传输协议，只要TCP数据包的源地址、目的地址、源端口、目的端口和TCP序号是正确的，BGP就会认为这个数据包有效，但数据包的大部分参数对于攻击者来说是不难获得的。为了保证BGP免受攻击，可以在BGP邻居之间使用MD5认证或者Keychain认证来降低被攻击的可能性。</p>
<ul>
<li><p>MD5算法配置简单，配置后生成单一密码，需要人为干预才可以更换密码。</p>
</li>
<li><p>Keychain具有一组密码，可以根据配置自动切换，但是配置过程较为复杂，适用于对安全性能要求比较高的网络。</p>
</li>
</ul>
<p>•注意：BGP的MD5认证与BGP的Keychain认证互斥。</p>
</blockquote>
<h2 id="BGP的GTSM"><a href="#BGP的GTSM" class="headerlink" title="BGP的GTSM"></a>BGP的GTSM</h2><p>BGP的GTSM功能检测IP报文头中的TTL（Time-to-Live）值是否在一个预先设置好的特定范围内，并对不符合TTL值范围的报文进行丢弃，这样就避免了网络攻击者模拟“合法”BGP报文攻击设备。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/31.png"></p>
<blockquote>
<p>•如图所示：如果没有使能BGP的GTSM功能，设备收到大量非法BGP报文后，发现是发送给本机的报文，会直接上送控制层面处理。这时将会因为控制层面处理大量攻击报文，导致设备CPU占用率高，系统异常繁忙。</p>
</blockquote>
<h2 id="BGP认证的基础配置命令"><a href="#BGP认证的基础配置命令" class="headerlink" title="BGP认证的基础配置命令"></a>BGP认证的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/32.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> | <em>ipv6-address</em> } <strong>keychain</strong> <em>keychain-name</em></p>
<p>▫<em>keychain-name</em>：指定Keychain名称。字符串形式，长度范围是1~47，不区分大小写。字符不包括问号和空格，但是当输入的字符串两端使用双引号时，可在字符串中输入空格。</p>
</blockquote>
<h2 id="GTSM功能的基础配置命令"><a href="#GTSM功能的基础配置命令" class="headerlink" title="GTSM功能的基础配置命令"></a>GTSM功能的基础配置命令</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/33.png"></p>
<blockquote>
<p>•命令：[Huawei-bgp] <strong>peer</strong> { <em>group-name</em> | <em>ipv4-address</em> | <em>ipv6-address</em> } <strong>valid-ttl-hops</strong> [ <em>hops</em> ]</p>
<ul>
<li><em>hops</em>：指定需要检测的TTL跳数值。整数形式，取值范围是1~255，缺省值是255。如果配置为hops，则被检测的报文的TTL值有效范围为[255–hops+1, 255]</li>
</ul>
<p>•命令：[Huawei] <strong>gtsm</strong> <strong>default-action</strong> { <strong>drop</strong> | <strong>pass</strong> }</p>
<ul>
<li><p><strong>drop</strong>：未匹配GTSM策略的报文不能通过过滤，报文被丢弃。</p>
</li>
<li><p><strong>pass</strong>：未匹配GTSM策略的报文可以通过过滤。</p>
</li>
</ul>
<p>•命令：[Huawei] <strong>gtsm</strong> <strong>log drop-packet</strong> <strong>all</strong></p>
<ul>
<li><strong>all</strong>：所有单板。</li>
</ul>
</blockquote>
<h2 id="GTSM配置举例-1"><a href="#GTSM配置举例-1" class="headerlink" title="GTSM配置举例 (1)"></a>GTSM配置举例 (1)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/34.png"></p>
<blockquote>
<p>•如图所示：</p>
<p>▫假设AS101内，通过静态路由或OSPF实现AS101内部网络可达，配置省略。</p>
<p>▫R1通告Loopback0接口地址到BGP中。</p>
</blockquote>
<h2 id="GTSM配置举例-2"><a href="#GTSM配置举例-2" class="headerlink" title="GTSM配置举例 (2)"></a>GTSM配置举例 (2)</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/35.png"></p>
<h2 id="查看GTSM配置"><a href="#查看GTSM配置" class="headerlink" title="查看GTSM配置"></a>查看GTSM配置</h2><p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/36.png"></p>
<h1 id="3-BGP路由反射器组网方式"><a href="#3-BGP路由反射器组网方式" class="headerlink" title="3.BGP路由反射器组网方式"></a>3.BGP路由反射器组网方式</h1><h2 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h2><p>引入路由反射器，可以简化IBGP全互联的需求，也可以减轻网络和CPU的负担。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/37.png"></p>
<blockquote>
<p>•路由反射器相关角色：</p>
<p>▫RR：允许把从IBGP对等体学到的路由反射到其他IBGP对等体的BGP设备，类似OSPF网络中的DR。</p>
<p>▫Client：与RR形成反射邻居关系的IBGP设备。在AS内部客户机只需要与RR直连。</p>
<p>▫Non-Client：既不是RR也不是客户机的IBGP设备。在AS内部非客户机与RR之间，以及所有的非客户机之间仍然必须建立全互联关系。</p>
<p>▫Originator（始发者）：在AS内部始发路由的设备。Originator_ID属性用于防止集群内产生路由环路。</p>
<p>▫Cluster（集群）：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路。</p>
<p>•将一台BGP路由器指定为RR的同时，还需要指定其Client。至于Client本身，无需做任何配置，它并不知晓网络中存在RR。</p>
<p>•RR发布路由规则：</p>
<ul>
<li>从非客户机IBGP对等体学到的路由，发布给此RR的所有客户机。</li>
<li>从客户机学到的路由，发布给此RR的所有非客户机和客户机。</li>
<li>从EBGP对等体学到的路由，发布给所有的非客户机和客户机。</li>
</ul>
</blockquote>
<h2 id="常见组网：备份RR组网"><a href="#常见组网：备份RR组网" class="headerlink" title="常见组网：备份RR组网"></a>常见组网：备份RR组网</h2><p>•为增加网络的可靠性，防止单点故障对网络造成影响，有时需要在一个集群中配置一个以上的RR。</p>
<p>•转发路径上的路由器与所有RR均建立IBGP关系，任意一个RR均有完整的BGP路由。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/38.png"></p>
<h2 id="常见组网：多集群RR组网-1"><a href="#常见组网：多集群RR组网-1" class="headerlink" title="常见组网：多集群RR组网 (1)"></a>常见组网：多集群RR组网 (1)</h2><p>•一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。</p>
<p>•当RR所处的网络层相同时，可以将不同集群的RR全互联，形成同级RR。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/39.png"></p>
<h2 id="常见组网：多集群RR组网-2"><a href="#常见组网：多集群RR组网-2" class="headerlink" title="常见组网：多集群RR组网 (2)"></a>常见组网：多集群RR组网 (2)</h2><p>•一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。</p>
<p>•当RR所处的网络层不同时，可以将较低网络层次的RR配成客户机，形成分级RR。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/40.png"></p>
<blockquote>
<p>•分级RR与单级RR的路由发布规则相同。</p>
<p>•分级RR设计需要考虑两个因素：</p>
<ul>
<li>顶层全互联的拓扑大小：如果IBGP全互联数量已经多到难以管理了，则可考虑引入RR分级部署。</li>
<li>可替代路径的数量：该因素影响负载分担和资源消耗。越多的层次越会减少负载分担链路的数量，但需要的路由器资源更少。</li>
</ul>
</blockquote>
<h2 id="单集群问题"><a href="#单集群问题" class="headerlink" title="单集群问题"></a>单集群问题</h2><p>为了在基于RR的架构中提供所期望的冗余，正确的集群划分是非常重要的。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/41.png"></p>
<h2 id="多集群设计"><a href="#多集群设计" class="headerlink" title="多集群设计"></a>多集群设计</h2><p>多集群设计不仅提供了针对链路失效的物理冗余，同时提供了针对客户机与RR之间的IBGP会话失效的逻辑冗余。</p>
<p><img src="/2021/06/30/IPadv-BGP%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/42.png"></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.（单选题）命令**“ip as-path-filter 1 permit ^(100|200)$**”中匹配到的AS_Path是什么？(   )</p>
<p>A.AS_Path 100</p>
<p>B.AS_Path 200</p>
<p>C.AS_Path 100 200</p>
<p><strong>D.AS_Path 100 或 AS_Path 200</strong></p>
<p>2.（判断题）BGP的GTSM功能，可以预防非法BGP邻居建立。(   )</p>
<p>A.正确</p>
<p><strong>B.错误</strong></p>
<p>3.（判断题）BGP的备份RR组网中，主备RR收到对方反射的路由会丢弃，避免路由环路。(   )</p>
<p><strong>A.正确</strong></p>
<p>B.错误</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•AS_Path Filter和Community Filter都是BGP专有的路由匹配工具，可以使用这两种工具匹配AS_Path属性或Community属性来匹配BGP路由，再与路由策略相结合，从而实现BGP的路由控制。</p>
<p>•BGP还支持各种高级特性，包括：通过ORF功能实现邻居按需发布路由，通过对等体组简化配置，通过BGP安全特性预防非法邻居建立以及非法BGP报文攻击。</p>
<p>•BGP通过RR打破了IBGP水平分割规则，简化了IBGP全互联的需求，也减轻了网络和CPU的负担。常见的RR组网方式包括：备份RR组网和多集群RR组网。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url">IPadv-MPLSVPN部署与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-23T15:17:09+08:00">
                2021-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>•BGP/MPLS IP VPN因其支持地址空间重叠、组网方式灵活、可扩展性好，并能够方便地支持MPLS TE等一系列优点，已经在广域IP承载网络得到了广泛的应用。</p>
<p>•针对不同客户的业务需求以及组网情况，MPLS VPN的部署方式不尽相同。</p>
<p>•本课程将介绍几种常见的MPLS VPN应用场景与这些场景下MPLS VPN的部署方法，此外还将介绍OSPF对MPLS VPN的扩展特性与功能。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>▫描述MPLS VPN的应用场景与组网类型</p>
<p>▫部署MPLS VPN的Intranet方案</p>
<p>▫部署MPLS VPN的Hub&amp;Spoke方案</p>
<p>▫描述OSPF对MPLS VPN扩展功能与特性</p>
<h1 id="1-MPLS-VPN应用与组网概述"><a href="#1-MPLS-VPN应用与组网概述" class="headerlink" title="1.MPLS VPN应用与组网概述"></a>1.MPLS VPN应用与组网概述</h1><h2 id="MPLS-VPN典型应用"><a href="#MPLS-VPN典型应用" class="headerlink" title="MPLS VPN典型应用"></a>MPLS VPN典型应用</h2><p>•目前，MPLS VPN的主要应用包括企业互连和虚拟业务网络。</p>
<p>▫企业互连应用：可通过MPLS VPN将分布在各地的分支机构、出差员工和合作伙伴的IP网络连接在一起；</p>
<p>▫虚拟业务网络：可在同一物理网络上运行多种业务，如VoIP、IPTV等，为每个业务建立一个VPN，实现业务隔离。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/1.png"></p>
<blockquote>
<p>•MPLS VPN的主要优点包括但不限于以下几项：</p>
<ul>
<li>可以实现“一点接入，全网连通”，支持异种介质的互连。而不像传统专线那样在每一对用户设备间采用同样的介质连接，可方便地提供普遍服务。</li>
<li>可以实现“弹性带宽”，采用流量监管技术，在保证用户基本带宽的同时，对突发流量尽力而为，同时基本带宽也可以“软扩容”，即根据用户的需求在一个范围内连续选择。</li>
<li>在资源隔离或隧道绑定的MPLS VPN技术保证下，充分保证每个VPN的专有带宽，满足各类业务有不同的用户，不同的流量模型，不同的QoS要求。</li>
</ul>
</blockquote>
<h2 id="MPLS-VPN基本组网-Intranet"><a href="#MPLS-VPN基本组网-Intranet" class="headerlink" title="MPLS VPN基本组网 - Intranet"></a>MPLS VPN基本组网 - Intranet</h2><p>当采用Intranet组网方案时，一个VPN中的所有用户形成闭合用户群，相互之间能够进行流量转发，VPN中的用户不能与任何本VPN以外的用户通信，其站点通常是属于同一个组织。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/2.png"></p>
<h2 id="MPLS-VPN基本组网-Extranet"><a href="#MPLS-VPN基本组网-Extranet" class="headerlink" title="MPLS VPN基本组网 - Extranet"></a>MPLS VPN基本组网 - Extranet</h2><p>当采用Extranet组网方案时，VPN用户可将部分站点中的网络资源给其他VPN用户进行访问。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/3.png"></p>
<h2 id="MPLS-VPN基本组网-Hub-amp-Spoke-1"><a href="#MPLS-VPN基本组网-Hub-amp-Spoke-1" class="headerlink" title="MPLS VPN基本组网 - Hub&amp;Spoke (1)"></a>MPLS VPN基本组网 - Hub&amp;Spoke (1)</h2><p>当采用Hub&amp;Spoke方案时，可以将多个站点中的一个站点设置为Hub站点，其余站点为Spoke站点。站点间的互访必须通过Hub站点，通过Hub站点集中管控站点间的数据传输。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/4.png"></p>
<h2 id="MPLS-VPN基本组网-Hub-amp-Spoke-2"><a href="#MPLS-VPN基本组网-Hub-amp-Spoke-2" class="headerlink" title="MPLS VPN基本组网 - Hub&amp;Spoke (2)"></a>MPLS VPN基本组网 - Hub&amp;Spoke (2)</h2><p>从Site1到Site2的路由发布过程如下：</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/5.png"></p>
<h2 id="MCE组网"><a href="#MCE组网" class="headerlink" title="MCE组网"></a>MCE组网</h2><p>•当一个私网需要根据业务或者网络划分VPN时，不同VPN用户间的业务需要完全隔离。此时，为每个VPN单独配置一台CE将增加用户的设备开支和维护成本。</p>
<p>•具有MCE（Multi-VPN-Instance，CE多实例CE）功能的CE设备可以在MPLS VPN组网应用中承担多个VPN实例的CE功能，减少用户网络设备的投入。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/6.png"></p>
<h2 id="MPLS-VPN跨域组网"><a href="#MPLS-VPN跨域组网" class="headerlink" title="MPLS VPN跨域组网"></a>MPLS VPN跨域组网</h2><p>•随着MPLS VPN解决方案的广泛应用，服务的终端用户的规格和范围也在增长，在一个企业内部的站点数目越来越大，某个地理位置与另外一个服务提供商相连的需求变得非常的普遍，例如国内运营商的不同城域网之间，或相互协作的运营商的骨干网之间都存在着跨越不同自治系统（AS，Autonomous System）的情况。</p>
<p>•一般的MPLS VPN体系结构都是在一个AS内运行，任何VPN的路由信息都是只能在一个AS内按需扩散。AS之间的MPLS VPN部署需要通过跨域（Inter-AS） MPLS VPN解决方案来实现。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/7.png"></p>
<blockquote>
<p>•RFC2547中提出了三种跨域VPN解决方案，分别是：</p>
<ul>
<li>跨域VPN-OptionA（Inter-Provider Backbones Option A）方式：需要跨域的VPN在ASBR（AS Boundary Router）间通过专用的接口管理自己的VPN路由，也称为VRF-to-VRF；</li>
<li>跨域VPN-OptionB（Inter-Provider Backbones Option B）方式：ASBR间通过MP-EBGP发布标签VPN-IPv4路由，也称为EBGP redistribution of labeled VPN-IPv4 routes；</li>
<li>跨域VPN-OptionC（Inter-Provider Backbones Option C）方式：PE间通过Multi-hop MP-EBGP发布标签VPN-IPv4路由，也称为Multihop EBGP redistribution of labeled VPN-IPv4 routes。</li>
</ul>
<p>•更多跨域MPLS VPN相关内容，请参考HCIE-Datacom相关课程。</p>
</blockquote>
<h1 id="2-MPLS-VPN典型场景部署介绍"><a href="#2-MPLS-VPN典型场景部署介绍" class="headerlink" title="2.MPLS VPN典型场景部署介绍"></a>2.MPLS VPN典型场景部署介绍</h1><h2 id="Intranet场景"><a href="#Intranet场景" class="headerlink" title="Intranet场景"></a>Intranet场景</h2><h3 id="部署Intranet场景的MPLS-VPN"><a href="#部署Intranet场景的MPLS-VPN" class="headerlink" title="部署Intranet场景的MPLS VPN"></a>部署Intranet场景的MPLS VPN</h3><p>•如图所示，客户X及Y各自有2个站点，现需要通过MPLS VPN实现站点之间的互联，分别对应VPNX和VPNY；</p>
<p>•互联接口、AS号及IP地址信息，CE与PE通过如图的协议或方法交换路由信息；</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/8.png"></p>
<blockquote>
<p>•注：本课程仅讨论非跨域的MPLS VPN部署场景。</p>
</blockquote>
<h3 id="部署思路"><a href="#部署思路" class="headerlink" title="部署思路"></a>部署思路</h3><p>1.MPLS VPN骨干网配置</p>
<p>1.1 IGP配置，实现骨干网的IP连通性。</p>
<p>1.2 MPLS与MPLS LDP配置，建立MPLS LSP公网隧道，传输VPN数据。</p>
<p>1.3 MP-BGP配置，建立后续传递VPNv4路由的MP-BGP对等体关系。</p>
<p>2.VPN用户接入配置</p>
<p>2.1 创建VPN实例并配置参数（RT、RD）</p>
<p>2.2 将接口加入VPN实例</p>
<p><strong>2.3</strong> <strong>配置PE与CE之间的路由交换</strong></p>
<h3 id="PE-CE之间部署OSPF-1"><a href="#PE-CE之间部署OSPF-1" class="headerlink" title="PE-CE之间部署OSPF (1)"></a>PE-CE之间部署OSPF (1)</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/9.png"></p>
<h3 id="PE-CE之间部署OSPF-2"><a href="#PE-CE之间部署OSPF-2" class="headerlink" title="PE-CE之间部署OSPF (2)"></a>PE-CE之间部署OSPF (2)</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/10.png"></p>
<h3 id="PE-CE之间部署静态路由"><a href="#PE-CE之间部署静态路由" class="headerlink" title="PE-CE之间部署静态路由"></a>PE-CE之间部署静态路由</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/11.png"></p>
<h3 id="PE-CE之间部署EBGP"><a href="#PE-CE之间部署EBGP" class="headerlink" title="PE-CE之间部署EBGP"></a>PE-CE之间部署EBGP</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/12.png"></p>
<h3 id="特殊场景下的BGP配置-AS号替换"><a href="#特殊场景下的BGP配置-AS号替换" class="headerlink" title="特殊场景下的BGP配置 - AS号替换"></a>特殊场景下的BGP配置 - AS号替换</h3><p>在MPLS VPN场景中，若PE与CE之间运行EBGP交互路由信息，则可能会出现两个站点的AS号相同的情况。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/13.png"></p>
<h3 id="特殊场景下的BGP配置-SoO"><a href="#特殊场景下的BGP配置-SoO" class="headerlink" title="特殊场景下的BGP配置 - SoO"></a>特殊场景下的BGP配置 - SoO</h3><p>•在CE多归属场景，若使能了BGP的AS号替换功能，可能会引起路由环路，需要SoO（Site of Origin）特性来避免环路。</p>
<ul>
<li><p>CE1与CE3处于同一个VPN站点1，CE2位于站点Site2，Site1和Site2站点所在的AS号都为65001。PE与CE之间运行的都是EBGP路由协议，为了Site 1和Site 2之间的路由可以正常学习，需要在PE1和PE2上配置AS号替换功能。</p>
</li>
<li><p>CE1传递站点内的路由给PE1，PE1传递该路由给CE3，由于配置AS号替换，CE3会接收该路由，可能会导致产生路由环路。</p>
</li>
</ul>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/14.png"></p>
<blockquote>
<p>•注：192.168.100.1和192.168.200.1分别是CE1和CE3上和PE1建立BGP对等体的接口地址。</p>
</blockquote>
<h3 id="PE-CE之间部署IS-IS"><a href="#PE-CE之间部署IS-IS" class="headerlink" title="PE-CE之间部署IS-IS"></a>PE-CE之间部署IS-IS</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/15.png"></p>
<h2 id="Hub-amp-Spoke场景"><a href="#Hub-amp-Spoke场景" class="headerlink" title="Hub&amp;Spoke场景"></a>Hub&amp;Spoke场景</h2><h3 id="部署Hub-amp-Spoke场景的MPLS-VPN"><a href="#部署Hub-amp-Spoke场景的MPLS-VPN" class="headerlink" title="部署Hub&amp;Spoke场景的MPLS VPN"></a>部署Hub&amp;Spoke场景的MPLS VPN</h3><p>•Hub&amp;Spoke有以下组网方案：</p>
<p>​    ▫方式一：Hub-CE与Hub-PE，Spoke-PE与Spoke-CE使用EBGP</p>
<p>​    ▫方式二：Hub-CE与Hub-PE，Spoke-PE与Spoke-CE使用IGP</p>
<p>​    ▫方式三：Hub-CE与Hub-PE使用EBGP，Spoke-PE与Spoke-CE使用IGP</p>
<p>•<strong>无法</strong>通过Hub-CE与Hub-PE使用IGP，Spoke-PE与Spoke-CE使用EBGP来部署Hub&amp;Spoke组网的MPLS VPN。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/16.png"></p>
<h3 id="VRF配置"><a href="#VRF配置" class="headerlink" title="VRF配置"></a>VRF配置</h3><p>•Spoke-PE上创建一个VPN实例，RT配置如图。</p>
<p>•Hub-PE上创建VPN_in和VPN_out两个VPN实例，分别用于从Spoke-PE接收私网路由或向Spoke-PE发布私网路由，RT配置如图。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/17.png"></p>
<h3 id="方式一部署-路由发布过程"><a href="#方式一部署-路由发布过程" class="headerlink" title="方式一部署 - 路由发布过程"></a>方式一部署 - 路由发布过程</h3><p>•Spoke-CE与Spoke-PE之间通过EBGP交互路由信息，建立EBGP连接后，把相关的路由发布到BGP即可。</p>
<p>•Hub-PE与Hub-CE之间建立两条EBGP连接，分别用来发布和接收私网路由。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/18.png"></p>
<blockquote>
<p>•以路由从Spoke-CE1发布到Spoke-CE2为例，大体过程如下：</p>
<p>1.Spoke-CE1通过EBGP将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将该路由发布给Hub-PE。</p>
<p>3.Hub-PE通过VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表，并通过EBGP发布给Hub-CE。</p>
<p>4.Hub-CE通过EBGP连接学习到该路由，并通过另一个EBGP连接将该路由发布给Hub-PE的VPN实例（VPN_out）。</p>
<p>5.Hub-PE发布携带VPN_out的Export Target属性的路由给所有Spoke-PE。</p>
<p>6.Spoke-PE2通过EBGP将该路由发布给Spoke-CE2。</p>
</blockquote>
<h3 id="方式一部署-Hub-PE与Hub-CE间配置"><a href="#方式一部署-Hub-PE与Hub-CE间配置" class="headerlink" title="方式一部署 - Hub-PE与Hub-CE间配置"></a>方式一部署 - Hub-PE与Hub-CE间配置</h3><p>•Hub-PE通过VPN_in对应的EBGP连接将从Spoke站点学习的路由发布到Hub站点。</p>
<p>•Hub-CE通过VPN_out对应的EBGP将这些路由发布到Spoke站点。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/19.png"></p>
<h3 id="方式二部署-路由发布过程"><a href="#方式二部署-路由发布过程" class="headerlink" title="方式二部署 - 路由发布过程"></a>方式二部署 - 路由发布过程</h3><p>•以选用OSPF作为IGP协议为例：</p>
<p>▫Spoke-CE与Spoke-PE之间通过OSPF（进程100）邻居关系交互路由信息。</p>
<p>▫Hub-PE通过两个OSPF进程与Hub-CE建立OSPF邻居，分别负责私网路由的发送和接收。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/20.png"></p>
<blockquote>
<p>•以路由从Spoke-CE1发布到Spoke-CE2为例，大体过程如下：</p>
<p>1.Spoke-CE1通过OSPF100将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将路由发布给Hub-PE。</p>
<p>3.Hub-PE通过VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表；通过将BGP引入OSPF100的配置进而将从Spoke-PE1传递来的路由发布给Hub-CE。</p>
<p>4.Hub-CE通过OSPF100接收该路由；并通过配置路由引入将路由发布到OSPF200，OSPF200再将路由发布给Hub-PE。</p>
<p>5.Hub-PE的BGP-VPN实例（VPN_out）引入OSPF200多实例的路由，将携带Export Target属性的路由发布给所有Spoke-PE。</p>
<p>6.Spoke-PE2通过OSPF100将该路由发布给Spoke-CE2。</p>
</blockquote>
<h3 id="方式二部署-Hub-PE与Hub-CE间配置"><a href="#方式二部署-Hub-PE与Hub-CE间配置" class="headerlink" title="方式二部署 - Hub-PE与Hub-CE间配置"></a>方式二部署 - Hub-PE与Hub-CE间配置</h3><p>•Hub-PE通过VPN_in对应的OSPF（进程100）将从Spoke站点学习的路由发布到Hub站点。</p>
<p>•Hub-CE通过VPN_out对应的OSPF（进程200）将这些路由发布到Hub-PE，进而发布给所有Spoke站点。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/21.png"></p>
<h3 id="方式三部署-路由发布过程"><a href="#方式三部署-路由发布过程" class="headerlink" title="方式三部署 - 路由发布过程"></a>方式三部署 - 路由发布过程</h3><p>•以选用OSPF作为IGP协议为例，Spoke-CE与Spoke-PE之间通过OSPF（进程100）邻居关系交互路由信息。</p>
<p>•Hub-PE与Hub-CE之间建立两条EBGP连接，分别用来发布和接收私网路由，Hub-PE与Hub-CE的配置与方式一相同。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/22.png"></p>
<blockquote>
<p>•以路由从Spoke-CE1发布到Spoke-CE2为例，大体过程如下：</p>
<p>1.Spoke-CE1通过OSPF100将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将路由发布给Hub-PE。</p>
<p>3.Hub-PE通过VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表，并通过EBGP发布给Hub-CE。</p>
<p>4.Hub-CE通过EBGP连接学习到该路由，并通过另一个EBGP连接将该路由发布给Hub-PE的VPN实例（VPN_out）。</p>
<p>5.Hub-PE发布携带VPN_out的Export Target属性的路由给Spoke-PE2。</p>
<p>6.Spoke-PE2通过OSPF100将该路由发布给Spoke-CE2。</p>
</blockquote>
<h3 id="为什么没有方式四？"><a href="#为什么没有方式四？" class="headerlink" title="为什么没有方式四？"></a>为什么没有方式四？</h3><p>•<strong>无法</strong>通过Hub-CE与Hub-PE使用IGP，Spoke-PE与Spoke-CE使用EBGP来部署Hub&amp;Spoke组网的MPLS VPN</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/23.png"></p>
<blockquote>
<p>•以从Spoke-CE1向Spoke-CE2发布路由（目的地址为192.168.1.0/24）为例，大体过程如下：</p>
<p>1.Spoke-CE1通过EBGP将路由发布给Spoke-PE1。</p>
<p>2.Spoke-PE1通过IBGP将路由发布给Hub-PE。</p>
<p>3.Hub-PE通过BGP-VPN实例（VPN_in）的Import Target属性将该路由引入VPN_in路由表；并通过OSPF100多实例发布给Hub-CE。</p>
<p>4.Hub-CE通过OSPF100学习到该路由；并通过OSPF200将路由发布给Hub-PE。</p>
<p>5.Hub-PE的BGP-VPN实例（VPN_out）引入OSPF200多实例路由，并将携带VPN_out的Export Target属性的路由发布给所有Spoke-PE。</p>
<p>6.Spoke-PE2的VPN实例根据Import Target属性引入该路由；Spoke-PE2通过EBGP发布给本地Spoke-CE2。</p>
<p>•Hub-PE的BGP-VPN实例（VPN_out）通过Export Target属性将路由发布给Spoke-PE2的同时，也会将该路由发布给Spoke-PE1。此时，这条路由是Hub-PE通过IGP（OSPF200多实例）引入的，由于IGP路由不携带AS-PATH属性，AS_Path为空；而原来从Spoke-CE1来的192.168.1.0/24路由，其AS_Path不为空，所以从Hub-PE返回的路由会优于从Spoke-CE1来的路由。这样会引起路由振荡，其过程如下：</p>
<p>1.Spoke-CE1发来的路由因为AS_Path变成非最佳路由</p>
<p>2.Spoke-PE1发布Update撤销路由的报文给Hub-PE来撤销192.168.1.0/24路由</p>
<p>3.Hub-PE（通过撤销相应的OSPF LSA）撤销发给Hub-CE的路由</p>
<p>4.Hub-CE（原理同上）撤销发给Hub-PE的路由</p>
<p>5.Hub-PE发布Update撤销路由撤销发给Spoke-PE1的路由</p>
<p>•于是在Spoke-PE1上从Spoke-CE1来的路由又变成最佳路由。Spoke-PE1又通过IBGP将路由发布给Hub-PE。Hub-PE又会返回该路由，从Spoke-CE1来的路由又变成非最佳路由。如此反复。</p>
</blockquote>
<h1 id="3-OSPF-VPN拓展"><a href="#3-OSPF-VPN拓展" class="headerlink" title="3.OSPF VPN拓展"></a>3.OSPF VPN拓展</h1><h2 id="OSPF与BGP互操作"><a href="#OSPF与BGP互操作" class="headerlink" title="OSPF与BGP互操作"></a>OSPF与BGP互操作</h2><h3 id="MPLS-VPN中的OSPF-BGP"><a href="#MPLS-VPN中的OSPF-BGP" class="headerlink" title="MPLS VPN中的OSPF/BGP"></a>MPLS VPN中的OSPF/BGP</h3><p>•当PE-CE间部署OSPF交互路由信息时，若在PE上使用标准BGP/OSPF过程（简称为BGP/OSPF互操作）互来传递路由信息，则远端PE在将BGP引入VPN实例的OSPF进程时，会直接产生Type5 LSA，不同站点都会将其他站点的路由视为自治系统外部路由（AS_external）。</p>
<p>•为了解决标准BGP/OSPF的互操作导致的OSPF路由信息丢失的问题，BGP和OSPF都做了相应的拓展。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/24.png"></p>
<blockquote>
<p>•在实际应用中，如果两个要互通的Site都在相同的AS内，那么每个Site都应该将另一个Site的路由看成区域间路由，而不是AS外部路由。</p>
</blockquote>
<h3 id="BGP扩展团体属性"><a href="#BGP扩展团体属性" class="headerlink" title="BGP扩展团体属性"></a>BGP扩展团体属性</h3><p>•为了保留OSPF的路由信息，BGP新增了部分可携带OSPF路由信息的团体属性：</p>
<ul>
<li><p>Domain ID：域标识符用来标识和区分不同的域。</p>
</li>
<li><p>Route Type：包含被引入到BGP的OSPF路由的 Area-ID 以及Route Type</p>
<ul>
<li>Area-ID：PE 的VPN实例的OSPF进程与CE建立邻接关系的区域号</li>
<li>Route Type：被引入的 OSPF 路由的类型<ul>
<li>1 或 2：表示路由的类型为区域内部路由， 也就是 PE 根据 Type-1 及 Type-2 LSA 所计算出来的路由。</li>
<li>3：表示路由的类型为区域间路由。</li>
<li>5：表示路由的类型为 OSPF 外部路由，也就是 PE 通过 Type-5 LSA 计算得出的路由。当 Route-Type 字段的值为 5 时， Area-ID 字段的值需为 0.0.0.0。</li>
<li>7：表示路由的类型为 NSSA 路由，也就是 PE 通过 Type-7 LSA 计算得出的路由。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Domain-ID"><a href="#Domain-ID" class="headerlink" title="Domain ID"></a>Domain ID</h3><p>•在PE上将OSPF引入BGP时，PE将根据本地的配置为BGP路由增加域ID属性，域ID作为BGP的扩展团体属性传播。</p>
<p>•在PE将BGP路由引入OSPF时，若BGP路由携带的Domain ID与本地相同，则认为两个站点属于同一个OSPF路由域。若不相同，则认为不在同一个路由域。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/27.png"></p>
<blockquote>
<p>•Domain ID需要在绑定到VRF的OSPF进程视图下使用命令<strong>domain-id</strong>配置。</p>
<ul>
<li><p>缺省情况下，Domain ID的值为0（NULL）。如果不同OSPF域都使用NULL作为Domain ID，将无法区分OSPF域，因此它们之间的路由将被当作区域内路由。</p>
</li>
<li><p>如果一个OSPF域配置了非0（即非NULL）的Domain ID，NULL不再是该OSPF域的Domain ID。</p>
</li>
</ul>
<p>•建议与同一个VPN相关的所有OSPF实例都使用相同的Domain ID，或者都使用缺省的Domain ID。</p>
</blockquote>
<h3 id="Domain-ID与Route-Type"><a href="#Domain-ID与Route-Type" class="headerlink" title="Domain ID与Route Type"></a>Domain ID与Route Type</h3><p>根据BGP路由中的Domain ID与Route Type属性，PE将产生不同类型的OSPF LSA类型发布到VRF的OSPF进程中</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/28.png"></p>
<h2 id="OSPF防环"><a href="#OSPF防环" class="headerlink" title="OSPF防环"></a>OSPF防环</h2><h3 id="Type3路由防环-案例"><a href="#Type3路由防环-案例" class="headerlink" title="Type3路由防环 - 案例"></a>Type3路由防环 - 案例</h3><p>•如图是Type3 LSA路由产生环路的一个例子：</p>
<p>​    ▫其中站点1和站点2都属于VPN1。</p>
<p>​    ▫站点1通过OSPF Area0接入骨干网的PE1；</p>
<p>​    ▫站点2通过OSPF Area0分别接入骨干网的PE2和PE3（双归属负载分担场景）。</p>
<blockquote>
<p>•环路产生过程如下：</p>
<p>1.Site1的CE1通过Type3 LSA发布到192.168.1.0/24的路由给PE1。</p>
<p>2.PE1向BGP引入OSPF VPN1进程，通过MP-IBGP将该路由发布给PE2和PE3。</p>
<p>3.由于PE2上配置了BGP到OSPF的路由引入，故PE2将产生Type3 LSA给CE2，CE2将来自PE2的Type3 LSA发布给PE3。</p>
<p>4.此时PE3收到两条到达192.168.1.0/24的路由：一条是PE1发布的，另一条是PE2上路由引入产生的。由于缺省情况下，IGP（OSPF）路由优先级高于IBGP路由，PE3将选择OSPF路由。</p>
<p>5.PE3将优选的学自OSPF通过MP-IBGP发布给PE1。</p>
<p>▫此时，PE1上存在两条到达目的地192.168.1.0/24网段的路由，一条通过OSPF学习自CE1，另一条通过MP-IBGP学习自PE3。可能会导致以下问题：</p>
<ul>
<li>PE1撤销192.168.1.0/24这条路由，但由于PE1与PE2之间的链路阻塞，BGP Update（撤销报文）无法及时发送给PE2，导致PE3发给PE1的路由依然存在（正常情况下会随着PE1发送给PE2的Update报文被撤销），PE1上到达目的地192.168.1.0/24的下一跳为PE3。此时路由环路产生。</li>
<li>若PE1上MP-IBGP的路由优先级高于OSPF，则PE1会优选PE3通告的BGP路由，此时PE1需要撤销发给PE2的BGP路由，导致PE3撤销发布给PE1的路由，PE1上的OSPF再次被优选。如此反复，形成路由震荡。</li>
</ul>
</blockquote>
<h3 id="Type3路由防环-DN位"><a href="#Type3路由防环-DN位" class="headerlink" title="Type3路由防环 - DN位"></a>Type3路由防环 - DN位</h3><p>•为了防止3类LSA环路，OSPF多实例进程使用LSA Options域中一个原先未使用的比特作为标志位，称为DN位。使用DN位可以防止Type3 LSA环路。</p>
<p>•PE路由器的OSPF实例进程在进行SPF计算时，忽略DN置位的Type3 LSA。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/29.png"></p>
<h3 id="Type5-7路由防环-案例"><a href="#Type5-7路由防环-案例" class="headerlink" title="Type5/7路由防环 - 案例"></a>Type5/7路由防环 - 案例</h3><p>•如图是Type5 LSA路由产生环路的一个例子：</p>
<p>​    ▫其中站点1和站点2都属于VPN1。</p>
<p>​    ▫站点1通过EBGP接入骨干网的PE1；</p>
<p>​    ▫站点2通过OSPF分别接入骨干网的PE2和PE3。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/30.png"></p>
<blockquote>
<p>•环路产生过程如下：</p>
<p>1.CE1通过EBGP发布到192.168.1.0/24的路由给PE1，AS_Path为65001。</p>
<p>2.PE1通过MP-IBGP将该路由发布给PE2和PE3。</p>
<p>3.PE2在OSPF VPN1实例进程中引入BGP路由，发布到192.168.1.0/24的Type5 LSA给CE2；</p>
<p>4.CE2将该Type5 LSA发布给PE3。</p>
<p>5.PE3将优选择OSPF路由（OSPF优先级高于IBGP），并通过MP-IBGP发布Update消息给PE1。</p>
<p>6.PE1收到PE3发送的MP-IBGP Update消息。由于其中的路由是PE3的BGP引入的IGP（OSPF）路由，其AS_Path为空，因此PE3发布的MP-IBGP路由优先级比从CE1发布的EBGP路由优先级高，PE1将优选用PE3发布的路由。</p>
<p>7.此时形成一条路由环路：PE3—&gt;CE2—&gt;PE2—&gt;PE1—&gt;PE3。</p>
<p>•由于PE1不再优选CE1学来的路由，故PE1会撤销发给PE2的路由，PE2中的OSPF VPN实例进程进程中也要对应撤销引入的BGP路由，继而CE2、PE3都相继撤销该OSPF路由。PE3向PE1发布的BGP路由也被撤销，在PE1上，从CE1学来的路由又变成最优路由。这样，形成了路由振荡。</p>
<p>•Type7 LSA环路的产生和消除的过程与Type5类似，此处不再赘述。</p>
</blockquote>
<h3 id="Type5-7路由防环-VPN-Route-Tag"><a href="#Type5-7路由防环-VPN-Route-Tag" class="headerlink" title="Type5/7路由防环 - VPN Route Tag"></a>Type5/7路由防环 - VPN Route Tag</h3><p>•可以使用VPN Route Tag（VPN路由标记）来防止此5类或7类路由环路。</p>
<p>•PE在根据收到的BGP的私网路由生成5/7类LSA时，携带VPN路由标记。当PE发现LSA的VPN路由标记和本地配置的一样，就会忽略这条LSA，因此可以避免上述环路。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/31.png"></p>
<blockquote>
<p>•VPN路由标记不在BGP的扩展团体属性中传递，只是本地概念，只在收到BGP路由并且产生OSPF LSA的PE设备上有意义。</p>
<p>•缺省情况下，VPN的路由标记是根据BGP的AS号计算得到的。如果没有配置BGP，则默认值为0。</p>
<p>•可以通过指令<strong>route-tag</strong>配置VPN的路由标记。</p>
</blockquote>
<h2 id="OSPF-sham-link"><a href="#OSPF-sham-link" class="headerlink" title="OSPF sham link"></a>OSPF sham link</h2><h3 id="Sham-link的应用场景"><a href="#Sham-link的应用场景" class="headerlink" title="Sham link的应用场景"></a>Sham link的应用场景</h3><p>•通常情况下，BGP对等体之间通过BGP扩展团体属性在MPLS VPN骨干网上承载路由信息。另一端PE上运行的OSPF可利用这些信息来生成PE到CE的Type 3 LSA，这些路由是区域间路由（Inter_Area route）。</p>
<p>•若在CE1和CE2之间增加一条后门（Backdoor）链路，并且直接运行OSPF交互路由。通过后门链路学习到的路由类型为区域内路由（Intra_Area route）。</p>
<p>•由于区域内路由优于区域间路由，故后门链路会被优选，若想实现后门链路作为备份链路，可采用sham link实现。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/32.png"></p>
<h3 id="Sham-link的工作机制"><a href="#Sham-link的工作机制" class="headerlink" title="Sham link的工作机制"></a>Sham link的工作机制</h3><p>•Sham link在两台PE之间创建了一条区域内链路。当LSA在伪装链路中泛洪，所有的OSPF路由类型都不会改变，不会转换成LSA3或者LSA5的类型。</p>
<p>•Sham link被看成是两个VPN实例之间的链路，链路的两端是PE上的端点地址，分别作为建立连接时的源和目的地址。伪连接的源地址和目的地址使用32位掩码的Loopback接口地址，该Loopback接口需要绑定到VPN实例中，并通过BGP发布。</p>
<p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/33.png"></p>
<blockquote>
<p>•同一个OSPF进程的多条Sham link可以共用端点地址，但不同OSPF进程不能拥有两条端点地址完全相同的Sham link。</p>
</blockquote>
<h3 id="Sham-link的配置示例"><a href="#Sham-link的配置示例" class="headerlink" title="Sham link的配置示例"></a>Sham link的配置示例</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/34.png"></p>
<blockquote>
<p>•在配置Sham link时可以指定Sham link的路由开销。缺省值为1。</p>
</blockquote>
<h3 id="sham-link的配置验证"><a href="#sham-link的配置验证" class="headerlink" title="sham link的配置验证"></a>sham link的配置验证</h3><p><img src="/2021/06/23/IPadv-MPLSVPN%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8/35.png"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>1.（多选题）在MPLS VPN组网中，当PE向OSPF引入从其他PE学习来的VPN路由时，可能会产生以下哪几类LSA（    ）。</p>
<p>A.Type 1 LSA</p>
<p><strong>B.Type 3 LSA</strong></p>
<p><strong>C.Type 5 LSA</strong></p>
<p><strong>D.Type 7 LSA</strong></p>
<p>2.（判断）CE通过BGP传递路由给PE时，可能会携带SoO属性。（    ）。</p>
<p>A. 正确</p>
<p><strong>B. 错误</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>•MPLS VPN在针对不同类型的场景下有不同的组网方案，常见的有Intranet组网、Extranet组网以及Hub&amp;Spoke组网。此外，根据MPLS VPN骨干网是否跨域又可以分为跨域组网和单域组网。</p>
<p>•PE-CE之间进行路由信息交互时，可以使用静态路由、OSPF、IS-IS或BGP中的任何一种。其中OSPF为MPLS VPN做了许多扩展特性，如：</p>
<p>​    ▫Domain ID：用来区分VPN实例中引入的路由是否来自同一个OSPF域</p>
<p>​    ▫DN位：用来防止因为3类LSA产生的路由环路</p>
<p>​    ▫VPN Route Tag：用来方式因为5类或7类LSA产生的路由环路</p>
<p>​    ▫sham link：用于特殊场景下的OSPF路由选路控制</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
