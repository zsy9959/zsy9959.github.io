<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/" itemprop="url">IE-PIM双栈原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:31+08:00">
                2021-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/2.png"></p>
<blockquote>
<ul>
<li><p>现代网络传输技术对以下两项目标给予更高的关注：</p>
<ul>
<li>资源发现</li>
<li>点对多点的IP传输</li>
</ul>
</li>
<li><p>实现这两项目标有三种解决方案：单播（Unicast）、广播（Broadcast）、组播（Multicast）</p>
</li>
<li><p>通过比较三种解决方案的数据传输方式，说明组播方式更适合点对多点的IP传输。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/3.png"></p>
<blockquote>
<ul>
<li>学习完此课程，您将会：了解组播与单播以及广播三种数据传输方式的区别。掌握组播的地址结构以及组播报文的转发流程。掌握组播技术中的相关概念，如源路径树、共享树等。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>组播协议包括用于主机注册的组播组管理协议，和用于组播选路转发的组播路由协议。各种组播协议在网络中的如图所示。</p>
</li>
<li><p>IGMP（Internet Group Management Protocol）在接收者主机和组播路由器之间运行，该协议定义了主机与路由器之间建立和维护组播成员关系的机制。</p>
</li>
<li><p>组播路由器之间运行组播路由协议，组播路由协议用于建立和维护组播路由，并正确、高效地转发组播数据包。</p>
</li>
<li><p>对于ASM模型，可以将组播路由分为域内和域间两大类。</p>
<ul>
<li>域内组播路由协议用来在自治系统AS（Autonomous System）内发现组播源并构建组播分发树，将信息传递到接收者。域内组播路由协议包括：DVRMP、MOSPF、PIM。<ul>
<li>DVRMP是距离矢量组播路由协议（Distance Vector Multicast Routing Protocol）是一种密集模式协议。该协议有跳数限制，最大跳数32跳。</li>
<li>MOSPF是OSPF路由协议的扩展协议。它通过定义新的LSA来支持组播。</li>
<li>PIM（Protocol Independent Multicast）是典型的域内组播路由协议，分为DM（Dense Mode）和SM（Sparse Mode）两种模型。当接收者在网络中的分布较为密集时，适用DM；较为稀疏时，适用SM。PIM必须和单播路由协议协同工作。</li>
</ul>
</li>
<li>域间组播路由协议用来实现组播信息在AS之间的传递。<ul>
<li>MSDP（Multicast Source Discovery Protocol）能够跨越AS传播组播源信息。</li>
<li>MPBGP （MultiProtocol Border Gateway Protocol）的组播扩展MBGP （Multicast BGP）能够跨越AS传播组播路由。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>对于SSM模型，没有域内和域间的划分。由于接收者预先知道组播源的具体位置，因此可以借助PIM SM的部分功能直接创建组播传输路径。</li>
<li>为了使不同的 PIM-SM 域之间组播数据能够互通，需要在域间部署 MSDP 协议。MSDP 通过在各个 PIM-SM 域之间建立 MSDP 对等体关系，对等体之间交互 SA 消息来传递组播信 息，从而实现接收者主机可以接收其他 PIM-SM 域的组播源数据。MSDP 仅用于 IPv4 网络， 只对 ASM 服务模型有意义。在单个 PIM 域内，使用 IGMP 管理组成员关系，使用 PIM-SM 建 立组播路由指导数据转发。 </li>
<li>由于 PIM 协议依赖于单播路由表，从而组播转发路径与单播转发路径是一致的。当组播源与接收者分布在不同的AS中时，需要跨AS建立组播转发树。此时可以部署MBGP 协议， 生成一张独立于单播路由的组播路由表，使组播数据通过组播路由表进行传输。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/7.png"></p>
<blockquote>
<ul>
<li><p>相对于PIM-DM的“推（Push）模式”，PIM-SM使用“拉（Pull）模式”转发组播报文。PIM-SM假设网络中的组成员分布非常稀疏，几乎所有网段均不存在组成员，直到某网段出现组成员时，才构建组播路由，向该网段转发组播数据。一般应用于组播组成员规模相对较大、相对稀疏的网络。</p>
</li>
<li><p>基于这一种稀疏的网络模型，它的实现方法是：</p>
<ul>
<li>在网络中维护一台重要的PIM路由器：汇聚点RP（Rendezvous Point），可以为随时出现的组成员或组播源服务。网络中所有PIM路由器都知道RP的位置。</li>
<li>当网络中出现组成员（用户主机通过IGMP加入某组播组G）时，最后一跳路由器向RP发送Join报文，逐跳创建（*，G）表项，生成一棵以RP为根的RPT。</li>
<li>当网络中出现活跃的组播源（信源向某组播组G发送第一个组播数据）时，第一跳路由器将组播数据封装在Register报文中单播发往RP，在RP上创建（S，G）表项，注册源信息。</li>
</ul>
</li>
<li><p>PIM-SM的关键机制包括邻居建立、DR竞选、RP发现、RPT构建、组播源注册、SPT切换、Assert；同时也可通过配置BSR（Bootstrap Router）管理域来实现单个PIM-SM域的精细化管理。PIM-SM中PIM邻居建立过程以及Assert机制与PIM-DM相同。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li>源路径树以组播源作为树根，将组播源到每一个接收者的最短路径结合起来构成的转发树。</li>
<li>源路径树使用的是从组播源到接收者的最短路径，也称为最短路径树（shortest path tree，SPT）。对于某个组，网络要为任何一个向该组发送报文的组播源建立一棵树。</li>
<li>本例中有两个组播源（源S1和源S2），接收者R1和RT2。所以本例中有两棵源路径树，分别是：</li>
<li>S1—A—C（R1）—–E（R2）</li>
<li>S2—F—-D—C（R1）——E（R2）</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li>共享树以某个路由器作为路由树的树根，该路由器称为汇集点（Rendezvous Point，RP），将 RP 到所有接收者的最短路径结合起来构成转发树。使用共享树时，对应某个组，网络中只有一棵树。所有的组播源和接收者都使用这棵树来收发报文，组播源先向树根发送数据报文，之后报文又向下转发到达所有的接收者。 </li>
<li>本例中两个源S1和S2共享一颗树 D（RP）—-C（R1）—-E（R2）</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/10.png"></p>
<blockquote>
<ul>
<li>PIM IPv6是与静态路由、RIPng、OSPFv3、IS-ISv6、BGP4+等IPv6单播路由协议类型无关的组播路由协议，其借助上述单播路由协议生成的路由项和RPF（Reverse Path Forwarding）机制创建组播路由表，实现组播报文转发。PIM IPv6域是指由支持PIM IPv6协议的组播路由器构成的网络。</li>
<li>目前，存在两种组播模型：任意源组播ASM（Any-Source Multicast）和指定源组播SSM（Source-Specific Multicast）。IPv6中，ASM模型包括IPv6 PIM-DM（Protocol Independent Multicast-Dense Mode）和IPv6 PIM-SM（Protocol Independent Multicast Sparse Mode）；SSM模型则使用MLDv2和IPv6 PIM-SM的部分机制来实现。</li>
<li>在组成员稀疏分布的大规模IPv6网络中，使用IPv6 PIM-SM，其主要特性是接收者需要显式加入。缺省情况下，IPv6 PIM-SM假设网络中的所有节点都不需要接收组播报文，上游节点只有接收到下游节点的加入消息后才进行组播数据的转发。</li>
<li>IPv6 PIM-SM中，汇集点RP（Rendezvous Point）只向拥有接收者的下游分枝转发组播信息。这样可以节省数据报文和控制报文占用的网络带宽，减少路由器的处理开销。</li>
<li>当主机希望从指定组播组接收数据时，与之相连的路由器向这个组的RP发送加入（Join）消息，沿途建立以RP为根节点的共享树RPT（Rendezvous Point Tree）。共享树的含义是不同组播源向相同组播组转发组播数据时，都使用此共享路径。</li>
<li>当组播源向组播组发送数据时，与源相连的DR把组播数据封装在注册消息中以单播方式向RP发送。注册消息到达RP后，由RP对组播数据解封装，再沿RPT向接收者发送。当以注册消息方式发送的组播数据达到一定速率后，RP向组播源发送加入消息，建立组播源与RP之间的组播分发树。然后，RP向组播源的DR发送注册停止消息，指示DR直接以非封装方式根据组播转发表发送组播数据。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li><p>借助Hello消息可以为共享网络（如Ethernet）选举DR（Designated Router），DR将作为本网段中组播信息的唯一转发者。无论是和组播源S连接的网络，还是和接收者连接的网络，只要网络为共享媒介则需要选举DR，接收者侧DR向RP发送Join加入消息；组播源侧DR向RP发送Register注册消息。</p>
</li>
<li><p>DR的选举过程如下所述：</p>
<ul>
<li>共享网段上的各路由器相互间发送带有DR优先级选项的Hello消息；</li>
<li>具有最高优先级的路由器被选举为此网段的DR。如果路由器具有相同的优先级，则IPv6地址最大的路由器被选举为DR。</li>
</ul>
</li>
<li><p>当DR出现异常，其他路由器将接收不到其发出的Hello消息。在此DR超时后，会触发共享网段上新一轮的DR选举。</p>
</li>
<li><p>如果网络中至少有一台路由器不支持在Hello报文中携带DR优先级，由IPv6链路本地地址最大的路由器充当DR。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/12.png"></p>
<blockquote>
<ul>
<li>如何发现RP？对于小规模的简单网络，一个RP用于全网转发信息就足够了，此RP的位置可通过静态指定，在DR和叶子路由器以及组播数据流将要经过的所有路由器上手工指定RP的IP地址。然而，在大多数应用中，IPv6 PIM-SM网络覆盖了很大的区域，需要通过RP转发大量的组播流量。因此，不同的组播组应该具有各自的RP。为了减少配置多个静态RP的工作量以及更好的适应网络的实时变化，采用自举（Bootstrap）机制来动态选举RP。</li>
<li>自举路由器BSR（BootStrap Router）是IPv6 PIM-SM网络的管理核心。BSR收集来自各候选RP即C-RP（Candidate-RP）的通告（Advertisement）消息，选择合适的C-RP来构成组播组的RP-Set信息。RP-Set是各组播组与对应C-RP的数据库。BSR通过自举消息向整个IPv6 PIM-SM网络通告RP-Set信息。包括DR在内的所有路由器学习到各组播组对应的C-RP后，根据哈希算法计算出各组播组对应的唯一RP。</li>
<li>一个网络（或一个管理域）只能有一个BSR，但可以有多个候选BSR即 C-BSR （Candidate-BSR）。一旦BSR发生故障后，可以通过自举机制从C-BSR中选举出新的BSR，从而避免业务的中断。IPv6 PIM-SM域中可以配置多个C-RP。BSR负责收集并发送各组播组的RP-Set信息。<ul>
<li>RP配置方式建议：<ul>
<li>中小型网络：建议选择静态RP方式，对设备要求低，也比较稳定。</li>
<li>如果网络中只有一个组播源，建议选择直连组播源的设备作为静态RP，这样可以省略源端DR向RP注册的过程。</li>
<li>采用静态RP方式要确保域内所有路由器（包括RP本身）的RP信息以及服务的组播组范围全网一致。</li>
<li>大型网络：可以采用动态RP方式，可靠性高，可维护性强。</li>
<li>如果网络中存在多个组播源，且分布密集，建议选择与组播源比较近的核心设备作为C-RP；如果网络中存在多个用户，且分布密集，建议选择与用户比较近的核心设备作为C-RP。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li>BootStrap router工作的原理和过程：首先要在网络中选择合适的路由器把它配置成候选BSR（C-BSR，Candidate BootStrap Router），每个C-BSR都有优先级，当它得知自己是C-BSR后，首先启动一个定时器（默认为150秒），监听网络中的 BootStrap Message。BootStrap Message 初始时通告发送路由器的优先级、BSR的IPv6地址，当C-BSR收到一个BootStrap Message后，它会把自己的优先级和报文里的优先级做比较，如果对方的优先级高，它就把自己的定时器重置，继续监听BootStrap Message；如果是自己的高，那么它就发送BootStrap Message声明自己是BSR，如果优先级相等，则比较IPv6地址，谁的IPv6地址大谁就是BSR。BSR消息发送的目的地址是FF02::13，所有的PIM IPv6路由器都能接收到这个报文，该报文TTL一般被置为1，但每个PIM IPv6路由器收到此报文后都是把它以泛洪的方式从自己所有的使能PIM IPv6的接口上发送出去，这就能保证网络中的每台PIM IPv6设备都能收到BootStrap Message。</li>
<li>RP就像C-BSR一样需要在设备上手工配置，首先配置C-RP（Candidate Rendezvous Point），包括RP IPv6地址、优先级和它所能服务的组。正如上文所述，一个RP可以给所有的IPv6组播组提供服务，也可以只给部分组提供服务。当C-RP收到BootStrap Message后，它可以从该message中得知网络中谁是BSR，然后C-RP通过Candidate-RP-Advertisement Message把自己所能服务的组单播给BSR，每个C-RP都这么做的话那么BSR就收集到了网络中所有C-RP的信息并把这些信息整理成一个集RP-Set。此后BSR通过BootStrap Message把RP-Set的信息通告给全网所有的路由器。</li>
<li>RP的选举规则：<ul>
<li>如果RP-Set对应该IPv6组地址的C-RP只有一个,那么DR就选该C-RP做RP；</li>
<li>如果对应该IPv6组地址的有多个C-RP，那么优先级最高的是RP（优先级数越小优先级越高）；</li>
<li>如果大家优先级相等，那么DR将开始Hash运算，把组地址、hash掩码、和C-RP的地址做为输入参数，输出是一些数字，数字高的C-RP将是该组的RP；</li>
<li>如果hash的结果大家也相等，那么IPv6地址最大的C-RP将成为该组的RP。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/14.png"></p>
<blockquote>
<ul>
<li><p>使能嵌入RP功能允许路由器从IPv6组播组地址中分析出RP的地址，从而取代静态配置RP或由BSR动态计算的RP。</p>
</li>
<li><p>使用嵌入式RP的组播组地址范围是FF7x::/16和FFFx::/16，x表示0～F的任意一个十六进制数。</p>
</li>
<li><p>在接收侧：</p>
<ul>
<li>接收者主机发布MLD报告消息，加入组播组；</li>
<li>接收侧的DR提取内嵌在组播组地址中的RP地址，向其发送IPv6 PIM-SM加入消息。</li>
</ul>
</li>
<li><p>在组播源侧：</p>
<ul>
<li>组播源知道组播地址后，向此组播组发送报文；</li>
<li>组播源侧的DR提取内嵌在组播地址中的RP地址，向其以单播方式发送IPv6 PIM-SM注册消息。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li>头8bits为FF说明是IPv6组播地址。</li>
<li>Flags字段的范围是7-F，说明是一个嵌入了RP地址的IPv6组播组地址。</li>
<li>RIID字段：RP Interface ID，抽取出来填充在RP地址的最后4bits。</li>
<li>Plen字段：RP地址的前缀长度，换算成十进制数后不能为0，也不能大于64。</li>
<li>Network Prefix字段：RP的地址前缀。</li>
<li>Group ID：组ID。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/16.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li>当接收者主机加入一个组播组G时，通过MLD报文知会与该主机直接相连的叶子路由器，叶子路由器掌握组播组G的接收者信息，然后朝着RP方向往上游节点发送加入组播组的Report消息。</li>
<li>从叶子路由器到RP之间途经的每个路由器都会在转发表中生成（<em>，G）表项，这些沿途经过的路由器就形成了RP共享树（RPT）的一个分支。其中（</em>，G）表示从任意源来的信息去往组播组G。RPT共享树以RP为根，以接收者为叶子。</li>
<li>当从组播源S来的发往组播组G的报文流经RP时，报文就会沿着已经建立好的RPT共享树路径到达叶子路由器，进而到达接收者主机。</li>
<li>当某接收者对组播信息不再感兴趣时，离该接收者最近的组播路由器会逆着RPT树朝RP方向逐跳发送Prune剪枝消息。第一个上游路由器接收到该剪枝消息，在接口列表中删除连接此下游路由器的接口，并检查自己是否拥有感兴趣的接收者，如果没有则继续向上游转发该剪枝消息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li><p>为了向RP通知组播源S的存在，当组播源S向组播组G发送了一个组播报文时，与组播源S直接相连的路由器接收到该组播报文后，就将该报文封装成IPv6 PIM Register注册报文，并单播发送给对应的RP。</p>
</li>
<li><p>当RP接收到来自组播源S的注册消息后，一方面解封装注册消息并将组播信息沿着RPT树转发到接收者，另一方面朝组播源S逐跳发送（S，G）加入消息，从而让RP和组播源S之间的所有路由器上都生成了（S，G）表项，这些沿途经过的路由器就形成了SPT树的一个分支。SPT源树以组播源S为根，以RP为目的地。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li>组播源S发出的组播信息沿着已经建立好的SPT树到达RP，然后由RP将信息沿着RPT共享树进行转发。当RP收到沿着SPT树转发的组播流量后，向与组播源S直连的路由器单播发送注册停止报文。组播源注册过程结束。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/20.png"></p>
<blockquote>
<ul>
<li>源数据流延源树（SPT）流向RP，从RP开始，数据流延共享树（RPT）流向接收者。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/21.png"></p>
<blockquote>
<ul>
<li><p>针对特定的源，PIM-SM通过指定一个利用带宽的SPT阈值可以实现将最后一跳路由器(即离接收者最近的DR)从RPT切换到SPT。当最后一跳路由器发现从RP发往组播组G的组播报文速率超过了该阈值时，就向单播路由表中到组播源S的下一跳路由器发送（S，G）加入消息，Join加入消息经过一个个路由器后到达第一跳路由器（即离组播源最近的DR），沿途经过的所有路由器都拥有了（S，G）表项，从而建立了SPT树分支。</p>
</li>
<li><p>用户端DR周期性检测组播报文的转发速率，一旦发现从RP发往组播组G的报文速率超过阈值，则触发SPT切换：</p>
<ul>
<li>用户端DR逐跳向源端DR发送（S，G）Join报文并创建（S，G）表项，建立源端DR到用户端DR的SPT。</li>
<li>SPT建立后，用户端DR会沿着RPT逐跳向RP发送剪枝报文，收到剪枝报文的路由器将（*，G）复制成相应的（S，G）,并将相应的下游接口置为剪枝状态。剪枝结束后，RP不再沿RPT转发组播报文到组成员端。</li>
<li>如果SPT不经过RP，RP会继续向源端DR逐跳发送剪枝报文，删除（S，G）表项中相应的下游接口。剪枝结束后，源端DR不再沿“源端DR-RP”的SPT转发组播报文到RP。</li>
</ul>
</li>
<li><p>在VRP中，缺省情况下连接接收者的路由器在探测到组播源之后（即接收到第一个数据报文），便立即加入最短路径树，即从RPT向SPT切换。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/22.png"></p>
<blockquote>
<ul>
<li>当路由器在不同接口接收到RPT和SPT两条路径上传输的相同组播数据时，丢弃沿RPT接收的数据，并向RP逐跳发送剪枝消息。RP接收到剪枝消息后，更新转发状态，并停止沿RPT转发（S, G）的组播流量；同时RP向组播源发送剪枝消息删除或更新相关的（S, G）转发项。通过这种方法，组播数据从RPT切换到SPT。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/24.png"></p>
<blockquote>
<ul>
<li>Host A和Host C分别是两个叶子网络中的组播信息接收者。这些接收者通过Router A、Router B、Router C和Router D连接到组播源。</li>
<li>配置思路：<ul>
<li>配置各路由器接口的IPv6地址和IPv6单播路由协议。<ul>
<li>配置各路由器接口的IPv6地址和掩码。</li>
<li>配置各路由器之间采用OSPFv3进行互连，进程号为1，区域号为0，确保网络中各路由器Router A、Router B、Router C和Router D之间能够在网络层互通。</li>
</ul>
</li>
<li>在各路由器上使能IPv6组播功能，在路由器各接口上使能IPv6 PIM-SM，主机侧接口上配置MLD，采用缺省版本2。</li>
<li>配置C-BSR和C-RP，充当C-BSR和C-RP的IPv6全球单播地址，此例中都为Router D上的2004::2。</li>
<li>检查配置结果。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/25.png"></p>
<blockquote>
<ul>
<li><p>进入系统视图</p>
<ul>
<li><strong>system-view</strong></li>
</ul>
</li>
<li><p>使能IPv6组播路由</p>
<ul>
<li><strong>multicast ipv6 routing-enable</strong></li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em></li>
</ul>
</li>
<li><p>使能IPv6 PIM-SM功能</p>
<ul>
<li><strong>pim</strong> <strong>ipv6</strong> <strong>sm</strong></li>
</ul>
</li>
<li><p>IPv6 PIM-SM只有在使能IPv6组播后才能配置。在接口上配置IPv6 PIM-SM后，路由器周期性发送Hello消息来发现PIM IPv6邻居，并处理邻居发来的报文。当路由器加入IPv6 PIM-SM域时，建议在非边界路由器的所有接口上使能IPv6 PIM-SM。</p>
</li>
<li><p>不能在一个接口上同时使能IPv6 PIM-SM和IPv6 PIM-DM。同一路由器上所有接口的PIM IPv6模式必须相同。</p>
</li>
<li><p>Router B、Router C和Router D上的配置过程与Router A上的配置相似。</p>
</li>
<li><p>与接受者相连的路由器上需要使能MLD。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/26.png"></p>
<blockquote>
<ul>
<li><p>在PIM域中可配置一个或多个C-BSR。从C-BSR选举出的BSR负责收集和通告C-RP信息。由于BSR和域中的其他设备需要交换大量信息，因此C-BSR与域中的其它设备之间应预留较大的带宽。所以由骨干网的路由器来充当C-BSR。</p>
</li>
<li><p>在指定本路由器的某接口地址作为C-BSR时，必须同时使能接口的IPv6 PIM-SM。C-BSR之间自动选举BSR的过程简要描述如下：</p>
<ul>
<li>初始时，每个C-BSR都认为自己是PIM-SM域内的BSR，使用自己接口的IPv6地址作为BSR地址来发送自举报文。</li>
<li>当C-BSR从其他路由器接收到自举报文时，把报文中的BSR地址与自己的BSR地址相比较。比较的标准包括优先级和BSR地址。如果优先级相同，优选BSR地址大的，即如果接收的自举报文中的BSR地址更高，则用此地址来代替自己的BSR地址，并不再认为自己是BSR；如果自举报文的BSR地址并不大于自己的BSR地址，则继续认为自己是BSR。</li>
</ul>
</li>
<li><p>进入PIM IPv6视图</p>
<ul>
<li><strong>pim-ipv6</strong></li>
</ul>
</li>
<li><p>配置自己的接口地址为C-BSR</p>
<ul>
<li>**c-**<strong>bsr</strong> <em>ipv6-address</em> [ <em>hash-length</em> ] [ <em>priority-value</em> ]</li>
</ul>
</li>
<li><p>配置C-RP</p>
<ul>
<li>**c-**<strong>rp</strong> <em>ipv6-address</em> [ <strong>priority</strong> <em>priority</em> ]</li>
</ul>
</li>
<li><p>配置静态RP</p>
<ul>
<li>**static-<em><strong><em>rp*</em> *rp</strong>-address</em> [ <em>basic-acl6-number</em> ] [ <strong>preferred</strong> ]</li>
</ul>
</li>
<li><p>配置嵌入式RP</p>
<ul>
<li>**embedded-**<strong>rp</strong> <strong>[</strong> <em>basic-acl6-number</em> <strong>]</strong></li>
</ul>
</li>
<li><p>**c-*<em><strong>bsr</strong>命令用来在希望自己成为BSR的路由器上配置自身某接口地址为C-BSR的地址。</em></p>
<ul>
<li>ipv6-address<em>：指定候选自举路由器C-BSR的IPv6全球单播地址。</em></li>
<li>hash-length*：指定计算RP的哈希函数的掩码长度。整数形式，取值范围是0～128。</li>
</ul>
</li>
<li><p><strong>pim</strong> <strong>ipv6</strong> <strong>bsr**</strong>-boundary<strong>命令用来设置作为BSR域边界的接口。在接口上配置此命令后，自举消息不能通过此接口，而其他PIM报文可以通过。</strong></p>
</li>
<li><p>c-rp**命令用来配置路由器向BSR通告自身是C-RP。配置成为C-RP的路由器和其他设备之间需要保留相对大的带宽。通过配置希望成为RP的接口地址，并选择合适的优先级。</p>
<ul>
<li><em>ipv6-address</em>：指定C-RP的IPv6全球单播地址。</li>
<li>如果网络中仅有一个动态RP，配置静态RP能避免由于单个RP发生故障引起的通信中断。使用静态RP转发组播数据时，应该在IPv6 PIM-SM域中所有路由器上配置完全相同的静态RP命令。</li>
</ul>
</li>
<li><p>**static-*<em><strong>rp</strong>命令用来配置静态RP。</em></p>
<ul>
<li>rp**-address*：指定静态RP地址。此地址必须是有效的IPv6全球单播地址。</li>
<li><em>basic-acl6-number</em>：指定用于控制静态RP服务的组播组范围的基本访问控制列表号。取值范围是2000～2999。</li>
<li><strong>preferred</strong>：表示配置的静态RP和由BSR机制选择的RP不同时，优先选择此静态RP。不指定此参数时，优先选择BSR机制选择的RP。</li>
</ul>
</li>
<li><p>嵌入式RP用于路由器从组播地址中获取RP地址，从而取代静态RP或从BSR机制选举的动态RP。使用嵌入式RP的组播地址范围是FF7x::/16～FFFx::/16，x表示0～F的任意一个十六进制数。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/28.png"></p>
<blockquote>
<ul>
<li><p>查看接口上的PIM IPv6信息 </p>
<ul>
<li><strong>display</strong> <strong>pim</strong> <strong>ipv6</strong> <strong>interface</strong> [ <em>interface-type interface-number</em> ]</li>
</ul>
</li>
<li><p>查看IPv6 PIM-SM域中BSR自举路由器的信息</p>
<ul>
<li><strong>display</strong> <strong>pim</strong> <strong>ipv6</strong> <strong>bsr**</strong>-info**</li>
<li>此网络中的BSR是Router D的POS2/0/0接口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/29.png"></p>
<blockquote>
<ul>
<li><p>查看IPv6 PIM-SM域中的RP信息</p>
<ul>
<li><strong>display</strong> <strong>pim</strong> <strong>ipv6</strong> <strong>rp**</strong>-info** [ <em>ipv6-group-address</em> ]</li>
</ul>
</li>
<li><p>此网络中的RP是Router D的POS2/0/0接口。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/30.png"></p>
<blockquote>
<ul>
<li>假设HostA加入组G（FF0E::1），RouterD和RouterB之间建立RPT树，在RPT路径上的路由器（RouterD和RouterB）生成（*, G）项。组播源S（2001::5）向组播组G发送组播报文后，在源树路径上的路由器（RouterA和RouterD）生成（S, G）项。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/31.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/33.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li>IPv6 PIM-SSM的实现可以概括成邻居发现、DR选举和SPT生成：<ul>
<li>邻居发现和DR选举过程与IPv6 PIM-SM中的描述相同，是通过在路由器间发送Hello消息来实现的；</li>
<li>由于PIM-SSM也使用PIM-SM协议，路由器生成RPT还是生成SPT的判决取决于组播地址是否在SSM组地址范围内。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/35.png"></p>
<blockquote>
<ul>
<li>SSM模型中，用信道（Channel）概念来表示（S, G）组合，用定制（Subscribed）消息概念来表示加入消息。</li>
<li>假定网络中的User A和User B需要接收组播源S的信息，就通过MLDv2向最近的查询器发送一个标为（include S, G）的报告信息。如果User A和User B不需要接收组播源S的信息，发送一个标为（exclude S, G）或包含其他组播源的报告消息。无论使用上述哪个报告消息，接收者是明确指定组播源S的。</li>
<li>接收到报告消息的查询器检查此消息的组播地址是否在SSM组地址的范围内。如果是，则路由器根据SSM模型建立组播分发树，随后向指定源逐跳发送定制消息（也称加入消息）。沿途上的所有路由器创建（S, G）项。以源S为根节点、接收者为叶子的SPT树就生成了。SSM模型使用此SPT树作为传输路径。</li>
<li>如果查询器发现组播地址在SSM组范围外，就在IPv6 PIM-SM基础上建立组播分发树。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>Host A和Host C分别是两个叶子网络中的组播信息接收者。这些接收者通过Router A、Router B、Router C和Router D连接到组播源。</li>
<li>Router B和N1、Router C和N2之间的主机侧接口必须运行MLDv2协议。</li>
<li>配置思路：<ul>
<li>配置各路由器接口的IPv6地址和IPv6单播路由协议。<ul>
<li>配置各路由器接口的IPv6地址和掩码。</li>
<li>配置各路由器之间采用OSPFv3进行互连，进程号为1，区域号为0，确保网络中各路由器Router A、Router B、Router C和Router D之间能够在网络层互通。</li>
</ul>
</li>
<li>在各路由器上使能IPv6组播功能，在路由器各接口上使能IPv6 PIM-SM。</li>
<li>在各路由器配置IPv6 PIM-SSM 组播组的地址范围。</li>
<li>在路由器的主机侧接口上配置MLDv2。</li>
<li>检查配置结果。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/37.png"></p>
<blockquote>
<ul>
<li><p>在Router A上配置IPv6 PIM-SSM组播组的地址范围是FF3E::1。</p>
</li>
<li><p>Router B、Router C和Router D上的配置过程与Router A上的配置相似。</p>
</li>
<li><p>SSM模型采用的是IPv6 PIM-SM的子集，所以必须先在网络中所有的路由器上使能IPv6 PIM-SM功能。同时，配置SSM组的地址范围。缺省情况下，采用IANA定义的SSM组范围。</p>
</li>
<li><p>如果用户希望从指定源S接收信息，或从指定源外的所有源S接收信息，必须发送含有信道（S, G）的MLDv2报告消息。接收侧的DR接收到此消息后，判断消息中的组播地址G是否在SSM组的地址范围内。如果是，DR向组播源S发送加入消息，并在沿途各路由器上创建（S, G）项，从而建立SPT树，SSM模型就此建立。如果组播地址G在SSM组地址范围外，或用户没有显式指定源地址S，DR触发建立IPv6 PIM-SM基础上的ASM模型。</p>
</li>
<li><p>SSM模型通过IPv6 PIM-SM的子集来实现。使能IPv6 PIM-SM的同时也就使路由器具有SSM处理能力。路由器周期性发送Hello报文来发现PIM IPv6邻居，并处理邻居发来的报文。当路由器加入IPv6 PIM-SSM时，建议在非边界路由器所有接口上使能IPv6 PIM-SSM。</p>
</li>
<li><p>组播源的信息通过IPv6 PIM-SSM模式还是IPv6 PIM-SM模式传递到接收者，取决于信道（S, G）的组播地址是否在SSM组地址范围内。因此，IPv6 PIM-SSM模式中，组地址信息十分重要。</p>
</li>
<li><p>如果没有指定SSM组地址范围，系统采用IANA为SSM保留的FF3x::/12网段作为缺省的地址范围。</p>
</li>
<li><p>进入系统视图</p>
<ul>
<li><strong>system-view</strong></li>
</ul>
</li>
<li><p>使能IPv6组播路由</p>
<ul>
<li><strong>multicast ipv6 routing-enable</strong></li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em> </li>
</ul>
</li>
<li><p>使能IPv6 PIM-SSM功能</p>
<ul>
<li><strong>pim</strong> <strong>ipv6</strong> <strong>sm</strong></li>
</ul>
</li>
<li><p>进入PIM IPv6视图</p>
<ul>
<li><strong>pim-ipv6</strong></li>
</ul>
</li>
<li><p>配置IPv6 PIM-SSM组播地址范围</p>
<ul>
<li><strong>ssm**</strong>-policy** <em>basic-acl6-number</em></li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/38.png"></p>
<blockquote>
<ul>
<li>如果Host A需要接收组播源S（2001::5）发给组G（FF3E::1）的信息，Router B建立到源的SPT。SPT路径上的Router A和Router B生成（S,G）项，SPT路径外的Router D不存在（S,G）项</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/39.png"></p>
<blockquote>
<ul>
<li>组播路由管理（Multicast Route Management）主要介绍如何创建或更改组播路由来控制组播报文的转发，以及组播转发路径的检测和维护。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/40.png"></p>
<blockquote>
<ul>
<li>组播路由和转发与单播路由和转发类似，首先每个组播路由协议都各自建立并维护了一张协议路由表。各组播路由协议的组播路由信息经过综合形成一个总的组播路由表（Multicast Routing-Table）。最后，路由器根据组播路由和转发策略，从组播路由表中选出最优的组播路由，并下发到组播转发表（Multicast Forwarding-Table），直接用于控制组播数据的转发。</li>
<li>通过组播转发表，整个网络建立了一条以组播源为根，组成员为叶子的一点到多点的转发路径。为了实现转发路径的控制与维护，组播路由管理提供了一系列特性。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li>(FC00::2, FFE3::1) (S, G)表项。 </li>
<li>Protocol: pim-sm 协议类型。第一个Protocol表示生成表项的协议类型，第二个Protocol表示生成下游接口的协议类型。</li>
<li>Flag: SPT LOC ACT PIM路由表项的标志。</li>
<li>UpTime: 00:04:24 存在时间。第一个UpTime表示表项已存在的时间，第二个UpTime表示下游接口已存在的时间。</li>
<li>Upstream interface: Vlanif20 上游接口。 </li>
<li>Upstream neighbor: FE80::A01:100:1 上游邻居。NULL表示不存在上游邻居。</li>
<li>RPF prime neighbor: FE80::A01:100:1 RPF邻居。NULL表示不存在RPF邻居。</li>
<li>Downstream interface(s) information: 下游接口信息。 </li>
<li>Total number of downstreams: 1 下游接口数量。 </li>
<li>Expires: 00:02:47 下游接口老化时间。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/42.png"></p>
<blockquote>
<ul>
<li>(FC00::2, FFE3::1) 第00001号表项，是(S, G)形式。 </li>
<li>Uptime: 00:00:14 组播路由表项更新时间。 </li>
<li>Upstream Interface: Vlanif10 上游接口。 </li>
<li>List of 1 downstream interface 下游接口列表。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/43.png"></p>
<blockquote>
<ul>
<li>(FC00:1::3, FF1E::1) 第00001号表项，是(S, G)形式。 </li>
<li>MID: 10 组播转发表项在MFIB表中的唯一标识，用于快速检索组播转发表。</li>
<li>Flags: ACT 组播转发表项的标志。 </li>
<li>UpTime: 02:54:43 组播转发表项已存在的时间。 </li>
<li>Timeout in: 00:03:26 组播转发表项超时时间。</li>
<li>Incoming interface: Vlanif10 表项入接口。 </li>
<li>List of 1 outgoing interfaces 表项出接口列表。</li>
<li>Activetime: 00:23:15 出接口已存在时间。 </li>
<li>Matched 38264 packets(1071392 bytes) 匹配该表项的报文数目。</li>
<li>Wrong If 0 packets 从错误接口进入的报文数目。</li>
<li>Forwarded 38264 packets(1071392 bytes) 已转发的报文数目。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/44.png"></p>
<blockquote>
<ul>
<li><p>RPF检查原理</p>
<ul>
<li>路由器收到一份组播报文后，会根据报文的源地址通过单播路由表查找到达“报文源”的路由，查看到“报文源”的路由表项的出接口是否与收到组播报文的入接口一致。如果一致，则认为该组播报文从正确的接口到达，从而保证了整个转发路径的正确性和唯一性。这个过程就被称为RPF检查。</li>
<li>如果这几条等价路由都是来自同一张路由表项，则选取下一跳地址最大的路由作为RPF路由。</li>
<li>RPF检验可以基于单播路由、MBGP路由和组播静态路由。他们之间的优先顺序为组播静态路由、MBGP路由、单播路由。</li>
</ul>
</li>
<li><p>拓扑描述</p>
</li>
<li><p>来自组播源FC00:0:0:2001::1/64的组播流从S1口到达路由器，路由器检查路由表，发现可以转发该组播流的端口为S0，RPF检查失败。因此达到S1口的数据流被丢弃。</p>
</li>
<li><p>来自组播源FC00:0:0:2001::1/64的组播流从S0口达到路由器，检查路由表发现入接口与接收该组播流的接口S0一致，RPF检查成功。因此组播流将被正确的转发。</p>
</li>
<li><p>组播路由协议通过已有的单播路由信息来确定上、下游邻居设备，创建组播路由表项。运用RPF检查机制，来确保组播数据流能够沿组播分发树（路径）正确的传输，同时可以避免转发路径上环路的产生。</p>
</li>
<li><p>在实际组播数据转发过程中，如果对每一份接收到的组播数据报文都通过单播路由表进行RPF检查，会给路由器带来很大负担。因此，路由器在收到一份来自源S发往组G的组播数据报文之后，首先会在组播转发表中查找有无相应的（S，G）组播转发表项：</p>
</li>
<li><p>如果不存在（S，G）转发表项，则对该报文执行RPF检查，将检查到的RPF接口作为入接口，创建组播路由表项，下发到组播转发表中。其中，对RPF检查结果的处理方式为：如果检查通过，表明接收接口为RPF接口，向转发表项的所有出接口转发；如果检查失败，表明报文来源路径错误，丢弃该报文。</p>
</li>
<li><p>如果存在（S，G）转发表项，并且接收该报文的接口与转发表项的入接口一致，则向所有的出接口转发该报文。</p>
</li>
<li><p>如果存在（S，G）转发表项，但是接收该报文的接口与转发表项的入接口不一致，则对此报文进行RPF检查。对RPF检查结果的处理方式为：</p>
<ul>
<li>若RPF检查选取出的RPF接口与转发表项的入接口一致，则说明（S，G）表项正确，报文来源路径错误，将其丢弃。</li>
<li>若RPF检查选取出的RPF接口与转发表项的入接口不符，则说明（S，G）表项已过时，于是把表项中的入接口更新为RPF接口。然后再根据RPF检查规则进行判断：如果接收该报文的接口正是其RPF接口，则向转发表项的所有出接口转发该报文，否则将其丢弃。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/46.png"></p>
<blockquote>
<ul>
<li>缺省情况下，组播报文转发过程中如果存在多条等价的最优转发路径，按照RPF检查对等价路由的处理规则，只会从IGP路由表中选取出下一跳地址最大的路由作为RPF路由。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/47.png"></p>
<blockquote>
<ul>
<li>组播源Source向组播组G发送组播流，路由器RouterA和RouterD之间运行某种IGP协议（如OSPF），RouterA→RouterB→RouterD和RouterA→RouterC→RouterD是2条等价转发路径。</li>
<li>缺省情况下，根据RPF检查规则，组播流会从Int1端口转发，因为Int1的IP地址比Int0地址大。配置组播负载分担之后，就不会根据下一跳地址来选取转发路径，RouterA→RouterB→RouterD和RouterA→RouterC→RouterD都会转发组播流。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/48.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/49.png"></p>
<blockquote>
<ul>
<li>如图所示，域内路由器运行PIM SM，和接收者相临的接口运行MLD v1，在IPv6组播中MLDv1协议等同于IPv4组播中的IGMPv2，用于获取组播组成员信息并通知上层协议。</li>
<li>区域内所有路由器通过RP的静态配置、BSR、或者自动发现方式得到RP信息。</li>
<li>和IPv6接收者相连的倒数第一跳路由器收到接收者发送的MLD report报文，沿RPF邻居向上游发送(*，G)加入消息，直到RP收到(*，G)加入消息，沿途路由器都创建(*，G)项，生成以RP为根的共享树。</li>
<li>组播源发出组播数据，第一跳路由器向RP发送PIM注册消息，RP收到后回应注册停止消息。</li>
<li>RP向通过RPF邻居向第一跳路由器发(S，G)加入消息，沿途路由器创建(S，G)项，生成以第一跳路由器为根的源路径树。</li>
<li>组播数据沿源路径树到达RP，并沿(*，G)转发，沿途路由器生成(S，G)项，组播数据到达接收者。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/50.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/51.png"></p>
<blockquote>
<ul>
<li><p>IPv6 PIM-SM和IPv4 PIM-SM有哪些不同？</p>
<ul>
<li>地址不同，协议机制完全一样。</li>
</ul>
</li>
<li><p>IPv6 PIM-SSM的工作机制是怎样的？</p>
<ul>
<li>IPv6 PIM-SSM的实现可以概括成邻居发现、DR选举和SPT生成：<ul>
<li>邻居发现和DR选举过程与IPv6 PIM-SM中的描述相同，是通过在路由器间发送Hello消息来实现的；</li>
<li>由于PIM-SSM也使用PIM-SM协议，路由器生成RPT还是生成SPT的判决取决于组播地址是否在SSM组地址范围内。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/" itemprop="url">IE-MLD原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:11+08:00">
                2021-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li>组播侦听发现协议MLD（Multicast Listener Discovery）用于IPv6组播中的组成员管理，其基本原理和功能与IGMP相似。MLD的目的是使能每个IPv6路由器发现在其直连网络上的组播侦听者（即希望接收组播数据的节点）的存在，并且能明确发现这些邻居节点所感兴趣的组播地址。然后提供这些消息给路由器所使用的组播路由协议，以确保组播数据转发至存在接收者的所有链接。</li>
<li>MLD是非对称协议，明确了组播侦听者与路由器的不同行为。对路由器本身正在侦听的组播地址来说，路由器扮演协议的两种角色，包括对自己的消息作出回应。</li>
<li>如果路由器有不止一个接口在同一网络上，它只需要在其中一个接口上运行此协议。另一方面，对侦听者来说，则必须在所有接口运行此协议以便上层协议从接口接收所需要的组播数据。</li>
<li>所有MLD版本都支持ASM （Any-Source Multicast）模型。MLDv2可以直接应用于SSM （Source-Specific Multicast） 模型，而 MLDv1 则需要 SSM-Mapping 技术的支持。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>组播侦听者是希望接收组播数据的主机节点。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/7.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li><p>类型（Type）：MLD消息共有三种。</p>
<ul>
<li>组播侦听查询（类型值＝130），可分为两种子类型：<ul>
<li>普遍查询：用于获得在所连网络上具有侦听者的组播地址。</li>
<li>特定组播地址查询：用于获得在所连网络上对一特定组播地址是否存在侦听者。</li>
</ul>
</li>
</ul>
</li>
<li><p>组播侦听报告（类型值＝131）</p>
</li>
<li><p>组播侦听离开（ Multicast Listener Done）(类型值＝132)</p>
</li>
<li><p>代码（Code）</p>
<ul>
<li>发送时设置为1；接收时忽略。</li>
</ul>
</li>
<li><p>校验和（Checksum）</p>
<ul>
<li>标准的ICMPv6校验和，覆盖所有MLD消息以及IPv6首部区域中的伪首部。</li>
</ul>
</li>
<li><p>最大响应延迟（Maximum Response Delay）</p>
<ul>
<li>最大响应延迟值只在查询报文消息中有意义，它指定了发送响应报文的最大允许时间延迟，单位为毫秒。在其他报文消息中，发送时设置为零，接收时忽略。</li>
</ul>
</li>
<li><p>保留（Reserved）</p>
<ul>
<li>发送者设为零；接收者忽略。</li>
</ul>
</li>
<li><p>组播地址（Multicast Address）</p>
<ul>
<li>在查询报文中，当发送普遍查询时，组播地址值设为零；当发送特定组查询时，设为特定的IPv6组播地址。在报告或离开报文中，组播地址值分别设为报文发送者要侦听或者停止侦听的特定IPv6组播地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li><p>所有MLD路由器在初始时都认为自己是查询器，并向本地网段内的所有主机和路由器发送MLD普遍组查询（General Query）报文（目的地址为 FF02::1）。</p>
</li>
<li><p>本地网段中的其它MLD路由器在收到该报文后，将报文的源IPv6地址与自己的接口地址作比较。通过比较，IPv6地址最小的路由器将成为查询器，其它路由器成为非查询器（Non-Querier）。</p>
</li>
<li><p>所有非查询器上都会启动一个定时器（即其它查询器存在时间定时器 Other Querier Present Timer）。在定 时器超时前，如果收到了来自查询器的 MLD 查询报文，则重置该定时器；否则，就认为原查询器失效， 并发起新的查询器选举过程。 </p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/10.png"></p>
<blockquote>
<ul>
<li><p>VRP遵循RFC 2710来实现MLDv1。MLDv1基于查询/响应（Query/Response）机制完成组播组成员的管理。</p>
</li>
<li><p>MLDv1有两种类型的查询消息（Query Message）：</p>
<ul>
<li>普遍查询（General Query）：查询直连链路上是否有组播组的侦听者。</li>
<li>指定组播组查询（Multicast-address-specific Query）：查询直连链路上是否有某个指定组播地址的侦听者。</li>
</ul>
</li>
<li><p>如果共享网段上存在配置MLD的多个组播路由器，将触发查询路由器（Querier）选举机制，由网段上IPv6地址最小的路由器充当查询器（也称MLD查询器），其他路由器充当非查询器（Non-Querier）。</p>
</li>
<li><p>以普遍查询为例，主机加入组播组的基本过程是：</p>
<ul>
<li>1、MLD查询器周期性地向共享网段上的所有本地链路主机以组播方式（目的地址为FF02::1）发送普遍查询消息。</li>
<li>2、网段上的所有主机都接收到该普遍查询消息。如果主机Host B和Host C希望加入某组播组G1，则设置定时器延时来响应。</li>
<li>3、希望加入的主机在定时器超时后以组播方式向网段上的所有主机和路由器发送报告消息（Report Message）来响应查询，此消息包含组播组G1的地址信息。</li>
<li>4、网段上的所有主机和路由器接收到此报告消息后，也就获得了关于G1的组播信息。此时网段中其他也希望加入组播组G1的主机将不再发送相同的报告消息，如果主机Host A希望加入另一个组播组G2，就会发送包含组播组G2地址的报告消息以响应普遍查询消息来加入G2。</li>
<li>5、在查询/报告过程后，MLD查询器可以了解到在自己的直连网段上是否有组播组G1的接收者，生成形式为(<em>, G1)组播路由项，</em>表示任意的组播源。</li>
<li>6、通过组播路由机制，MLD查询器接收到组播源发来的组播信息。如果直连网段上有接收者，就在网段上转发此数据，加入组播组的主机接收该数据。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li>当主机想离开组播组，就以组播地址（目的地址是FF02::2）向链路上发送一个离开消息（Done Message），并且在其组播地址域携带要停止侦听的地址。</li>
<li>当查询器从链路上收到离开消息时，如果要离开的组播报文地址在此链路上查询器的侦听者地址列表中，查询器就会发送Last Listener Query Count次组播地址特定查询，每次间隔时间为Last Listener Query Interval。组播地址特定查询一般将Last Listener Query Interval设定为Maximum Response Delay，如果最后查询的响应延迟时间过后，没有此组播地址的报告在此链路上发送给查询器，因此此地址就从侦听者列表中删除。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/12.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li><p>头192bits部分是和MLDv1的消息格式相同的部分。</p>
</li>
<li><p>标志位S（Suppress Router-side Processing）：</p>
<ul>
<li>表示路由器接收到查询消息后是否对定时器更新进行抑制。</li>
</ul>
</li>
<li><p>查询器的健壮性变量 QRV（Querier’s Robustness Variable）：</p>
<ul>
<li>健壮性变量值QRV是最后侦听者查询次数的缺省值，也就是路由器在确定没有剩余侦听者存在之前而发送的特定组播地址查询的次数。</li>
</ul>
</li>
<li><p>查询器发送普遍查询消息的查询间隔 QQIC（Querier’s Query Interval Code）。</p>
</li>
<li><p>源数目（Number of Sources）：</p>
<ul>
<li>普遍查询或指定组播组查询中，此字段设置为0。</li>
<li>指定组播源-组查询中，此字段表示查询消息中包含的源地址个数。</li>
</ul>
</li>
<li><p>源地址（Source Address）：</p>
<ul>
<li>指定查询的组播源地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/14.png"></p>
<blockquote>
<ul>
<li><p>主机通过发送MLD报告消息来汇报当前的组播侦听状态。</p>
</li>
<li><p>类型（Type）：</p>
<ul>
<li>Type=143</li>
</ul>
</li>
<li><p>保留（Reserved）：</p>
<ul>
<li>发送时设置为0；接收时忽略。</li>
</ul>
</li>
<li><p>校验和（Checksum）：</p>
<ul>
<li>标准的ICMPv6校验和，覆盖所有MLD消息以及IPv6首部区域中的伪首部。</li>
</ul>
</li>
<li><p>组播地址记录的个数（ Number of Multicast Address Records ）</p>
</li>
<li><p>组播地址记录 （Multicast Address Records ）：</p>
<ul>
<li>表示主机在接口上侦听到的每个组播地址信息，包括记录类型、组播地址、源地址等。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li><p>MLDv2兼容MLDv1，原理与MLDv1相同。MLDv2支持源列表和过滤模式，可以指定源地址加入，用于实现SSM。</p>
</li>
<li><p>对 IPv6 组播源的过滤 ：MLDv2是在指定组播组查询的基础上增加关于组播源的过滤模式：Include或Exclude。</p>
<ul>
<li>如果主机加入组播组时，只要求接收某些指定源如S1、S2、……发来的组播组报文，MLD报告消息中可以设置为Include Sources (S1, S2, …)。</li>
<li>如果主机加入组播组时，拒绝接收某些指定源如S1、S2、……发来的组播报文，则可以设置从指定源外的源地址接收组播组报文，MLD报告消息中可以设置为Exclude Sources (S1, S2, …)。</li>
</ul>
</li>
<li><p>IPv6 组播组状态跟踪：运行MLDv2协议的组播路由器按每条直连链路上的组播地址（per multicast address per attached link）来保持组播组的状态。组播组状态包括：</p>
<ul>
<li>过滤模式：保持对Include或Exclude的状态跟踪。</li>
<li>源列表：保持对新增或删除组播源的跟踪。</li>
<li>定时器：例如表示组播地址超时后切换到Include模式的过滤定时器、关于源记录的源定时器等。</li>
</ul>
</li>
<li><p>接收者主机的状态侦听：运行MLDv2协议的组播路由器通过侦听接收者主机的状态，记录和维护网段上加入到源-组的主机的信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/16.png"></p>
<blockquote>
<ul>
<li>接收者通过组播方式接收视频点播信息，不同组织的接收者组成末梢网络，每个末梢网络中都存在一到多台接收者Host。</li>
<li>Host A和Host C为两个末梢网络中的组播信息接收者。PIM网络中的Router A通过GE1/0/0接口连接末梢网络N1，通过POS2/0/0接口连接PIM网络中的其它设备；Router B和Router C路由器通过各自的GE1/0/0接口连接末梢网络N2，分别通过POS2/0/0接口连接PIM网络中的其它设备。</li>
<li>Router A和末梢网络N1之间运行MLDv1。</li>
<li>Router B、Router C和末梢网络N2之间运行MLDv2。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li><p>进入系统视图</p>
<ul>
<li><strong>system-view</strong></li>
</ul>
</li>
<li><p>使能IP组播路由</p>
<ul>
<li><strong>multicast ipv6 routing-enable</strong></li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em></li>
</ul>
</li>
<li><p>使能MLD</p>
<ul>
<li><strong>mld</strong> <strong>enable</strong></li>
<li>配置了MLD的路由器必须在接口上使能MLD来侦听所有的IPv6组播地址。在需要建立和维持组播组成员关系的接口上使能MLD。</li>
<li>查询器在直连网段上周期性发送MLD查询消息来维持组播侦听者的信息。当接收到组成员报告消息时，组播路由器刷新相关的组成员信息。</li>
</ul>
</li>
<li><p>进入MLD视图</p>
<ul>
<li><strong>mld</strong></li>
</ul>
</li>
<li><p>配置全局性MLD版本</p>
<ul>
<li><strong>version</strong> { <strong>1</strong> | <strong>2</strong> } </li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em></li>
</ul>
</li>
<li><p>配置接口MLD版本</p>
<ul>
<li><strong>mld</strong> <strong>version</strong> { <strong>1</strong> | <strong>2</strong> } </li>
<li>MLD版本号的配置是可选的。缺省情况下，使用MLDv2版本。</li>
<li>当接口下没有配置新值时，缺省采用MLD视图下配置的值；假如接口下配置了新值，则接口视图下的取值优先被选择。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li>缺省情况下使用MLDv2。</li>
<li>Router C的配置与Router B类似。</li>
<li>在这样一个网络上需要选举查询器，那一台路由器将被选举成查询器呢？</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li>可以看到，Router B是查询器，这是因为同一网段上组播路由器Router B的GE1/0/0的IPv6地址较小。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/21.png"></p>
<blockquote>
<ul>
<li><p>配置完成后，当 RouterA 收到来自主机的 MLDv1 报告报文时，首先检查该报文中所携带的 IPv6 组播组地址 G， 然后根据检查结果的不同分别进行处理： </p>
<ul>
<li>如果 G 不在 IPv6 SSM 组地址范围内，则提供 ASM 组播服务。 </li>
<li>如果 G 在 IPv6 SSM 组地址范围内： </li>
<li>若 RouterA 上没有 G 对应的 MLD SSM Mapping 规则，则无法提供 SSM 组播服务，丢弃该报文； </li>
<li>若 RouterA 上有 G 对应的 MLD SSM Mapping 规则，则依据规则将报告报文中所包含的（*，G）信息 映射为（G，INCLUDE，（ S1，S2…））信息，可以提供 SSM 组播服务。SSM映射功能使采用MLDv1版本的主机无须升级MLD版本就能顺利接收SSM的数据报文。此功能不影响采用MLDv2的主机。</li>
</ul>
</li>
<li><p>映射策略可以多次配置，实现同一个组到多个源的映射。在一台路由器上，转发且仅转发映射表中的指定源-组报文。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/25.png"></p>
<blockquote>
<ul>
<li><p>MLD的主要功能是什么？</p>
<ul>
<li>组播侦听发现协议MLD（Multicast Listener Discovery）用于IPv6组播中的组成员管理，其基本原理和功能与IGMP相似。MLD的目的是使能每个IPv6路由器发现在其直连网络上的组播侦听者（即希望接收组播数据的节点）的存在，并且能明确发现这些邻居节点所感兴趣的组播地址。然后提供这些消息给路由器所使用的组播路由协议，以确保组播数据转发至存在接收者的所有链接。</li>
</ul>
</li>
<li><p>MLDv2和MLDv1有哪些主要区别？</p>
<ul>
<li>MLDv2兼容MLDv1，原理与MLDv1相同。MLDv2支持源列表和过滤模式，可以指定源地址加入，用于实现SSM。</li>
</ul>
</li>
<li><p>SSM Mapping的主要作用是什么？</p>
<ul>
<li>发送MLDv1格式的报告消息的主机，不能接收到SSM组范围内的数据报文。 SSM映射功能使采用MLDv1版本的主机无须升级MLD版本就能顺利接收SSM的数据报文。此功能不影响采用MLDv2的主机。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/27.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/" itemprop="url">IE-路由import与Control</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:01+08:00">
                2021-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/1.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/2.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/3.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/4.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/5.png"></p>
<blockquote>
<ul>
<li><p>ACL访问控制类表</p>
<ul>
<li>ACL是由permit或deny语句组成的一系列有顺序规则的集合，它通过匹配报文的信息实现对报文的分类。路由器根据ACL定义的规则判断哪些报文可以接收，哪些报文需要拒绝，从而实现对报文的过滤。</li>
<li>ACL通过配置的一系列匹配规则对特定的数据包进行过滤，从而识别需要过滤的对象。然后，根据预先设定的策略允许或禁止相应的数据包通过。同时，ACL可以作为基础配置被其他功能模块引用。</li>
</ul>
</li>
<li><p>ip-prefix前缀类表</p>
<ul>
<li>ip-prefix将路由条目与前缀过滤列表的每一项进行匹配，然后根据定义的匹配模式进行过滤，达成路由筛选的目的。</li>
<li>ip-prefix不能用来过滤数据包，只能过滤路由信息。</li>
</ul>
</li>
<li><p>as-path-filter AS路径过滤器</p>
<ul>
<li>BGP的路由信息中，包含一个自治系统路径域。As-path-filter就是针对自治系统路径域指定匹配条件。AS路径过滤器仅应用于BGP协议。</li>
</ul>
</li>
<li><p>community-filter团体属性过滤器</p>
<ul>
<li>BGP的路由信息中，可以携带一个或多个团体属性，团体属性过滤器就针对团体属性域指定匹配条件。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/6.png"></p>
<blockquote>
<ul>
<li><p>ACL编号：用于标识ACL，表明该ACL是数字型ACL。</p>
<ul>
<li>根据ACL规则功能的不同，ACL被划分为基本ACL、高级ACL、二层ACL和用户ACL这几种类型，每类ACL编号的取值范围不同。</li>
<li>除了可以通过ACL编号标识ACL，设备还支持通过名称来标识ACL，就像用域名代替IP地址一样，更加方便记忆。这种ACL，称为命名型ACL。</li>
<li>命名型ACL实际上是“名字+数字”的形式，可以在定义命名型ACL时同时指定ACL编号。如果不指定编号，则由系统自动分配。</li>
</ul>
</li>
<li><p>规则：即描述报文匹配条件的判断语句。</p>
<ul>
<li>规则编号：用于标识ACL规则。可以自行配置规则编号，也可以由系统自动分配。ACL规则的编号范围是0～4294967294，所有规则均按照规则编号从小到大进行排序。所以，图1中的rule 5排在首位，而规则编号最大的rule15排在末位。系统按照规则编号从小到大的顺序，将规则依次与报文匹配，一旦匹配上一条规则即停止匹配。</li>
<li>动作：包括permit/deny两种动作，表示允许/拒绝。</li>
<li>匹配项：ACL定义了极其丰富的匹配项。除了图中的源地址和生效时间段，ACL还支持很多其他规则匹配项。例如，二层以太网帧头信息（如源MAC、目的MAC、以太帧协议类型）、三层报文信息（如目的地址、协议类型）以及四层报文信息（如TCP/UDP端口号）等。</li>
<li>如果规则存在，则系统会从ACL中编号最小的规则开始查找。如果匹配上了permit规则，则停止查找规则，并返回ACL匹配结果为：匹配（允许）。如果匹配上了deny规则，则停止查找规则，并返回ACL匹配结果为：匹配（拒绝）。如果未匹配上规则，则继续查找下一条规则，以此循环。如果一直查到最后一条规则，报文仍未匹配上，则返回ACL匹配结果为：不匹配。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/7.png"></p>
<blockquote>
<ul>
<li><p>基本ACL</p>
<ul>
<li>仅使用报文的源IP地址、分片信息和生效时间段信息来定义规则。</li>
</ul>
</li>
<li><p>高级ACL</p>
<ul>
<li>既可使用IPv4报文的源IP地址，也可使用目的IP地址、IP协议类型、ICMP类型、TCP源/目的端口、UDP源/目的端口号、生效时间段等来定义规则。</li>
</ul>
</li>
<li><p>二层ACL</p>
<ul>
<li>使用报文的以太网帧头信息来定义规则，如根据源MAC（Media Access Control）地址、目的MAC地址、二层协议类型等。</li>
</ul>
</li>
<li><p>用户ACL</p>
<ul>
<li>既可使用IPv4报文的源IP地址，也可使用目的IP地址、IP协议类型、ICMP类型、TCP源端口/目的端口、UDP源端口/目的端口号等来定义规则。</li>
</ul>
</li>
<li><p>除此之外，还有基于IPv6的ACL，基本ACL6和高级ACL6。</p>
<ul>
<li>基本ACL6：可使用IPv6报文的源IPv6地址、分片信息和生效时间段来定义规则。</li>
<li>高级ACL6：可以使用IPv6报文的源IPv6地址、目的IPv6地址、IPv6协议类型、ICMPv6类型、TCP源/目的端口、UDP源/目的端口号、生效时间段等来定义规则。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/8.png"></p>
<blockquote>
<ul>
<li><p>ACL的匹配顺序</p>
<ul>
<li>一个ACL 可以由多条“deny | permit”语句组成，每一条语句描述一条规则，这些规则可能存在重复或矛盾的地方（一条规则可以包含另一条规则，但两条规则不可能完全相同）。</li>
<li>设备支持两种匹配顺序，即配置顺序（config）和自动排序（auto）。当将一个数据包和访问控制列表的规则进行匹配的时候，由规则的匹配顺序决定规则的优先级，ACL通过设置规则的优先级来处理规则之间重复或矛盾的情形。缺省的ACL匹配顺序是config模式。</li>
</ul>
</li>
<li><p>配置顺序</p>
<ul>
<li>如果配置规则时指定了规则编号，则规则编号越小，规则插入位置越靠前，该规则越先被匹配。</li>
<li>如果配置规则时未指定规则编号，则由系统自动为其分配一个编号。该编号是一个大于当前ACL内最大规则编号且是步长整数倍的最小整数，因此该规则会被最后匹配。</li>
</ul>
</li>
<li><p>自动排序（auto）</p>
<ul>
<li>自动排序（auto）使用“深度优先”的原则进行匹配。</li>
<li>“深度优先”即根据规则的精确度排序，匹配条件（如协议类型、源和目的IP 地址范围等）限制越严格越精确。例如可以比较地址的反掩码，反掩码越小，则指定的主机的范围就越小，限制就越严格。</li>
<li>若“深度优先”的顺序相同，则匹配该规则时按rule-id从小到大排列。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/9.png"></p>
<blockquote>
<ul>
<li>ACL6和ACL命令行不同，而对应的编号可以相同，二者互不影响。</li>
<li>例如：<ul>
<li>[RouterA] acl ipv6 number 3001</li>
<li>[RouterA-acl6-adv-3001] rule deny ipv6 source 3001::2/64</li>
<li>[RouterA] acl 3001</li>
<li>[Router-acl-adv-3001] rule permit ip source 202.169.10.5 0.0.0.0</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/10.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/11.png"></p>
<blockquote>
<ul>
<li><p>ip-prefix</p>
<ul>
<li>每个地址前缀列表可以包含多个IP-Prefix条目，每个IP-Prefix条目对应一个索引号（index）。路由将按照索引号从小到大依次检查IP-Prefix列表，任意一个index匹配成功，将不再检查其余项。若所有index都匹配失败，路由信息将被过滤。</li>
<li>根据匹配的前缀不同，前缀过滤列表可以进行精确匹配，也可以进行在一定掩码长度范围内匹配。</li>
<li>前缀过滤列表可以进行精确匹配或者在一定掩码长度范围内匹配，可以通过配置关键字greater-equal和less-equal指定待匹配的前缀掩码长度范围。如果没有配置关键字greater-equal或less-equal，前缀过滤列表进行精确匹配，即只匹配掩码长度为前缀过滤列表掩码长度的相同IP地址路由；如果只配置了关键字greater-equal，则待匹配的掩码长度范围为从greater-equal指定值到32 位长度；如果只匹配了关键字less-equal，则待匹配的掩码长度范围为从指定的掩码到关键字less-equal指定值。</li>
<li>greater-equal-value与less-equal-value的取值限制：mask-length&lt;=greater-equal-value&lt;=less-equal-value&lt;=32。</li>
</ul>
</li>
<li><p>ip-prefix特点</p>
<ul>
<li>当所有前缀过滤列表均未匹配时，缺省情况下，存在最后一条默认匹配模式为deny。</li>
<li>当引用的前缀过滤列表不存在时，默认匹配模式为permit。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/12.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/13.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/14.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/15.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/16.png"></p>
<blockquote>
<ul>
<li>AS路径过滤器是将BGP中的AS_Path属性作为匹配条件的过滤器，只有BGP在收发路由的时候才能使用。</li>
<li>由于AS_Path属性记录AS号是将最后经历的AS号放在AS_Path记录中的最左侧，所以在配置as-path-filter时需要格外注意。<ul>
<li>如果一条路由起源于AS100，然后依次经过AS300, AS200, AS500，最后到达AS600。那么在AS600里，路由的AS-PATH属性表示为（500 200 300 100）。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/17.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/18.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/19.png"></p>
<blockquote>
<ul>
<li>团体属性过滤器是将BGP中的团体属性作为匹配条件的过滤器，只有BGP在收发路由的时候才能使用。</li>
<li>团体属性包括基本basic团体属性和extended团体属性<ul>
<li>自定义团体属性和公认团体属性均属于basic团体属性。</li>
<li>MPLS VPN中的RT和SOO均属于extended团体属性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/20.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/21.png"></p>
<blockquote>
<ul>
<li><p>路由策略主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。</p>
</li>
<li><p>路由策略常用于如下场景：</p>
<ul>
<li>控制路由的引入：<ul>
<li>在对路由做相互引入时，为了防止次优路径或者环路，可以使用路由策略加以解决。</li>
</ul>
</li>
<li>控制路由的接收和发布：<ul>
<li>根据网络需求，接收或者发布特定的路由。</li>
</ul>
</li>
<li>设置特定路由的属性：<ul>
<li>可以通过路由策略修改路由的属性，以对网络进行优化、调整。</li>
</ul>
</li>
</ul>
</li>
<li><p>路由策略原理</p>
<ul>
<li>一个Route-Policy由多个节点构成，路由进入路由策略后，按节点序号从小到大依次检查各个节点是否匹配。一个节点包括多个if-match和apply子句。if-match子句用来定义该节点的匹配条件，apply子句用来定义通过过滤的路由行为。if-match子句的过滤规则关系是“与”，即该节点的所有if-match子句都必须匹配。Route-Policy节点间的过滤关系是“或”，即只要通过了一个节点的过滤，就可通过该Route-Policy。如果没有通过任何一个节点的过滤，路由信息将无法通过该Route-Policy。</li>
<li>对于同一个Route-Policy节点，在匹配的过程中，各个if-match子句间是“与”的关系，即路由信息必须同时满足所有匹配条件，才可以执行apply子句的动作。但命令if-match route-type和if-match interface除外，这两个命令的各自if-match子句间是“或”的关系，与其它命令的if-match子句间仍是“与”的关系。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/22.png"></p>
<blockquote>
<ul>
<li>上面拓扑为双点双向重发布的示意图，如果不加控制，将会发生次优路由和环路等故障，产生故障的过程具体分析如下：<ul>
<li>在拓扑中，R1将网段10.0.0.0/24及2000::/64引入到OSPF。R2/R3分别将该路由引入ISIS，正常情况下，R2/R3将路由引入ISIS会有先后，假设R3先于R2将该路由引入到IS-IS。那么R2就会同时从OSPF和IS-IS学到10.0.0.0/24及2000::/64的路由。于是R2会根据路由协议的优先级优选通过IS-IS学到的路由（OSPF的外部路由优先级为150，IS-IS的路由优先级为15）。于是，当R2访问10.0.0.0/24及2000::/64网段时，会使用R4-R3-R1这条次优路径。为了避免出现这种情况，可以在路由器R2上使用route-policy修改OSPF ASE路由的优先级，使得OSPF ASE的路由优先于从IS-IS学到的路由，使得R2选择正确的路由。</li>
<li>当R1连接网络10.0.0.0/24及2000::/64的接口断掉之后，虽然该条外部LSA会在OSPF区域内老化，但是由于R2通过IS-IS已经学习到了10.0.0.0/24及2000::/64网络，所以R2会将该网络引入到OSPF，进而使R1和R3会通过R2学习到了网络10.0.0.0/24及2000::/64。当R2访问访问网络10.0.0.0/24及2000::/64时，流量会沿R4-R3-R1-R2的路径发送，从而引发环路。为避免这种情况，我们可以通过给路由条目添加标记tag标签，然后对特定标签进行过滤的方法来避免环路的发生。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/23.png"></p>
<blockquote>
<ul>
<li><p>控制路由的接收和发布</p>
<ul>
<li>只接收必要、合法的路由信息，以控制路由表的容量，提高网络的安全性。</li>
</ul>
</li>
<li><p>拓扑解释</p>
<ul>
<li>R4将网络10.0.X.0/24及2000::/64&amp;3000::/64引入到OSPF中。根据业务需要，R1只能接收网络10.0.0.0/24和2000::/64；而R2只能接收网络10.0.1.0/24和3000::/64。对于这种需求，可以通过filter-policy加以实现。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/24.png"></p>
<blockquote>
<ul>
<li>Filter-policy import命令用来按照过滤策略，设置OSPF对接收的路由进行过滤。</li>
<li>Filter-policy export命令用来按照过滤策略，设置对引入的路由在向外发布时进行过滤。<ul>
<li>通过指定protocol或process-id对特定的某一种协议或某一进程的路由进行过滤。如果没有指定protocol和process-id，则OSPF将对所有引入的路由信息进行过滤。</li>
<li>由于Type5、7 LSA是有ABSR产生的，因此，本命令仅在ASBR上配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/25.png"></p>
<blockquote>
<ul>
<li><p>Filter-policy import命令用来配置IS-IS路由加入IP路由表时的过滤策略。</p>
<ul>
<li>配置该命令后，不会影响本地设备的LSP的扩散和LSDB的同步，只会影响本地的IP路由表。</li>
</ul>
</li>
<li><p>Filter-policy export命令用来配置IS-IS对已引入的路由在向外发布时进行过滤的过滤策略。</p>
<ul>
<li>配置该命令后，不会影响本地设备的路由，只会将引入的部分外部路由发布给IS-IS邻居。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/26.png"></p>
<blockquote>
<ul>
<li>filter-policy import命令用来配置对接收的路由信息进行过滤。</li>
<li>filter-policy export命令用来配置对发布的路由进行过滤，只有通过过滤的路由才被BGP发布。<ul>
<li>如果指定protocol参数，将只对引入的这种协议产生的路由进行过滤，对引入的其他协议产生的路由不受影响。如果没有指定protocol参数，对引入的任何一个协议产生的路由都要进行过滤。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/27.png"></p>
<blockquote>
<ul>
<li>拓扑描述<ul>
<li>通过route-policy修改BGP中的Local_Pref属性，进而影响流量走向。R2将从EBGP学到的10.0.0.0/24和2000::/64路由的Local_Pref设为300，R3将从EBGP学到的该路由的Local_Pref设置为200，R1/R2/R3相互之间通过IBGP交互各自的路由，最终将选择以R2作为本AS去往网络10.0.0.0/24和2000::/64的出口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/28.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/29.png"></p>
<blockquote>
<ul>
<li>策略路由与路由策略存在以下不同：<ul>
<li>策略路由的操作对象是数据包，在路由表已经产生的情况下，不按照路由表进行转发，而是根据需要，依照某种策略改变数据包转发路径。</li>
<li>路由策略的操作对象是路由信息。路由策略主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/30.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/31.png"></p>
<blockquote>
<ul>
<li><p>匹配顺序：</p>
<ul>
<li>如果找到了匹配的本地策略路由节点，则按照以下步骤发送报文：<ul>
<li>查看用户是否设置了报文的优先级: 如果用户设置了报文的优先级，首先根据用户设置的优先级设置报文的优先级，然后继续向下执行;如果用户未设置报文的优先级，则继续向下执行</li>
<li>查看用户是否设置了本地策略路由的出接口: 如果用户设置了出接口，则将报文从出接口发送出去，不再继续执行下面的步骤;如果用户未设置出接口，则继续向下执行</li>
<li>查看用户是否设置了本地策略路由的下一跳（用户可以设置两个下一跳以达到负载分担的目的）如果用户设置了策略路由的下一跳，则将报文发往下一跳，不再继续执行下面的步骤; 如果用户未设置下一跳，则按照正常流程根据报文的目的地址查找路由。如果没有查找到路由，则继续向下执行</li>
<li>查看用户是否设置了本地策略路由的缺省出接口: 如果用户设置了缺省出接口，则将报文从缺省出接口发送出去，不再继续执行下面的步骤;如果用户未设置缺省出接口，则继续执行</li>
<li>查看用户是否设置了本地策略路由的缺省下一跳:如果用户设置了缺省下一跳，则将报文发往缺省下一跳，不再继续执行下面的步骤;如果用户未设置缺省下一跳，则继续执行</li>
<li>丢弃报文，产生ICMP_UNREACH 消息</li>
</ul>
</li>
</ul>
</li>
<li><p>如果没有找到匹配的本地策略路由节点，按照发送IP报文的一般流程，根据目的地址查找路由</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/32.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/33.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/34.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/35.png"></p>
<blockquote>
<ul>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RTX与RTY互联，则互联地址为XY.1.1.X与XY.1.1.Y，掩码长度为24位。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/36.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>route-policy命令用来创建Route-Policy并进入该Route-Policy视图。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>route-policy route-policy-name { permit | deny } node node<ul>
<li>route-policy-name：指定Route-Policy名称。</li>
<li>permit：指定Route-Policy节点的匹配模式为允许。如果路由匹配所有的if-match子句，该路由可通过过滤并执行此节点apply命令中规定的一系列动作；否则，必须进行下一节点的测试。</li>
<li>deny：指定Route-Policy节点的匹配模式为拒绝。如果路由匹配所有的if-match子句，该路由不能通过过滤从而不能进入下一节点的测试。</li>
<li>node node：Route-Policy的节点索引。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>Route-Policy用于过滤路由信息以及为通过过滤的路由信息设置路由属性。一个Route-Policy由多个节点构成。一个节点包括多个if-match和apply子句。if-match子句用来定义该节点的匹配条件，apply子句用来定义通过过滤的路由行为。if-match子句的过滤规则关系是“与”，即该节点的所有if-match子句都必须匹配。Route-Policy节点间的过滤关系是“或”，即只要通过了一个节点的过滤，就可通过该Route-Policy。如果没有通过任何一个节点的过滤，路由信息将无法通过该Route-Policy。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/37.png"></p>
<blockquote>
<ul>
<li>此处的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
<li>对于该需求，主要考察对filter-policy和ACL的理解。所谓最优配置，实际上就是使用最少的命令达到要求的效果。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/38.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>filter-policy export命令用来按照过滤策略，设置对引入的路由在向外发布时进行过滤。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>filter-policy { acl-number | acl-name acl-name | ip-prefix ip-prefix-name } export [ protocol [ process-id ] ]<ul>
<li>acl-number：指定基本访问控制列表号。</li>
<li>acl-name acl-name：指定访问控制列表名称。</li>
<li>ip-prefix ip-prefix-name：指定地址前缀列表名称。</li>
<li>protocol：指定发布路由信息的协议。</li>
<li>process-id：当发布的路由协议为rip、isis、ospf时，可以指定进程号。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>OSPF通过命令import-route引入外部路由后，为了避免路由环路的产生，通过filter-policy export命令对引入的路由在发布时进行过滤，只将满足条件的外部路由转换为Type-5 LSA（AS-external-LSA）并发布出去。</li>
<li>通过指定protocol或process-id对特定的某一种协议或某一进程的路由进行过滤。如果没有指定protocol和process-id，则OSPF将对所有引入的路由信息进行过滤。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/39.png"></p>
<blockquote>
<ul>
<li>该案例拓扑和之前的拓扑一致。我们在完成需求后，要充分考虑到是否存在次优路由，是否发生了环路。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/40.png"></p>
<blockquote>
<ul>
<li>通过路由协议的相互引入之后，R4到达网络172.16.X.0/24出现次优路径。产生次优路径主要是因为R3将OSPF路由先行分发入ISIS协议域，于是R4从OSPF和ISIS同时学到了172.16.X.0/24的路由，因为OSPF的外部路由的preference值为150，而ISIS的preference值为15，所以R4选择了ISIS路由前往172.16.X.0/24网段，于是产生次优路由。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/41.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/42.png"></p>
<blockquote>
<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。<ul>
<li>需要修正R4访问172.16.X.0/24网段的路由，避免出现经过ISIS区域的次优路由。</li>
<li>可以通过Tag实现对双点双向路由引入的控制，从而避免环路。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/43.png"></p>
<blockquote>
<ul>
<li><p>如果在做路由互相引入的时候不做过滤，那么，在网络发生变化的时候，可能会在网络中导致环路。为避免环路就要保证路由协议间相互引入的时候只引入各路由域自身的路由。在上面的配置场景中，使用了tag来实现路由相互引入时的限制。使用tag的优势是不需要指定具体的路由条目，当路由域内具体的路由项有增减的时候，引入的路由条目的tag值会随之变化，不需要手工干预，具有很好的扩展性。</p>
</li>
<li><p>虽然上面的配置场景的路由策略能够很好地避免环路，但是并不能解决次优路由的问题。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/44.png"></p>
<blockquote>
<ul>
<li><p>次优路由主要是因为双点双向导入时，R3/R4中的某一台路由器会同时从两侧得到172.16.X.0/24路由，而因为OSPF的外部路由preference值大于ISIS的preference值（preference值越小越优先），导致R3/R4（其中一台）选择了次优路由。要解决此问题，需要修改OSPF外部路由条目的preference值，只要使OSPF_ASE路由的preference值小于ISIS路由的preference值就可以解决此问题。</p>
</li>
<li><p>考虑到合理性问题，不建议将OSPF_ASE路由的preference值设置成比OSPF内部路由的preference值（10）还小。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/45.png"></p>
<blockquote>
<ul>
<li>本案例中，是对原案例进行的扩展，在原案例的基础上进行配置。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/46.png"></p>
<blockquote>
<ul>
<li>当仅仅进行路由汇总，发现存在两个问题。第一个问题，R5学习到了该汇总路由；第二个问题，在R2 ping一个不存在的地址产生了环路。</li>
<li>第一个问题产生的原因，主要是由于R3和R4学习到对方产生的汇总路由后，再引入到ISIS域中产生的。此处，R3首先进行了OSPF汇聚配置，通过R2传递到R4。R4将该OSPF汇聚路由引入到ISIS，通告给R5。</li>
<li>第二个问题产生的原因，是因为R2上面有2条等价的10.0.0.0/16的路由，下一跳分别是R3和R4。当tracert的端口号变化时，tracert报文会被送给R3或R4。（1）tracert报文发给R4时： R4晚于R3进行OSPF路由汇聚，所以R4只有1条R3通告的OSPF聚合路由，所以R4对于10. 0.0.0/16，下一跳为R2。形成环路。（2）tracert报文发给R3时： R4生成OSPF汇聚路由后，通过R2通告给R3；R3生成OSPF汇聚路由后，通过R2传递给R4，R4将该OSPF汇聚路由引入到ISIS，通过R5通告给R3。所以R3会收到2条16位掩码的路由，通过比较协议优先级，R3会优选ISIS，下一跳为R5。R5的下一跳为R4。而R4晚于R3进行OSPF路由汇聚，所以R4有R3通告的OSPF聚合路由，所以R4对于10. 0.0.0/16，下一跳为R2。形成环路。</li>
<li>为了解决上面两个问题，我们需要保证R3和R4既不能学习到对方产生的汇总路由，又不能将该路由引入到ISIS路由域。所以，我们只需在R3和R4上将他们学习到的对方的汇总路由过滤即可。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/47.png"></p>
<blockquote>
<ul>
<li>在R3/R4上增加过滤策略，不从OSPF接收特定的汇聚路由。保证该汇聚路由不再重新导入到ISIS路由域。避免了环路。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/48.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/49.png"></p>
<blockquote>
<p>案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</p>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/50.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li>policy-based-route命令用来创建或修改策略路由和策略点。</li>
<li>ip local policy-based-route命令用来使能本地策略路由。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>policy-based-route policy-name { permit | deny } node node-id<ul>
<li>policy-name：指定策略名称。</li>
<li>permit：策略点的模式，表示对满足匹配条件的报文进行策略路由。</li>
<li>deny：策略点的模式，表示对满足匹配条件的报文不进行策略路由。</li>
<li>node-id：指定策略点的顺序号。</li>
</ul>
</li>
<li>ip local policy-based-route policy-name<ul>
<li>policy-name：指定策略路由的名称。 </li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在部署策略路由时，如果需要配置报文的出接口，则报文的出接口不能为以太接口等广播型接口。</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>在R5上指定不同的源地址对到达相同目的地的数据包进行跟踪，可以发现数据包选用了不同的路径。注意，ip local policy-based-route命令应用的策略只对路由器本地发起的数据包起作用。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/51.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/52.png"></p>
<blockquote>
<ul>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RTX与RTY互联，则互联地址为XY.1.1.X与XY.1.1.Y，掩码长度为24位。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/53.png"></p>
<blockquote>
<ul>
<li>该部分只需要注意R5在做路由引入时，需要精细匹配。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/54.png"></p>
<blockquote>
<ul>
<li>当tracert一个不存在的、但是在网络10.0.0.0/16内的地址时，会发生环路。该环路的产生主要是由于OSPF产生汇总路由时，不自动生成指向null0的路由所致。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/55.png"></p>
<blockquote>
<ul>
<li>在R5上通过命令配置指向null0的静态路由，即可破除环路。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/56.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/57.png"></p>
<blockquote>
<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RTX与RTY互联，则互联地址为XY.1.1.X与XY.1.1.Y,掩码长度为24位。</li>
<li>R1接口S1/0/0地址为12.1.1.1/24，R2接口S1/0/0地址为12.1.1.2/24；R1接口S1/0/1地址为21.1.1.1/24，R2接口S1/0/1地址为21.1.1.2/24。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/58.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/59.png"></p>
<blockquote>
<ul>
<li>通过filter-policy结合ACL，将需求中指定的两个网段导入到ISIS协议中，注意，当使用filter-policy过滤路由协议的导入的时候，使用export方向。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/60.png"></p>
<blockquote>
<ul>
<li>本案例中通过在导入路由的时候给路由条目加Tag的方法防止出现路由环路。ISIS路由协议如果需要支持Tag，必须要使用wide类型的开销，否则ISIS路由不能携带Tag标记。</li>
<li>使用Tag标签防止了路由回环，但是不能防止次优路由的产生。如果要避免次优路由，需要修改相应路由的preference值。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/61.png"></p>
<blockquote>
<ul>
<li>本例中的配置将避免路由10.0.0.0/16在R3/R4上出现次优路由。因为导入速度的不一致，总会导致R3/R4两台路由器中的一台会从ISIS和OSPF同时学到10.0.0.0/16，如果R3先行导入，那么R4就会同时从ISIS和OSPF学到10.0.0.0/16路由，而R4选择路由时会比较他们的preference，因OSPF外部路由的preference值为150，而isis的preference值为15，所以R4会选择到达经由IS-IS域到达网络10.0.0.0/16，该路径是次优路径。所以，通过在R4上，修改OSPF外部路由10.0.0.0/16的preference值，使其小于IS-IS的preference值，从而消除次优路径，考虑合理性，建议OSPF的外部路由preference值要大于OSPF的内部preference值（10）。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/62.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/63.png"></p>
<blockquote>
<ul>
<li>ABCD</li>
<li>D</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/64.png"></p>
<blockquote>
<ul>
<li>AB</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/65.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/" itemprop="url">IE-BGP双栈原理Advance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-09T15:31:25+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/1.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/2.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/3.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/4.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/5.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/6.png"></p>
<blockquote>
<ul>
<li>在大规模的网络中，BGP路由表十分庞大，给设备造成了很大的负担，同时使发生路由振荡的几率也大大增加，影响网络的稳定性。</li>
<li>路由聚合是将多条路由合并的机制，它通过只向对等体发送聚合后的路由而不发送所有的具体路由的方法，减小路由表的规模。并且被聚合的路由如果发生路由振荡，也不再对网络造成影响，从而提高了网络的稳定性。</li>
<li>路由聚合是会使用Aggregator属性（可选过渡属性），该属性标识发生聚合的节点，携带发生聚合节点的route-id和AS号。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/7.png"></p>
<blockquote>
<ul>
<li>自动聚合注意事项<ul>
<li>该命令对BGP引入的路由进行聚合，引入的路由可以是直连路由、静态路由、OSPF路由、IS-IS路由。配置聚合后，BGP将按照自然网段聚合路由，明细路由在BGP路由更新中被抑制。该命令对network命令引入的路由无效。</li>
<li>BGP只向对等体发送聚合后的路由；</li>
<li>缺省情况下BGP不启用自动聚合；</li>
<li>聚合之后的路由将带有atomic_aggregate和aggregator属性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/8.png"></p>
<blockquote>
<ul>
<li>手动聚合<ul>
<li>可通过命令决定是否抑制明细路由，抑制后该聚合后的路由会携带atomic_aggregate属性。</li>
<li>聚合路由不会携带成员明细路由的AS_PATH属性。</li>
<li>通过AS_SET属性来携带AS号，以避免环路。SET和SEQUENCE的不同之处在于，SET选项下的AS列表通常用于路由聚合，将来自不同AS的AS号无序排列在AS列表里；而SEQUENCE选项下的AS列表是有序的，每经过一个AS都会将其AS号排列在列表的前端。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/9.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/10.png"></p>
<blockquote>
<ul>
<li>对等体组（Peer Group）是一些具有某些相同策略的对等体的集合。当一个对等体加入对等体组中时，此对等体将获得与所在对等体组相同的配置。当对等体组的配置改变时，组内成员的配置也相应改变。</li>
<li>在大型BGP网络中，对等体的数量会很多，其中很多对等体具有相同的策略，在配置时会重复使用一些命令，利用对等体组可以简化配置。</li>
<li>对等体组中的单个对等体也可以配置自己的发布路由与接收路由的策略。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/11.png"></p>
<blockquote>
<ul>
<li><p>BGP按组打包</p>
<ul>
<li>缺省情况下，BGP会针对不同邻居（即使出口策略相同）单独打包路由。</li>
<li>应用按组打包功能后，每条待发送路由只被打包一次然后发给组内的所有邻居，使打包效率成倍提升。</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>一个反射器有3个客户机，有10万条路由需要反射。如果按照每个邻居分别打包的方式，反射器RR在向3个客户机发送路由的时候，所有路由被打包的总次数是10万×3。而按组打包技术将这个过程变为10 万×1，性能相当于提升了3倍。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/12.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/13.png"></p>
<blockquote>
<ul>
<li><p>团体属性是一组有相同特征的目的地址的集合。团体属性用一组以4字节为单位的列表来表示，设备中团体属性的格式是aa:nn或团体号。</p>
<ul>
<li>aa:nn：aa和nn的取值范围都是0～65535，管理员可根据实际情况设置具体数值。通常aa表示自治系统AS编号，nn是管理员定义的团体属性标识。例如，来自AS100的一条路由，管理员定义的团体属性标识是1，则该路由的团体属性格式是100:1。</li>
<li>团体号：团体号是0～4294967295的整数。RFC1997中定义，0（0x00000000）～65535（0x0000FFFF）和4294901760（0xFFFF0000）～4294967295（0xFFFFFFFF）是预留的。</li>
</ul>
</li>
<li><p>团体属性用来简化路由策略的应用和降低维护管理的难度，利用团体可以使多个AS中的一组BGP设备共享相同的策略。团体是一个路由属性，在BGP对等体之间传播，且不受AS的限制。BGP设备在将带有团体属性的路由发布给其它对等体之前，可以先改变此路由原有的团体属性。</p>
</li>
<li><p>公认团体属性</p>
<ul>
<li>Internet：缺省情况下，所有的路由都属于Internet团体。具有此属性的路由可以被通告给所有的BGP对等体。</li>
<li>No_Advertise：具有此属性的路由在收到后，不能被通告给任何其他的BGP对等体。</li>
<li>No_Export：具有此属性的路由在收到后，不能被发布到本地AS之外。如果使用了联盟，则不能被发布到联盟之外，但可以发布给联盟中的其他子AS。</li>
<li>No_Export_Subconfed：具有此属性的路由在收到后，不能被发布到本地AS之外，也不能发布到联盟中的其他子AS。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/14.png"></p>
<blockquote>
<ul>
<li>为保证IBGP对等体之间的连通性，需要在IBGP对等体之间建立全连接（Full-mesh）关系。假设在一个AS内部有n台路由器，那么应该建立的IBGP连接数就为n(n-1)/2。当IBGP对等体数目很多时，对网络资源和CPU资源的消耗都很大。利用路由反射可以解决这一问题。</li>
<li>在一个AS内，其中一台路由器作为路由反射器RR（Route Reflector），其它路由器作为客户机（Client）。客户机与路由反射器之间建立IBGP连接。路由反射器和它的客户机组成一个集群（Cluster）。路由反射器在客户机之间反射路由信息，客户机之间不需要建立BGP连接。</li>
<li>路由反射器概念<ul>
<li>路由反射器RR（Route Reflector）：允许把从IBGP 对等体学到的路由反射到其他IBGP对等体的BGP设备。</li>
<li>客户机（Client）：与RR形成反射邻居关系的IBGP设备。在AS内部客户机只需要与RR直连。</li>
<li>非客户机（Non-Client）：既不是RR也不是客户机的IBGP设备。在AS内部非客户机与RR之间，以及所有的非客户机之间仍然必须建立全连接关系。</li>
<li>始发者（Originator）：在AS内部始发路由的设备。Originator_ID属性用于防止集群内产生路由环路。</li>
<li>集群（Cluster）：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/15.png"></p>
<blockquote>
<ul>
<li><p>在向IBGP邻居发布学习到的路由信息时，RR按照以下规则发布路由</p>
<ul>
<li>从EBGP对等体学到的路由，发布给所有的非客户机和客户机。</li>
<li>从非客户机IBGP对等体学到的路由，发布给此RR的所有客户机。</li>
<li>从客户机学到的路由，发布给此RR的所有非客户机和客户机（发起此路由的客户机除外）。</li>
</ul>
</li>
<li><p>RR的配置方便，只需要对作为反射器的路由器进行配置，客户机并不需要知道自己是客户机。</p>
</li>
<li><p>在某些网络中，路由反射器的客户机之间已经建立了全连接，它们可以直接交换路由信息，此时客户机到客户机之间的路由反射是没有必要的，而且还占用带宽资源。VRP支持配置命令undo reflect between-clients来禁止RR将从客户机收到的路由再反射给其他客户机。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/16.png"></p>
<blockquote>
<ul>
<li><p>Originator ID由RR产生，使用的Router ID的值标识路由的发送者，用于防止集群内产生路由环路。</p>
<ul>
<li>当一条路由第一次被RR反射的时候，RR将Originator_ID属性加入这条路由，标识这条路由的发起设备。如果一条路由中已经存在了Originator_ID属性，则RR将不会创建新的Originator_ID属性。</li>
<li>当设备接收到这条路由的时候，将比较收到的Originator ID和本地的Router ID，如果两个ID相同，则不接收此路由。</li>
</ul>
</li>
<li><p>路由反射器和它的客户机组成一个集群（Cluster）。在一个AS内，每个路由反射器使用唯一的Cluster ID作为集群标识。</p>
<ul>
<li>为了防止集群间产生路由环路，路由反射器使用Cluster_List属性，记录路由经过的所有集群的Cluster ID。</li>
<li>当RR在它的客户机之间或客户机与非客户机之间反射路由时，RR会把本地Cluster_ID添加到Cluster_List的前面。如果Cluster_List为空，RR就创建一个。</li>
<li>当RR接收到一条更新路由时，RR会检查Cluster_List。如果Cluster_List中已经有本地Cluster_ID，丢弃该路由；如果没有本地Cluster_ID，将其加入Cluster_List，然后反射该更新路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/17.png"></p>
<blockquote>
<ul>
<li><p>备份RR主要是为了解决单点故障。</p>
</li>
<li><p>备份RR</p>
<ul>
<li>VRP需要使用命令reflector cluster-id给所有位于同一个集群内的路由反射器配置相同的Cluster_ID。</li>
<li>在冗余的环境里，客户机会收到不同反射器发来的到达同一目的地的多条路由，这时客户机应用BGP选择路由的策略来选择最佳路由。</li>
<li>Cluster_List的应用保证了同一AS内的不同RR之间不出现路由循环。</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>当客户机Client1从外部对等体接收到一条更新路由（10.0.0.0/24）后，它通过IBGP向RR1和RR2通告这条路由。</li>
<li>RR1接收到该更新路由后，它向其他的客户机（Client2、Client3）和非客户机（RR2）反射，同时将本地Cluster_ID添加到Cluster_List前面。</li>
<li>RR2接收到该反射路由后，检查Cluster_List，发现自己的Cluster_ID已经包含在Cluster_List中。因此，它丢弃该更新路由，不再向自己的客户机反射。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/18.png"></p>
<blockquote>
<ul>
<li>一个骨干网被分成多个反射集群，每个RR将其它的RR配置成非客户机，各RR之间建立全连接。每个客户机只与所在集群的RR建立IBGP连接。这样该自治系统内的所有BGP路由器都会收到反射路由信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/19.png"></p>
<blockquote>
<ul>
<li>Cluster1中部署了一个一级RR（RR-1），Cluster2和Cluster3中的RR(RR-2和RR-3)作为RR-1的客户端。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/20.png"></p>
<blockquote>
<ul>
<li>联盟<ul>
<li>联盟将一个AS划分为若干个子AS。每个子AS内部建立IBGP全连接关系，子AS之间建立联盟EBGP连接关系，但联盟外部AS仍认为联盟是一个AS。</li>
<li>配置联盟后，原AS号将作为每个路由器的联盟ID。</li>
<li>原有的IBGP 属性，包括Local Preference属性、MED属性和NEXT_HOP属性等；联盟相关的属性在传出联盟时会自动被删除，即管理员无需在联盟的出口处配置过滤子AS号等信息的操作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/21.png"></p>
<blockquote>
<ul>
<li><p>AS_PATH属性被定义为公认必遵属性，该属性由AS号所组成。AS_PATH包含4种不同类型</p>
<ul>
<li>AS_SET: 由一系列AS号无序地组成，包含在UPDATE消息里。当网络发生聚合时，可通过适当策略使AS_PATH使用类型AS_SET来避免路径信息丢失。</li>
<li>AS_SEQUENCE: 由一系列AS号顺序地组成，包含在UPDATE消息里。一般情况下，AS_PATH类型为AS_SEQUENCE。</li>
<li>AS_CONFED_SEQUENCE: 在本地联盟内由一系列成员AS号按顺序地组成，包含在UPDATE消息中，用法和AS_SEQUENCE相同，只能在本地联盟内传递。</li>
<li>AS_CONFED_SET: 在本地联盟内由一系列成员AS无序地组成，包含在UPDATE消息中，用法和AS_SET相同，只能在本地联盟内传递。</li>
</ul>
</li>
<li><p>联盟内部的成员AS号对于其他非联盟AS是不可见的，所以路由在从联盟内部发送到其他非联盟AS时，联盟成员AS号被剥离。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/22.png"></p>
<blockquote>
<ul>
<li>反射器和联盟的比较<ul>
<li>联盟需要重新划分区域，对现网改动较大。</li>
<li>反射器在配置时，只需要对RR进行配置，客户机不需要做任何其他的操作；联盟需要在所有路由器上进行配置。</li>
<li>RR与RR间需要IBGP全互联。</li>
<li>路由反射器应用较为广泛；联盟应用较少。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/23.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/24.png"></p>
<blockquote>
<ul>
<li><p>BGP安全特性：</p>
<ul>
<li>MD5：BGP使用TCP作为传输层协议，为提高BGP的安全性，可以在建立TCP连接时进行MD5认证。但BGP的MD5认证并不能对BGP报文认证，它只是为TCP连接设置MD5认证密码，由TCP完成认证。如果认证失败，则不建立TCP连接。</li>
<li>GTSM（Generalized TTL Security Mechanism）：GTSM通过检测IP报文头中的TTL值是否在一个预先定义好的特定范围内，对IP层以上业务进行保护，增强系统的安全性。使能BGP的GTSM策略后，接口板对所有BGP报文的TTL值进行检查。根据实际组网的需要，对于不符合TTL值范围的报文，GTSM可以设置为通过或丢弃。配置GTSM缺省动作为丢弃时，可以根据网络拓扑选择合适的TTL有限值范围，不符合TTL值范围的报文会被接口板直接丢弃，这样就避免了网络攻击者模拟的“合法”BGP报文占用CPU。该功能与EBGP多跳互斥。</li>
<li>限制从对等体接收的路由数量，防止资源耗尽性攻击。</li>
</ul>
</li>
<li><p>AS_Path长度保护。通过在入口和出口两个方向对AS_Path的长度进行限定，直接丢弃AS_Path超限的报文。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/25.png"></p>
<blockquote>
<ul>
<li>路由衰减（Route Dampening）用来解决路由不稳定的问题。多数情况下，BGP协议都应用于复杂的网络环境中，路由变化十分频繁。为了防止持续的路由振荡带来的不利影响，BGP使用路由衰减来抑制不稳定的路由。</li>
<li>BGP衰减使用惩罚值（Penalty Value）来衡量一条路由的稳定性，惩罚值越高则说明路由越不稳定。路由每发生一次振荡（路由从激活状态变为未激活状态，称为一次路由振荡），BGP便会给此路由增加一定的惩罚值（1000）。当惩罚值超过抑制阈值（Suppress Value）时，此路由被抑制，不加入到路由表中，也不再向其他BGP对等体发布更新报文。</li>
<li>当某条路由的惩罚值到达最大抑制值（Maximum Suppress Value）,便不会再增加，这样就可以确保某路由在非常短的时间内翻动十几次之后，不会将惩罚值累加到一个很高的、使路由始终保持被抑制状态的值。</li>
<li>被抑制的路由每经过一段时间，惩罚值便会减少一半，这个时间称为半衰期（Half-life）。当惩罚值降到再使用阈值（Reuse Value）时，此路由变为可用并被加入到路由表中，同时向其他BGP对等体发布更新报文。上文提到的惩罚值、抑制阈值和半衰期都可以手动配置。</li>
<li>路由衰减只适用于EBGP路由。对于从IBGP收来的路由不能进行衰减，因为IBGP路由经常含有本AS的路由，内部网络路由要求转发表尽可能一致，IGP快速收敛就是为了达到信息同步，转发一致。如果衰减对IBGP路由起作用，不同设备的衰减参数不一致时，会导致转发表不一致。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/26.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/27.png"></p>
<blockquote>
<ul>
<li>RFC5291、RFC5292规定了BGP基于前缀的ORF能力，能将本端设备配置的基于前缀的入口策略通过路由刷新报文发送给BGP邻居。BGP邻居根据这些策略构造出口策略，在路由发送时对路由条目进行过滤。这样不仅避免了本端设备接收大量无用的路由，降低了本端设备的CPU使用率，还有效减少了BGP邻居的配置工作，降低了链路带宽的占用率。</li>
<li>拓扑描述<ul>
<li>直连EBGP邻居中，Client1、R1协商基于前缀的ORF 能力后，Client1将本地配置的基于前缀的入口策略打包到Route-refresh报文中发送给R1。R1根据接收到的路由刷新报文构造出口策略，通过Route-refresh报文发送路由给Client1。Client1只收到它需要的路由，而R1不必维护路由策略，减少了配置工作。</li>
<li>Client1、Client2为RR的客户端，Client1与RR、Client2与RR，分别协商基于前缀的ORF 能力，Client1、Client2将本地配置的基于前缀的入口策略打包到Route-refresh 报文中发送给RR。RR 根据接收到的前缀信息构造出口策略，通过Route-refresh 报文将路由反射给Client1、Client2。Client1和Client2只收到需要的路由，RR不必维护路由策略，减少了配置工作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/28.png"></p>
<blockquote>
<ul>
<li>Active-Route-Advertise<ul>
<li>默认情况下路由只需在BGP中优选即可向邻居发布。配置了此特性之后，路由必须同时满足在BGP协议层面优选与在路由管理层面活跃两个条件，才能向邻居发布。</li>
<li>与命令bgp-rib-only（用来禁止BGP路由下发到IP路由表）互斥。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/29.png"></p>
<blockquote>
<ul>
<li><p>4字节AS号定义的角色</p>
<ul>
<li>New Speaker：支持4字节AS号扩展能力的对等体。</li>
<li>Old Speaker：不支持4字节AS号扩展能力的对等体。</li>
<li>New Session：New Speaker之间建立的BGP连接。</li>
<li>Old Session：New Speaker和Old Speaker之间或者Old Speaker之间建立的BGP连接。</li>
</ul>
</li>
<li><p>协议扩展</p>
<ul>
<li>定义了2种新的可选过渡属性AS4_Path（属性码为0x11）和AS4_Aggregator属性（属性码为0x12）用于在Old Session上传递4字节AS信息。</li>
<li>如果New Speaker和Old Speaker建立连接，定义AS_TRANS（保留值为23456）用于衔接2字节AS和4字节AS。</li>
<li>新的AS号有三种写法：<ul>
<li>splain：就是一个十进制的数字</li>
<li>asdot+:写成（2字节）.（2字节）的形式，所以旧的2字节ASN123可以写成0.123，ASN65536是1.0；最大为65535.65535；</li>
<li>asdot：旧的2字节写法照旧，新的4字节写成asdot+的形式；（1－65535；1.0－65535.65535）</li>
<li>华为支持asdot写法。</li>
</ul>
</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>R2收到R1的一条四字节AS的路由,AS号码为10.1；</li>
<li>R2与R3建立邻居，需要令R3认为R2的AS号为AS_TRANS；</li>
<li>R2发送路由给R3的时候把AS_TRANS记录在AS_Path里面，把10.1与自己的AS号码20.1按照BGP要求的顺序记录在AS4_Path；</li>
<li>R3对于不识别的属性AS4_Path不作处理依然保留，它只按照BGP的规则来发送路由给RD。当然它认为R4的AS号码也是AS_TRANS；</li>
</ul>
</li>
<li><p>这样当R4收到从R3来的路由会把AS_PATH中的AS_TRANS按照顺序替换为AS4_Path里所记录的相应的地址，在R4上把AS_PATH属性还原为30 20.1 10.1。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/31.png"></p>
<blockquote>
<ul>
<li><p>按策略进行下一跳迭代</p>
<ul>
<li>BGP需要对非直连的下一跳进行路由迭代，但是如果不对迭代到的路由进行过滤的话，可能会迭代到一个错误的转发路径上。按策略进行下一跳迭代就是通过配置路由策略来限制迭代到的路由。如果路由不能通过路由策略，则该路由迭代失败。</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>R1和R2、R3之间通过Loopback口建立IBGP邻居。R1从R2、R3分别收到了前缀为10.0.0.0/24的BGP路由。其中从R2收到的BGP路由的原始下一跳为2.2.2.2。另外，R1上Ethernet0/0/0的接口地址为2.2.2.100/24。</li>
<li>当R2正常运行时，R1收到从R2发来的前缀为10.0.0.0/24的路由会迭代到IGP路由2.2.2.2/32。但是当R2的IGP发生故障时，IGP路由2.2.2.2/32被撤销，这样就导致下一跳重新迭代。在R1上会用原始下一跳2.2.2.2在IP路由表中进行最长匹配迭代，结果会迭代到2.2.2.0/24的路由上。但此时用户期望的是，当到2.2.2.2的路由不可达时，可以重新选路优选到3.3.3.3的路由。实际上该故障主要是由于BGP收敛引起的，从而产生了路由的瞬时黑洞。</li>
<li>配置下一跳迭代策略，可以通过到BGP路由原始下一跳所依赖路由的掩码长度来过滤迭代路由。可以通过配置下一跳迭代策略，使到原始下一跳2.2.2.2只能依赖于2.2.2.2/32的IGP路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/32.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/33.png"></p>
<blockquote>
<ul>
<li><p>常见的企业网络拓扑类型</p>
<ul>
<li>单归属自治系统（一个出口设备且连接到一个ISP）</li>
<li>多归属到单自治系统（多个出口设备仅连接到一个ISP）</li>
<li>多归属到多自治系统（多个出口设备且连接到多个ISP）</li>
</ul>
</li>
<li><p>单归属自治系统：仅有一个出口设备且只连接到一个ISP。</p>
<ul>
<li>这种情况下，就可以不需要配置BGP协议。可在用户边界设备上添加一条默认路由，并宣告到用户自治系统内部。</li>
</ul>
</li>
<li><p>多归属到单自治系统：增加了对链路和网络设备的冗余性，一般这种情况下用户网络用的会是私有AS号。</p>
<ul>
<li>若两条链路采用主备的方式，那么也不需要采用BGP。两台出口设备分别向本自治系统内的设备宣告metric值不同的默认路由即可。（若采用OSPF为IGP，外部路由的cost应该采用E2方式，仅考虑外部开销（cost））</li>
<li>若两台路由器采用负载分担方式：<ul>
<li>方式一：两台路由器分别向自治系统内（IGP采用OSPF）宣告cost type为E1的默认路由，使得自治系统其他路由器选择距离自己最近的出口路由器到达外部网络。这种情况也可以不使用BGP。但是当两个出口路由器的物理间隔十分大，并且对时延有很高要求时，就可以考虑采取BGP来获取更精细的路由条目。</li>
<li>方式二：与ISP设备之间建立BGP连接，从BGP接收更为精细的路由条目，配合上路由策略工具的使用，来达到针对不同目的地址使用不同出口路由的目的。</li>
</ul>
</li>
</ul>
</li>
<li><p>多归属到多自治系统：不仅增加了对链路和网络设备的冗余性，同时使用了做到了ISP的冗余备份。</p>
<ul>
<li>对于这种自治系统，需要充分考虑到地址空间是否独立于运营商，是否拥有公有AS号等问题。</li>
<li>理想情况下，当用户网络拥有独立于ISP的地址空间和公有AS号时，有三种部署方式<ul>
<li>方式一：采取主备方式，出口路由器向内部宣告开销不一样的默认路由。</li>
<li>方式二：负载分担方式，出口路由器向内部宣告默认路由，仅使用IGP的开销计算机制，由IGP自行决定使用哪一台出口路由器。</li>
<li>方式三：部署BGP。考虑与ISP签署的合约，企业本身的业务流量特点等因素，使用各种路由策略工具，如有必要也可以使用默认路由宣告等方式。充分控制企业进和出方向的流量。</li>
</ul>
</li>
<li>一般情况下，多归属到多自治系统的网络会考虑部署BGP协议，因为前两种方法不利于路由的控制。但是不是绝对的，需要仔细权衡所得到的好处与增加路由复杂度所带来的代价。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/35.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/36.png"></p>
<blockquote>
<ul>
<li><p>BGP路由劫持</p>
<ul>
<li>产生原因：BGP协议里虽然有一些简单的安全认证的部分，但是对于两个已经成功建立BGP连接的AS来说，基本会无条件的相信对方AS所传来的信息，包括对方声称所拥有的IP地址范围。</li>
<li>潜在危害：若无条件相信对方发送过来的Update消息，不排除恶意的AS宣告不存在的IP网段，通过修改AS_Path等BGP属性，让其他AS认为这条路径才是到达这个目的网段的最短路径，那么该恶意的AS就能截获到数据流量。</li>
</ul>
</li>
<li><p>不对称路由</p>
<ul>
<li>产生原因：不恰当的属性使用或者是路由聚合不合理导致路由精准性不足，导致流量的出方向和入方向不同。</li>
<li>潜在危害：首先，不对称流量会使互联网络的流量模型变得难以预测，使得网络基准、容量规划、故障检测及排除变得困难；其次，不对称流量会使链路使用率出现不均衡，某些链路的带宽出现饱和，而其他链路的带宽却得不到有效利用；再次，不对称流量会使出流量和入流量的时延出现很大的差异，这种时延变化（即抖动）会对某些时延敏感型应用（如语音和直播视频）造成损害。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/37.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/38.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/39.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/40.png"></p>
<blockquote>
<ul>
<li><p>非BGP路由和BGP路由之间的交互</p>
<ul>
<li>一般情况下，IGP与BGP会有路由的引入。应采用合理的过滤策略，使合适的路由在IGP与BGP之间互相引入。</li>
</ul>
</li>
<li><p>默认路由的控制</p>
<ul>
<li>对于默认路由的发放，可以通过策略使默认路由根据某些具体条件来下发默认路由。</li>
</ul>
</li>
<li><p>策略路由</p>
<ul>
<li>通过策略路由来优化流量路径。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/41.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/42.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/43.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/44.png"></p>
<blockquote>
<ul>
<li><p>案例描述</p>
<ul>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RX与RY互联，则互联地址为XY.1.1.X与XY.1.1.Y，掩码长度为24位。</li>
</ul>
</li>
<li>OSPF和OSPFv3已经运行正常，且设备互联地址和环回口地址已经宣告进了OSPF或OSPFv3。</li>
</ul>
</li>
<li><p>案例分析</p>
<ul>
<li>EBGP邻居之间使用环回口建立邻居关系。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/45.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>peer as-number命令用来配置指定对等体（组）的对端AS号。</li>
<li>peer connect-interface命令用来指定发送BGP报文的源接口，并可指定发起连接时使用的源地址。</li>
<li>peer next-hop-local命令用来设置向IBGP对等体（组）通告路由时，把下一跳属性设为自身的IP地址。</li>
<li>group命令可以用来创建对等体组。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>上述命令均为BGP进程视图下的命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address as-number as-number</li>
<li>ip-address：对等体的IPv4地址。</li>
<li>as-number：对等体的对端AS号。</li>
<li>peer ipv4-address connect-interface interface-type interface-number [ ipv4-source-address ]</li>
<li>ip-address：对等体的IPv4地址。</li>
<li>interface-type interface-number：接口类型和接口号。</li>
<li>ipv4-source-address：建立连接时的IPv4源地址。</li>
<li>peer ipv4-address next-hop-local</li>
<li>ip-address：对等体的IPv4地址。</li>
<li>group group-name [ external | internal ]<ul>
<li>group-name:对等体组的名称。</li>
<li>external:创建EBGP对等体组。</li>
<li>internal:创建IBGP对等体组。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在使用Loopback接口作为BGP报文的源接口时，必须注意以下事项：</li>
<li>确认BGP对等体的Loopback接口的地址是可达的。</li>
<li>如果是EBGP连接，还要配置peer ebgp-max-hop命令，允许EBGP通过非直连方式建立邻居关系。</li>
<li>peer next-hop-local和peer next-hop-invariable是两条互斥命令。</li>
<li>Display bgp peer中的Rec表示本端从对等体上收到路由前缀的数目。</li>
<li>IPv6的配置与IPv4配置一致。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/47.png"></p>
<blockquote>
<ul>
<li>案例描述<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
<li>需求2中，要求缺省路由的下发需要关联路由172.16.0.0/16，如果172.16.0.0/16消失，该缺省路由也消失。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/48.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>peer route-policy命令用来对来自对等体（组）的路由或向对等体（组）发布的路由指定Route-Policy，对接收或发布的路由进行控制。</li>
<li>peer default-route-advertise命令用来设置给对等体（组）发布缺省路由。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>peer route-policy命令为BGP视图命令</li>
<li>peer default-route-advertise命令BGP视图命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address route-policy route-policy-name { import | export }<ul>
<li>ipv4-address：对等体的IPv4地址。</li>
<li>route-policy-name：Route-Policy的名称。</li>
<li>import：对从对等体（组）来的路由应用Route-Policy。</li>
<li>export：对向对等体（组）发布的路由应用Route-Policy。</li>
</ul>
</li>
<li>peer { group-name | ipv4-address } default-route-advertise [ route-policy route-policy-name ] [ conditional-route-match-all{ ipv4-address1 { mask1 | mask-length1 } } &amp;&lt;1-4&gt; | conditional-route-match-any { ipv4-address2 { mask2 | mask-length2 } } &amp;&lt;1-4&gt; ]<ul>
<li>ipv4-address：对等体的IPv4地址。</li>
<li>route-policy route-policy-name：指定Route-Policy名称。</li>
<li>conditional-route-match-all ipv4-address1{ mask1 | mask-length1 }：指定条件路由的IPv4地址，以及掩码/掩码长度。匹配所有条件路由则发送缺省路由。</li>
<li>conditional-route-match-any ipv4-address2{ mask2 | mask-length2 }：指定条件路由的IPv4地址，以及掩码/掩码长度。匹配任一条件路由则发送缺省路由。</li>
</ul>
</li>
</ul>
</li>
<li><p>实验现象</p>
<ul>
<li>我们通过命令display ip routing-table命令用来显示路由表中包含的信息。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/50.png"></p>
<blockquote>
<ul>
<li>案例描述<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/51.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li>aggregate命令用来在BGP路由表中创建一条聚合路由。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>命令aggregate为BGP视图命令。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>aggregate ipv4-address { mask | mask-length } [ as-set | attribute-policy route-policy-name1 | detail-suppressed | origin-policy route-policy-name2 | suppress-policyroute-policy-name3 ] *<ul>
<li>ipv4-address：指定聚合路由的IPv4地址。</li>
<li> mask：仅IBGP路由参与负载a分担。</li>
<li>mask-length：指定聚合路由的网络掩码长度。</li>
<li>as-set：指定生成具有AS-SET的路由。</li>
<li>attribute-policy route-policy-name1：指定聚合后路由的属性策略名称。</li>
<li>detail-suppressed：指定仅通告聚合路由。</li>
<li>origin-policy route-policy-name2：指定允许生成聚合路由的策略名称。</li>
<li>suppress-policy route-policy-name3：指定抑制指定路由通告的策略名称。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>手工聚合和自动聚合本地均会产生指向NULL0的路由。</li>
<li>IPv6的配置与IPv4配置一致。</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>命令display ip routing-table protocol bgp可以查看BGP学到的路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/52.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/53.png"></p>
<blockquote>
<ul>
<li><p>路由器Rx和Ry（X&lt;Y）之间的接口网段为10.0.xy.0/24网段，Rx地址=10.0.xy.x  Ry地址=10.0.xy.y 。</p>
</li>
<li><p>所有接口地址均已经配置完成。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/54.png"></p>
<blockquote>
<ul>
<li>使用命令display bgp peer 可以查看是否已经建立BGP邻居关系。</li>
<li>使用命令display bgp routing-table 可以查看是否已经获取到路由信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/55.png"></p>
<blockquote>
<ul>
<li>路由器Rx和Ry（X&lt;Y）之间的接口网段为10.0.xy.0/24网段，Rx地址=10.0.xy.x  Ry地址=10.0.xy.y 。</li>
<li>所有接口地址均已经配置完成。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/56.png"></p>
<blockquote>
<ul>
<li>可以看到，因为AS_Set中包含本自治系统的AS号，所以导致无法接受这条聚合后的路由，可以考虑关闭明细抑制或取消AS_Set。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/57.png"></p>
<blockquote>
<ul>
<li>案例总结：<ul>
<li>配置路由聚合时需要谨慎，聚合配置不当会出现以下问题：<ul>
<li>无法学习到正确的路由；</li>
<li>可能导致环路的产生。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/58.png"></p>
<blockquote>
<ul>
<li>路由器Rx和Ry（X&lt;Y）之间的接口网段为10.0.xy.0/24网段，Rx地址=10.0.xy.x  Ry地址=10.0.xy.y 。</li>
<li>所有接口地址均已经配置完成。</li>
<li>R5是R3的client ， R6是R4的client 。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/59.png"></p>
<blockquote>
<ul>
<li>配置完成之后所有BGP邻居关系建立正常，且OSPF学习到的路由也都完整</li>
<li>R2与R1配置类似，R3与R4配置类似，R5与R6配置类似。</li>
<li>建立完成之后R1通告直连的192.168.1.0/24进入BGP，R7通告直连的192.168.2.0/24进入BGP。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/60.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/61.png"></p>
<blockquote>
<ul>
<li>配置完成之后所有BGP邻居关系建立正常，且OSPF学习到的路由也都完整。</li>
<li>R2与R1配置类似，R3与R4配置类似，R5与R6配置类似。</li>
<li>建立完成之后各路由器通告自己的loopback 0口的地址</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/62.png"></p>
<blockquote>
<ul>
<li>故障分析：<ul>
<li>R7向R5和R6发送192.168.2.0/24前缀。</li>
<li>R5,R6收到，分别向自己的IBGP邻居R3,R4发送。</li>
<li>这里分析R4的情况。R4收到后会有一个路径决策过程，这里R3也会向它发送192.168.2.0/24的前缀，根据BGP路径决策的13个原则，R4最总选择IGP度量值最小的，即选择R6作为下一跳。然后它将这个最佳路径发往R3和R1。</li>
<li>同理，R3最终选择的下一跳是R5。</li>
<li>关键在于R1和R2。因为R1只能收到R4发来的更新，所以，它去往192.168.2.0/24的下一跳也是R4；同理R2去往192.168.2.0/24的下一跳是R5。</li>
<li>经过IGP路由的递归查询，从192.168.1.1到192.168.2.1的数据包会在R1和R2之间来回转发，直到IP报文的TTL被减至0 。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/63.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/64.png"></p>
<blockquote>
<ul>
<li><p>参考答案：</p>
<p>1.A</p>
<p>2.路由聚合分为自动聚合和手工聚合</p>
<ul>
<li>自动聚合：只能聚合通过import命令引入的路由，只能按照自然掩码进行聚合，IPv6不支持自动聚合。</li>
<li>手工聚合：IPv4与IPv6路由均能聚合，可设置明细路由抑制，添加AS_set等功能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/65.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/66.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/67.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/" itemprop="url">IE-BGP双栈原理Basic</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-09T15:29:54+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/1.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/2.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/3.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/4.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/5.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/6.png"></p>
<blockquote>
<ul>
<li><p>BGP是一种用于自治系统（Autonomous System）之间的动态路由协议。早期发布的三个版本分别是BGP-1（RFC1105）、BGP-2（RFC1163）和BGP-3（RFC1267），主要用于交换AS之间的可达路由信息，构建AS域间的传播路径，防止路由环路的产生，并在AS级别应用一些路由策略。当前使用的版本是BGP-4（RFC4271）。</p>
</li>
<li><p>BGP作为事实上的Internet外部路由协议标准，被广泛应用于ISP之间。</p>
</li>
<li><p>BGP概述</p>
<ul>
<li>BGP是一种外部网关协议（EGP），与OSPF、RIP等内部网关协议（IGP）不同，其着眼点不在于自动发现网络拓扑，而在于在AS之间选择最佳路由和控制路由的传播。</li>
<li>BGP使用TCP作为其传输层协议（监听端口号为179），提高了协议的可靠性，且不需要专门的机制来确保连接的可控性。</li>
<li>BGP进行域间的路由选择，对协议的稳定性要求非常高。因此用TCP协议的高可靠性来保证BGP协议的稳定性。<ul>
<li>BGP的对等体之间必须在逻辑上连通，并进行TCP连接。目的端口号为179，本地端口号任意。</li>
<li>路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息。</li>
</ul>
</li>
<li>BGP从设计上避免了环路的发生。</li>
<li>AS之间：BGP通过携带AS路径信息来标记途经的AS，带有本地AS号的路由将被丢弃，从而避免了域间产生环路。</li>
<li>AS内部：BGP在AS内学到的路由不再通告给AS内的BGP邻居，避免了AS内产生环路。<ul>
<li>BGP提供了丰富的路由策略，能够对路由实现灵活的过滤和选择。</li>
<li>BGP提供了防止路由振荡的机制，有效提高了Internet网络的稳定性。</li>
<li>BGP易于扩展，能够适应网络新的发展。主要是通过TLV进行扩展。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/7.png"></p>
<blockquote>
<ul>
<li>BGP的运行是通过消息驱动的，共有Open、Update、Notification、Keepalive和Route-Refresh等5种消息类型。<ul>
<li>Open消息：是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系。对等体在接收到Open消息并协商成功后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-Refresh消息的交换。</li>
<li>Update消息：用于在对等体之间交换路由信息。一条Update消息可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息。<ul>
<li>一条Update消息可以发布多条具有相同路由属性的可达路由，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI（Network Layer Reachability Information）字段里的所有目的地（用IP前缀表示）。</li>
<li>一条Update消息可以撤销多条不可达路由。每一个路由通过目的地（用IP前缀表示），清楚的定义了BGP Speaker之间先前通告过的路由。</li>
<li>一条Update消息可以只用于撤销路由，这样就不需要包括路径属性或者NLRI。相反，也可以只用于通告可达路由，就不需要携带撤销路由信息了。</li>
</ul>
</li>
<li>Keepalive消息：BGP会周期性的向对等体发出Keepalive消息，用来保持连接的有效性。</li>
<li>Notification消息：当BGP检测到错误状态时，就向对等体发出Notification消息，之后BGP连接会立即中断。</li>
<li>Route-Refresh消息：通过OPEN消息告知BGP peer本地支持路由刷新能力（Route-Refresh capability）。在所有BGP路由器使能Route-Refresh能力的情况下，如果BGP的入口路由策略发生了变化，本地BGP路由器会向对等体发布Route-Refresh消息，收到此消息的对等体会将其路由信息重新发给本地BGP路由器。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。</li>
</ul>
</li>
</ul>
<ul>
<li>BGP报文应用：<ul>
<li>BGP使用TCP建立连接，本地监听端口为179。和TCP连接建立相同，BGP连接的建立也要经过一系列的对话和握手。TCP通过握手协商通告其端口等参数，BGP的握手协商的参数有：BGP版本、BGP连接保持时间、本地的路由器标识（Router ID）、授权信息等。这些信息都在Open消息中携带。</li>
<li>BGP连接建立后，如果有路由需要发送则发送Update消息通告对端。Update消息发布路由时，还要携带此路由的路由属性，用以帮助对端BGP协议选择最优路由。在本地BGP路由变化时，要通过Update消息来通知BGP对等体。</li>
<li>经过一段时间的路由信息交换后，本地BGP和对端BGP都无新路由通告，趋于稳定状态。此时要定时发送KEEPALIVE消息以保持BGP连接的有效性。对于本地BGP，如果在保持时间内，未收到任何对端发来的BGP消息，就认为此BGP连接已经中断，将断开此BGP连接，并删除所有从该对等体学来的BGP路由。</li>
<li>当本地BGP在运行中发现错误时（如对端BGP版本本地不支持、本地BGP收到了结构非法的Update消息等），要发送Notification消息通告BGP对等体。本地BGP退出BGP连接时，也需发送Notification报文。</li>
</ul>
</li>
</ul>
<ul>
<li>BGP报头<ul>
<li>Marker（标记）：16字节，固定为1。</li>
<li>Length（长度）：两字节无符号整数。指定了消息的全长，包括头部。</li>
<li>Type（类型）：1 字节，指示报文类型：<ul>
<li>Open</li>
<li>Update</li>
<li>Keepalive</li>
<li>Notification</li>
<li>Route-Refresh</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Open报文结构<ul>
<li>Version：BGP的版本号。对于BGPv4来说，其值为4。</li>
<li>My Autonomous System：本地AS编号。通过比较两端的AS编号可以确定是EBGP连接还是IBGP连接。</li>
<li>Hold Time：在建立对等体关系时两端要协商Hold time，并保持一致。如果两端所配置的Hold time时间不同，则BGP会选择较小的值作为协商的结果。如果在这个时间内未收到对端发来的Keepalive消息，则认为BGP连接中断。如果保持时间为0，则标识不发送Keepalive报文。</li>
<li>BGP Identifier：BGP路由器的Router ID，以IP地址的形式表示，用来识别BGP路由器。</li>
<li>Opt Parm Len（Optional Parameters Length）：可选参数的长度。如果为0则没有可选参数。</li>
<li>Optional Parameters：是一个可选参数用于BGP验证或多协议扩展（Multiprotocol Extensions）等功能。每一个参数为一个（Parameter Type-Parameter Length-Parameter Value）三元组。</li>
</ul>
</li>
</ul>
<ul>
<li>Update报文结构<ul>
<li>Withdrawn Routes Length ：（2字节无符号整数） 不可达路由长度，表示Withdrawn Routes字段的数据长度。如果Withdrawn Routes Length字段数值为0，则表示Withdrawn Routes字段没有任何数据，在UPDATE消息中不会被显示。</li>
<li>Withdrawn Routes ：（变长） 撤销路由。该字段包括一系列的IP地址前缀信息，以&lt;length, prefix&gt;的格式来表示，比如&lt;19,198.18.160.0&gt;表示一个198.18.160.0 255.255.224.0的网络。 </li>
<li>Path Attribute Length ：（2字节无符号整数） 路由属性长度，表示Path Attribute字段的数据长度。如果Path Attribute Length数值为0，则表示Path Attribute字段没有任何数据，在UPDATE消息中不会被显示。</li>
<li>Network Layer Reachability Information ：（变长） 网络可达信息。包括一系列的IP地址前缀。格式与撤消路由字段一样&lt;length, prefix&gt;。</li>
</ul>
</li>
</ul>
<ul>
<li>Keepalive报文结构<ul>
<li>KeepAlive 报文的组成只包括一个BGP数据报头。</li>
<li>缺省情况下，发送KeepAlive 的时间间隔为 60 秒，Hold Time是180秒。每次从邻居处接收到KeepAlive 报文将重置Hold Time定时器，如果Hold Time定时器超时，就认为对等体Down掉。</li>
</ul>
</li>
</ul>
<ul>
<li>Notification报文结构<ul>
<li>Errorcode：错误码。1字节长的字段。每个不同的错误都使用唯一的代码表示，而每一个错误码都可以拥有一个或多个错误子码，但如果某些错误码并不存在错误子码的话，则该错误子码字段以全0表示。</li>
<li>Errsubcode：错误子码。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/8.png"></p>
<blockquote>
<ul>
<li>BGP有限状态机共有六种状态，分别是Idle、Connect、Active、OpenSent、OpenConfirm和Established。<ul>
<li>Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态。<ul>
<li>Start事件是由一个操作者配置一个BGP过程，或者重置一个已经存在的过程或者路由器软件重置BGP过程引起的。</li>
<li>任何状态中收到Notification报文或TCP拆除链路通知等Error事件后，BGP都会转至Idle状态。</li>
</ul>
</li>
<li>在Connect状态下，BGP启动连接重传定时器（Connect Retry，缺省为32秒），等待TCP完成连接。<ul>
<li>此阶段主动发起TCP连接；</li>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态；</li>
<li>如果TCP连接失败，那么BGP转至Active状态；</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态。</li>
<li>如果发生其他事件（由系统或者操作人员启动的），则退回到Idle状态。</li>
</ul>
</li>
<li>在Active状态下，BGP总是在试图建立TCP连接。<ul>
<li>此阶段等待对方发起TCP连接；</li>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态；</li>
<li>如果TCP连接失败，那么BGP停留在Active状态；</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。</li>
</ul>
</li>
<li>在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。<ul>
<li>如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态；</li>
<li>如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。</li>
</ul>
</li>
<li>在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。</li>
<li>在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。<ul>
<li>如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。</li>
<li>如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。</li>
<li>Route-refresh报文不会改变BGP状态。</li>
<li>如果收到Notification报文，那么BGP转至Idle状态。</li>
<li>如果收到TCP连接断开消息，那么BGP断开连接，转至Idle状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/9.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/10.png"></p>
<blockquote>
<ul>
<li>BGP路由信息处理：<ul>
<li>当从对等体接收到更新数据包时，路由器会把这些更新数据包存储到路由选择信息库(Routing Information Base, RIB)中，并指明是来自哪个对等体的(Adj-RIB-In)。这些更新数据包被输入策略引擎过滤后，路由器将会执行路径选择算法，来为每一条前缀确定最佳路径。</li>
<li>得出的最佳路径被存储到本地BGP RIB (Loc-RIB)中，然后被提交给本地IP路由选择表(IP-RIB)，以用作安装考虑。</li>
<li>除了从对等体接收来的最佳路径外，Loc-RIB也会包含当前路由器注入的(被称为本地发起的路由)，并被选择为最佳路径的BGP前缀。Loc-RIB中的内容在被通告给其他对等体之前，必须通过输出策略引擎。只有那些成功通过输出策略引擎的路由，才会被安装到输出RIB (Adj-RIB-Out)中。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/11.png"></p>
<blockquote>
<ul>
<li>BGP设备将最优路由加入BGP路由表，形成BGP路由。<ul>
<li>从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体</li>
<li>从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP和IBGP对等体</li>
<li>当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体</li>
<li>路由更新时，BGP设备只发送更新的BGP路由</li>
<li>从IBGP邻居学到的路由，只有当IGP中也存在相同的路由时才会宣告给EBGP对等体</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/12.png"></p>
<blockquote>
<ul>
<li>同步是指IBGP和IGP之间的同步，其目的是避免误导外部AS的路由器。</li>
</ul>
<ul>
<li><p>拓扑说明（在同步开启情况下）</p>
<ul>
<li>R4通过BGP学习到R1宣告的10.0.0.0/24网络。R4在将该网络通告给R5之前，会首先检查自己的IGP路由表是否已经存在10.0.0.0/24网络。如果R4本地IGP路由表项存在10.0.0.0/24网络，则将该网络通告给R5；如果R4本地IGP路由表项不存在10.0.0.0/24网络，则不能将该网络通告给R5。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>VRP平台缺省情况下BGP与IGP是取消同步机制的，并不可改变。但取消同步是有条件的，在以下两种情况下可以取消同步：</li>
<li>本AS不是过渡AS。</li>
<li>本AS内所有路由器建立IBGP全连接。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/13.png"></p>
<blockquote>
<ul>
<li><p>BGP路由属性是一套参数，它对特定的路由进一步的描述，使得BGP能够对路由进行过滤和选择。</p>
</li>
<li><p>常用的属性类别如下所示：</p>
<ul>
<li>Origin为公认必遵属性</li>
<li>AS_Path为公认必遵属性</li>
<li>Next_Hop为公认必遵属性</li>
<li>Local_Pref为公认任意属性</li>
<li>community为可选过渡属性</li>
<li>MED为可选非过渡属性</li>
<li>Originator_ID为可选非过渡属性</li>
<li>Cluster_List为可选非过渡属性</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/14.png"></p>
<blockquote>
<ul>
<li>Origin属性用来定义路径信息的来源，标记一条路由是怎么成为BGP路由的。它有以下3种类型：<ul>
<li>IGP：具有最高的优先级。通过路由始发AS的IGP得到的路由信息，比如通过network命令注入到BGP路由表的路由，其Origin属性为IGP。</li>
<li>EGP：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP。</li>
<li>Incomplete：优先级最低。通过其他方式学习到的路由信息。比如BGP通过import-route命令引入的路由，其Origin属性为Incomplete。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/15.png"></p>
<blockquote>
<ul>
<li>在BGP进行选路时会优先比较协议首选值。默认情况下均为0，该值越大越优先。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/16.png"></p>
<blockquote>
<ul>
<li><p>AS_Path属性可以当做BGP选路的参考属性之一，AS_Path长度越短越优先。此外，当BGP路由器从EBGP对等体接收路由时，如果发现AS_Path列表中有本AS号，则不接收该路由，从而避免了AS间的路由环路。</p>
<ul>
<li>当BGP Speaker本地通告一条路由时：<ul>
<li>当BGP Speaker将这条路由通告到其他AS时，便会将本地AS号添加在AS_Path列表中，并通过Update消息通告给邻居路由器。</li>
<li>当BGP Speaker将这条路由通告到本地AS时，便会在Update消息中创建一个空的AS_Path列表。</li>
</ul>
</li>
<li>当BGP Speaker传播从其他BGP Speaker的Update消息中学习到的路由时：<ul>
<li>当BGP Speaker将这条路由通告到其他AS时，便会把本地AS编号添加在AS_Path列表的最前面（最左面）。收到此路由的BGP路由器根据AS_Path属性就可以知道去目的地址所要经过的AS。离本地AS最近的相邻AS号排在前面，其他AS号按顺序依次排列。</li>
<li>当BGP Speaker将这条路由通告到本地AS时，不会改变这条路由相关的AS_Path属性。</li>
</ul>
</li>
</ul>
</li>
<li><p>拓扑描述：</p>
<ul>
<li>当R4将网段10.0.0.0/24通告给AS400和AS100时，会在AS_PATH中添加自己的AS号。当R5将网段10.0.0.0/24通告给AS100时，也会添加添加自己的AS号。当AS100内的R1、R3和R2之间将网段10.0.0.0/24相互通告时，AS_PATH属性不会改变，在其他BGP选路条件相同的前提下，BGP会选择AS_PATH路径最短的，即选择通过R3直达R4的路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/17.png"></p>
<blockquote>
<ul>
<li>Next_Hop属性记录了路由的下一跳信息。BGP的下一跳属性和IGP的有所不同，不一定就是邻居设备的IP地址。通常情况下，Next_Hop属性遵循下面的规则：<ul>
<li>BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/18.png"></p>
<blockquote>
<ul>
<li>Local_Pref属性<ul>
<li>该属性仅在IBGP对等体之间有效，不通告给其他AS。它表明路由器的BGP优先级。</li>
<li>当BGP路由器通过不同的IBGP对等体得到目的地址相同但下一跳不同的多条路由时，将优先选择Local_Pref属性值较高的路由，缺省情况下该值为100。</li>
</ul>
</li>
</ul>
<ul>
<li>拓扑描述<ul>
<li>AS100内，R1，R2和R3之间分别两两建立IBGP对等体关系，而R2和R3分别和位于AS200和AS300的路由器建立EBGP对等体关系。这样路由器R2和R3都会从自己的EBGP对等体收到10.0.0.0/24这条路由，为了让AS100内的三台路由器优选R2作为10.0.0.0/24这条路由在本AS的出口，我们只需要在R2和R3上适当的对该路由的Local Pref属性进行修改，就可以达到目的。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/19.png"></p>
<blockquote>
<ul>
<li>当一个运行BGP的设备通过不同的EBGP对等体（EBGP对等体需属于同一AS）得到目的地址相同但下一跳不同的多条路由时，在其它条件相同的情况下，将优先选择MED 值较小者作为最佳路由。</li>
<li>MED属性仅在相邻两个AS之间传递，收到此属性的AS一方不会再将其通告给任何其他第三方AS。MED属性可以手动配置，如果路由没有配置MED属性，BGP选路时将该路由的MED值按缺省值0来处理。</li>
<li>拓扑描述<ul>
<li>R1和R2将网段10.0.0.0/24传递给各自的EBGP邻居R3和R4，R3和R4在其他条件相同的情况下，优先选择MED值较低的路径，即均选择经由R1访问网络10.0.0.0/24。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/20.png"></p>
<blockquote>
<ul>
<li><p>BGP路径选择</p>
</li>
<li><p>下一跳地址必须可达。</p>
</li>
<li><p>协议首选值（PrefVal）是华为设备的特有属性，该属性仅在本地有效。</p>
</li>
<li><p>如果路由没有本地优先级，BGP选路时将该路由按缺省的本地优先级100来处理。通过执行default local-preference命令可以修改BGP路由的缺省本地优先级。</p>
</li>
<li><p>本地生成的路由包括通过network命令或import-route命令引入的路由、手动聚合路由和自动聚合路由。</p>
<ul>
<li>优选聚合路由（聚合路由优先级高于非聚合路由）。</li>
<li>通过aggregate命令生成的手动聚合路由的优先级高于通过summary automatic命令生成的自动聚合路由。</li>
<li>通过network命令引入的路由的优先级高于通过import-route命令引入的路由。</li>
</ul>
</li>
<li><p>优选AS路径（AS_Path）最短的路由。</p>
<ul>
<li>AS_Path的长度不包括AS_CONFED_SEQUENCE和AS_CONFED_SET。</li>
<li>AS_SET的长度为1，无论AS_SET中包括多少AS号。</li>
<li>执行bestroute as-path-ignore命令后，BGP选路时，忽略AS_Path的比较。</li>
</ul>
</li>
<li><p>优选MED值最低的路由。</p>
<ul>
<li>BGP只比较来自同一个AS（不包括联盟的子AS）的路由的MED值。即，只有两条路由的AS_SEQUENCE（不包括AS_CONFED_SEQUENCE）属性的第一个AS号相同时，BGP才会比较二者的MED值。</li>
<li>如果路由没有MED属性，BGP选路时将该路由的MED值按缺省值0来处理；执行bestroute med-none-as-maximum命令后，BGP选路时将该路由的MED值按最大值4294967295来处理。</li>
<li>执行compare-different-as-med命令后，BGP将强制比较来自不同自治系统中的邻居的路由的MED值。除非能够确认不同的自治系统采用了同样的IGP和路由选择方式，否则不要使用compare-different-as-med命令（可能产生环路）。</li>
<li>执行bestroute med-confederation命令后，只有当AS_Path中不包含外部AS号（不属于联盟的子AS），且AS_CONFED_SEQUENCE的第一个AS号相同时，才能比较MED值的大小。</li>
<li>执行deterministic-med命令后，将消除路由接收顺序对选路结果的影响。</li>
</ul>
</li>
<li><p>负载分担</p>
<ul>
<li>当到达同一目的地址存在多条等价路由时，可以通过BGP等价负载分担实现均衡流量的目的。</li>
<li>形成BGP等价负载分担的条件是：BGP选路规则中“到下一跳的IGP metric”这条规则之前所有需要比较的属性完全相同。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/21.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/22.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/23.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/24.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/25.png"></p>
<blockquote>
<ul>
<li><p>除了多地址族的能力协商外，还有</p>
<ul>
<li>4字节AS号能力</li>
<li>Route-Refresh支持能力</li>
<li>多层标签能力</li>
</ul>
<p>等能力都会在该字段列出来进行协商。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/26.png"></p>
<blockquote>
<ul>
<li>地址族信息（Address Family Information）域：由2字节的地址族标识AFI（Address Family Identifier）和1字节的子地址族标识SAFI（Subsequent Address Family Identifier）组成。</li>
<li>下一跳长度（Length of Next Hop Network Address）域：1字节长度，表示下一跳地址的长度，通常情况下为16</li>
<li>下一跳地址（Network Address of Next Hop）域：长度由上一个字段决定，一般情况下为全球单播地址。</li>
<li>保留字段（Reserved）域：一字节，必须为0 </li>
<li>网络层可达信息（Network Layer Reachability Information）域：表示含有匹配相同属性的路由信息。当此字段为0时，表示为缺省路由。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/27.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/28.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/29.png"></p>
<blockquote>
<ul>
<li><p>地址族信息（Address Family Information）域：由2字节的地址族标识AFI（Address Family Identifier）和1字节的子地址族标识SAFI（Subsequent Address Family Identifier）组成。</p>
</li>
<li><p>撤销路由（Withdrawn Routes）域：表示撤销的路由条目。格式为&lt;掩码长度，路由前缀&gt; ，当此掩码长度为0时，表示为缺省路由。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/30.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/31.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/32.png"></p>
<blockquote>
<ul>
<li><p>地址分配规则：</p>
<ul>
<li>Rx和Ry（X&lt;Y）直连接口的IPv4网段为：10.0.xy.0/24. Rx相应接口的地址为10.0.xy.x ，Ry为10.0.xy.y </li>
<li>Rx和Ry（X&lt;Y）直连接口的IPv6网段为：2000::xy00/120. Rx相应接口的地址为2000::xy0x ，Ry为2000::xy0y </li>
<li>各路由器的LoopBack 0 接口的地址已给出,各LoopBack 0接口的IPv6地址为2000::z(z为相应路由器的编号)</li>
</ul>
</li>
<li><p>提示：</p>
<ul>
<li>AS内可运行OSPF，ISIS等协议来实现互通</li>
<li>稳定的IBGP关系可通过loopback接口来建立</li>
<li>EBGP邻居关系直接用物理接口建立即可</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/33.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>peer as-number命令用来配置指定对等体（组）的对端AS号。</li>
<li>peer connect-interface命令用来指定发送BGP报文的源接口，并可指定发起连接时使用的源地址。</li>
<li>peer next-hop-local命令用来设置向IBGP对等体（组）通告路由时，把下一跳属性设为自身的IP地址。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>上述命令均为BGP进程视图下的命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address as-number as-number<ul>
<li>ip-address：对等体的IPv4地址。</li>
<li>as-number：对等体的对端AS号。</li>
</ul>
</li>
<li>peer ipv4-address connect-interface interface-type interface-number [ ipv4-source-address ]<ul>
<li>ip-address：对等体的IPv4地址。</li>
<li>interface-type interface-number：接口类型和接口号。</li>
<li>ipv4-source-address：建立连接时的IPv4源地址。</li>
</ul>
</li>
<li>peer ipv4-address next-hop-local<ul>
<li>ip-address：对等体的IPv4地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在使用Loopback接口作为BGP报文的源接口时，必须注意以下事项：<ul>
<li>确认BGP对等体的Loopback接口的地址是可达的。</li>
<li>如果是EBGP连接，还要配置peer ebgp-max-hop命令，允许EBGP通过非直连方式建立邻居关系。</li>
</ul>
</li>
</ul>
</li>
<li><p>peer next-hop-local和peer next-hop-invariable是两条互斥命令。</p>
</li>
<li><p>Display bgp peer中的PrefRcv表示本端从对等体上收到路由前缀的数目。</p>
</li>
<li><p>IPv6的配置与IPv4基本一致，但是在指定完peer地址和as-number之后，需手工进入ipv6-family unicast视图，执行peer peer-ip-address enable 命令来激活。</p>
</li>
<li><p>本页图中的互连接口IPv6地址，掩码位是120。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/34.png"></p>
<blockquote>
<ul>
<li>此拓扑与“基础配置”一致，已建立了BGP邻居关系</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/35.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li><strong>peer route-policy</strong>命令用来对来自对等体（组）的路由或向对等体（组）发布的路由指定Route-Policy，对接收或发布的路由进行控制。</li>
<li><strong>apply preferred-value</strong> preferred-value 命令用来在路由策略中配置改变BGP路由的首选值的动作。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>peer route-policy命令为BGP视图命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address route-policy route-policy-name { import | export }<ul>
<li>ipv4-address：对等体的IPv4地址。</li>
<li>route-policy-name：Route-Policy的名称。</li>
<li>import：对从对等体（组）来的路由应用Route-Policy。</li>
<li>export：对向对等体（组）发布的路由应用Route-Policy。</li>
<li>preferred-value：指定BGP的首选值。在选择路由时，协议优选首选值最高的BGP路由。整数形式，取值范围0～65535，默认为0</li>
</ul>
</li>
</ul>
</li>
<li><p>实验现象</p>
<ul>
<li>我们使用display bgp routing-table和display bgp ipv6 routing-table命令查看BGP路由表。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>Preferred-value是BGP协议的私有属性，该命令只对BGP路由生效。Preferred-value是BGP选路规则中的weight值，不是RFC规定的标准属性，所以该命令仅在本地生效，在BGP的出口策略中不生效。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/36.png"></p>
<blockquote>
<ul>
<li>沿用BGP“基础配置”拓扑，仅建立了BGP邻居关系。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/37.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li><strong>apply local-preference</strong> preference  配置路由的本地优先级</li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>Preference 指定的BGP路由的本地优先级，整数形式，取值范围是0～4294967295，默认情况下为100</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>策略生效后，将影响BGP路由选路。</li>
<li>本地优先级仅用于同一个AS域内的选路，不向域外发布这个属性，所以用于配置EBGP邻居的export方向的策略时，apply local-preference命令的设置不生效。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/38.png"></p>
<blockquote>
<ul>
<li>保留上一步local-preference的配置，其他不变。</li>
<li>需要解决上一步出现的来回路径不一致的问题，可通过R2宣告更高MED属性的路由，使得R5选择R3宣告的路由。 </li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/39.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li><strong>apply</strong> <strong>cost</strong> [ <strong>+</strong> | <strong>-</strong> ]  cost命 令用来在路由策略中配置改变路由的开销值的动作。</li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>+：表示增加开销值。</li>
<li>-： 表示减少开销值。</li>
<li>cost ：指定路由的开销值。对路由的选路进行控制，需要将路由的开销设置为固定值时，可以通过调整开销值避免路由环路的产生。</li>
</ul>
</li>
<li><p>注意事项：</p>
</li>
<li><p>在缺省情况下，BGP只比较来自同一AS的路由的MED值。这里的AS不包括联盟的子AS。为了使BGP在联盟内选择最优路由时能够比较MED值，可以配置bestroute med-confederation命令。</p>
</li>
<li><p>配置bestroute med-confederation命令后，只有当AS_Path中不包含外部自治系统（不在联盟内的自治系统）号时才比较MED值的大小。如果AS_Path中包含外部自治系统号，则不进行比较。</p>
<ul>
<li>例如：自治系统65000、65001、65002和65004属于同一联盟。四条到达同一目的地址的待选路由如下所示：<ul>
<li>path1：AS_Path=65000 65004，med=2</li>
<li>path2：AS_Path=65001 65004，med=3</li>
<li>path3：AS_Path=65002 65004，med=4</li>
<li>path4：AS_Path=65003 65004，med=1</li>
</ul>
</li>
</ul>
</li>
<li><p>在配置bestroute med-confederation命令后，因为path1、path2和path3的AS_Path中不包含同一联盟外的自治系统，所以当BGP需要通过比较MED值来选择路由时，将只比较path1、path2和path3的MED值。而path4的AS_Path中包含同一联盟外的自治系统，因此不比较path4的MED值。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/40.png"></p>
<blockquote>
<ul>
<li>拓扑与配置采用“基础配置”的内容。仅有基本的BGP邻居配置</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/41.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li><strong>apply as-path</strong> { { as-number-plain | as-number-dot } &amp;&lt;1-10&gt; { additive } | none overwrite }</li>
</ul>
</li>
<li><p>参数含义</p>
<ul>
<li><em>as*</em>-number-plain*<em>：</em>指定要替换或增加的整数形式的AS号。在同一个命令行中最多可以同时指定10个AS号。</li>
<li><em>as*</em>-number-dot* <em>：指</em>定要替换或增加的点分形式的AS号。在同一个命令行中最多可以同时指定10个AS号。</li>
<li><strong>additive</strong> <strong>：</strong>在原有的AS_Path列表中追加指定的AS号。</li>
<li><strong>overwrite</strong> <strong>：</strong>用指定的AS号覆盖原有的AS_Path列表。</li>
<li><strong>None</strong> <strong>：</strong>清空原来的AS_Path列表。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>策略生效后，将会影响BGP路由选路。</li>
<li>配置该命令会直接影响网络流量所经过的途径，另外也可能造成环路和选路错误，<strong>请谨慎使用该命令</strong>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/42.png"></p>
<blockquote>
<ul>
<li>拓扑与配置采用“基础配置”的内容。仅有基本的BGP邻居配置</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/43.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li><strong>if-match as-path-filter</strong> { as-path-filter-number &amp;&lt;1-16&gt; | as-path-filter-name } </li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>as-path-filter-number ：指定AS路径过滤器号。在一个命令行中可以配置多个此参数，但最大不能超过16。 整数形式，取值范围1～256。</li>
<li><em>as-path-filter*</em>-name*指定AS路径过滤器名称。字符串形式，区分大小写，不支持空格，长度范围是1～51，且不能都是数字。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>在一个命令行中可以配置多个AS-Path-filter值，但最多不能超过16个。它们之间是“或”的关系，即通过其中某一个AS路径过滤器的过滤就可以通过该命令的过滤。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/44.png"></p>
<blockquote>
<ul>
<li><p><strong>命令含义：</strong></p>
<ul>
<li><em>ip*</em> <strong>as-path-filter</strong> { <em>as-path-filter-number</em> | <em>as-path-filter-name</em> } { <strong>deny</strong> | <strong>permit</strong> } <em>regular-expression</em>命令用来创建AS路径过滤器。</li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>as-path-filter-number 指定的AS路径过滤器号。 整数形式，取值范围1～256。</li>
<li>as-path-filter-name 指定的AS路径过滤器名称。 字符串形式，区分大小写，不支持空格，长度范围是1～51，且不能都是数字。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
<li>deny 指定AS路径过滤器的匹配模式为拒绝。</li>
<li>permit 指定AS路径过滤器的匹配模式为允许。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/45.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/46.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/47.png"></p>
<blockquote>
<ul>
<li>拓扑与配置采用“基础配置”的内容。仅有基本的BGP邻居配置</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/48.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li><strong>maximum</strong> <strong>load-balancing</strong>命令用来设置等价路由的最大条数。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>命令maximum load-balancing为BGP视图命令。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>ebgp：仅EBGP路由参与负载分担。</li>
<li>ibgp：仅IBGP路由参与负载分担。</li>
<li>number：BGP路由表中最大等价路由条数。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>如果配置了maximum load-balancing number命令，那么再配置maximum load-balancing ebgp number或maximum load-balancing ibgpnumber命令都不会生效；如果配置了maximum load-balancing ebgp number或maximum load-balancing ibgp number命令，那么再配置maximum load-balancing number命令也不会生效。</li>
<li>AS_Path不仅需要长度相等，内容也必须一致才能形成负载分担。可在BGP进程视图下使用load-balancing as-path-ignore设置路由在形成负载分担时不比较路由的AS-Path属性。</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>使用命令display ip routing-table protocol bgp可以查看到通过BGP学到的等价路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/49.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/50.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/51.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/52.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/53.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/54.png"></p>
<blockquote>
<ul>
<li>参考答案：<ul>
<li>T，正确</li>
<li>F，AS_Path需要完全一样才能形成负载分担。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/55.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/" itemprop="url">IE-ISIS双栈原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-06T11:00:29+08:00">
                2021-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>IGP的收敛可以总体描述为如下状态D+O+F+SPT+RIB+DD</p>
<ul>
<li>D状态为从链路出现故障以后到路由器发现链路故障所用的时间。</li>
<li>O状态为生成LSP，用来描述新的网络拓扑结构所需要的时间。</li>
<li>F状态为从发现链路故障一直到向邻居发布FIB更新的时间。</li>
<li>SPT状态为运行SPF算法，计算最短路径树的时间。</li>
<li>RIB状态为用主CPU更新RIB表项和FIB表项的时间</li>
<li>DD状态为从主控板向线卡上发布更新路由信息的延迟</li>
</ul>
</li>
<li><p>RIB状态和DD状态一般与路由器的硬件有关，如主CPU、线卡CPU、内存、网络处理器有关，这两个状态人为无法对收敛时间做出很大的改变。所以本文基本上以讨论前四个状态为主。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>现有的故障检测方法主要包括：<ul>
<li>硬件检测：例如通过SDH（Synchronous Digital Hierarchy，同步数字体系）告警检测链路故障。硬件检测的优点是可以很快发现故障，但并不是所有介质都能提供硬件检测。</li>
<li>慢Hello机制：通常是指路由协议的Hello机制。这种机制检测到故障所需时间为秒级。对于高速数据传输，例如吉比特速率级，超过1秒的检测时间将导致大量数据丢失；对于时延敏感的业务，例如语音业务，超过1秒的延迟也是不能接受的。并且，这种机制依赖于路由协议。IS-IS协议一般通过IIH报文，用来做邻居发现和失效性检测，这个检测的速度是秒级的。</li>
<li>其他检测机制：不同的协议或设备制造商有时会提供专用的检测机制，但在系统间互联互通时，这样的专用检测机制通常难以部署，如BFD</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/7.png"></p>
<blockquote>
<ul>
<li>在IS-IS协议中，当LSP生成定时器到期时，系统会根据当前拓扑重新生成一个自己的LSP。原有的实现机制是采用间隔时间定长的定时器，不能同时满足快速收敛和低CPU占用率的需要。</li>
<li>为了加快网络的收敛速度，同时又不影响系统性能，因此在产生LSP时使用了智能定时器，它可以根据路由信息的变化频率自动调整延迟时间。使其可以对于突发事件（如接口Up/Down）快速响应，加快网络的收敛速度。同时，当网络变化频繁时，智能定时器的间隔时间会自动延长，避免过度占用CPU资源。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li><p>用户可以指定每次扩散的LSP数量，这个数量是针对所有接口的。如果需要发送的LSP的数量大于这个数，则就发送<em>lsp*</em>-count*个LSP。如果配置了定时器，在路由计算之前如果这个定时器未超时，则立即扩散；否则在该定时器超时时发送。</p>
</li>
<li><p>如果命令中没有指定级别，则缺省同时在Level-1和Level-2中使能此功能。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li>通常情况下，一个正常运行的IS-IS网络是稳定的，发生大量的网络变动的几率很小，IS-IS路由器不会频繁的进行路由计算，所以第一次触发的时间可以设置的非常短（毫秒级）。如果拓扑变化比较频繁，智能定时器会随着计算次数的增加，间隔时间也会逐渐延长，避免占用大量的CPU资源。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/10.png"></p>
<blockquote>
<ul>
<li><p>在ISO-10589中定义使用Dijkstra算法进行路由计算。当网络拓扑中有一个节点发生变化时，这种算法需要重新计算网络中的所有节点，计算时间长，占用过多的CPU资源，影响整个网络的收敛速度。</p>
</li>
<li><p>I-SPF改进了这个算法，除了第一次计算时需要计算全部节点外，每次只计算影响的节点，而最后生成的最短路径树SPT与原来的算法所计算的结果相同，大大降低了CPU的占用率，提高了网络收敛速度。</p>
</li>
<li><p>在路由计算中，路由代表叶子，路由器则代表节点。如果I-SPF计算后的SPT改变，PRC会只处理那个变化的节点上的所有叶子；如果经过I-SPF计算后的SPT并没有变化，则PRC只处理变化的叶子信息。</p>
</li>
<li><p>比如一个IS接口，则整个网络拓扑的SPT是不变的，这时PRC只更新这个节点的接口路由，从而节省CPU占用率。</p>
</li>
<li><p>PRC和I-SPF节点使能一个IS-配合使用可以将网络的收敛性能进一步提高，它是原始SPF算法的改进，所以已经代替了原有的算法。</p>
</li>
<li><p>默认情况下华为路由器采用I-SPF和PRC进行计算，不需要命令配置。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/11.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/12.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/13.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/14.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/15.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/16.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/17.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li><p>当IS-IS要发布的链路状态协议数据报文PDU（Protocol Data Unit）中的信息量太大时，IS-IS路由器将会生成多个LSP分片，用来携带更多的IS-IS信息。</p>
</li>
<li><p>IS-IS LSP分片由LSP ID中的LSP Number字段进行标识，这个字段的长度是1字节。因此，一个IS-IS进程最多可产生256个LSP分片，携带的信息量有限。在RFC3786中规定，IS-IS可以配置虚拟的System ID ，并生成虚拟IS-IS的LSP报文来携带路由等信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li>Mode-1应用场景：用于网络中的部分路由器不支持LSP分片扩展特性的情况。</li>
<li>Mode-1工作原理：虚拟系统参与路由SPF计算，初始系统发布的LSP中携带了到每个虚拟系统的链路信息。类似地，虚拟系统发布的LSP也包含到初始系统的链路信息。这样，在网络中虚拟系统看起来与初始系统相连的真实路由器是一样的。这种方式是为了兼容不支持分片扩展的老版本所做的一个过渡模式。在老版本中，IS-IS无法识别IS Alias ID TLV，所以虚拟系统的LSP必须表现的像一个普通IS-IS发出的报文。</li>
<li>Mode-2应用场景：用于网络中所有路由器都支持LSP分片扩展特性的情况。</li>
<li>Mode-2工作原理：虚拟系统不参与路由SPF计算，网络中所有路由器都知道虚拟系统生成的LSP实际属于初始系统。在该模式下工作的IS-IS，可以识别IS Alias ID TLV的内容，并作为计算树和路由的依据。</li>
<li>说明：无论在哪种方式下，初始系统和虚拟系统的LSP零分片中，都必须包含IS Alias ID TLV来表示初始系统是谁。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/21.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/25.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/27.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/28.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/29.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/30.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/31.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/33.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li>引入：<ul>
<li>Level-1 区域内的路由信息通过Level-1-2 路由器通报给Level-2 区域，因此，Level-1-2和Level-2 路由器知道整个IS-IS 路由域的路由信息。但是，在缺省情况下，Level-2 路由器并不将自己知道的其他Level-1 区域以及骨干区域的路由信息通报给Level-1 区域。这样，Level-1 路由器将不了解本区域以外的路由信息，可能导致对本区域之外的目的地址无法选择最佳的路由。</li>
<li>为解决上述问题，IS-IS 提供了路由渗透功能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/35.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>注意Level 1路由器在收到两条相同的路由的时候，会优选本区域的路由，不会优选L2区域过来的路由，尽管L2的路由cost较小。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/37.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/38.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/39.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/40.png"></p>
<blockquote>
<ul>
<li><p>IETF的draft-ietf-isis-ipv6-05.txt中规定了IS-IS为支持IPv6所新增的内容。主要是新添加的支持IPv6路由信息的两个TLVs（Type-Length-Values）和一个新的NLPID（Network Layer Protocol Identifier）。</p>
</li>
<li><p>新增的两个TLV分别是：</p>
<ul>
<li>IPv6 Reachability：类型值为236（0xEC），通过前缀、度量、标记等来描述可达的IPv6前缀信息。在IPv4中有IPv4内部可达性TLV和IPv4外部可达性TLV，在IPv6的扩展当中使用一个“X”bit来区分“内部”和“外部”。</li>
<li>IPv6 Interface Address：类型值为232（0xE8），它相当于IPv4中的“IP Interface Address” TLV，只不过把原来的32比特的IPv4地址改为128比特的IPv6地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li>这个数据结构可能会重复多次（当有多个路由前缀的时候）。</li>
<li>Metric字段已经被重新定义了，MAX_PATH_METRIC (1023) 变成了 MAX_V6_PATH_METRIC (0xFE000000). 如果一个前缀的METRIC大于MAX_V6_PATH_METRIC ，那么它不是用来构建路由表的，而是用于一些特殊的目的。</li>
<li>TLV128：IP内部可达性信息；TLV130：IP外部可达性信息；在TLV236中，“外部”和“内部”用“X”比特表示。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/42.png"></p>
<blockquote>
<ul>
<li>注意：在hello PDU中，“接口地址TLV”只包含发送hello包的接口的Link-local地址；对于LSP，“接口地址TLV”只包含IS的non-link-local IPV6地址。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/43.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/44.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/45.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/46.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/47.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/48.png"></p>
<blockquote>
<ul>
<li><p>新增四个TLV</p>
<ul>
<li>TLV 229 – Multi-Topology Identifier</li>
<li>TLV 222 – Multi-Topologies Intermediate System</li>
<li>TLV 235 – Multi-Topologies Reachable IPv4 Prefixes</li>
<li>TLV 237 – Multi-Topologies Reachable IPv6 Prefixes</li>
</ul>
</li>
<li><p>Reserved MT ID Values</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/49.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/50.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/51.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/52.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/53.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/54.png"></p>
<blockquote>
<ul>
<li>ISIS快速收敛特性建议全部部署</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/55.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/56.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/57.png">****</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/" itemprop="url">IE-OSPF双栈原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-04T14:54:19+08:00">
                2021-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>LSA头部信息，除Hello报文外，其它的OSPF报文都携带LSA信息。</p>
<ul>
<li>LS age：此字段表示LSA已经生存的时间，单位是秒。</li>
<li>Option：该字段指出了部分OSPF域中LSA能够支持的可选性能。</li>
<li>LS type：此字段标识了LSA的格式和功能。常用的LSA类型有五种。</li>
<li>Link State ID：根据LSA的不用而不同。</li>
<li>Advertising Router：始发LSA的路由器的ID。</li>
<li>Sequence Number：当LSA每次新的实例产生时，这个序列号就会增加。这个更新可以帮助其他路由器识别最新的LSA实例。</li>
<li>Checksum：关于LSA的全部信息的校验和。因为Age字段，所以校验和会随着老化时间的增大而每次都需要重新进行计算。</li>
<li>Length：是一个包含LSA头部在内的LSA的长度。</li>
</ul>
</li>
<li><p>Router-LSA，Router-LSA必须描述始发路由器所有接口或链路。</p>
<ul>
<li>Link State ID：是指始发路由器的路由器ID。</li>
<li>Flag：<ul>
<li>V：设置为1时，说明始发路由器是一条或者多条具有完全邻接关系的虚链路的一个端点。</li>
<li>E：当始发路由器是一个ASBR路由器时，该为置为1。</li>
<li>B：当始发路由器是一个ABR路由器时，该为置为1。</li>
</ul>
</li>
<li>Number of links：表明一个LSA所描述的路由器链路数量。</li>
<li>Link Type：<ul>
<li>值为1表示为点到点网络，常见的PPP链路需要使用点到点网络描述。</li>
<li>值为2表示连接一个transit网络，有至少两台路由器的广播型网段或NBMA网段就是一种Transit网段。</li>
<li>值为3表示连接stubnet网络，一般该网络上不存在邻居关系，如只有一个出口的以太网或回环接口。</li>
<li>值为4表示虚链路。</li>
</ul>
</li>
<li>Link ID：<ul>
<li>Link Type为1时该值表示邻居路由器的路由器ID。</li>
<li>Link Type为2时该值表示DR路由器的接口的IP地址。</li>
<li>Link Type为3时该值表示IP网络或子网地址。</li>
<li>Link Type为4时该值表示邻居路由器的路由器ID。</li>
</ul>
</li>
<li>Link Data：<ul>
<li>Link Type为1时该值表示和网络相连的始发路由器接口的IP地址。</li>
<li>Link Type为2时该值表示和网络相连的始发路由器接口的IP地址。</li>
<li>Link Type为3时该值表示网络的子网掩码。</li>
<li>Link Type为4时该值表示始发路由器的虚链路接口的IP地址。</li>
</ul>
</li>
<li>ToS，暂不支持。</li>
<li>Metric：是指一条链路或接口的代价。</li>
</ul>
</li>
<li><p>Network-LSA</p>
<ul>
<li>Link State ID：是指DR路由器的接口地址。</li>
<li>Network Mask：指定这个网络上使用的地址或者子网的掩码。</li>
<li>Attached router：列出该多路访问网络上与DR形成完全邻接关系且包括DR本身的所有路由器的路由器ID。</li>
</ul>
</li>
<li><p>Network-summary-LSA和ASBR-summary-LSA</p>
<ul>
<li>Link State ID：对于3类LSA来说，表示所通告的网络或子网的IP地址。对于4类LSA来说表示所通告的ASBR路由器的路由器ID。</li>
<li>Network Mask：对于3类LSA来说，表示所通告的网络的子网掩码。对于4类LSA来说，该字段没有实际意义，一般置为0.0.0.0。</li>
<li>Metric：始发路由器到目的地址的路由的代价。</li>
</ul>
</li>
<li><p>AS-external-LSA</p>
<ul>
<li>Link State ID：表示所通告的网络或子网的IP地址。</li>
<li>Network Mask:指所通告的网络的子网掩码。</li>
<li>E：用来指定这条路由使用的外部度量的类型。如果该E bit设置为1,那么度量类型就是E2;如果该E bit设置为0,那么度量类型就是E1。</li>
<li>Metric：指路由的代价。由ASBR设定。</li>
<li>Forwarding Address：是指到达所通告的目的地的数据包应该被转发到的地址。如果转发地址是0.0.0.0,那么数据包将被转发到始发ASBR上。</li>
<li>External Route Tag:标记外部路由。</li>
</ul>
</li>
<li><p>NSSA LSA</p>
<ul>
<li>Forwarding Address：如果所引入外部路由的下一跳在OSPF路由域内，则Forwarding Address直接设置为所引入外部路由的下一跳；如果所引入外部路由的下一跳不在OSPF路由域内，则Forwarding Address设置为该ASBR上某个OSPF路由域内的Stub网段（例如Loopback0接口）的接口IP地址，有多个Stub网段时选IP地址最大者。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/7.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li>Option字段解释：<ul>
<li>DN：用来避免在MPLS VPN中出现环路。当PE向CE发送3类、5类和7类LSA时需要设置DN位，其他PE路由器从CE接收到该LSA时，不能够在它的OSPF路由计算中使用该LSA。</li>
<li>O：该字段指出始发路由器支持Opaque LSA（类型9、类型10和类型11）。</li>
<li>DC位：当始发路由器支持按需链路上的OSPF的能力时，该位将被设置。</li>
<li>EA：当始发路由器具有接收和转发External-Attributes-LSA（type8 LSA）的能力时，该位被置位。</li>
<li>N位：只用在Hello数据包中。N=1表明路由器支持7类LSA。N=0表明该路由器将不接收和发送NSSA LSA。</li>
<li>P位：只用在NSSA LSA。该位将告诉NSSA区域的ABR路由器将7类LSA转换为5类LSA。</li>
<li>MC位：当始发路由器支持转发组播数据包的能力时，该位将被置位。</li>
<li>E位：当始发路由器具有接收AS-external-LSA（type5 LSA）的能力时，该位被置位。在所有5类LSA和始发于骨干区域以及非末节区域的LSA中，该位置为1。而始发于末节区域的LSA中，该位置为0。如果Hello报文中该位被置位则表明该接口具有接收和发送5类LSA的能力。</li>
<li>MT位：表示始发路由器支持多拓扑OSPF。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li><p>快速收敛：</p>
<ul>
<li>I-SPF改进了这个算法，除了第一次计算时需要计算全部节点外，每次只计算受到影响的节点，而最后生成的最短路径树SPT与原来的算法所计算的结果相同，大大降低了CPU的占用率，提高了网络收敛速度。</li>
<li>PRC的原理与I-SPF相同，都是只对发生变化的路由进行重新计算。不同的是，PRC不需要计算节点路径，而是根据I-SPF算出来的SPT来更新路由。在路由计算中，叶子代表路由，节点则代表路由器。SPT变化和叶子变化都会引起路由信息的变化，但两者不存在依赖关系，PRC根据SPT或叶子的不同情况进行相应的处理：<ul>
<li>SPT变化，PRC处理变化节点上的所有叶子的路由信息。</li>
<li>SPT没有变化，PRC不会处理节点的路由信息。</li>
<li>叶子变化，PRC处理变化的叶子的路由信息。</li>
<li>叶子没有变化，PRC不会处理叶子的路由信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>智能定时器，OSPF智能定时器分别对路由计算、LSA的产生、LSA的接收进行控制，加速网络收敛。OSPF智能定时器可以通过以下两种方式来加速网络收敛：</p>
<ul>
<li><p>在频繁进行路由计算的网络中，OSPF智能定时器根据用户的配置和指数衰减技术动态调整两次路由计算的时间间隔，减少路由计算的次数，从而减少CPU的消耗，待网络拓扑稳定后再进行路由计算。</p>
</li>
<li><p>在不稳定网络中，当路由器由于拓扑的频繁变化需要产生或接收LSA时，OSPF智能定时器可以动态调整时间间隔，在时间间隔之内不产生LSA或对接受到的LSA不进行处理，从而减少整个网络无效LSA的产生和传播。</p>
</li>
<li><p>智能定时器对路径计算的作用：</p>
<ul>
<li><p>根据本地维护的链路状态数据库LSDB，运行OSPF协议的路由器通过SPF算法计算出以自己为根的最短路径树，并根据这一最短路径树决定到目的网络的下一跳。通过调节SPF的计算间隔，可以抑制网络频繁变化可能导致的占用过多带宽资源和路由器资源。</p>
</li>
<li><p>在特定组网环境下（例如对路由收敛时间要求较高的环境），可以指定以毫秒为单位的时间间隔，用来增加路由计算的频度，从而加快路由的收敛。</p>
</li>
<li><p>当OSPF的链路状态数据库（LSDB）发生改变时，需要重新计算最短路径。如果网络频繁变化，由于不断的计算最短路径，会占用大量系统资源，影响路由器的效率。通过配置智能定时器，设置合理的SPF计算的间隔时间，可以避免占用过多的路由器内存和带宽资源。</p>
</li>
<li><p>使能智能定时器后：</p>
<p>​    初次计算SPF的间隔时间由start-interval参数指定。</p>
<p>​    第n（n≥2）次计算SPF的间隔时间为hold-interval×2(n-1)。</p>
<p>当hold-interval×2(n-1)达到指定的最长间隔时间max-interval时，OSPF连续三次计算SPF的时间间隔都是最长间隔时间，之后，再次返回步骤1，按照初始间隔时间start-interval计算SPF。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>按优先级收敛：</p>
<ul>
<li>可以通过IP前缀列表等将特定路由过滤出来，通过对不同的路由配置不同的收敛优先级，达到重要的路由先收敛的目的，提高网络的可靠性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li><p>通过设置路由器上非缺省外部路由数量的上限，来避免数据库超限。OSPF网络中所有路由器都必须配置相同的上限值。这样，只要路由器上外部路由的数量达到该上限，路由器就进入Overflow状态，并同时启动超限状态定时器（默认超时时间为5秒），路由器在定时器超过5秒后自动退出超限状态。</p>
</li>
<li><p>OSPF Database Overflow过程：</p>
<ul>
<li>进入Overflow状态时，路由器删除所有自己产生的非缺省外部路由。</li>
<li>处于Overflow状态中时，路由器不产生非缺省外部路由；丢弃新收到的非缺省外部路由且不回复确认报文；当超限状态定时器超时，检查外部路由数量是否仍然超过上限，如果超限则重启定时器，如果没有则退出超限状态。</li>
<li>退出Overflow状态时，路由器删除超限状态定时器；产生非缺省外部路由；接收新收到的非缺省外部路由并回复确认报文；准备下一次进入超限状态。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/12.png"></p>
<blockquote>
<ul>
<li><p>OSPF 缺省路由通常应用于下面两种情况：</p>
<ul>
<li>由区域边界路由器（ABR）发布 Type3 缺省 Summary LSA，用来指导区域内设备进行区域之间报文的转发。</li>
<li>由自治系统边界路由器（ASBR）发布 Type5 外部缺省 ASE LSA，或者 Type7 外部缺省NSSA LSA，用来指导自治系统（AS）内设备进行自治系统外报文的转发。</li>
</ul>
</li>
<li><p>OSPF 缺省路由的发布原则如下：</p>
<ul>
<li>OSPF 路由器只有具有对外的出口时，才能够发布缺省路由 LSA。</li>
<li>如果 OSPF 路由器已经发布了缺省路由 LSA，那么不再学习其它路由器发布的相同类型缺省路由。即路由计算时不再计算其它路由器发布的相同类型的缺省路由 LSA，但数据库中存有对应 LSA。</li>
<li>外部缺省路由的发布如果要依赖于其它路由，那么被依赖的路由不能是本 OSPF 路由域内的路由，即不是本进程 OSPF 学习到的路由。因为外部缺省路由的作用是用于指导报文的域外转发，而本 OSPF 路由域的路由的下一跳都指向了域内，不能满足指导报文域外转发的要求。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li><p>OSPF 支持使用路由策略对路由信息进行过滤。缺省情况下， OSPF 不进行路由过滤。</p>
</li>
<li><p>OSPF 可以使用的路由策略包括 route-policy，filter，filter-policy，filter-lsa-out，访问控制列表（access-list），地址前缀列表（prefix-list）。 </p>
</li>
<li><p>OSPF 路由过滤可以应用于以下几个方面： </p>
<ul>
<li>路由引入的过滤：<ul>
<li>OSPF可以引入其它路由协议学习到的路由。在引入时可以通过配置路由策略来过滤路由，只引入满足条件的路由。</li>
<li>可以在OSPF 路由表中被发布出去</li>
</ul>
</li>
<li>3类LSA学习、发布的过滤：<ul>
<li>通过filter import、filter export命令在 ABR上对进入或离开本区域的3型LSA 进行过滤。该配置只在ABR上有效（只有ABR才能发布3型LSA）。 </li>
<li>5、7类LSA生成的过滤：</li>
<li>OSPF 引入外部路由后会生成5、7型LSA。可以通过filter-policy export来对5、7型LSA的生成进行过滤。该过滤规则只在 ASBR 上配置才有效。</li>
</ul>
</li>
</ul>
</li>
<li><p>接口视图下的LSA过滤。通过ospf filter-lsa-out命令， 匹配除Grace LSA外的所有LSA、3、5、7型LSA，并匹配ACL规定的路由前缀时，实现LSA的通告过滤。</p>
</li>
<li><p>路由计算的过滤：</p>
<ul>
<li>通过filter-policy import过滤规则，可以设置 OSPF对数据库中的区域内、区域间、外部LSA计算为路由条目时进行过滤。<br> 该过滤只作用于路由表项的添加与否，即只有通过过滤的路由才被添加到本地路由表中，产生该路由的LSA仍然会在OSPF自治系统内扩散。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/14.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>OSPF支持的网络类型有P2P网络、P2MP网络、NBMA网络和广播网络；IS-IS仅支持P2P网络和广播网络。</li>
<li>OSPF工作在IP之上，协议号为89。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/16.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>OSPF建立邻居需要检查Hello报文中的掩码、认证、hello/dead时间间隔、区域等信息。而IS-IS形成邻居关系条件比较宽松。</li>
<li>OSPF P2P链路建立邻居关系需要三次握手。IS-IS则不要三次握手，但是华为设备缺省情况下使能IS-IS P2P网络三次握手功能，以保证邻居建立的可靠性。</li>
<li>IS-IS邻居关系分为层1和层2。</li>
<li>OSPF依据优先级和router-id选举DR/BDR，且选举结束后，不可抢占。在OSPF中，所有DRother与DR/BDR形成完全邻接关系，DRother间形成2-way即不完全邻接关系。OSPF中，如果优先级为0，则表示该路由器不参与DR/BDR选举。</li>
<li>IS-IS选举DIS依据优先级和MAC地址，可以抢占。在IS-IS中，所有路由器均形成邻接关系。IS-IS中，如果优先级为0，则表示该路由器也会参与DIS选举，只是优先级比较低。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>IS-IS LSP种类较少，但是扩展性较强，主要通过LSP携带的TLV字段进行功能扩展。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li>相关解释如下：<ul>
<li>OSPF开销是基于带宽的；IS-IS理论上开销类型分为四种，包括缺省开销、时延开销、代价开销、差错开销，但在实现上只采用缺省开销。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/19.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/21.png"></p>
<blockquote>
<p>默认情况下，OSPF不检查DD报文中的MTU。</p>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/25.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/27.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/28.png"></p>
<blockquote>
<ul>
<li>IPv6中重点强调了一个“链路（link）”的概念，在IPv6中，一个链路上可以分配多个IP子网，也就是IPv6前缀。和IPv4中不同的是，同一个链路上的两个节点即使不具有相同的IPv6前缀，也可以直接通过这个链路通信。这一点极大地改变了OSPF的行为。</li>
<li>OSPFv3是基于链路运行的，而不是以前的基于IP子网的运行。在OSPFv3中我们更多的是使用“链路”和“前缀”这两个术语。但这两个概念是分离的，没有必然的对应关系。同一链路上的两个节点不必具有相同的前缀。所以在讨论路由协议时，OSPFv2的术语“网络”和“子网”在这里应该用“链路”替换掉。同样，一个OSPF接口现在是连接到一个链路上，而不再是一个IP子网上了。OSPF协议分组的接收以及Hello分组和LSA的格式也因此做出了相应的修改。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/29.png"></p>
<blockquote>
<ul>
<li><p>一个路由器可以学习到这个链路上相连的所有其它路由器的链路本地地址，并使用这些链路本地地址作为下一跳来转发报文。</p>
</li>
<li><p>IPv6在RFC2373中定义了链路本地（link-local）地址用于一个单一链路上，其目的是完成邻居发现（neighbor discovery）和自动配置（auto-configuration）等功能。IPv6路由器不转发源地址为link-local类型的分组。Link-local单播地址范围为IPv6地址范围FE80/10。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/30.png"></p>
<blockquote>
<ul>
<li><p>Router A、 Router B、 Router C和Router D连接到同一个广播网上，它们共享同一条链路且都能建立邻居关系，通过在Router A的Eth1/1、 Router B的Eth1/1、Router C的Eth1/2上指定实例1、在Router A的Eth1/1、 Router B的Eth1/1、 RouterD的Eth1/3上指定实例2，实现了Router A、 Router B和Router C可以建立邻居关系， Router A、 Router B和Router D可以建立邻居关系。</p>
</li>
<li><p>这是通过在OSPFv3报文头中添加Instance ID字段来实现的。如果接口配置的Instance ID与接收的OSPF v3报文的Instance ID不匹配，则丢弃该报文，从而无法建立起邻居关系。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/31.png"></p>
<blockquote>
<ul>
<li>OSPFv3协议一般自身不再提供认证功能，而是通过使用IPv6提供的安全机制来保证自身报文的合法性。所以， OSPFv2报文中的认证字段，在OSPFv3报文头中被取消。 </li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/33.png"></p>
<blockquote>
<ul>
<li><p>与OSPFv2一样， OSPFv3的五种报文都有同样的报文头，只是报文中的字段有些不同。</p>
</li>
<li><p>OSPFv3的LSU和LSAck报文与OSPFv2相比没有什么变化，但OSPFv3的报文头、 Hello、 DD以及LSR报文中的字段与OSPFv2略有不同，报文的改变包括以下几点：</p>
<ul>
<li>版本号从 2 升级到 3。</li>
<li>报文头的不同：与 OSPFv2 报文头相比， OSPFv3 报文头长度只有 16 字节，去掉了认证字段但加了 Instance ID 字段。 Instance ID 字段用来支持在同一条链路上运行多个实例，且只在链路本地范围内有效，如果路由器接收到的 Hello 报文的 Instance ID 与当前接口配置的 Instance ID 不同，将无法建立邻居关系。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li><p>Hello 报文的不同：与 OSPFv2 Hello 报文相比， OSPFv3 Hello 报文去掉了网络掩码字段，增加了 Interface ID 字， 用来标识发送该 Hello 报文的接口ID。 </p>
</li>
<li><p>Instance ID:  4字节。报文发送者的发送接口标识，仅用来区分同一路由器上的不同接口，不包含地址信息。</p>
</li>
<li><p>Rtr Pri:  1字节。路由器优先级，优先级高者成为DR。</p>
</li>
<li><p>Options: 3字节。 OSPFv3中将Options字段扩展为24位。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/35.png"></p>
<blockquote>
<ul>
<li><p>在OSPFv2中， Option字段出现在每一个Hello报文、 DD报文以及每一个LSA中。</p>
</li>
<li><p>在 OSPFv3中， Option字段只在 Hello报文、 DD报文、 Router LSA、 Network LSA、 Inter Area Router LSA以及Link LSA中出现。 </p>
</li>
<li><p>从上图可以看出，与OSPFv2相比， OSPFv3的Option字段增加了R比特、 V比特。</p>
<ul>
<li>R 比特：用来标识设备是否是具备转发能力的路由器。如果 R 比特置 0，宣告该节点的路由信息将不会参加路由计算，如果当前设备是一个不想转发非本地地址的报文，可以将 R 比特置 0。</li>
<li>V6 比特：如果 V6 比特置 0，该路由器或链路也不会参加IPv6路由计算。</li>
<li>E: 如果为0，不支持AS-External-LSA洪泛；</li>
<li>MC: 与多播相关；</li>
<li>N: 是否在NSSA (Not So Stub Area)区域；</li>
<li>DC: 是否支持按需拨号。</li>
</ul>
</li>
<li><p>Options字段的各位的匹配情况会产生不同影响：</p>
<ul>
<li>阻止邻居的建立，例如Hello报文中的选项不匹配。</li>
<li>阻止LSA的洪泛，例如E-Bit，如果为0，不洪泛AS-External-LSA。</li>
<li>阻止LSA参加路由计算，例如V6-Bit，如果为0，该Router不参加IPv6路由计算。</li>
<li>Options字段使OSPF路由器能支持可选的能力，并且与其它路由器互相通告其能力。通过这种机制，具有不同能力的路由器可以在一个OSPF路由域中混合工作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>OSPFv2中的LS Type长度为8比特，指定LSA的类型； OSPFv3的LSA Type字段由OSPFv2的8比特扩充为16比特。<ul>
<li>U 位：描述了路由器收到一个类型未知的 LSA 时如何处理，取值为 0 表示把类型未知 LSA 当成具有链路本地范围的 LSA 一样处理，取值为 1 表示按照S2/S1 位标识的泛洪范围来处理。 </li>
<li>S2/S1 位：共同标识 LSA 的泛洪范围，取值 00 表示 LSA 只在产生该 LSA 的本地链路上泛洪；取值 01 表示 LSA 的泛洪范围为产生该 LSA 的路由器所在区域；取值 10 表示 LSA 将在整个自治系统内进行泛洪；取值 11 保留。</li>
<li>LSA Function Code： LSA 类型编码，描述 LSA 的类型。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/37.png"></p>
<blockquote>
<ul>
<li><p>在OSPFv2中，收到类型未知的LSA将直接丢弃。 </p>
</li>
<li><p>OSPFv3在LSA的LS Type字段中增加了一个U比特位来位标识对未知类型LSA的处理方式： </p>
<ul>
<li>如果 U 比特置 1，则对于未知类型的 LSA 按照 LSA 中的 LS Type 字段描述的泛洪范围进行泛洪；</li>
<li>如果 U 比特置 0，对于未知类型的 LSA 仅在链路范围内泛洪。</li>
</ul>
</li>
<li><p>LSA的泛洪范围已经被明确地定义在LSA的LS Type字段，目前，有三种LSA泛洪范围。 </p>
<ul>
<li>链路本地范围(Link-local Scope)。<ul>
<li>LSA 只在本地链路上泛洪，不会超出这个范围， Link-LSA(新增)。</li>
</ul>
</li>
<li>区域范围(Area Scope)。<ul>
<li> Router-LSA, Network-LSA, Inter-Area-Prefix-LSA, Inter-Area-Router-LSA, Intra-Area-Prefix-LSA(新增)都是区域范围泛洪的 LSA。 </li>
</ul>
</li>
<li>自治系统范围(AS Scope)。<ul>
<li>LSA 将被泛洪到整个路由域，AS-External-LSA。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/38.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/39.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/40.png"></p>
<blockquote>
<ul>
<li>OSPFv3新增了Link-LSA和Intra Area Prefix LSA。<ul>
<li>Router LSA 不再包含地址信息，使能 OSPFv3 的路由器为它所连接的每条链路产生单独的 Link-LSA，将当前接口的链路本地地址以及路由器在这条链路上的一系列 IPv6 地址信息向该链路上的所有其它路由器通告。</li>
<li>Router LSA 和 Network LSA 中不再包含路由信息，这两类 LSA 中所携带的路由信息由 Intra Area Prefix LSA 来描述，该类 LSA 用来公告一个或多个IPv6 地址前缀。 </li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li><p>在OSPFv2中，使用“IP网段＋掩码”来表示前缀信息，而且两段信息在不同LSA中的位置还各不相同，结构很不清晰。在OSPFv3的LSA中，使用专门的三元组（Prefix-Length, PrefixOptions, Prefix）来表示前缀信息。由LSA公告的每个前缀都拥有一个自己的PrefixOptions 字段。</p>
</li>
<li><p>Prefix-Length</p>
<ul>
<li>1字节。前缀的bit位长度，对于缺省路由该字段取值为0。</li>
<li>PrefixOptions，1字节。前缀信息的选项，用来描述前缀的某些特殊属性字段，格式如下：</li>
<li>NU位：非单播位。如果设置为1，则这个前缀不会纳入IPv6单播路由计算中。</li>
<li>LA位：本地地址位。如果设置为1，则这个前缀是路由器的一个接口地址。</li>
<li>MC位：组播位。如果设置为1，则这个前缀应该纳入组播计算中，否则不纳入组播计算。</li>
<li>P位：传播位。如果一个NSSA区域的前缀需要被ABR传播出去，就需要设置这一位。</li>
</ul>
</li>
<li><p>Prefix</p>
<ul>
<li>长度不定，为4字节的倍数。用于表示前缀的IPv6网络地址信息。</li>
</ul>
</li>
<li><p>Prefix-length可变，但必须是32bit（4字节）的整数倍，可用0来填充。因此它的长度可能是0、4、8、12、16字节。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/42.png"></p>
<blockquote>
<ul>
<li>W：用于组播路由；</li>
<li>V：该路由器为虚连接的一端；</li>
<li>E：该路由器为ASBR；</li>
<li>B：该路由器为ABR。</li>
<li>Type：1字节。路由器的该链路的链路类型；</li>
<li>Metric：2字节。数据报文从此接口发出时的cost值；</li>
<li>Interface ID：4字节。接口ID，用于标识接口，无地址含义。</li>
<li>Neighbor Interface ID：4字节。邻居接口ID。</li>
<li>Neighbor Router ID：4字节。邻居Router ID。 </li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/43.png"></p>
<blockquote>
<ul>
<li>Router-LSA具有区域泛洪范围，用于描述该路由器在某个区域内的所有连接，而且只描述建立了邻接关系的连接（邻居为full状态）。这意味着Stub类型的链路不在这里描述了（在OSPFv2中用链路类型3描述）。另外，如果是点到多点链路的话，需要为每个邻居都产生一个描述。由于每个链路描述的长度固定，因此可以通过LSA头中的LSA长度来确定Router-LSA中的Link数。</li>
<li> 一个Router-LSA可以包含多个链路描述（link description）。同一个路由器可以生成多个Router-LSA，通过Link State ID进行区分。在SPF计算时，对于同一个路由器产生的多个Router-LSA必须合在一起参与运算。</li>
<li>OSPFv3的Router-LSA中不再包含前缀信息，仅仅描述了拓扑连接情况。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/44.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/45.png"></p>
<blockquote>
<ul>
<li><p>Options：3字节。含义见第36页。该字段实际上是该链路上所有路由器的Link-LSA的Options字段的集合，也即是它们的能力集合。</p>
</li>
<li><p>Attached Router：</p>
<ul>
<li>每个路由器4字节。该链路上所有与DR有Full关系的路由器的Router ID。</li>
<li>OSPFv3的Network-LSA具有区域泛洪范围，由DR生成。它的Link State ID为DR的Interface ID，而且将OSPFv2中的掩码字段取消了，所以它不再包含前缀信息，而仅仅描述了拓扑连接情况。</li>
<li>另外，由于其中的Options字段为链路上所有路由器的能力集合，因此DR的能力大小并不会影响其他路由器的LSA传播。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/46.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/47.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/48.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/49.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/50.png"></p>
<blockquote>
<ul>
<li>OSPFv3的Intra-Area-Prefix-LSA具有区域泛洪范围，用于发布区域内前缀信息。根据所参考的LSA不同可分为以下两种情况：<ul>
<li>参考Router-LSA，由各路由器分别生成，用于发布点到点链路的前缀信息以及Stub网络的前缀信息；</li>
<li>参考Network-LSA，由DR生成，用于发布该链路对应网络上的所有前缀信息，这些前缀来自链路上所有路由器各自生成的Link-LSA。但是，Link-LSA中的本地链路地址信息、NU或LA位置1的前缀除外。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/51.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/52.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/53.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/54.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/55.png"></p>
<blockquote>
<ul>
<li>Metric：20bit。表示ABR到达该前缀描述的路由的cost值。</li>
<li>前缀信息：描述前缀的Prefix三元组。</li>
<li>在OSPFv2中，使用LSA头里面的Link State ID字段来表示网络地址，掩码包含在LSA内容里。</li>
<li>OSPFv3的Inter-Area-Prefix-LSA中，LSA头里的Link State ID不再包含前缀信息，仅仅是一个32位的编号，用于区分同一路由器产生的不同LSA，所有前缀均通过Prefix三元组来描述。</li>
<li>Inter-Area-Prefix-LSA具有区域泛洪范围，由ABR生成。每个Inter-Area-Prefix-LSA包含一条地址前缀信息，且不能包含本地链路地址信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/56.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/57.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/58.png"></p>
<blockquote>
<ul>
<li>Options：3字节，并非生成LSA的路由器的能力描述，而是描述了目的ASBR的能力。</li>
<li> Metric：3字节，表示ABR到目的ASBR路由器的cost值。</li>
<li> Destination Router ID：4字节，目的ASBR路由器的Router ID。</li>
<li>在OSPFv2中，使用LSA头里面的Link State ID字段来表示目的ASBR的Router ID。OSPFv3的Inter-Area-Router-LSA中，LSA头里的Link State ID不再有具体含义，仅仅是一个32位的编号，用于区分同一路由器产生的不同LSA。</li>
<li>Inter-Area-Router-LSA具有区域泛洪范围，由ABR生成。每个Inter-Area-Router-LSA包含一条目的ASBR信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/59.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/60.png"></p>
<blockquote>
<ul>
<li><p>E：外部路由的Metric类型。如果设置为1，表示此为2类外部路由，其Metric不随着路由的传递而增长。如果设置为0，表示此为1类外部路由，其Metric随着路由的传递而增长。</p>
</li>
<li><p>F：如果设置为1，则表示后面的Forwarding Address可选字段存在。</p>
</li>
<li><p>T：如果设置为1，则表示后面的External Route Tag可选字段存在。</p>
</li>
<li><p>前缀信息：描述前缀的Prefix三元组。</p>
</li>
<li><p>Ref LS Type：2字节。如果非0，则表示后面的Referenced Link State ID可选字段存在。</p>
</li>
<li><p>Forwarding Address：16字节。可选的128位IPv6地址。当前面的F位为1时存在。表示到达目的的数据应该转发到这个地址。在公告路由器不是最优的下一跳的时候可以使用。</p>
</li>
<li><p>External Route Tag：4字节。可选的标记位。可以用于ASBR之间的通信。一个比较常见的例子是，在OSPF自治系统的两个边界路由器上进行路由分发时，通过对引入的路由进行标记，可以很方便地进行路由过滤。</p>
</li>
<li><p>Referenced Link State ID：4字节。当前面的Ref LS Type字段非0时存在。如果存在，说明此条外部路由有一些相关信息需要参考另外一个LSA。被参考的LSA由以下字段值确定：</p>
<ul>
<li>其LS type等于此AS-external-LSA的Referenced LS Type；</li>
<li>其Link State ID等于此AS-external-LSA的Referenced Link State ID；</li>
<li>其Advertising Router等于此ASexternal-LSA的Advertising Router。</li>
<li>这种参考能力是为未来的扩展准备的，目前并没有使用。</li>
</ul>
</li>
<li><p>在OSPFv2中，使用LSA头里面的Link State ID字段来表示网络地址，掩码包含在LSA内容里。</p>
</li>
<li><p>OSPFv3的AS-external-LSA中，LSA头里的Link State ID不再包含前缀信息，仅仅是一个32位的编号，用于区分同一路由器产生的不同LSA，所有前缀均通过Prefix三元组来描述。</p>
</li>
<li><p>AS-external-LSA具有AS泛洪范围，由ASBR生成。每个AS-external-LSA包含一条地址前缀信息，且不能包含本地链路地址信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/61.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/62.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/63.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/64.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/65.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/66.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/67.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/68.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/69.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/70.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/71.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/72.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/73.png"></p>
<p><img src="/2021/08/04/IE-OSPF%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/74.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/" itemprop="url">IE-IPv6基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-26T17:30:23+08:00">
                2021-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/1.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/2.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/3.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/4.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/5.png"></p>
<blockquote>
<ul>
<li><p>ICANN(the Internet Corporation for Assigned Names and Numbers)是Internet的中心管理机构。</p>
</li>
<li><p>并不是所有的地址都会被分配。一些地址被预留，用于广播、测试、私有网络使用等。这些地址被称为专用地址(special-use address)。你可以查询RFC5735来了解哪些地址是专用地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/6.png"></p>
<blockquote>
<ul>
<li><p>实践证明IPv4是一个非常成功的协议，它本身也经受住了Internet从数目很少的计算机发展到目前上亿台计算机互联的考验。但该协议是几十年前基于当时的网络规模而设计的。在今天看来，IPv4的设计者们对于Internet的估计和预想显得很不充分。随着Internet的扩张和新应用的不断推出，IPv4越来越显示出它的局限性。</p>
</li>
<li><p>Internet规模的快速扩大是当时完全没有预料到的，特别是近十年来，更是爆炸式增长，已经走进了千家万户，人们的日常生活已经离不开它了。但也就是这种快速发展，出现了迫在眉睫的IP地址空间耗尽问题。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/7.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/8.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/9.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/10.png"></p>
<blockquote>
<p>IPv6特点：</p>
<ul>
<li>地址空间，IPv6地址采用128比特标识。128位的地址结构使IPv6理论上可以拥有（43亿×43亿×43亿×43亿）个地址。近乎无限的地址空间是IPv6的最大优势。</li>
<li>报文结构，IPv6使用了新的协议头格式，也就是说IPv6数据包有全新的报文头，而并不是仅仅简单地将IPv4报文头中的地址部分增加到128bits而已。在IPv6中，报文头包括固定头部和扩展头部，一些非根本性的和可选择的字段被移到了IPv6协议头之后的扩展协议头中。这使得网络中的中间路由器在处理IPv6协议头时，有更高的效率。</li>
<li>实现自动配置和重新编址，IPv6协议内置支持通过地址自动配置方式使主机自动发现网络并获取IPv6地址，大大提高了内部网络的可管理性。</li>
<li>支持层次化网络结构，巨大的地址空间使得IPv6可以方便的进行层次化网络部署。层次化的网络结构可以方便的进行路由聚合，提高了路由转发效率。</li>
<li>支持端对端安全，IPv6中，网络层支持IPSec的认证和加密，支持端到端的安全。</li>
<li>更好的支持QoS，IPv6在包头中新定义了一个叫做流标签的特殊字段。IPv6的流标签字段使得网络中的路由器可以对属于一个流的数据包进行识别并提供特殊处理。用这个标签，路由器可以不打开传送的内层数据包就可以识别流，这就使得即使数据包有效载荷已经进行了加密，仍然可以实现对QoS的支持。</li>
<li>支持移动特性，由于采用了Routing header和Destination option header等扩展报头，使得IPv6提供了内置的移动性。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/11.png"></p>
<blockquote>
<ul>
<li><p>IPv6数据包由一个IPv6报头、多个扩展报头和一个上层协议数据单元组成。</p>
</li>
<li><p>IPv6基本报头（IPv6 Header）</p>
<ul>
<li>每一个IPv6数据包都必须包含报头，其长度固定为40bytes。</li>
<li>基本报头提供报文转发的基本信息，会被转发路径上面的所有路由器解析。</li>
</ul>
</li>
<li><p>上层协议数据单元（Upper Layer Protocol Data Unit）</p>
<ul>
<li>上层协议数据单元一般由上层协议包头和它的有效载荷构成，有效载荷可以是一个ICMPv6报文、一个TCP报文或一个UDP报文。</li>
</ul>
</li>
<li><p>IPv6报头格式中主要字段解释如下：</p>
<ul>
<li>Version：版本号，长度为4bit。对于IPv6，该值为6。</li>
<li>Traffic Class：流类别，长度为8bit。等同于IPv4中的ToS字段，表示IPv6数据报的类或优先级，主要应用于QoS。</li>
<li>Flow Label：流标签，长度为20bit。IPv6中的新增字段，用于区分实时流量，不同的流标签+源地址可以唯一确定一条数据流，中间网络设备可以根据这些信息更加高效率的区分数据流。</li>
<li>Payload Length：有效载荷长度，长度为16bit。有效载荷是指紧跟IPv6报头的数据报的其它部分（即扩展报头和上层协议数据单元）。</li>
<li>Next Header：下一个报头，长度为8bit。</li>
<li>Hop Limit：跳数限制，长度为8bit。该字段类似于IPv4中的Time to Live字段，它定义了IP数据报所能经过的最大跳数。每经过一个路由器，该数值减去1，当该字段的值为0时，数据报将被丢弃。</li>
<li>Source Address：源地址，长度为128bit。表示发送方的地址。</li>
<li>Destination Address：目的地址，长度为128bit。表示接收方的地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/12.png"></p>
<blockquote>
<ul>
<li>在IPv4中，IPv4报头包含可选字段Options，内容涉及security、Timestamp、Record route等，这些Options可以将IPv4报头长度从20字节扩充到60字节。在转发过程中，处理携带这些Options的IPv4报文会占用路由器很大的资源，因此实际中也很少使用。</li>
<li>IPv6将这些Options从IPv6基本报头中剥离，放到了扩展报头中，扩展报头被置于IPv6报头和上层协议数据单元之间。一个IPv6报文可以包含0个、1个或多个扩展报头，仅当需要路由器或目的节点做某些特殊处理时，才由发送方添加一个或多个扩展头。与IPv4不同，IPv6扩展头长度任意，不受40字节限制，这样便于日后扩充新增选项，这一特征加上选项的处理方式使得IPv6选项能得以真正的利用。但是为了提高处理选项头和传输层协议的性能，扩展报头总是8字节长度的整数倍。当使用多个扩展报头时，前面报头的Next Header字段指明下一个扩展报头的类型，这样就形成了链状的报头列表。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/13.png"></p>
<blockquote>
<p>说明：</p>
<ul>
<li><p>路由设备转发时根据基本报头中Next Header值来决定是否要处理扩展头，并不是所有的扩展报头都需要被转发路由设备查看和处理的。</p>
</li>
<li><p>除了目的选项扩展报头可能在一个IPv6报文中出现一次或两次（一次在路由扩展报头之前，另一次在上层协议数据报文之前），其余扩展报头只能出现一次。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/14.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/15.png"></p>
<blockquote>
<ul>
<li>IPv4地址分为：单播地址、组播地址、广播地址。而IPv6中没有广播地址，增加了任播地址。也就是说IPv6地址被分为：单播地址、组播地址、任播地址。<ul>
<li>单播地址用于标识一个接口，发往该目的地址的报文会被送到被标识的接口；</li>
<li>组播地址用于标识多个接口，发往该目的地址的报文会被送到被标识的所有接口；</li>
<li>任播地址用于标识多个接口，发往该目的地址的报文会被送到被标识的所有接口中最近的一个接口上。实际上任播地址与单播地址使用同一个地址空间，也就是说，由路由器决定数据包是做任播转发还是单播转发。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/16.png"></p>
<blockquote>
<ul>
<li>全球单播地址是带有全球单播前缀的IPv6地址，其作用类似于IPv4中的公网地址。这种类型的地址允许路由前缀的聚合，从而限制了全球路由表项的数量。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/17.png"></p>
<blockquote>
<ul>
<li>链路本地地址是IPv6中的应用范围受限制的地址类型，只能在连接到同一本地链路的节点之间使用。它使用了特定的本地链路前缀FE80::/10（最高10位值为1111111010），同时将接口标识添加在后面作为地址的低64比特。</li>
<li>当一个节点启动IPv6协议栈时，启动时节点的每个接口会自动配置一个链路本地地址（其固定的前缀+EUI-64规则形成的接口标识）。这种机制使得两个连接到同一链路的IPv6节点不需要做任何配置就可以通信。所以链路本地地址广泛应用于邻居发现，无状态地址配置等应用。</li>
<li>以链路本地地址为源地址或目的地址的IPv6报文不会被路由设备转发到其他链路。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/18.png"></p>
<blockquote>
<ul>
<li><p>唯一本地地址是另一种应用范围受限的地址，它仅能在一个站点内使用。由于本地站点地址的废除（RFC3879），唯一本地地址被用来代替本地站点地址（RFC4193）。</p>
</li>
<li><p>唯一本地地址的作用类似于IPv4中的私网地址，任何没有申请到提供商分配的全球单播地址的组织机构都可以使用唯一本地地址。唯一本地地址只能在本地网络内部被路由转发而不会在全球网络中被路由转发。</p>
</li>
<li><p>字段解释：</p>
<ul>
<li>Prefix：前缀；固定为FC00::/7。</li>
<li>L：L标志位；值为1代表该地址为在本地网络范围内使用的地址；值为0被保留，用于以后扩展。</li>
<li>Global ID：全球唯一前缀；通过伪随机方式产生（RFC4193）。</li>
<li>Subnet ID：子网ID；划分子网使用。</li>
<li>Interface ID：接口标识。</li>
</ul>
</li>
<li><p>唯一本地地址具有如下特点：</p>
<ul>
<li>具有全球唯一的前缀（虽然随机方式产生，但是冲突概率很低）。</li>
<li>可以进行网络之间的私有连接，而不必担心地址冲突等问题。</li>
<li>具有知名前缀（FC00::/7），方便边缘路由器进行路由过滤。</li>
<li>如果出现路由泄漏，该地址不会和其他地址冲突，不会造成Internet路由冲突。</li>
<li>应用中，上层应用程序将这些地址看作全球单播地址对待。</li>
<li>独立于互联网服务提供商ISP（Internet Service Provider）。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/19.png"></p>
<blockquote>
<ul>
<li><p>未指定地址</p>
<ul>
<li>IPv6中的未指定地址即 0:0:0:0:0:0:0:0/128 或者::/128。该地址可以表示某个接口或者节点还没有IP地址，可以作为某些报文的源IP地址（例如在NS报文的重复地址检测中会出现）。源IP地址是::的报文不会被路由设备转发。</li>
</ul>
</li>
<li><p>环回地址</p>
<ul>
<li>IPv6中的环回地址即 0:0:0:0:0:0:0:1/128 或者::1/128。环回与IPv4中的127.0.0.1作用相同，主要用于设备给自己发送报文。该地址通常用来作为一个虚接口的地址（如Loopback接口）。实际发送的数据包中不能使用环回地址作为源IP地址或者目的IP地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/20.png"></p>
<blockquote>
<ul>
<li><p>对于IPv6 单播地址来说，如果地址的前三bit不是000，则接口标识必须为64位，如果地址的前三位是000，则没有此限制。</p>
</li>
<li><p>接口ID的长度为64bit，用于标识链路上的接口。在每条链路上，接口ID必须唯一。接口ID有许多用途，最常见的用于就是黏贴在链路本地地址前缀后面，形成接口的链路本地地址。或者在无状态自动配置中，黏贴在获取到的IPv6全局单播地址前缀后面，构成接口的全局单播地址。</p>
</li>
<li><p>IEEE EUI-64规范</p>
<ul>
<li>这种由MAC地址产生IPv6地址接口ID的方法可以减少配置的工作量，尤其是当采用无状态地址自动配置时（后面会介绍），只需要获取一个IPv6前缀就可以与接口ID形成IPv6地址。</li>
<li>使用这种方式最大的缺点就是某些恶意者可以通过二层MAC推算出三层IPv6地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/21.png"></p>
<blockquote>
<ul>
<li><p>假设一个接口的MAC地址如上图所示，那么采用EUI-64规范，接口可根据该MAC地址计算得到接口ID，由于MAC地址全局唯一，因此该接口ID也相应的具备全局唯一性。计算过程如下。</p>
</li>
<li><p>将48bit的MAC地址对半劈开，然后插入“FFFE”，再对从左数起的第7位，也就是U/L位取反，即可得到对应的接口ID。</p>
</li>
<li><p>在单播MAC地址中，第1个Byte的第7bit是U/L（Universal/Local，也称为G/L，其中G表示Global）位，用于表示MAC地址的唯一性。如果U/L=0，则该MAC地址是全局管理地址，是由拥有OUI的厂商所分配的MAC地址；如果U/L=1，则是本地管理地址，是网络管理员基于业务目的自定义的MAC地址。</p>
</li>
<li><p>而在在EUI-64接口ID中，第7bit的含义与MAC地址正好相反，0表示本地管理，1表示全球管理，所以使用EUI-64格式的接口ID，U/L位为1，则地址是全球唯一的，如果为0，则为本地唯一。这就是为什么要反转该位。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/22.png"></p>
<blockquote>
<ul>
<li><p>IPv6的组播与IPv4相同，用来标识一组接口，一般这些接口属于不同的节点。一个节点可能属于0到多个组播组。发往组播地址的报文被组播地址标识的所有接口接收。</p>
</li>
<li><p>Flags 永久标志：</p>
<ul>
<li>0000：永久多播地址。</li>
<li>0001：临时多播地址。</li>
<li>（注：前3bits 保留为0）。</li>
</ul>
</li>
<li><p>Scope 应用范围：</p>
<ul>
<li>0001：本地接口范围，单个接口范围有效，仅用于Loopback。</li>
<li>0010：本地链路范围。</li>
<li>0100：本地管理范围，管理员配置的。</li>
<li>0101：本地站点范围。</li>
<li>1000：本地组织范围，属于同一个组织的多个站点范围。</li>
<li>1110：全局范围。</li>
</ul>
</li>
<li><p>Group ID：</p>
<ul>
<li>组播组ID。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/23.png"></p>
<blockquote>
<ul>
<li>类似于IPv4，IPv6同样有一些特殊的组播地址，这些地址由特别的含义，这里举几个例子（还有很多类似的特殊地址）：<ul>
<li>FF01::1（节点本地范围组播地址）</li>
<li>FF02::1（链路本地范围所有节点组播地址）</li>
<li>FF01::2（节点本地范围所有路由器组播地址）</li>
<li>FF02::2（链路本地范围所有路由器组播地址）</li>
<li>FF05::2（站点本地范围所有路由器组播地址）</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/24.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/25.png"></p>
<blockquote>
<ul>
<li><p>当一个节点具有了单播或任播地址，就会对应生成一个与之相对应的被请求节点组播地址，并且加入这个组播组。一个单播地址或任播地址对应一个被请求节点组播地址。该地址主要用于地址解析、邻居发现机制和地址重复检测等功能。</p>
</li>
<li><p>被请求节点组播地址由固定前缀FF02::1:FF00:0/104和对应IPv6地址的最后24bit组成。被请求节点组播地址的有效范围为本地链路范围。</p>
</li>
<li><p>被请求节点组播地址的作用究竟是什么呢？举个非常简单的例子，回顾一下IPv4中的ARP，这个协议主要用于地址解析，当设备需要解析某个IP地址对应的MAC地址时，就会发送一个广播ARP Request帧，之所以要发送广播帧，是因为它要确保广播域内所有节点都能收到。然而除了目标节点之外，该帧对于其他节点而言是个困扰，因为它们不得不去解析这个帧（一直解析到ARP载荷），这个动作将会浪费设备的资源。</p>
</li>
<li><p>在IPv6中，ARP及广播都被取消，当设备需要请求某个IPv6地址对应的MAC地址时，设备依然需要发送请求报文，但是该报文是一个组播报文，其目的IPv6地址是目标IPv6单播地址对应的被请求节点组播地址，而目的MAC地址则是该组播地址对应的组播MAC地址。由于只有目标节点才会侦听这个被请求节点组播地址，因此当其他设备收到该帧时，这些设备可以通过目的MAC地址、在网卡层面就判断出不需要处理它并将帧丢弃。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/26.png"></p>
<blockquote>
<ul>
<li>这是IPv6特有的地址类型，它用来标识一组网络接口（通常属于不同的节点）。目标地址是任播地址的数据包将发送给其中路由意义上最近的一个网络接口。适合于“One-to-One-of-Many”（一对组中的一个）的通讯场合。接收方只需要是一组接口中的一个即可，如移动用户上网就需要因地理位置的不同，而接入离用户最近的一个接收站，这样才可以使移动用户在地理位置上不受太多的限制。</li>
<li>任播地址从单播地址空间中进行分配，使用单播地址的任何格式。因而，从语法上，任播地址与单播地址没有区别。被分配具有任播地址的节点必须得到明确的配置，从而知道它是一个任播地址。目前，任播地址仅被用做目标地址，且仅分配给路由器。</li>
<li>在RFC3513中定义了子网路由器任播地址（Subnet-Router anycast Address），其接口ID为全0。</li>
<li>发往该任播地址的报文会被发送到任播地址所代表子网（子网路由器任播地址的前缀）内的某一台路由器，该路由器是离得最“近”的一台。所谓最近一般是路由的概念。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/27.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/28.png"></p>
<blockquote>
<ul>
<li>ICMPv6的协议类型号（即IPv6报文中的Next Header字段的值）为58。</li>
<li>在IPv4中，Internet控制报文协议（ICMP）向源节点报告关于向目的地传输IP数据包过程中的错误和信息。它为诊断、信息和管理目的定义了一些消息，如：目的不可达、数据包超长、超时、回应请求和回应应答等。在IPv6中，ICMPv6除了提供ICMPv4常用的功能之外，还有其它的一些机制需要ICMPv6消息，诸如邻居发现、无状态地址配置（包括重复地址检测）、路径MTU发现等等。</li>
<li>所以ICMPv6是一个非常重要的协议。它是理解IPv6中其它机制的基础。</li>
<li>报文解释：<ul>
<li>Type：表明消息的类型，0至127表示差错报文类型，128至255表示消息报文类型。</li>
<li>Code：表示此消息类型细分的类型。</li>
<li>Checksum：表示ICMPv6报文的校验和。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/29.png"></p>
<blockquote>
<ul>
<li><p>目标不可达（Destination Unreachable）。</p>
<ul>
<li>当数据包无法被转发到目标节点或上层协议时，路由器或目标节点发送ICMPv6目标不可达差错报文。在目标不可达报文中，类型（Type）字段值为1，代码（Code）字段值为0-4，每一个代码值都定义了具体含义（RFC2463）：<ul>
<li>0：没有到达目标的路由。</li>
<li>1：与目标的通信被管理策略禁止。</li>
<li>2：未指定。</li>
<li>3：地址不可达。</li>
<li>4：端口不可达。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据包超长（Packet Too Big）。</p>
<ul>
<li>如果由于出口链路的MTU小于IPv6数据包的长度而导致数据包无法转发，路由器就会发送数据包超长报文。该报文被用于IPv6路径MTU发现的处理 。数据包超长报文的类型字段值为2，代码字段值为0。</li>
</ul>
</li>
<li><p>超时（Time Exceeded）。</p>
<ul>
<li>当路由器收到一个IPv6报头中的跳限制（Hop Limit）字段值为0的数据包时，会丢弃该数据包并向源发送ICMPv6超时报文。在超时报文中，类型字段的值为3，代码字段的值为0或1：<ul>
<li>0：在传输中超越了跳限制。</li>
<li>1：分片重组超时。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/31.png"></p>
<blockquote>
<p>1.路由器发现：该功能帮助设备发现链路上的路由器，并获得路由器通告的信息。</p>
<p>2.无状态自动配置：无状态自动配置是IPv6的一个亮点功能，它使得IPv6主机能够非常便捷地连入到IPv6网络中，即插即用，无需手工配置繁冗的IPv6地址，无需部署应用服务器（例如DHCP服务器）为主机分发地址。无状态自动配置机制使用到了ICMPv6中的路由器请求报文（RS）及路由器通告报文（RA）。</p>
<p>3.重复地址检测：重复地址检测是一个非常重要的机制，一个IPv6地址必须经历重复地址检测并通过检测之后才能够启用。重复地址检测用于发现链路上是否存在IPv6地址冲突。</p>
<p>4.地址解析：在IPv6中，取消了IPv4中的ARP协议，使用NDP所定义的邻居请求报文（NS）及邻居通告报文（NA）来实现地址解析功能。</p>
<p>5.邻居的状态跟踪：IPv6定义了节点之间邻居的状态机，同时还维护邻居IPv6地址与二层地址如MAC的映射关系，相应的表项存储于设备的IPv6邻居表中。</p>
<p>6.前缀重编址：IPv6路由器能够通过ICMPv6的路由器通告报文（RA）向链路上通告IPv6前缀信息。通过这种方式，主机能够从RA中所包含的前缀信息自动构建自己的IPv6单播地址。当然这些自动获取的地址是有生存时间的。通过在RA中通告IPv6地址前缀，并且灵活地设定地址的生存时间，能够实现网络中IPv6新、老前缀的平滑过渡，而无需在主机终端上消耗大量的手工劳动重新配置地址。</p>
<p>7.路由器重定向：路由器向一个IPv6节点发送ICMPv6的重定向消息，通知它在相同的本地链路上有一个更好的、到达目的地的下一跳。IPv6中的重定向功能与IPv4中的是一样的。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/32.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/33.png"></p>
<blockquote>
<p>在IPv4中，可以通过ARP就可以由IP地址解析到链路层地址，ARP协议是工作在第二层。在IPv6中在邻居发现协议（RFC2461）中定义地址解析的，其中使用了ICMPv6的报文，在三层完成地址解析，主要带来以下几个好处：</p>
<p>1.加强了介质独立性：这就意味着我们无需为每一个链路层定义一个新的地址解析协议，在每一个链路层都使用相同的地址解析协议；</p>
<p>2.可以利用三层安全机制：ARP欺骗（如伪造ARP应答以盗窃数据流）是IPv4中的一个很大的安全问题，在第三层实现地址解析，可以利用三层标准的安全认证机制（例如IPSEC）解决这个问题；</p>
<p>3.ARP请求报文使用广播，会泛滥到整个二层网络中每台主机是公认的一个IPv4性能问题。在第三层实现地址解析可以将地址解析请求仅仅发送到待解析地址所属的“Solicited-node”组播组即可。采用组播的传送方式，大大减轻了性能压力。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/34.png"></p>
<blockquote>
<ul>
<li><p>地址解析过程中使用了两种ICMPv6报文：邻居请求（Neighbor Solicitation）和邻居通告（Neighbor Advertisement）。</p>
</li>
<li><p>邻居请求 Neighbor Solicitation</p>
<ul>
<li>ICMP的Type为135，Code为0；</li>
<li>Target Address是需要解析的IPv6地址，因此该处不准出现组播地址。</li>
<li>邻居请求发送者的链路层地址会被放在Options字段中。</li>
</ul>
</li>
<li><p>邻居通告 Neighbor Advertisement</p>
<ul>
<li>ICMP Type为136，Code为0；</li>
<li>R标志（Router flag）表示发送者是否为路由器，如果1则表示是；</li>
<li>S标志（Solicited flag）表示发送邻居通告是否是响应某个邻居请求，如果1则表示是；</li>
<li>O标志（Overide flag）表示邻居通告中的消息是否覆盖已有的条目信息，如果1则表示是；</li>
<li>Traget Address表示所携带的链路层地址对应的IPv6地址。</li>
<li>被请求的链路层地址被放在Options字段中，其格式仍然采用TLV格式，具体可以参考RFC2463 。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/35.png"></p>
<blockquote>
<ul>
<li>有了NS和NA两种报文，两台主机如何获取对方的链路层地址呢？</li>
<li>在上图所示的场景中，PC1要请求PC2的2001::2这个地址对应的MAC地址，PC1将发送一个NS报文达到这个目的。这个NS报文的源地址是2001::1，目的地址则是2001::2对应的被请求节点组播地址。</li>
<li>然后IPv6数据包又被封装上数据帧的头部，其中源MAC地址是PC1的MAC地址，目的MAC地址则是2001::2这个目标地址对应的被请求节点组播地址映射得到的MAC地址，这是一个组播MAC地址。</li>
<li>这样就完成了一个双向交互链路层地址的过程。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/36.png"></p>
<blockquote>
<ul>
<li><p>除R2外的其他节点也会收到这个数据帧，在读取数据帧头的时候发现目的MAC地址是一个组播MAC地址，而该组播MAC地址在本地并不侦听，因此在网卡层面就将数据帧丢弃而不再往报文里看了。</p>
</li>
<li><p>PC2收到这个数据帧后，由于本地网卡接收目的MAC地址为3333-FF00-0002的数据帧，因此在对数据帧做校验之后从帧头的类型字段得知里头是个IPv6报文，于是将帧头拆掉，把IPv6报文上送IPv6协议栈处理。IPv6协议栈从报文的IPv6头部中的目的IPv6地址得知这个数据包是发往一个被请求节点组播地址FF02::1:FF00:2，而本地网卡加入了这个组播组。接着，从IPv6包头的NextHeader字段得知IPv6包头后面封装着一个ICMPv6的报文，因此将IPv6包头拆除，将ICMPv6报文交给ICMPv6协议去处理。最后ICMPv6发现这是个NS报文，要请求自己2001::2对应的MAC地址，于是回送一个NA报文给PC1，在该报文中就包含着PC2的MAC地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/37.png"></p>
<blockquote>
<p>l在windows7操作系统里，可以使用netsh interface ipv6 show neighbors命令查看邻居缓存的内容。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/38.png"></p>
<blockquote>
<ul>
<li>前面简单地讲述了如何进行地址解析的，但是实际的通讯过程中不仅仅是地址解析这么简单，而是需要维护一张邻居表，每个邻居都有相应的状态，状态之间可以迁移。</li>
<li>RFC2461中定义了5种状态：INCOMPLETE、REACHABLE、STALE、DELAY、PROBE。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/39.png"></p>
<blockquote>
<ul>
<li>邻居状态的迁移是比较复杂的，此处不会做详细地介绍，下面以A、B两个节点之间相互通讯过程的A节点的邻居状态变化，假设A、B两个节点之前没有任何通讯：</li>
</ul>
<p>1.A先发送NS，并生成邻居缓存条目，状态为Incomplete；</p>
<p>2.若B回复NA，则Incomplete-&gt;Reachable，否则10s后Incomplete-&gt;Empty，即删除条目；</p>
<p>3.经过ReachableTime（默认30s），条目状态Reachable-&gt;Stale；</p>
<p>4.或者在Reachable状态，收到B的非请求NA，且链路层地址不同，则马上-&gt;Stale；</p>
<p>5.在Stale状态若A需要向B发送数据，则Stale-&gt;Delay，同时发送NS请求；</p>
<p>6.在Delay_First_Probe_Time（默认5秒）后，Delay-&gt;Probe，其间若有NA应答，则Delay-&gt;Reachable；</p>
<p>7.在Probe状态，每隔RetransTimer（默认1秒）发送单播NS，发送MAX_UNICAST_SOLICIT个后再等RestransTimer，有应答则-&gt;Reachable，否则进入Empty，即删除表项。</p>
<ul>
<li><p>从以上的机制可以看出IPv6的邻居关系优于IPv4的ARP，IPv6的邻居关系维护机制确保通讯发起之前邻居是可达的，而ARP本身是做不到的，仅仅通过老化机制来实现。</p>
</li>
<li><p>关于邻居状态的维护以及状态迁移可以参考RFC2461。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/40.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/41.png"></p>
<blockquote>
<ul>
<li>在上图中，R2已是在线的设备，该设备已经使用了如图所示的地址，现在我们为R1新配置IPv6的地址2001::FFFF/64，观察一下会发生什么事情。R1的接口配置2001::FFFF/64地址后，该地址立即进入tentative状态，此时仍然是不可用的，除非该地址通过DAD检测。</li>
</ul>
<p>1.R1向链路上以组播的方式发送一个NS报文，该NS的源IPv6地址为“::”，目的IPv6地址为要进行DAD检测的2001::FFFF对应的被请求节点组播地址，也就是FF02::1:FF00:FFFF。这个NS里包含着要做DAD检测的目标地址2001::FFFF。</p>
<p>2.链路上的节点都会收到这个组播的NS报文，没有配置2001::FFFF的节点接口由于没有加入该地址对应的被请求节点组播组，因此在收到这个NS的时候默默丢弃。而R2在收到这个NS后，由于它的接口配置了2001::FFFF地址，因此接口会加入组播组FF02::1:FF00:FFFF，而此刻所收到的报文又是以该地址为目的地址，因此它会解析该报文，它发现对方进行DAD的目标地址与自己本地接口地址相同，于是立即回送一个NA报文，该报文的目的地址是FF02::1，也就是所有节点组播地址，同时在报文内写入目标地址2001::FFFF，以及自己接口的MAC地址。</p>
<p>3.当R1收到这个NA后，它就知道2001::FFFF在链路上已经有人在用了，因此将该地址标记为Duplicate（重复的），该地址将不能用于通信。</p>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/42.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/44.png"></p>
<blockquote>
<ul>
<li><p>使用IPv6地址无状态自动配置后，设备的IPv6地址无需进行手工配置，即插即用，减轻网络管理的负担。</p>
</li>
<li><p>大致的工作过程如下：</p>
<p>1.主机根据本地接口ID自动产生网卡的链路本地地址。</p>
<p>2.主机对链路本地地址进行DAD检测， 如果该地址不存在冲突则可以启用。</p>
<p>3.主机发送RS报文尝试在链路上发现IPv6路由器，该报文的源地址为主机的链路本地地址。</p>
<p>4.路由器回复RA报文（携带IPv6前缀信息，路由器在未收到RS时也能够配置主动发出RA报文）。</p>
<p>5.主机根据路由器回应的RA报文，获得IPv6地址前缀信息，使用该地址前缀，加上本地产生的接口ID，形成单播IPv6地址。</p>
<p>6.主机对生成的IPv6地址进行DAD检测，如果没有检测到冲突，那么该地址才能够启用。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/45.png"></p>
<blockquote>
<ul>
<li><p>路由器发现功能用来发现与本地链路相连的设备，并获取与地址自动配置相关的前缀和其他配置参数。</p>
</li>
<li><p>经过前面的介绍，我们已经知道IPv6地址支持无状态自动配置，即主机通过路由器发送的RA报文获取网络前缀信息，然后主机自己生成地址的接口标识部分，并自动配置IPv6地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/46.png"></p>
<blockquote>
<ul>
<li>主机如何获知网络的前缀（实际上不仅仅前缀前缀信息，还有其它的信息）呢？主要通过两个途径：被动接收到网络上路由器通告（Router Advertisement），从通告中获得；主动发送路由器请求（Router Solicitation），路由器回应路由器通告后，主机从通告中获得。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/47.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/48.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/49.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/50.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/51.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/52.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/53.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/54.png"></p>
<blockquote>
<ul>
<li>经常网关路由器发现报文从其它网关路由器转发更好，它就会发送重定向报文告知报文的发送者，让报文发送者选择另一个网关路由器。<ul>
<li>报文格式中Type为137，Code为0；</li>
<li>Target Address是更好的路径下一跳地址；</li>
<li>Destination Address是需要重定向转发的报文的目的地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/55.png"></p>
<blockquote>
<ul>
<li><p>下面是一个具体的例子，假设主机A想与主机B通讯，主机A的默认网关路由器是RTA，那么当A发送报文给B时报文会被送到RTA。</p>
</li>
<li><p>RTA接收到A发送的报文以后会发现实际上主机A直接发送给路由器RTB更好，它将发送一个ICMPv6重定向报文给主机A，其中Target Address为RTB，Destination Address为主机B。</p>
</li>
<li><p>主机A接收到了重定向报文之后，会在默认路由表中添加一个主机路由，以后发往主机B的报文就直接给RTB。</p>
</li>
<li><p>这就是重定向的一个简单过程，其中会有个问题：RTA如何知道去往主机B的路径通过RTB更好呢？其实这个很简单，因为RTA会发现报文进入的接口就是报文路由得出接口，也就是说发往主机B的路由实际上只是在RTA上转了一圈出来了，然后转发到RTB，据此，RTA能判断出直接给RTB是更好的路径。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/56.png"></p>
<blockquote>
<ul>
<li><p>前面学习的关于IPv6报文转发相关知识的时候知道，IPv6报文在转发的过程中是不进行分片操作的，当然也不进行分片报文的整合工作。IPv6报文仅在源节点进行分片，在目的节点进行组装。那么这会产生一个问题，源节点将报文到底分成多大的呢？很简单，为了所有的报文都能在路径上畅通无阻，那么分片的报文大小不能超过路径上最小的MTU，也就是PMTU——路径MTU。</p>
</li>
<li><p>RFC1981中定义了PMTU发现的机制，它是通过ICMPv6的Packet Too Big报文来完成的。首先源节点假设PMTU就是其出接口的MTU，发出报文，当转发路径上存在一个小于当前假设的PMTU时，就会向源节点发送Packet Too Big报文，并且携带自己的MTU值，此后源节点将PMTU的假设值更改为新收到的MTU值。如此反复，直到报文到达目的地之后，源节点就能知道到达某个目的地的PMTU了。</p>
</li>
<li><p>假设源到目的要先后经过4条链路，链路地MTU分别是1500、1500、1400、1300，当源发送一个分片报文的时候，首先分成1500大小的片，当到达1400的出接口时，路由器就会返回Packet Too Big错误，同时携带1400的MTU值。源接收到之后就会重新分成1400大小的片，当到达1300的出接口时，同样返回Packet Too Big错误，携带1300的MTU值。之后源重新分成1300的报文，最终到达目的地，这样就找到了该路径的PMTU。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/57.png"></p>
<blockquote>
<ul>
<li><p>值得注意的是，只有数据包超过路径上的最小MTU时，PMTU发现机制才有意义，因为如果报文很小，小于路径最小的MTU，就不可能产生Packet Too Big报文。</p>
</li>
<li><p>由于IPv6要求链路层所支持的最小MTU为1280，所以PMTU的值不会小于1280。而最大的PMTU一般由链路层决定，如果链路层是一个隧道，那么支持的PMTU可能很大。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/58.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/59.png"></p>
<blockquote>
<ul>
<li><p>IPv6与IPv4共存技术：</p>
<ul>
<li>双协议栈：<ul>
<li>IPv6节点同时支持IPv6和IPv4协议栈。</li>
</ul>
</li>
<li>隧道：<ul>
<li>IPv6报文作为IPv4的载荷，由IPv4 Internet中连接多个IPv6孤岛。</li>
</ul>
</li>
</ul>
</li>
<li><p>IPv6与IPv4互通技术：</p>
<ul>
<li>提供IPv6与IPv4互相访问的技术。</li>
<li>适用于IPv6 Internet与IPv4 Internet共存，而两者又有互相通讯的需求。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/60.png"></p>
<blockquote>
<ul>
<li><p>双栈技术是IPv4向IPv6过渡的一种有效的技术。网络中的节点同时支持IPv4和IPv6协议栈，源节点根据目的节点的不同选用不同的协议栈，而网络设备根据报文的协议类型选择不同的协议栈进行处理和转发。双栈可以在一个单一的设备上实现，也可以是一个双栈骨干网。对于双栈骨干网，其中的所有设备必须同时支持IPv4/IPv6协议栈，连接双栈网络的接口必须同时配置IPv4地址和IPv6地址。</p>
</li>
<li><p>所谓的双栈就是主机或者网络设备同时支持IPv4及IPv6双协议栈，如果节点支持双栈，那么它能够同时使用V4和V6的协议栈、同时处理IPv4及IPv6的数据。在双栈设备上，上层应用会优先选择IPv6协议栈，而不是IPv4。 比如，一个同时支持v4和v6的应用请求通过DNS请求地址，会先请求AAAA记录，如果没有，则再请求A记录。双栈是V4、V6并存及IPv6过渡技术的基础。<br> 就拿上图来说，路由器就是一个双栈设备，默认情况下路由器本身就已经支持IPv4，接口上也配置了IPv4的地址，已经能够正常转发IPv4的报文，此刻在激活路由器的IPv6数据转发能力，再为接口分配IPv6的单播地址，那么这个接口又有了IPv6数据转发能力。当然，此时对于路由器而言，IPv4及IPv6协议栈互不干扰，独立工作。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/61.png"></p>
<blockquote>
<ul>
<li><p>如果一个边界设备要与多个设备建立手动隧道，就需要在设备上配置多个隧道，配置比较麻烦。所以手动隧道通常用于两个边界路由器之间，为两个IPv6网络提供连接。</p>
</li>
<li><p>手动隧道优缺点</p>
<ul>
<li>优点：可以用于任何IPv6穿越IPv4的环境，通用性好。</li>
<li>缺点：必须手工配置。</li>
</ul>
</li>
<li><p>转发机制</p>
<ul>
<li>IPv6 over IPv4手动隧道转发机制为：当隧道边界设备的IPv6侧收到一个IPv6报文后， 根据IPv6报文的目的地址查找IPv6路由转发表，如果该报文是从此虚拟隧道接口转发出去，则根据隧道接口配置的隧道源端和目的端的IPv4地址进行封装。封装后的报文变成一个IPv4报文，交给IPv4协议栈处理。报文通过IPv4网络转发到隧道的终点。隧道终点收到一个隧道协议报文后，进行隧道解封装。并将解封装后的报文交给IPv6协议栈处理。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/62.png"></p>
<blockquote>
<ul>
<li><p>IPv6 over IPv4 GRE隧道使用标准的GRE隧道技术提供了点到点连接服务，需要手工指定隧道的端点地址。GRE隧道本身并不限制被封装的协议和传输协议，一个GRE隧道中被封装的协议可以是协议中允许的任意协议（可以是IPv4、IPv6、OSI、MPLS等）。</p>
</li>
<li><p>IPv6 over IPv4 GRE隧道在边界路由器上的传输机制和IPv6 over IPv4手动隧道相同。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/63.png"></p>
<blockquote>
<ul>
<li><p>6to4隧道也属于一种自动隧道，隧道也是使用内嵌在IPv6地址中的IPv4地址建立的。与IPv4兼容自动隧道不同，6to4自动隧道支持Router到Router、Host到Router、Router到Host、 Host到Host。</p>
</li>
<li><p>地址格式：</p>
<ul>
<li>FP：可聚合全球单播地址的格式前缀（Format Prefix），其值为001。</li>
<li>TLA：顶级聚合标识符（Top Level Aggregator），有13个比特位，其二进制值为0 0000 0000 0010。</li>
<li>SLA：站点级聚合标识符（Site Level Aggregator）。</li>
</ul>
</li>
<li><p>6to4地址可以表示为2002::/16，而一个6to4网络可以表示为2002:IPv4地址::/48。6to4地址的网络前缀长度为64bit，其中前48bit（2002: a.b.c.d）被分配给路由器上的IPv4地址决定了，用户不能改变，而后16位（SLA）是由用户自己定义的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/64.png"></p>
<blockquote>
<ul>
<li>一个IPv4地址只能用于一个6to4隧道的源地址，如果一个边界路由器连接了多个6to4网络使用同样的IPv4地址做为隧道的源地址，则使用6to4地址中的SLA ID来区分，但他们共用一个隧道。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/65.png"></p>
<blockquote>
<ul>
<li><p>普通IPv6网络需要与6to4网络通过IPv4网络互通，这可以通过6to4中继路由器方式实现。所谓6to4中继，就是通过6to4隧道转发的IPv6报文的目的地址不是6to4地址，但转发的下一跳是6to4地址，该下一跳为路由器我们称之为6to4中继。隧道的IPv4目的地址依然从下一跳的6to4地址中获得。</p>
</li>
<li><p>如果6to4网络2中的主机要与IPv6网络互通，在其边界路由器上配置路由指向的下一跳为6to4中继路由器的6to4地址，中继路由器的6to4地址是与中继路由器的6to4隧道的源地址相匹配的。6to4网络2中去往普通IPv6网络的报文都会按照路由表指示的下一跳发送到6to4中继路由器。6to4中继路由器再将此报文转发到纯IPv6网络中去。当报文返回时，6to4中继路由器根据返回报文的目的地址（为6to4地址）进行IPv4报文头封装，数据就能够顺利到达6to4网络中了。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/66.png"></p>
<blockquote>
<ul>
<li><p>ISATAP（Intra-Site Automatic Tunnel Addressing Protocol）是另外一种自动隧道技术。ISATAP隧道同样使用了内嵌IPv4地址的特殊IPv6地址形式，只是和6to4不同的是，6to4是使用IPv4地址做为网络前缀，而ISATAP用IPv4地址做为接口标识。</p>
</li>
<li><p>地址描述</p>
</li>
<li><p>如果IPv4地址是全局唯一的，则u位为1，否则u位为0。g位是IEEE 群体/个体标志。由于ISATAP是通过接口标识来表现的，所以，ISATAP地址有全局单播地址、链路本地地址、ULA地址、组播地址等形式。ISATAP地址的前64位是通过向ISATAP路由器发送请求来得到的，它可以进行地址自动配置。在ISATAP隧道的两端设备之间可以运行ND协议。ISATAP隧道将IPv4网络看作一个非广播的点到多点的链路（NBMA）。</p>
</li>
<li><p>转发过程描述：</p>
</li>
<li><p>在IPv4网络内部有两个双栈主机PC2和PC3，它们分别有一个私网IPv4地址。要使其具有ISATAP功能，需要进行如下操作：</p>
<ul>
<li>首先配置ISATAP隧道接口，这时会根据IPv4地址生成ISATAP类型的接口ID。</li>
<li>根据接口ID生成一个ISATAP链路本地IPv6地址，生成链路本地地址以后，主机就有了在本地链路上进行IPv6通信的能力。</li>
<li>进行自动配置，主机获得IPv6全球单播地址、ULA地址等。</li>
<li>当主机与其它IPv6主机进行通讯时，从隧道接口转发，将从报文的下一跳IPv6地址中取出IPv4地址作为IPv4封装的目的地址。如果目的主机在本站点内，则下一跳就是目的主机本身，如果目的主机不在本站点内，则下一跳为ISATAP路由器的地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/67.png"></p>
<blockquote>
<ul>
<li>当IPv4网络的节点需要直接与IPv6网络的节点进行通信时，默认情况下当然是行不通的，因为两个协议栈无法兼容。但是借助一台设备，由该设备来实现IPv6与IPv4的互转，那么上述通信需求就可以实现了。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/68.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/69.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/70.png"></p>
<blockquote>
<ul>
<li><p>设置对GRE报文头进行校验是一个可选的操作步骤。如果设置了对GRE报文头进行校验，则发送端根据GRE报文头和净荷信息计算校验和，然后将包含校验和的报文转发到对端。接收端收到报文后，计算接收报文的校验和，并将该校验和与报文中的校验和进行比较。如果结果一致，那么它将会继续处理此报文，否则将其丢弃。如果本端配置了校验和，但是对端没有配置校验和，那么本端不会对接收的报文进行校验和验证。</p>
</li>
<li><p>设置GRE报文头的关键字也是一个可选的操作步骤。如果设置了GRE报文头中的KEY字段，接收端将会检查接收的GRE报文头的关键字，如果与本端配置的关键字完全相同，表明验证成功，接受该报文，否则丢弃该报文。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/71.png"></p>
<blockquote>
<p>命令含义：</p>
<ul>
<li>interface tunnel命令用来创建一个Tunnel接口，并进入该Tunnel接口视图。</li>
<li>tunnel-protocol gre指定Tunnel为手动隧道模式。</li>
<li>source { ipv4-address | interface-type interface-number }指定Tunnel的源接口。</li>
<li>destination { ipv4-address }指定Tunnel的目的接口。</li>
<li>ipv6 address { ipv6-address prefix-length }设置Tunnel接口的IPv6地址。</li>
</ul>
</blockquote>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/72.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/73.png"></p>
<p><img src="/2021/07/26/IE-IPv6%E5%9F%BA%E7%A1%80/74.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/" itemprop="url">IE-WAN技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-20T22:22:43+08:00">
                2021-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/1.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/2.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/3.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/4.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/5.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/6.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/7.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/8.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/9.png"></p>
<blockquote>
<p>lT: 表示双绞线；</p>
<p>lTX：表示2对高质量的双绞线；</p>
<p>lFX：表示2根光纤。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/10.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/11.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/12.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/13.png"><br><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/14.png"></p>
<blockquote>
<p>lOC-n: Optical Carrier level n（光载体等级）是光纤传输的一种单位，最小的单位为OC-1，其传输数据量约为51.84 Mbps。</p>
<p>lSTM: Synchronous Transport Module，同步传输模块。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/15.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/16.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/17.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/18.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/19.png"></p>
<blockquote>
<ul>
<li><p>PPP共定义了三个协议组件，分别是数据封装方式，链路控制协议（Link Control Protocol，LCP）和网络层控制协议（Network Control Protocol，NCP）。</p>
</li>
<li><p>数据封装方式定义了如何封装多种类型的上层协议数据包。</p>
</li>
<li><p>为了能适应多种多样的链路类型，PPP定义了链路控制协议LCP。LCP可以自动检测链路环境，如是否存在环路；协商链路参数，如最大数据包长度，使用何种认证协议等等。与其他数据链路层协议相比，PPP协议的一个重要特点是可以提供认证功能，链路两端可以协商使用何种认证协议并实施认证过程，只有认证成功才会建立连接。这个特点使PPP协议适合运营商用来接入分散的用户。</p>
</li>
<li><p>PPP定义了一组网络层控制协议NCP，每一个协议对应一种网络层协议，用于协商网络层地址等参数，例如IPCP用于协商控制IP，IPXCP用于协商控制IPX协议等。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/20.png"></p>
<blockquote>
<p>PPP报文封转格式</p>
<ul>
<li><p>Flag域</p>
<ul>
<li>Flag域标识一个物理帧的起始和结束，该字节为0x7E。</li>
</ul>
</li>
<li><p>Address域</p>
<ul>
<li>Address域可以唯一标识对端。PPP协议是被运用在点对点的链路上，因此，使用PPP协议互连的两个通信设备无须知道对方的数据链路层地址。按照协议的规定将该字节填充为全1的广播地址，对于PPP协议来说，该字段无实际意义。</li>
</ul>
</li>
<li><p>Control域</p>
<ul>
<li>该字段默认值为0x03，表明为无序号帧，PPP默认没有采用序列号和确认来实现可靠传输。</li>
<li>Address和Control域一起标识此报文为PPP报文，即PPP报文头为FF03。</li>
</ul>
</li>
<li><p>Protocol域</p>
<ul>
<li>协议域可用来区分PPP数据帧中信息域所承载的数据报类型。</li>
</ul>
</li>
<li><p>Code域</p>
<ul>
<li>代码域的长度为一个字节，主要是用来标识LCP数据报文的类型。</li>
</ul>
</li>
<li><p>Identifier域</p>
<ul>
<li>标识域为1个字节，用来匹配请求和响应，当标识域值为非法时，该报文将被丢弃。</li>
<li>通常一个配置请求报文的ID是从0x01开始逐步加1的。当对端接收到该配置请求报文后，无论使用何种报文回应对方，但必须要求回应报文中的ID要与接收报文中的ID一致。</li>
</ul>
</li>
<li><p>Length域</p>
<ul>
<li>长度域的值就是该LCP报文的总字节数据。它是代码域、标志域、长度域和数据域四个域长度的总和。</li>
<li>长度域所指示字节数之外的字节将被当作填充字节而忽略掉，而且该域的内容不能超过MRU的值。</li>
</ul>
</li>
<li><p>Data域</p>
<ul>
<li>Type为协商选项类型。</li>
<li>Length为协商选项长度，它是指Data域的总长度，也就是包含Type、Length和Data。</li>
<li>Data为协商的选项具体内容。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/22.png"></p>
<blockquote>
<p>建链过程</p>
<ul>
<li>Dead：这是PPP工作开始和结束的阶段。当物理层变为可用状态（UP）之后，PPP进入Establish阶段。</li>
<li>Establish：PPP在此阶段使用LCP协商链路层参数。如果链路层参数协商不成功（FAIL），则PPP连接建立不成功，PPP退回到Dead阶段。如果链路层参数协商成功（OPENED），则PPP进入Authenticate阶段。</li>
<li>Authenticate：PPP在此阶段认证对端，如果认证失败（FAIL），则PPP进入Terminate阶段；如果认证成功（SUCCESS）或者没配置认证（NONE），则PPP进入Network阶段。</li>
<li>Network：PPP在此阶段使用NCP进行网络层参数协商，协商成功则PPP连接建立成功，开始传输网络层数据包。当上层协议认为应当关闭此连接（例如按需电路）或者管理员手工关闭PPP连接（CLOSING），则PPP进入Terminate阶段。</li>
<li>Terminate：PPP在此阶段使用LCP关闭PPP连接。PPP连接关闭（Down）后，PPP进入Dead阶段。</li>
</ul>
<p>注意：此处列出的是PPP的工作阶段，并非PPP的协议状态。由于PPP是由一组协议组成的，因此PPP本身没有协议状态。只有特定的的协议如LCP和NCP等才有协议状态和状态转换（协议状态机）。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/23.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/24.png"></p>
<blockquote>
<ul>
<li><p>LCP协议有3大类报文：</p>
<p>1.链路配置包，用于建立和配置链路：Configure-Request（匹配请求），Configure-Ack（匹配确认），Configure-Nak（匹配否认），和Configure-Reject（匹配拒绝）。</p>
<p>2.链路结束包，用于结束一个链路：Terminate-Request（终止请求） 和 Terminate-Ack（终止确认）。</p>
<p>3.链路维修包，用于管理和调试一个链路：Code-Reject（代码拒绝）, Protocol-Reject（协议拒绝）, Echo-Request（回波请求）, Echo-Reply（回波应答）, 和 Discard-Request（抛弃请求）。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/25.png"></p>
<blockquote>
<ul>
<li>用于协商的参数<ul>
<li>在VRP平台上，MRU参数使用接口上配置的最大传输单元（MTU）值来表示的。</li>
<li>常用的PPP认证协议有PAP和CHAP（后续章节介绍），一条PPP链路的两端可以使用不同的认证协议认证对端，但是被认证方必须支持认证方使用的认证协议并正确配置用户名和密码等认证信息。</li>
<li>LCP使用魔术字（Magic-Number）检测链路环路和其它异常情况。魔术字为随机产生的一个数字，随机机制需要保证两端产生相同魔术字的可能性几乎为0。</li>
<li>收到一个Configure-Request报文之后，其包含的魔术字需要和本地产生的魔术字做比较，如果不同，表示链路无环路，则使用Confugure-Ack报文确认（其他参数也协商成功），表示魔术字协商成功。在后续发送的报文中，如果报文含有魔术字字段，则该字段设置为协商成功的魔术字，LCP不再产生新的魔术字。</li>
<li>如果收到的Configure-Request报文和自身产生的魔术字相同，则发送一个Configure-Nak报文，携带一个新的魔术字。然后，不管新收到的Configure-Nak报文中是否携带相同的魔术字，LCP都发送一个新的Configure-Request报文，携带一个新的魔术字。如果链路有环路，则这个过程会不停的持续下去，如果链路没有环路，则报文交互会很快恢复正常。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/26.png"></p>
<blockquote>
<ul>
<li><p>链路协商成功</p>
<ul>
<li>如图所示，R1和R2使用串行链路相连，运行PPP。当物理层链路变为可用状态之后，R1和R2使用LCP协商链路参数。本例中，R1首先发送一个LCP报文。</li>
<li>R1向R2发送Configure-Request报文，此报文包含在发送者（R1）上配置的链路层参数，每个链路层参数使用“类型，长度，取值”的结构表示。</li>
<li>当R2收到此Configure-Request报文之后，如果R2能识别此报文中的所有链路层参数，并且认为每个参数的取值都是可以接受的，则向R1回应一个Configure-Ack报文。</li>
<li>在没有收到Configure-Ack报文的情况下，每隔3秒重传一次Configure-Request报文，如果连续10次发送Configure-Request报文仍然没有收到Configure-Ack报文，则认为对端不可用，停止发送Configure-Request报文。</li>
</ul>
</li>
<li><p>注：完成上述过程只是表明R2认为R1上的链路参数配置是可接受的。R2也需要向R1发送Configure-Request报文，使R1检测R2上的链路参数配置是不是可接受的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/27.png"></p>
<blockquote>
<ul>
<li>链路协商参数不成功</li>
<li>当R2收到R1发送的Configure-Request报文之后，如果R2能识别此报文中携带的所有链路层参数，但是认为部分或全部参数的取值不能接受，即参数的取值协商不成功，则R2需要向R1回应一个Configure-Nak报文。</li>
<li>在这个Configure-Nak报文中，只包含不能接受的那部分链路层参数列表，每一个包含在此报文中链路层参数的取值均被修改为此报文的发送者（R2）上可以接受的取值（或取值范围）。</li>
<li>在收到Configure-Nak报文之后，R1需要根据此报文中的链路层参数重新选择本地使用的相关参数，并重新发送一个Configure-Request。</li>
<li>连续五次协商仍然不成功的参数将被禁用，不再继续协商。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/28.png"></p>
<blockquote>
<ul>
<li>链路参数协商参数不能识别<ul>
<li>当R2收到R1发送的Configure-Request报文之后，如果R2不能识别此报文中携带的部分或全部链路层参数，则R2需要向R1回应一个Configure-Reject报文。</li>
<li>在此Configure-Reject报文中，只包含不被识别的那部分链路层参数列表。</li>
<li>在收到Configure-Reject报文之后，R1需要向R2重新发送一个Configure-Request报文，在新的Configure-Request报文中，不再包含不被对端（R2）识别的参数。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/29.png"></p>
<blockquote>
<ul>
<li>检测链路状态<ul>
<li>LCP建立连接之后，可以使用Echo-Request报文和Echo-Reply报文检测链路状态，收到一个Echo-Request报文之后应当回应一个Echo-Reply报文，表示链路状态正常。</li>
<li>VRP平台默认每隔10秒发送一次Echo-Request报文。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/30.png"></p>
<blockquote>
<ul>
<li>连接关闭<ul>
<li>认证不成功或者管理员手工关闭等原因可以使LCP关闭已经建立的连接。</li>
<li>LCP关闭连接使用Terminate-Request报文和Terminate-Ack报文，Terminate-Request报文用于请求对端关闭连接，一旦收到一个Terminate-Request报文，LCP必须回应一个Terminate-Ack报文确认连接关闭。</li>
<li>在没有收到Terminate-Ack报文的情况下，每隔3秒重传一次Terminate-Request报文，连续两次重传没有收到Terminate-Ack报文，则认为对端不可用，连接关闭。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/31.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/32.png"></p>
<blockquote>
<p>lPAP报文直接封装在PPP报文中。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/33.png"></p>
<blockquote>
<ul>
<li>PAP工作模式<ul>
<li>被认证方将配置的用户名和密码信息使用Authenticate-Request报文以明文方式发送给认证方，本例中，用户名为“huawei”，密码为“hello”；</li>
<li>认证方收到被认证方发送的用户名和密码信息之后，根据本地配置的用户名和密码数据库检查用户名和密码信息是否正确匹配，如果正确，则返回Authenticate-Ack报文，表示认证成功，如果不能正确匹配，则返回Authenticate-Nak报文，表示认证失败。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/34.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/35.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/36.png"></p>
<blockquote>
<ul>
<li><p>CHAP的认证过程需要三次报文的交互。为了匹配请求报文和回应报文，报文中含有Identifier字段，一次认证过程所使用的报文均使用相同的Identifier信息。CHAP单向验证过程分为两种情况：验证方配置了用户名和验证方没有配置用户名。推荐使用验证方配置用户名的方式，这样可以对验证方的用户名进行确认。</p>
</li>
<li><p>验证方配置了用户名的验证过程（即接口配置命令ppp chap user username）：</p>
<ul>
<li>验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge），并同时将本端的用户名附带上一起发送给被验证方。</li>
<li>被验证方接到验证方的验证请求后，先检查本端接口上是否配置了ppp chap password命令，如果配置了该命令，则被验证方将生成的密文（（Identifier＋密码＋随机数）的MD5）和自己的用户名发回验证方（Response）。如果接口上未配置ppp chap password命令，则根据此报文中验证方的用户名在本端的用户表查找该用户对应的密码，将密文（（Identifier＋密码＋随机数）的MD5）和被验证方自己的用户名发回验证方（Response）。</li>
<li>验证方将自己本身保存的密码、Identifier和随机数进行MD5算法，和收到respone中的密文进行比较，以验证认证是否正确。</li>
</ul>
</li>
<li><p>验证方没有配置用户名（即接口没有配置命令ppp chap user username）：</p>
<ul>
<li>验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge）。</li>
<li>被验证方接到验证方的验证请求后，利用Identifier、ppp chap password命令配置的CHAP密码和随机数进行MD5算法，将生成的密文和自己的用户名发回验证方（Response）。</li>
<li>验证方将自己本身保存的密码、Identifier和随机数进行MD5算法，和收到respone中的密文进行比较，以验证认证是否正确。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/37.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/38.png"></p>
<blockquote>
<ul>
<li><p>IPCP，用于协商控制IP参数，使PPP可用于传输IP数据包。</p>
</li>
<li><p>IPCP使用和LCP相同的协商机制、报文类型，但IPCP并非调用LCP，只是工作过程、报文等和LCP相同。</p>
<ul>
<li>两端配置的IP地址分别为12.1.1.1/24和12.1.1.2/24（两端IP地址即使不在同一网段也会通过IPCP协商）。</li>
<li>两端静态配置IP地址的时候协商过程如下：<ul>
<li>R1和R2都要发送Configure-Request报文，在此报文中包含本地配置的IP地址。</li>
<li>R1和R2接收到对端的Configure-Request报文之后，检查其中的IP地址，如果IP地址是一个合法的单播IP地址，而且和本地配置的IP地址不同（没有IP冲突），则认为对端可以使用该地址，回应一个Configure-Ack报文。</li>
<li>通过IPCP发送的信息，PPP链路的两端都可以知道对端使用的32位IP地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/39.png"></p>
<blockquote>
<ul>
<li><p>如图所示，R1配置为请求对端分配IP地址，R2配置IP地址12.1.1.2/24，并且启用R2给对端分配IP地址的能力，给R1分配IP地址12.1.1.1。</p>
</li>
<li><p>两端动态协商IP地址的过程如下：</p>
<ul>
<li>R1向R2发送一个Configure-Request报文，此报文中含有IP地址0.0.0.0，一个含有0.0.0.0的IP地址的Configure-Request报文表示向对端请求IP地址；</li>
<li>R2收到上述Configure-Request报文后，认为其中包含的地址（0.0.0.0）不合法，使用Configure-Nak回应一个新的IP地址12.1.1.1；</li>
<li>R1收到此Configure-Nak报文之后，更新本地IP地址，并重新发送一个Configure-Request报文，包含新的IP地址12.1.1.1；</li>
<li>R2收到Configure-Request报文后，认为其中包含的IP地址为合法地址，回应一个Configure-Ack报文；</li>
<li>同时，R2也要向R1发送Configure-Request报文请求使用地址12.1.1.2，R1认为此地址合法，回应Configure-Ack报文。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/40.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/41.png"></p>
<blockquote>
<p>MultiLink PPP允许将报文分片，分片将从多个点对点链路上送到同一个目的地。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/42.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/43.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>ppp authentication-mode命令用来设置本端PPP协议对对端设备的认证方式。</li>
<li>ppp chap user命令用来配置CHAP验证的用户名。</li>
<li>ppp chap password命令用来配置CHAP验证的口令。</li>
<li>ip address ppp-negotiate命令用来为本端接口配置IP地址可协商属性，使本端接口接受PPP协商产生的由对端分配的IP地址。</li>
<li>remote address命令用来配置为对端分配IP地址或指定地址池。</li>
</ul>
</li>
<li><p>ppp authentication-mode { chap | pap }</p>
<ul>
<li>chap：采用CHAP认证方式。</li>
<li>pap：采用PAP认证方式。</li>
</ul>
</li>
<li><p>ppp chap user username</p>
<ul>
<li>username：设置CHAP验证的用户名。</li>
</ul>
</li>
<li><p>ppp chap password { cipher | simple } password</p>
<ul>
<li>cipher：表示密码为密文显示。</li>
<li>simple：表示密码为明文显示。</li>
<li>password：设置CHAP认证的口令。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/44.png"></p>
<blockquote>
<ul>
<li>命令含义<ul>
<li>interface mp-group命令用来创建一个MP-Group类型的接口并进入MP-Group接口视图。</li>
<li>ppp mp mp-group命令用来将接口加入指定的MP-group，使该接口工作在MP方式。</li>
<li>restart命令用来重新启动当前接口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/45.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/46.png"></p>
<blockquote>
<ul>
<li>Trunk接口分为Eth-Trunk和IP-Trunk两种。<ul>
<li>Eth-Trunk只能由以太网链路构成。</li>
<li>IP-Trunk一般由POS接口构成。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/47.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/48.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/49.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/50.png"></p>
<blockquote>
<ul>
<li>PPPoE概述<ul>
<li>PPPoE利用以太网将大量主机组成网络，通过一个远端接入设备连入因特网，并运用PPP协议对接入的每个主机进行控制，具有适用范围广、安全性高、计费方便的特点。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/51.png"></p>
<blockquote>
<ul>
<li><p>PPPoE可分为三个阶段，即Discovery阶段、Session阶段和Terminate阶段。</p>
</li>
<li><p>Discovery阶段：</p>
<ul>
<li>PPPoE Client广播发送一个PADI（PPPoE Active Discovery Initial）报文，在此报文中包含PPPoE Client想要得到的服务类型信息。</li>
<li>所有的PPPoE Server收到PADI报文之后，将其中请求的服务与自己能够提供的服务进行比较，如果可以提供，则单播回复一个PADO（PPPoE Active Discovery Offer）报文。</li>
<li>根据网络的拓扑结构，PPPoE Client可能收到多个PPPoE Server发送的PADO报文，PPPoE Client选择最先收到的PADO报文对应的PPPoE Server做为自己的PPPoE Server，并单播发送一个PADR（PPPoE Active Discovery Request）报文。</li>
<li>PPPoE Server产生一个唯一的会话ID（Session ID），标识和PPPoE Client的这个会话，通过发送一个PADS（PPPoE Active Discovery Session-confirmation）报文把会话ID发送给PPPoE Client，会话建立成功后便进入PPPoE Session阶段。</li>
<li>完成后通信双方都会知道PPPoE的Session_ID及对方MAC，它们共同确定唯一的PPPoE Session。</li>
</ul>
</li>
<li><p>Seesion阶段：</p>
<ul>
<li>PPPoE Session上的PPP协商和普通的PPP协商方式一致。PPPoE Session的PPP协商成功后，就可以承载PPP数据报文。在PPPoE Session阶段所有的以太网数据包都是单播发送的。</li>
</ul>
</li>
<li><p>Terminate阶段：</p>
<ul>
<li>进入PPPoE Session阶段后，PPPoE Client和PPPoE Server都可以通过发送PADT报文的方式来结束PPPoE连接。PADT数据包可以在会话建立以后的任意时刻单播发送。在发送或接收到PADT后，就不允许再使用该会话发送PPP流量了。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/52.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/53.png"></p>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/54.png"></p>
<blockquote>
<p>此例中，R1模拟PPPoE客户机PC进行PPPoE拨号上网，R4作为PPPoE Server对其进行验证和地址分配。</p>
</blockquote>
<p><img src="/2021/07/20/IE-WAN%E6%8A%80%E6%9C%AF/55.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/" itemprop="url">IE-LAN技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-20T17:56:08+08:00">
                2021-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%871.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%872.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%873.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%874.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%875.png"></p>
<blockquote>
<p>MAC地址表的定义</p>
<ul>
<li>MAC地址表记录了交换机学习到的其他设备的MAC地址与接口的对应关系，以及接口所属VLAN等信息。设备在转发报文时，根据报文的目的MAC地址查询MAC地址表，如果MAC地址表中包含与报文目的MAC地址对应的表项，则直接通过该表项中的出接口转发该报文；如果MAC地址表中没有包含报文目的MAC地址对应的表项时，设备将采取广播方式在所属VLAN内除接收接口外的所有接口转发该报文。</li>
</ul>
<p>MAC地址表中的表项分为：动态表项、静态表项和黑洞表项。</p>
<ul>
<li><p>动态表项：由接口通过报文中的源MAC地址学习获得，表项可老化。在系统复位、接口板热插拔或接口板复位后，动态表项会丢失。可以通过查看动态MAC地址表项，可以判断两台相连设备之间是否有数据转发；也可以通过查看指定动态MAC地址表项的个数，可以获取接口下通信的用户数。</p>
</li>
<li><p>静态表项：由用户手工配置，并下发到各接口板，表项不可老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。一条静态MAC地址表项，只能绑定一个出接口。一个接口和MAC地址静态绑定后，不会影响该接口动态MAC地址表项的学习。通过绑定静态MAC地址表项，可以保证合法用户的使用，防止其他用户使用该MAC进行攻击。</p>
</li>
<li><p>黑洞表项：由用户手工配置，并下发到各接口板，表项不可老化。在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。通过配置黑洞MAC地址表项，可以过滤掉非法用户。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%876.png"></p>
<blockquote>
<p>通过“display mac-address”命令，可以查看设备的mac表项，如图所示，mac表的组成可以分为动态、静态和黑洞。从表项中也可以看出，mac地址所对应的VLAN以及VSI。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%877.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%878.png"><br><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%879.png"></p>
<blockquote>
<ul>
<li><p>接口使能端口安全功能时，接口上之前学习到的动态MAC地址表项将被删除，之后学习到的MAC地址将变为安全动态MAC地址。</p>
</li>
<li><p>接口使能Sticky MAC功能时，接口上的安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>接口去使能端口安全功能时，接口上的安全动态MAC地址将被删除，重新学习动态MAC地址。</p>
</li>
<li><p>接口去使能Sticky MAC功能时，接口上的Sticky MAC地址，会转换为安全动态MAC地址。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8710.png"></p>
<blockquote>
<p>说明：</p>
<ul>
<li><p>接口使能Sticky MAC功能，安全动态MAC地址表项将转化为Sticky MAC地址，之后学习到的MAC地址也变为Sticky MAC地址。</p>
</li>
<li><p>接口使能Sticky MAC功能，即使配置了port-security aging-time，Sticky MAC也不会被老化。</p>
</li>
<li><p>Sticky MAC地址表项，保存后重启设备不丢弃。</p>
</li>
</ul>
<p>端口安全的保护动作：</p>
<ul>
<li><p>Restrict：丢弃源MAC地址不存在的报文并上报告警。推荐使用restrict动作。</p>
</li>
<li><p>Protect：只丢弃源MAC地址不存在的报文，不上报告警。</p>
</li>
<li><p>Shutdown：接口状态被置为error-down，并上报告警。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8711.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8712.png"></p>
<blockquote>
<ul>
<li><p>如图所示，MAC地址为0011-0022-0034的表项，出接口由GE1/0/1刷新为GE1/0/2，这就是MAC地址漂移。设备出现MAC地址漂移时，设备CPU占用率会有不同程度的升高。正常情况下，网络中不会在短时间内出现大量MAC地址漂移的情况。出现这种现象一般都意味着网络中存在环路，可以通过查看告警信息和漂移记录，快速定位和排除环路。</p>
</li>
<li><p>网络中产生环路或非法用户进行网络攻击都会造成MAC地址发生漂移，导致MAC地址不稳定。在规划网络时，可以通过下面两种方式来避免这种情况：</p>
<ul>
<li>提高接口MAC地址学习优先级。当不同接口学到相同的MAC地址表项时，高优先级接口学到的MAC地址表项可以覆盖低优先级接口学到的MAC地址表项，防止MAC地址在接口间发生漂移。</li>
<li>不允许相同优先级的接口发生MAC地址表项覆盖。当伪造网络设备所连接口的优先级与安全的网络设备相同时，后学习到的伪造网络设备的MAC地址表项不会覆盖之前正确的表项。但如果网络设备下电，仍会学习到伪造网络设备的MAC地址，当网络设备再次上电时将无法学习到正确的MAC地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8713.png"></p>
<blockquote>
<ul>
<li><p>配置MAC地址漂移检测功能后，在发生MAC地址漂移时，可以上报包括MAC地址、VLAN，以及跳变的接口等信息的告警。其中跳变的接口即为可能出现环路的接口。网络管理员可以根据告警信息，手工排查网络中环路的源头，也可以使用MAC漂移检测提供的后续动作，使跳变的端口down或者VLAN从端口中退出，实现自动破环。</p>
</li>
<li><p>如图所示网络中，若SwitchC和SwitchD之间误接网线，则SwitchB、SwitchC、SwitchD之间形成环路。当SwitchA上Port1接口从网络中收到一个广播报文后转发给SwitchB，该报文经过环路，会被SwitchA上Port2接口收到。配置MAC地址漂移检测功能，SwitchA就会感知到MAC地址出接口跳变的现象。若连续出现此现象，SwitchA就会上报MAC漂移告警，提醒管理员进行维护。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8714.png"></p>
<blockquote>
<ul>
<li><p>接口配置不同的MAC地址学习优先级后，如果不同接口学到相同的MAC地址表项，那么高优先级接口学到的MAC地址表项可以覆盖低优先级接口学到的MAC地址表项，防止MAC地址发生漂移。</p>
</li>
<li><p>配置不允许相同优先级的接口发生MAC地址表项覆盖，也可以防止MAC地址漂移，提高网络的安全性。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8715.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8716.png"></p>
<blockquote>
<p>免费ARP有如下作用：</p>
<ul>
<li>IP地址冲突检测：当设备接口的协议状态变为Up时，设备主动对外发送免费ARP报文。正常情况下不会收到ARP应答，如果收到，则表明本网络中存在与自身IP地址重复的地址。如果检测到IP地址冲突，设备会周期性的广播发送免费ARP应答报文，直到冲突解除。</li>
<li>用于通告一个新的MAC地址：发送方更换了网卡，MAC地址变化了，为了能够在动态ARP表项老化前通告网络中其他设备，发送方可以发送一个免费ARP。</li>
<li>在VRRP备份组中用来通告主备发生变换：发生主备变换后，MASTER设备会广播发送一个免费ARP报文来通告发生了主备变换。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8717.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8718.png"></p>
<blockquote>
<ul>
<li><p>在STP和RSTP的算法中，所有VLAN共享一课生成树，会造成部分VLAN无法通信、次优路径、流量无法负载分担等问题。</p>
</li>
<li><p>为了弥补STP和RSTP的缺陷，IEEE于2002年发布的802.1S标准定义了MSTP。MSTP兼容STP和RSTP，既可以快速收敛，又提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8719.png"></p>
<blockquote>
<ul>
<li><p>所谓生成树实例就是多个VLAN的一个集合。通过将多个VLAN捆绑到一个实例，可以节省通信开销和资源占用率。MSTP各个实例拓扑的计算相互独立，在这些实例上可以实现负载均衡。可以把多个相同拓扑结构的VLAN映射到一个实例里，这些VLAN在端口上的转发状态取决于端口在对应MSTP实例的状态。</p>
</li>
<li><p>如图所示，MSTP通过设置VLAN映射表（即VLAN和MSTI的对应关系表），把VLAN和MSTI联系起来。每个VLAN只能对应一个MSTI，即同一VLAN的数据只能在一个MSTI中传输，而一个MSTI可能对应多个VLAN。</p>
</li>
<li><p>经计算，最终生成两棵生成树：</p>
<ul>
<li>MSTI1以S4为根交换设备，转发VLAN2的报文。</li>
<li>MSTI2以S6为根交换设备，转发VLAN3的报文。</li>
</ul>
</li>
<li><p>这样所有VLAN内部可以互通，同时不同VLAN的报文沿不同的路径转发，实现了负载分担。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8720.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8721.png"></p>
<blockquote>
<ul>
<li><p>MST由交换网络中的多台交换设备以及它们间的网段所构成。MSTI是MST域下实例，一个MST域下可以有多个MSTI。</p>
</li>
<li><p>VLAN映射表描述了VLAN和MSTI之间的映射关系。如图2所示，MST Region4中，VLAN1映射到MSTI1，VLAN2映射到MSTI2，其余VLAN映射到MSTI3。</p>
</li>
<li><p>公共生成树CST是连接交换网络内所有MST域的一棵生成树。如果把每个MST域看作是一个节点，CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树。</p>
</li>
<li><p>内部生成树IST（Internal Spanning Tree）是各MST域内的一棵生成树。IST是一个特殊的MSTI，MSTI的ID为0，通常称为MSTI0。</p>
</li>
<li><p>SST（Single Spanning Tree）：运行STP或RSTP的交换设备只能属于一个生成树；MST域中只有一个交换设备，这个交换设备构成单生成树。</p>
</li>
<li><p>所有MST域的IST加上CST就构成一棵完整的生成树，即CIST。</p>
</li>
<li><p>域根（Regional Root）分为IST域根和MSTI域根。</p>
<ul>
<li>IST域根如图1所示，在MST域中IST生成树中距离总根最近的交换设备是IST域根。</li>
<li>一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI。MSTI域根是每个多生成树实例的树根。如图3所示，域中不同的MSTI有各自的域根。</li>
</ul>
</li>
<li><p>总根是CIST（Common and Internal Spanning Tree）的根桥。如图1中的S1。</p>
</li>
<li><p>主桥（Master Bridge）也就是IST Master，它是域内距离总根最近的交换设备。如图1中的黄色交换机。如果总根在MST域中，则总根为该域的主桥。</p>
</li>
<li><p>端口角色：同RSTP，MSTP中定义了根端口、指定端口、Alternate端口、Backup端口和边缘端口。</p>
</li>
<li><p>端口状态：同RSTP，MSTP定义的端口状态有Forwarding, Learning, Discarding。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8722.png"></p>
<blockquote>
<p>MSTI的特点：</p>
<ul>
<li>每个MSTI独立计算自己的生成树，互不干扰。</li>
<li>每个MSTI的生成树计算方法与STP基本相同。</li>
<li>每个MSTI的生成树可以有不同的根，不同的拓扑。</li>
<li>每个MSTI在自己的生成树内发送BPDU。</li>
<li>每个MSTI的拓扑通过命令配置决定。</li>
<li>每个端口在不同MSTI上的生成树参数可以不同。</li>
<li>每个端口在不同MSTI上的角色、状态可以不同。</li>
</ul>
<p>在运行MSTP协议的网络中，一个VLAN报文将沿着如下路径进行转发：</p>
<ul>
<li><p>在MST域内，沿着其对应的MSTI转发。</p>
</li>
<li><p>在MST域间，沿着CST转发。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8723.png"></p>
<blockquote>
<ul>
<li><p>如图所示，在MSTP中，P/A机制工作过程如下：</p>
<p>1.上游设备发送Proposal报文，请求进行快速迁移。下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口。</p>
<p>2.上游设备继续发送Agreement报文。下游设备接收到后，根端口转为Forwarding状态。</p>
<p>3.下游设备回应Agreement报文。上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。</p>
</li>
<li><p>缺省情况下，华为数据通信设备使用增强的快速迁移机制。如果华为数据通信设备和其他制造商的设备进行互通，而其他制造商的设备P/A机制使用普通的快速迁移机制，此时，可在华为数据通信设备上通过设置P/A机制为普通的快速迁移机制，从而实现华为数据通信设备和其他制造商的设备进行互通。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8724.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8725.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8726.png"></p>
<blockquote>
<ul>
<li><p>如图所示，为园区网络CSS+iStack组网之一，其主要有简单、高效、可靠的特点。</p>
</li>
<li><p>简单</p>
<ul>
<li>各层设备均使用堆叠技术，逻辑设备少，网络拓扑简单，二层天然无环，无需部署xSTP破环协议。</li>
</ul>
</li>
<li><p>高效</p>
<ul>
<li>各层设备间使用Eth-Trunk链路聚合技术，负载分担算法灵活，链路利用率高。</li>
</ul>
</li>
<li><p>可靠</p>
<ul>
<li>服务器和主机可以配置多NIC网卡Teaming负载均衡或主备冗余链路提高服务器接入可靠性。</li>
<li>堆叠技术同链路聚合技术结合使用，各层物理设备形成双归接入组网，提高整网可靠性。</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><p>对设备性能要求较高，盒式设备堆叠台数过多，可能导致堆叠主的主控性能下降。</p>
</li>
<li><p>如果采用业务口堆叠或集群，会占用业务端口数。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8727.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8728.png"></p>
<blockquote>
<ul>
<li>通过交换机堆叠，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。<ul>
<li>高可靠性。堆叠系统多台成员交换机之间冗余备份；堆叠支持跨设备的链路聚合功能，实现跨设备的链路冗余备份。</li>
<li>强大的网络扩展能力。通过增加成员交换机，可以轻松的扩展堆叠系统的端口数、带宽和处理能力；同时支持成员交换机热插拔，新加入的成员交换机自动同步主交换机的配置文件和系统软件版本。</li>
<li>简化配置和管理。一方面，用户可以通过任何一台成员交换机登录堆叠系统，对堆叠系统所有成员交换机进行统一配置和管理；另一方面，堆叠形成后，不需要配置复杂的二层破环协议和三层保护倒换协议，简化了网络配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8729.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8730.png"></p>
<blockquote>
<ul>
<li><p>“系统自动完成堆叠”实际上可以细分为三步：</p>
<p>1.主交换机选举</p>
<p>​    ①运行状态比较，已经运行的交换机比处于启动状态的交换机优先竞争为主交换机。</p>
<p>​    ②堆叠优先级高的交换机优先竞争为主交换机。</p>
<p>​    ③堆叠优先级相同时，MAC地址小的交换机优先竞争为主交换机。</p>
<p>2.拓扑收集和备交换机选举</p>
<ul>
<li>主交换机选举完成后，主交换机会收集所有成员交换机的拓扑信息，根据拓扑信息计算出堆叠转发表项和破环点信息下发给堆叠中的所有成员交换机，并向所有成员交换机分配堆叠ID。之后进行备交换机的选举，作为主交换机的备份交换机。当除主交换机外其它交换机同时完成启动时：<ul>
<li>堆叠优先级最高的设备成为备交换机。</li>
<li>堆叠优先级相同时，MAC地址最小的成为备交换机。</li>
</ul>
</li>
</ul>
<p>3.稳定运行</p>
<ul>
<li>角色选举、拓扑收集完成之后，剩下的其他成员交换机作为从交换机加入堆叠，所有成员交换机会自动同步主交换机的系统软件和配置文件：<ul>
<li>堆叠具有自动加载系统软件的功能，待组成堆叠的成员交换机不需要具有相同软件版本，只需要版本间兼容即可。当备交换机或从交换机与主交换机的软件版本不一致时，备交换机或从交换机会自动从主交换机下载系统软件，然后使用新系统软件重启，并重新加入堆叠。</li>
<li>堆叠具有配置文件同步机制，备交换机或从交换机会将主交换机的配置文件同步到本设备并执行，以保证堆叠中的多台设备能够像一台设备一样在网络中工作，并且在主交换机出现故障之后，其余交换机仍能够正常执行各项功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8731.png"></p>
<blockquote>
<ul>
<li><p>物理成员端口</p>
<ul>
<li>成员交换机之间用于堆叠连接的物理端口。物理成员端口用于转发需要跨成员交换机的业务报文或成员交换机之间的堆叠协议报文。</li>
</ul>
</li>
<li><p>逻辑堆叠端口</p>
<ul>
<li>逻辑堆叠端口是专用于堆叠的逻辑端口，需要和物理成员端口绑定。堆叠的每台成员交换机上支持两个逻辑堆叠端口，分别为stack-port n/1和stack-port n/2，其中n为成员交换机的堆叠ID。</li>
</ul>
</li>
<li><p>业务口堆叠根据连接线缆的不同又可以分为：普通线缆堆叠和专用线缆堆叠。</p>
<ul>
<li>普通线缆堆叠<ul>
<li>普通堆叠线缆包括：光线缆、网线和高速电缆。使用普通线缆堆叠时，逻辑堆叠端口需要手动进行配置，否则无法组建堆叠。</li>
</ul>
</li>
<li>专用线缆堆叠<ul>
<li>专用堆叠线缆的两端区分主和备，带有Master标签的一端为主端，不带有标签的一端为备端。使用专用线缆堆叠时，专用堆叠线缆按照规则插入端口后，交换机就可以自动组建堆叠。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8732.png"></p>
<blockquote>
<ul>
<li><p>堆叠成员加入是指向已经稳定运行的堆叠系统添加一台新的交换机。</p>
</li>
<li><p>使能堆叠并配置好SWD的堆叠参数</p>
<ul>
<li>如果是业务口堆叠，新加入的交换机需要配置物理成员端口加入逻辑堆叠端口；并且链形连接时，当前堆叠系统链形两端（或一端）的成员交换机也需要配置物理成员端口加入逻辑堆叠口。</li>
<li>如果是堆叠卡堆叠，新加入的成员交换机需要使能堆叠功能。</li>
<li>为了便于管理，建议为新加入的交换机配置堆叠ID。如果不配置，堆叠系统会为其分配一个堆叠ID。</li>
</ul>
</li>
<li><p>将SWD连接到堆叠系统</p>
<ul>
<li>如果是链形连接，新加入的交换机建议添加到链形的两端，这样对现有的业务影响最小。</li>
<li>如果是环形连接，需要把当前环形拆成链形，然后在链形的两端添加设备。</li>
</ul>
</li>
<li><p>系统完成堆叠</p>
<p>1.新加入的交换机连线上电启动后，进行角色选举，新加入的交换机会选举为从交换机，堆叠系统中原有主备从角色不变。</p>
<p>2.角色选举结束后，主交换机更新堆叠拓扑信息，同步到其他成员交换机上，并向新加入的交换机分配堆叠ID（新加入的交换机没有配置堆叠ID或配置的堆叠ID与原堆叠系统的冲突时）。</p>
<p>3.新加入的交换机更新堆叠ID，并同步主交换机的配置文件和系统软件，之后进入稳定运行状态。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8733.png"></p>
<blockquote>
<ul>
<li><p>堆叠合并是指稳定运行的两个堆叠系统合并成一个新的堆叠系统。如图所示，两个堆叠系统的主交换机SWA和SWD通过竞争，选举出一个更优的作为新堆叠系统的主交换机。竞争成功的主交换机SWA所在的堆叠系统将保持原有主备从角色和配置不变，业务也不会受到影响；而另外一个堆叠系统的所有成员交换机SWD和SWE将重新启动，以从交换机的角色加入到新堆叠系统，其堆叠ID将由新主交换机重新分配，并将同步新主交换机的配置文件和系统软件，该堆叠系统的原有业务也将中断。</p>
</li>
<li><p>堆叠合并通常在以下两种情形下出现：</p>
<ul>
<li>堆叠链路或设备故障导致堆叠分裂，链路或设备故障恢复后，分裂的堆叠系统重新合并。</li>
<li>待加入堆叠系统的交换机配置了堆叠功能，在不下电的情况下，使用堆叠线缆连接到正在运行的堆叠系统。通常情况下，不建议使用该方式形成堆叠，因为在合并前过程中可能会导致正在运行的堆叠系统重启，影响业务运行。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8734.png"></p>
<blockquote>
<p>堆叠成员退出是指成员交换机从堆叠系统中离开。根据退出成员交换机角色的不同，对堆叠系统的影响也有所不同：</p>
<ul>
<li>当主交换机退出，备份交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，指定新的备交换机，之后进入稳定运行状态。</li>
<li>当备交换机退出，主交换机重新指定备交换机，重新计算堆叠拓扑并同步到其他成员交换机，之后进入稳定运行状态。</li>
<li>当从交换机退出，主交换机重新计算堆叠拓扑并同步到其他成员交换机，之后进入稳定运行状态。</li>
</ul>
<p>堆叠成员交换机退出的过程，主要就是拆除堆叠线缆和移除交换机的过程：</p>
<ul>
<li>对于环形堆叠：成员交换机退出后，为保证网络的可靠性还需要把退出交换机连接的两个端口通过堆叠线缆进行连接。</li>
<li>对于链形堆叠：拆除中间交换机会造成堆叠分裂。这时需要在拆除前进行业务分析，尽量减少对业务的影响。</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8735.png"></p>
<blockquote>
<p>堆叠分裂是指稳定运行的堆叠系统中带电移出部分成员交换机，或者堆叠线缆多点故障导致一个堆叠系统变成多个堆叠系统。根据原堆叠系统主备交换机分裂后所处位置的不同，堆叠分裂可分为以下两类：</p>
<ul>
<li><p>堆叠分裂后，原主备交换机被分裂到同一个堆叠系统中：原主交换机会重新计算堆叠拓扑，将移出的成员交换机的拓扑信息删除，并将新的拓扑信息同步给其他成员交换机；而移出的成员交换机检测到堆叠协议报文超时，将自行复位，重新进行选举。</p>
</li>
<li><p>堆叠分裂后，原主备交换机被分裂到不同的堆叠系统中：原主交换机所在堆叠系统重新指定备交换机，重新计算拓扑信息并同步给其他成员交换机；原备交换机所在堆叠系统将发生备升主，原备交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员交换机，并指定新的备交换机。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8736.png"></p>
<blockquote>
<ul>
<li><p>由于堆叠系统中所有成员交换机都使用同一个IP地址和MAC地址（堆叠系统MAC），一个堆叠分裂后，可能产生多个具有相同IP地址和MAC地址的堆叠系统。为防止堆叠分裂后，产生多个具有相同IP地址和MAC地址的堆叠系统，引起网络故障，必须进行IP地址和MAC地址的冲突检查。多主检测MAD（Multi-Active Detection），是一种检测和处理堆叠分裂的协议。链路故障导致堆叠系统分裂后，MAD可以实现堆叠分裂的检测、冲突处理和故障恢复，降低堆叠分裂对业务的影响。</p>
</li>
<li><p>MAD检测方式有两种：直连检测方式和代理检测方式。在同一个堆叠系统中，两种检测方式互斥，不可以同时配置。</p>
</li>
<li><p>直连检测方式是指堆叠成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，堆叠系统正常运行时，不发送MAD报文；堆叠系统分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>通过中间设备直连：堆叠系统的所有成员交换机之间至少有一条检测链路与中间设备相连。</p>
</li>
<li><p>Full-mesh方式直连：堆叠系统的各成员交换机之间通过检测链路建立Full-mesh全连接，即每两台成员交换机之间至少有一条检测链路。</p>
</li>
<li><p>通过中间设备直连可以实现通过中间设备缩短堆叠成员交换机之间的检测链路长度，适用于成员交换机相距较远的场景。与通过中间设备直连相比，Full-mesh方式直连可以避免由中间设备故障导致的MAD检测失败，但是每两台成员交换机之间都建立全连接会占用较多的接口，所以该方式适用于成员交换机数目较少的场景。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8737.png"></p>
<blockquote>
<ul>
<li><p>代理检测方式是在堆叠系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求堆叠系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
</li>
<li><p>在代理检测方式中，堆叠系统正常运行时，堆叠成员交换机以30s为周期通过检测链路发送MAD报文。堆叠成员交换机对在正常工作状态下收到的MAD报文不做任何处理；堆叠分裂后，分裂后的两台交换机以1s为周期通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>MAD冲突处理</p>
<ul>
<li>堆叠分裂后，MAD冲突处理机制会使分裂后的堆叠系统处于Detect状态或Recovery状态。Detect状态表示堆叠正常工作状态，Recovery状态表示堆叠禁用状态。</li>
<li>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在多个处于Detect状态的堆叠系统，这些堆叠系统之间相互竞争，竞争成功的堆叠系统保持Detect状态，竞争失败的堆叠系统会转入Recovery状态；并且在Recovery状态堆叠系统的所有成员交换机上，关闭除保留端口以外的其它所有物理端口，以保证该堆叠系统不再转发业务报文。</li>
</ul>
</li>
<li><p>MAD故障恢复</p>
</li>
<li><p>通过修复故障链路，分裂后的堆叠系统重新合并为一个堆叠系统。重新合并的方式有以下两种：</p>
<ul>
<li>堆叠链路修复后，处于Recovery状态的堆叠系统重新启动，与Detect状态的堆叠系统合并，同时将被关闭的业务端口恢复Up，整个堆叠系统恢复。</li>
<li>如果故障链路修复前，承载业务的Detect状态的堆叠系统也出现了故障。此时，可以先将Detect状态的堆叠系统从网络中移除，再通过命令行启用Recovery状态的堆叠系统，接替原来的业务，然后再修复原Detect状态堆叠系统的故障及链路故障。故障修复后，重新合并堆叠系统。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8738.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8739.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8740.png"></p>
<blockquote>
<ul>
<li><p>CSS与iStack的区别在于，一般框式交换机堆叠称为CSS，盒式交换机堆叠称为iStack，都可以称为堆叠。两者只是叫法和实现有些差异，但是功能是一样的。</p>
</li>
<li><p>通过交换机集群，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。</p>
<ul>
<li>高可靠性：集群系统两台成员交换机之间冗余备份，同时利用链路聚合功能实现跨设备的链路冗余备份。</li>
<li>强大的网络扩展能力：通过组建集群增加交换机，从而轻松的扩展端口数、带宽和处理能力。</li>
<li>简化配置和管理：集群建立后，两台物理设备虚拟成为一台设备，用户只需登录一台成员交换机即可对集群系统所有成员交换机进行统一配置和管理。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8741.png"></p>
<blockquote>
<p>不同于iStack可以多台设备堆叠，对于CSS集群，集群中只能有一主一备两台交换机。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8742.png"></p>
<blockquote>
<ul>
<li><p>集群建立时，成员交换机间相互发送集群竞争报文，通过竞争，一台成为主交换机，负责管理整个集群系统，另一台则成为备交换机。</p>
</li>
<li><p>角色选举</p>
<p>1.最先完成启动，并进入单框集群运行状态的交换机成为主交换机。</p>
<p>2.当两台交换机同时启动时，集群优先级高的交换机成为主交换机。</p>
<p>3.当两台交换机同时启动，且集群优先级又相同时，MAC地址小的交换机成为主交换机。</p>
<p>4.当两台交换机同时启动，且集群优先级和MAC都相同时，集群ID小的交换机成为主交换机。</p>
</li>
<li><p>版本同步</p>
<ul>
<li>集群具有自动加载系统软件的功能，待组成集群的成员交换机不需要具有相同的软件版本，只需要版本间兼容即可。当主交换机选举结束后，如果备交换机与主交换机的软件版本号不一致时，备交换机会自动从主交换机下载系统软件，然后使用新的系统软件重启，并重新加入集群。</li>
</ul>
</li>
<li><p>配置同步</p>
<ul>
<li>集群具有严格的配置文件同步机制，来保证集群中的多台交换机能够像一台设备一样在网络中工作。</li>
</ul>
</li>
<li><p>配置备份</p>
<ul>
<li>交换机从非集群状态进入集群状态后，会自动将原有的非集群状态下的配置文件加上.bak的扩展名进行备份，以便去使能集群功能后，恢复原有配置。例如，原配置文件扩展名为.cfg，则备份配置文件扩展名为.cfg.bak。去使能交换机集群功能时，用户如果希望恢复交换机的原有配置，可以更改备份配置文件名并指定其为下一次启动的配置文件，然后重新启动交换机，恢复原有配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8743.png"></p>
<blockquote>
<ul>
<li><p>物理成员端口</p>
<ul>
<li>成员交换机之间用于集群连接的普通业务口。物理成员端口用于转发需要跨成员交换机的业务报文或成员交换机之间的集群协议报文。</li>
</ul>
</li>
<li><p>逻辑集群端口</p>
<ul>
<li>逻辑集群端口是专用于集群的逻辑端口，需要和物理成员端口绑定。集群的每台成员交换机上支持两个逻辑集群端口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8744.png"></p>
<blockquote>
<ul>
<li><p>使能了集群功能的单台交换机即为单框集群。</p>
<ul>
<li>集群成员加入是指向稳定运行的单框集群系统中添加一台新的交换机。如图1所示，新交换机SwitchB将加入单框集群系统从而形成新的集群系统。原单框集群的交换机成为主交换机，新加入的交换机成为备交换机。</li>
</ul>
</li>
<li><p>集群加入通常在以下两种情形下出现：</p>
<ul>
<li>在建立集群时，先将一台交换机使能集群功能后重启，重启后这台交换机将进入单框集群状态。然后再使能另外一台交换机的集群功能后重启，则后启动的交换机则按照集群成员加入的流程加入集群系统，成为备交换机。</li>
<li>在稳定运行的两框集群场景中，将其中一台交换机重启，则这台交换机将以集群成员加入的流程重新加入集群系统，并成为备交换机。</li>
</ul>
</li>
<li><p>集群合并是指稳定运行的两个单框集群系统合并成一个新的集群系统。如图2所示，两个单框集群系统将自动选出一个更优的作为合并后集群系统的主交换机。被选为主交换机的配置不变，业务也不会受到影响，框内的备用主控板将重启。而备交换机将整框重启，以集群备的角色加入新的集群系统，并将同步主交换机的配置，该交换机原有的业务也将中断。</p>
</li>
<li><p>集群合并通常在以下两种情形下出现：</p>
<ul>
<li>将两台交换机分别使能集群功能后重启（重启后的两台交换机都属于单框集群），再使用集群线缆将两台交换机连接，之后会进入集群合并流程。</li>
<li>集群链路或设备故障导致集群分裂。故障恢复后，分裂后的两个单框集群系统重新合并。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8745.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8746.png"></p>
<blockquote>
<ul>
<li><p>由于集群系统中所有成员交换机都使用同一个IP地址和MAC地址（集群系统MAC），一个集群分裂后，由于这些成员交换机运行着相同的配置文件（即原集群系统的配置文件），就会产生两个具有相同IP地址和MAC地址的集群系统。为防止集群分裂后，产生两个具有相同IP地址和MAC地址的集群系统，引起网络故障，必须进行IP地址和MAC地址的冲突检查。</p>
</li>
<li><p>多主检测MAD（Multi-Active Detection），是一种检测和处理集群分裂的协议。链路故障导致集群系统分裂后，MAD可以实现集群分裂的检测、冲突处理和故障恢复，降低集群分裂对业务的影响。</p>
</li>
<li><p>MAD检测方式有两种：直连检测方式和代理检测方式。在同一个集群系统中，两种检测方式互斥，不可以同时配置。</p>
</li>
<li><p>直连检测方式是指集群成员交换机间通过普通线缆直连的专用链路进行多主检测。在直连检测方式中，集群系统正常运行时，不发送MAD报文；集群系统分裂后，分裂后的两台交换机周期性地通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>直连检测的连接方式包括通过中间设备直连和集群成员交换机直接直连：</p>
<ul>
<li>通过中间设备直连：集群系统的成员交换机之间至少有一条检测链路与中间设备相连。此种方式适用于成员交换机相距较远的场景。</li>
<li>直接直连：集群成员交换机直接直连可以避免由中间设备故障导致MAD检测失败。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8747.png"></p>
<blockquote>
<ul>
<li><p>代理检测方式是在集群系统Eth-Trunk上启用代理检测，在代理设备上启用MAD检测功能。此种检测方式要求集群系统中的所有成员交换机都与代理设备连接，并将这些链路加入同一个Eth-Trunk内。与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。</p>
</li>
<li><p>在代理检测方式中，集群系统正常运行时，集群成员交换机以30s为周期通过检测链路发送MAD报文。集群成员交换机对在正常工作状态下收到的MAD报文不做任何处理；集群分裂后，分裂后的两台交换机周期性地通过检测链路发送MAD报文以进行多主冲突处理。</p>
</li>
<li><p>MAD冲突处理</p>
<ul>
<li>集群分裂后，MAD冲突处理机制会使分裂后的单框集群系统处于Detect状态或Recovery状态。Detect状态表示集群正常工作状态，Recovery状态表示集群禁用状态。</li>
<li>MAD冲突处理机制如下：MAD分裂检测机制会检测到网络中存在两个处于Detect状态的集群系统即两台交换机，此时会进行集群优先级比较（优先级相同比较MAC地址，MAC地址相同则比较集群ID），优先级高的交换机将成为主交换机继续正常工作，另一台交换机会转入Recovery状态；并且在Recovery状态的交换机上，关闭除保留端口以外的其它所有物理端口，以保证该交换机不再转发业务报文。</li>
</ul>
</li>
<li><p>MAD故障恢复</p>
</li>
<li><p>通过修复故障链路，分裂后的集群系统重新合并为一个集群系统。重新合并的方式有以下两种：</p>
<ul>
<li>集群链路修复后，处于Recovery状态的集群系统重新启动，与Detect状态的集群系统合并，同时将被关闭的业务端口恢复Up，整个集群系统恢复。</li>
<li>如果故障链路修复前，承载业务的Detect状态的集群系统也出现了故障。此时，可以先将Detect状态的集群系统从网络中移除，再通过命令行启用Recovery状态的集群系统，接替原来的业务，然后再修复原Detect状态集群系统的故障。故障修复后，重新合并集群系统。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8748.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8749.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8750.png"></p>
<blockquote>
<ul>
<li><p>链路聚合技术主要有以下三个优势：增加带宽、提高可靠性和负载分担。</p>
</li>
<li><p>链路聚合组和成员接口</p>
<ul>
<li>链路聚合组LAG是指将若干条以太链路捆绑在一起所形成的逻辑链路。组成Eth-Trunk接口的各个物理接口称为成员接口。</li>
</ul>
</li>
<li><p>活动接口和非活动接口、活动链路和非活动链路</p>
<ul>
<li>链路聚合组的成员接口存在活动接口和非活动接口两种。转发数据的接口称为活动接口，不转发数据的接口称为非活动接口。</li>
<li>活动接口对应的链路称为活动链路，非活动接口对应的链路称为非活动链路。</li>
</ul>
</li>
<li><p>活动接口数上限阈值</p>
<ul>
<li>当前活动链路数目达到上限阈值时，再向Eth-Trunk中添加成员接口，不会增加Eth-Trunk活动接口的数目，超过上限阈值的链路状态将被置为Down，作为备份链路。</li>
</ul>
</li>
<li><p>活动接口数下限阈值</p>
<ul>
<li>设置活动接口数下限阈值是为了保证最小带宽，当前活动链路数目小于下限阈值时，Eth-Trunk接口的状态转为Down。</li>
</ul>
</li>
<li><p>设备支持的链路聚合方式</p>
<ul>
<li>同板：是指链路聚合时，同一聚合组的成员接口分布在同一单板上。</li>
<li>跨板：是指链路聚合时，同一聚合组的成员接口分布在不同的单板上。</li>
<li>跨框：是指在集群场景下，成员接口分布在集群的各个成员设备上。</li>
<li>跨设备：是指E-Trunk基于LACP进行了扩展，能够实现多台设备间的链路聚合。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8751.png"></p>
<blockquote>
<ul>
<li><p>Eth-Trunk模块根据转发表转发数据帧的过程如下：</p>
<p>1.Eth-Trunk模块从MAC子层接收到一个数据帧后，根据负载分担方式提取数据帧的源MAC地址/IP地址或目的MAC地址/IP地址。</p>
<p>2.根据HASH算法进行计算，得到HASH-KEY值。</p>
<p>3.Eth-Trunk模块根据HASH-KEY值在转发表中查找对应的接口，把数据帧从该接口发送出去。</p>
</li>
<li><p>例如 ，某设备每Eth-Trunk支持最大加入接口数为8个，将接口1、2、3、4捆绑为一个Eth-Trunk接口，此时生成的转发表如图2所示。其中HASH-KEY值为0、1、2、3、4、5、6、7，对应的出接口号分别为1、2、3、4、1、2、3、4。</p>
</li>
<li><p>为了避免数据包乱序情况的发生，Eth-Trunk采用逐流负载分担的机制，其中如何转发数据则由于选择不同的负载分担方式而有所差别。</p>
</li>
<li><p>负载分担的方式主要包括以下几种，用户可以根据具体应用选择不同的负载分担方式。</p>
<ul>
<li>根据报文的源MAC地址进行负载分担；</li>
<li>根据报文的目的MAC地址进行负载分担；</li>
<li>根据报文的源IP地址进行负载分担；</li>
<li>根据报文的目的IP地址进行负载分担；</li>
<li>根据报文的源MAC地址和目的MAC地址进行负载分担；</li>
<li>根据报文的源IP地址和目的IP地址进行负载分担；</li>
<li>根据报文的VLAN、源物理端口等对L2、IPv4、IPv6和MPLS报文进行增强型负载分担。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8752.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8753.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8754.png"></p>
<blockquote>
<p>作为链路聚合技术，手工模式Eth-Trunk可以完成多个物理接口聚合成一个Eth-Trunk口来提高带宽，同时能够检测到同一聚合组内的成员链路有断路等有限故障，但是无法检测到链路层故障、链路错连等故障。</p>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8755.png"></p>
<blockquote>
<ul>
<li><p>如图所示，两端设备均会收到对端发来的LACPDU报文。以DeviceB为例，当DeviceB收到DeviceA发送的报文时，DeviceB会查看并记录对端信息，然后比较系统优先级字段，如果DeviceA的系统优先级高于本端的系统优先级，则确定DeviceA为LACP主动端。如果DeviceA和DeviceB的系统优先级相同，比较两端设备的MAC地址，确定MAC地址小的一端为LACP主动端。</p>
</li>
<li><p>选出主动端后，两端都会以主动端的接口优先级来选择活动接口，如果主动端的接口优先级都相同则选择接口编号比较小的为活动接口。两端设备选择了一致的活动接口，活动链路组便可以建立起来，从这些活动链路中以负载分担的方式转发数据。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8756.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8757.png"></p>
<blockquote>
<ul>
<li><p>在设备集群情况下，为了保证流量的可靠传输，流量的出接口设置为Eth-Trunk接口。那么Eth-Trunk接口中必定存在跨框成员口。当集群设备转发流量时，Eth-Trunk接口通过HASH算法可能会选择跨框的成员口。由于集群设备间线缆带宽有限，跨框转发流量增加了集群设备之间的带宽承载压力，同时也降低了流量转发效率。为了解决这个问题，可以使能Eth-Trunk接口流量本地优先转发。</p>
</li>
<li><p>如图所示，DeviceB和DeviceC组成集群，集群设备和DeviceA之间用Eth-Trunk连接。通过在集群设备上部署接口流量本地优先转发功能，可实现：</p>
<ul>
<li>入本设备流量从本设备转发<ul>
<li>当Eth-Trunk接口在DeviceB有出接口且出接口无故障时，DeviceB的Eth-Trunk接口转发表中将只包含DeviceB的出接口。这样DeviceB到DeviceA的流量在通过HASH算法选择出接口时只能选中DeviceB的接口，流量从DeviceB本设备转发出去。</li>
</ul>
</li>
<li>入本设备流量跨框转发<ul>
<li>当Eth-Trunk接口在DeviceB本设备无出接口或者出接口全部故障时，DeviceB的Eth-Trunk转发表中将包含Eth-Trunk接口中所有可转发的出接口。这样DeviceB到DeviceA的流量在通过HASH算法选择出接口时将选中DeviceC上的出接口，流量将通过DeviceC跨框转发。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8758.png"></p>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8759.png"></p>
<blockquote>
<ul>
<li><p>E-Trunk机制主要应用于CE双归接入VPLS、VLL、PWE3网络时，CE与PE间的链路保护以及对PE设备节点故障的保护。在没有使用E-Trunk前，CE通过Eth-Trunk链路只能单归到一个PE设备。如果Eth-Trunk出现故障或者PE设备故障，CE将无法与PE设备继续进行通信。使用E-Trunk后，CE可以双归到PE上，从而实现设备间保护。</p>
</li>
<li><p>如图，CE分别与PE1和PE2直连，PE1和PE2之间运行E-Trunk。PE侧，需要在PE1和PE2设备上分别创建ID相同的E-Trunk和Eth-Trunk，并将Eth-Trunk加入到E-Trunk。CE侧，在CE设备上配置LACP模式的Eth-Trunk，此Eth-Trunk分别与PE1和PE2设备相连。对CE设备而言，E-Trunk不可见。</p>
</li>
<li><p>PE1与PE2设备之间通过E-Trunk报文进行主备协商，确定E-Trunk的主备状态。正常情况下两台PE的协商结果是一个为主用一个为备用。PE设备上E-Trunk主备状态是根据报文中所携带的E-Trunk优先级和E-Trunk系统ID确定的。优先级的数值越小，优先级越高，优先级高的为主用。如果E-Trunk优先级相同，那么E-Trunk系统ID小的为主用。PE1为主，PE1的Eth-Trunk 10为主，链路状态为Up。PE2为备，PE2的Eth-Trunk 10为备，链路状态为Down。</p>
</li>
<li><p>如果CE到PE1间的链路出现故障：PE1会向对端发送E-Trunk报文，报文中携带PE1的Eth-Trunk 10故障的信息。PE2收到E-Trunk报文后，发现对端Eth-Trunk 10故障，则PE2设备上Eth-Trunk 10的状态将变为主。然后经过LACP协商，PE2设备上的Eth-Trunk 10的状态变为Up。这样PE2设备的Eth-Trunk状态变为Up，CE的流量会通过PE2转发，以达到对CE的流量进行保护的目的。</p>
</li>
<li><p>如果PE1设备出现故障：如果PE设备上配置了BFD，PE2检测到BFD会话状态为Down后，PE2设备从备用状态变为主用状态，PE2的Eth-Trunk 10状态也变为主。如果PE设备上没有配置BFD，PE2设备上的定时器超时后仍然没有收到PE1设备发送的E-Trunk报文，PE2设备从备用状态变为主用状态，PE2的Eth-Trunk 10状态也变为主。经过LACP协商，PE2设备上的Eth-Trunk 10的状态变为Up。CE的流量会通过PE2转发，以达到对CE的流量进行保护的目的。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8760.png"></p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>如何清除MAC地址表项和ARP表项？</p>
<ul>
<li>清除所有动态MAC（系统视图）：undo mac-address dynamic </li>
<li>清除所有静态MAC（系统视图） ：undo mac-address static</li>
<li>删除一条静态ARP表项（系统视图）：undo arp static</li>
<li>删除多条ARP表项（用户视图）：reset arp</li>
</ul>
</li>
<li><p>MSTP域如何配置？</p>
<ul>
<li>MSTP的域信息在stp region-configuration视图下配置，同一个域中各台设备的域配置信息必须完全一致。存在任何一点差异，就不在同一个域中。MSTP可以配置的域信息有：<ul>
<li>Format selector：格式选择符，在命令行不能配置，默认为0；</li>
<li>Region name：域名，默认是桥MAC地址；</li>
<li>Revision level：修订级别，默认是0；</li>
<li>Instance/Vlans Mapped：实例和VLAN映射表，默认全部VLAN映射到实例0。</li>
</ul>
</li>
</ul>
</li>
<li><p>Eth-Trunk是否支持抢占功能？</p>
<ul>
<li>只有在LACP模式下，Eth-Trunk才支持优先级抢占功能，可以执行lacp preempt enable命令使能优先级抢占功能。在LACP模式下，当活动链路中出现故障链路时，系统会从备用链路中选择优先级最高的链路替代故障链路；如果被替代的故障链路恢复了正常，而且该链路的优先级又高于替代自己的链路，这种情况下，如果使能了LACP优先级抢占功能，高优先级链路会抢占低优先级链路，回切到活动状态。要求Eth-Trunk两端LACP抢占功能使能情况配置一致，即：统一使能或不使能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/07/20/IE-LAN%E6%8A%80%E6%9C%AF/%E5%B9%BB%E7%81%AF%E7%89%8761.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">77</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
