<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsy&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="zsy&#39;s blog">
<meta property="og:description" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="张思宇">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>zsy's blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zsy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">just simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/" itemprop="url">IE-BGPEVPN原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-11T16:38:16+08:00">
                2021-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li>HIS(High Speed Internet)</li>
<li>BTV(Broadband TV)</li>
<li>Multihoming：当前VPLS只能支持multihoming的single-active冗余不是，不支持多路径多活转发。</li>
<li>组播优化：组播的LSPs可以结合VPLS，但是只能用于P2MP的LSPs。对于MP2MP的LSPs使用场景，VPLS无法支持。</li>
<li>配置复杂度高：当前VPLS提供基于BGP的auto-discovery的single-sided接入，但是需要工程师在接入侧以太配置上再配置大量的网络参数。</li>
<li>多租户的DCI互联：DCI链路之间不仅传统数据中心间二层，也需要扩展租户的的二层网络。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>我们提到了VXLAN的不足之处需要引入新的控制面协议，那么这里我们先看看EVPN协议，EVPN协议全称是Ethernet　VPN，RFC7432中有定义，是用来解决VPLS的一些现存问题，比如无法通过多个独立的链路实现multihoming。某些情况可能接收到多份广播报文、或者MAC持续漂移。而且Martini VPLS也存在大量peering配置的困扰。</li>
<li>那么RFC7432中定义的EVPN协议，则通过使用BGP协议作为控制面协议，MPLS作为转发面数据封装，通过引入一些新的内容，来解决VPLS场景下比如容易产生环路、多份广播报文以及MAC地址学习的问题。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/7.png"></p>
<blockquote>
<ul>
<li>EVPN（Ethernet Virtual Private Network）其实就是一种用于二层网络互联的VPN技术。EVPN技术采用类似于BGP/MPLS IP VPN的机制，在BGP协议的基础上定义了一种新的NLRI（Network Layer Reachability Information，网络层可达信息）即EVPN NLRI，EVPN NLRI定义了几种新的BGP EVPN路由类型，用于处在二层网络的不同站点之间的MAC地址学习和发布。</li>
<li>同时，VXLAN实现方案没有控制平面，是通过数据平面的流量泛洪进行VTEP发现和主机信息（包括IP地址、MAC地址、VNI、网关VTEP IP地址）学习的。这种方式导致数据中心网络存在很多泛洪流量。为了解决这一问题，VXLAN引入了EVPN作为控制平面，通过在VTEP之间交换BGP EVPN路由实现VTEP的自动发现、主机信息相互通告等特性，从而避免了不必要的数据流量泛洪。</li>
<li>除了RFC7432以外，之前还有3个相关的草案，其中第一个draft-ietf-bess-evpn-overlay目前已经成为正式的RFC，A Network Virtualization Overlay Solution Using Ethernet VPN (EVPN)RFC 8365，另外两个也正在努力成为标准的过程中。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li>使用VXLAN作为数据平面。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/9.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/10.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li>水平分割（分发ESI标签）；</li>
<li>快速收敛（其他PE根据RT1路由实现端口下MAC等明细路由的批量快速切换）；</li>
<li>别名（任意的多归PE发布MAC等明细路由，其他PE可根据RT1路由形成到所有多归PE的ECMP）；</li>
<li>使用M-LAG和堆叠技术实现Multihoming可以替代此类路由。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/12.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/13.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/14.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/15.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/16.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/17.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/18.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/19.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/21.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/23.png"></p>
<blockquote>
<ul>
<li> 参考RFC草案，IP Prefix Advertisement in EVPN</li>
<li> draft-ietf-bess-evpn-prefix-advertisement-11</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/25.png"></p>
<blockquote>
<ul>
<li>NVO实现每个租户的流量由独立的Overlay隧道承载。</li>
<li>在一个underlay网络之上可以承载多个Overlay隧道。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/27.png"></p>
<blockquote>
<ul>
<li>原有的VXLAN实现方案没有控制平面，是通过数据平面的流量泛洪进行VTEP发现和主机信息（包括IP地址、MAC地址、VNI、网关VTEP IP地址）学习的，这种方式导致数据中心网络存在很多泛洪流量。为了解决这一问题，VXLAN引入了EVPN作为控制平面，通过在VTEP之间交换BGP EVPN路由实现VTEP的自动发现、主机信息相互通告等特性，从而避免了不必要的数据流量泛洪。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/28.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/29.png"></p>
<blockquote>
<ul>
<li>EVPN通过扩展BGP协议新定义了几种BGP EVPN路由，这些BGP EVPN路由可以用于传递VTEP地址和主机信息，因此EVPN应用于VXLAN网络中，可以使VTEP发现和主机信息学习从数据平面转移到控制平面。那么接下来，我们就开始，为大家一起揭开BGP EVPN路由的神秘面纱。</li>
<li>首先VXLAN需要使用EVPN协议规定的Route Type2，又称为MAC/IP Advertisement route，用于发布主机的MAC或MAC+IP的信息。BGP-EVPN会通过BGP协议，将以太端口学习的MAC、ARP，转化为Route Type2路由发布给其他设备，其他设备接收后生成MAC转发表、主机路由转发表。</li>
<li>这个功能可不简单，传统设备我们学习MAC地址都是通过报文触发，学习报文的源MAC，而BGP-EVPN则通过Route Type2路由携带了MAC信息去发布MAC，可以节省很多的ARP流量。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/30.png"></p>
<blockquote>
<ul>
<li>那么我们来看一下Route Type2的主要应用场景：<ul>
<li>首先就是MAC路由发布，这里可以看到，当本端主机H1上线后，本端NVE学习到该主机的MAC地址，直接通过BGP-EVPN发送到远端设备；</li>
<li>远端VTEP学习到MAC路由后，下发到对应的EVPN实例，根据下一跳查找对应的VXLAN隧道，隧道可达，下发MAC转发表。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/31.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/32.png"></p>
<blockquote>
<ul>
<li>这里Type2路由发布的是MAC/IP路由，这里可以看到，当本端主机H1上线后，本端VTEP学习到该主机的MAC地址和ARP，生产EVPN的Type2路由，直接通过BGP-EVPN发送到远端设备。</li>
<li>远端VTEP学习到MAC/IP路由后，下发到对应的EVPN实例，根据下一跳查找对应的VXLAN隧道，隧道可达，下发MAC转发表和IP路由表。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/33.png"></p>
<blockquote>
<ul>
<li>接着我们看EVPN协议的Type3路由，又称为Inclusive Multicast Ethernet Tag route，该类型路由是由前缀和PMSI属性组成，用于隧道自动建立、VNI广播成员的自动加入。</li>
<li>该类型路由在VXLAN控制平面中主要用于VTEP的自动发现和VXLAN隧道的动态建立。作为BGP EVPN对等体的VTEP，通过Inclusive Multicast路由互相传递二层VNI和VTEP IP地址信息。</li>
<li>其中，Originating Router’s IP Address字段为本端VTEP IP地址，MPLS Label字段为二层VNI。如果对端VTEP IP地址是三层路由可达的，则建立一条到对端的VXLAN隧道。同时，如果对端VNI与本端相同，则创建一个头端复制表，用于后续BUM报文转发。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li>VXLAN隧道可以通过手动创建，通过指定两端的VTEP和VNI信息，静态配置创建隧道。而动态协议BGP EVPN中创建VXLAN隧道，则是通过Type3路由, 可以把本端的VTEP地址、VNI等信息发给远端，远端收到后会用来创建VXLAN隧道，并且创建VXLAN隧道的头端复制列表。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/35.png"></p>
<blockquote>
<ul>
<li>接下来我们再看一种路由，叫做Type5路由，又称IP前缀路由，可用于将EVPN以外的子网网络引入到EVPN，当然可以掩码是32位，用于发布主机的Host路由。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>Type5路由可以用来传递网段IP路由，同时可以携带对应VRF的L3 VNI。</li>
<li>也可以用来传递代表VRF的L3 VNI,这里什么是L3 VNI呢？<ul>
<li>由于在分布式网关环境下，跨子网要通信，需要代表各自VRF，而报文里面没有VRF，因此我们这边通过一个特定的VNI映射成VRF，这个VNI就是L3 VNI。</li>
<li>这时，远端的VTEP在学习到网段路由后，可以添加到对应VPN实例中，并根据下一跳驱动创建L3 VXLAN隧道，并下发路由表。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/37.png"></p>
<blockquote>
<ul>
<li>参考答案：<ul>
<li>MAC/IP通告，分布式网关下虚拟机迁移，MAC通告。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/38.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/39.png"></p>
<p><img src="/2021/09/11/IE-BGPEVPN%E5%8E%9F%E7%90%86/40.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/" itemprop="url">IE-SDNVXLAN原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-11T16:37:34+08:00">
                2021-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>概括来说，SDN2006年诞生于园区网，2012年可谓是SDN商用元年,发生了google部署sdn等重要事件将SDN推向了全球瞩目的焦点；同时2012年延展到电信网络。</p>
</li>
<li><p>下面我们结合重大事件加以介绍（内容较多，每一事件需记住关键点）。</p>
</li>
<li><p>2006年，SDN诞生于美国GENI项目资助的斯坦福大学Clean Slate课题，斯坦福大学Nick McKeown（尼克 麦吉翁）教授为首的研究团队提出了Openflow的概念用于校园网络的试验创新，后续基于Openflow给网络带来可编程的特性，SDN的概念应运而生。Clean Slate项目的最终目的是要重新发明英特网，旨在改变设计已略显不合时宜，且难以进化发展的现有网络基础架构。</p>
</li>
<li><p>2007年，斯坦福大学的学生Martin Casado（马丁 卡萨多） 领导了一个关于网络安全与管理的项目Ethane，该项目试图通过一个集中式的控制器，让网络管理员可以方便地定义基于网络流的安全控制策略，并将这些安全策略应用到各种网络设备中，从而实现对整个网络通讯的安全控制。</p>
</li>
<li><p>2008年，基于Ethane 及其前续项目Sane的启发， Nick McKeown 教授等人提出了OpenFlow 的概念，并于当年在ACM SIGCOMM 发表了题为《OpenFlow: Enabling Innovation in Campus Networks》的论文，首次详细地介绍了OpenFlow 的概念。该篇论文除了阐述OpenFlow 的工作原理外，还列举了OpenFlow 几大应用场景。</p>
</li>
<li><p>基于OpenFlow 为网络带来的可编程的特性，Nick McKeown教授和他的团队进一步提出了SDN（Software Defined Network，软件定义网络）的概念。2009年，SDN 概念入围Technology Review年度十大前沿技术，自此获得了学术界和工业界的广泛认可和大力支持。</p>
</li>
<li><p>2009年12月，OpenFlow规范发布了具有里程碑意义的可用于商业化产品的1.0版本。如OpenFlow在Wireshark抓包分析工具上的支持插件、OpenFlow的调试工具（liboftrace ）、OpenFlow虚拟计算机仿真（OpenFlowVMS）等也已日趋成熟。OpenFlow规范已经经历了1.1、1.2以及1.3等版本。OpenFlow 1.4标准已经在ONF内部审阅，预计2013年8月初将获得批准发布。</p>
</li>
<li><p>2011年3月，在Nick Mckeown教授等人的推动下，开放网络基金会ONF成立，主要致力于推动SDN架构、技术的规范和发展工作。ONF成员96家，其中创建该组织的核心会员有7家，分别是Google、Facebook、NTT、、Verizon、德国电信、微软、雅虎。</p>
</li>
<li><p>2011年5月，NEC推出第一台可商用的OpenFlow交换机</p>
</li>
<li><p>2012年4月，谷歌宣布其主干网络已经全面运行在OpenFlow上，并且通过10G网络链接分布在全球各地的12个数据中心，使广域线路的利用率从30%提升到接近饱和。从而证明了OpenFlow不再仅仅是停留在学术界的一个研究模型，而是已经完全具备了可以在产品环境中应用的技术成熟度。</p>
</li>
<li><p>2012年7月，软件定义网络(SDN)先驱者、开源政策网络虚拟化私人控股企业Nicira以12.6亿被VMware收购。 Nicira是一家颠覆数据中心的创业公司，它基于开源技术OpenFlow创建了网络虚拟平台（NVP）。OpenFlow是Nicira联合创始人Martin Casado在斯坦福攻读博士学位期间创建的开源项目，Martin Casado的两位斯坦福大学教授Nick McKeown和Scott Shenker同时也成为了Nicira的创始人。VMware的收购将Casado十几年来所从事的技术研发全部变成了现实——把网络软件从硬件服务器中剥离出来，也是SDN走向市场的第一步。</p>
</li>
<li><p>2012年底，AT&amp;T、英国电信(BT)、德国电信、Orange、意大利电信、西班牙电信公司和Verizon联合发起成立了网络功能虚拟化产业联盟(Network Functions Virtualisation，NFV)，旨在将SDN的理念引入电信业。由52家网络运营商、电信设备供应商、IT设备供应商以及技术供应商组建。</p>
</li>
<li><p>2013年4月，思科和IBM联合微软、Big Switch、博科、思杰、戴尔、爱立信、富士通、英特尔、瞻博网络、微软、NEC、惠普、红帽和VMware等发起成立了Open Daylight，与LINUX基金会合作，开发SDN控制器、南向/北向API等软件，旨在打破大厂商对网络硬件的垄断，驱动网络技术创新力，使网络管理更容易、更廉价。这个组织中只有SDN的供应商，没有SDN的用户——互联网或者运营商。Open Daylight项目的范围包括SDN控制器，API专有扩展等，并宣布要推出工业级的开源SDN控制器。</p>
</li>
<li><p>简单再补充点背景知识</p>
</li>
<li><p>Clean Slate计划</p>
<ul>
<li>痛点：现有网络架构不断修补，难以解决根本问题，重新定义网络架构也许是根本解决方案，推倒重来可行么？</li>
<li>CleanSlate项目的最终目的是要重新发明因特网，旨在改变设计已略显不合时宜，且难以进化发展的现有网络基础架构。</li>
<li>引出广义和狭义Clean Slate项目概念<ul>
<li>广义：泛指各种各样的下一代网络（NGN）项目</li>
<li>狭义：斯坦福大学尼克 麦吉翁（Nick McKeown）教授牵头的实验室研究计划（SDN诞生处）</li>
</ul>
</li>
</ul>
</li>
<li><p>Ethane项目（CleanSlate项目计划的子课题）</p>
<ul>
<li>斯坦福的学生马丁.卡萨多（尼克-麦吉翁是马丁的老师）领导了一个关于网络安全与管理的项目Ethane，该项目试图通过一个集中式的控制器，让网络管理员可以方便地定义基于网络流的安全控制策略，并将这些安全策略应用到各种网络设备中，从而实现对整个网络通讯的安全控制。</li>
<li>受此项目启发，Martin和他的导师Nick McKeown教授提出了OpenFlow的概念。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/6.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/7.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/8.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/9.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/10.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/11.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/12.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li>虚拟机规模受网络规格限制<ul>
<li>在大二层网络环境下，数据报文是通过查询MAC地址表进行二层转发，而MAC地址表的容量限制了虚拟机的数量。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/14.png"></p>
<blockquote>
<ul>
<li>网络隔离能力限制<ul>
<li>当前主流的网络隔离技术是VLAN或VPN（Virtual Private Network），在大规模的虚拟化网络中部署存在如下限制： 由于IEEE 802.1Q中定义的VLAN Tag域只有12比特，仅能表示4096个VLAN，无法满足大二层网络中标识大量用户群的需求。</li>
<li>传统二层网络中的VLAN/VPN无法满足网络动态调整的需求。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li>Google是大规模服务器集群的实践者，服务器间的大量通信要求网络是无阻塞的；</li>
<li>Google服务器单集群的规模已经达到了1万台左右；</li>
<li>国内的互连网厂家也在考虑规划2万台服务器的集群；</li>
<li>网络接口数量和容量是决定集群规模的核心因素；</li>
<li>构建跨地理区域的服务器集群，提高系统容灾能力。</li>
<li>大二层网络:<ul>
<li>大规模的二层网络；</li>
<li>要求网络横向流量提供无阻塞能力。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/16.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li>IT+CT形成合力；</li>
<li>TRILL是革命性的技术，Vxlan是改良的技术。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/18.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li><p>物理网路</p>
<ul>
<li>物理网络，带宽高，容量大；</li>
<li>大二层网络需要STP解决环路问题；</li>
<li>二层网络隔离受限，仅4k VLAN；</li>
<li>虚机迁移不够灵活，需要改变物理网络配置。</li>
</ul>
</li>
<li><p>Overlay网络：</p>
<ul>
<li>Overlay实现了某种程度的IP和位置信息的分离, 有更好的移动性, 满足二层网络弹性需求；</li>
<li>Overlay按需部署业务网络, 业务变化的时候Underlay网络不需要改变；</li>
<li>兼容性好，通过Overlay实现与物理网络解耦。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/21.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/25.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/27.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/28.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/29.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/30.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/31.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/33.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/34.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/35.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/36.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/37.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/38.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/39.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/40.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li>HOST A发送单播数据报文给HOST E。</li>
<li>注：NVE5作为三层网关，HOST A属于VNI 1，HOST E属于VNI 2，默认主机与网关都互相学习到ARP表, 各个节点MAC都已学习。</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/42.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/43.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/44.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/45.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/46.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/47.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/48.png"></p>
<blockquote>
<ul>
<li><p>软件方案：</p>
<ul>
<li>不改造现有物理设备，与具体厂商硬件设备解耦，无需配置物理网络，实现大规模逻辑二层网络的自动创建。</li>
</ul>
</li>
<li><p>硬件方案：</p>
<ul>
<li>新建物理网络，通过VXLAN Overlay网络，实现自动化业务发放。</li>
</ul>
</li>
<li><p>混合方案：</p>
<ul>
<li>通过SDN实现对虚拟网络及物理网络（交换机、防火墙及F5）的配置管理和自动化业务发放。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/49.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/50.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/51.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/52.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/53.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/54.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/55.png"></p>
<blockquote>
<ul>
<li>参考答案：<ul>
<li>AB</li>
<li>ABC</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/56.png"></p>
<p><img src="/2021/09/11/IE-SDNVXLAN%E5%8E%9F%E7%90%86/57.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/" itemprop="url">IE-QoS技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-31T15:08:57+08:00">
                2021-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/QoS%E6%8A%80%E6%9C%AF.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/76.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/77.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/78.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/79.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/80.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/81.png"></p>
<blockquote>
<ul>
<li>流分类用来定义一组流量匹配规则，以对报文进行分类。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/82.png"></p>
<blockquote>
<ul>
<li><strong>traffic classifier</strong> <em>classifier*</em>-name* [ <strong>operator</strong> { <strong>and</strong> | <strong>or</strong> } ]<ul>
<li><strong>classifier-name*</strong>：*指定流分类名称。</li>
<li>**Operator:**指定流分类下各规则之间的逻辑运算符。如果没有指定operator，则各规则之间缺省为逻辑“或”的关系。</li>
<li>**And:**指定流分类下各规则之间是逻辑“与”的关系。</li>
<li>**Or:**指定流分类下各规则之间是逻辑“或”的关系。指定该逻辑关系后，报文只需匹配流分类下的一个或多个规则就属于该类。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/83.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/84.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/85.png"></p>
<blockquote>
<ul>
<li>这是一个基于类的QoS的配置示例。在RTA上执行流分类；在RTB上执行带宽限制、重新标记等策略。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/86.png"></p>
<blockquote>
<ul>
<li>RTA上主要是执行流量分类。根据源地址的不同，分别把流量标记为AF11、AF21和EF。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/87.png"></p>
<blockquote>
<ul>
<li>在RTB上根据数据包的标记执行不同的QoS策略。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/88.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/89.png"></p>
<blockquote>
<ul>
<li>要实现流量的控制，必须有一种机制可以对通过设备的流量进行度量。令牌桶是目前最常采用的一种流量测量方法，用来评估流量速率是否超过了规定值。</li>
<li>当数据流到达设备时首先会根据数据的大小从令牌桶中取出与数据大小相当的令牌数量用来传输数据。也就是说要使数据被传输必须保证令牌桶里有足够多的令牌，如果令牌数量不够，则数据会被丢弃或缓存。这就可以限制报文的流量只能小于等于令牌生成的速度，达到限制流量的目的。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/90.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/91.png"></p>
<blockquote>
<ul>
<li>对于单速率标记算法的实现，华为路由器采用双桶结构。</li>
<li>双桶结构由两个桶实现，为方便将两个令牌桶称为C桶和E桶。C桶容量为CBS，E桶容量为EBS，总容量是CBS+EBS。如果不允许有突发流量，EBS则设置成0。</li>
<li>当EBS≠0时，称为单速双桶。当EBS=0，E桶的令牌数始终为0，相当于只使用了一个令牌桶——C桶，这种情况也称为单速单桶。单速单桶中，报文只标记为绿、红两色。</li>
<li>CIR CBS EBS的单位 :<ul>
<li>CIR（Committed Information Rate）：承诺信息速率，单位是bit/s，表示向令牌桶中投放令牌的速率。</li>
<li>CBS（Committed Burst Size）：承诺突发尺寸，单位为bit，用来定义在部分流量超过CIR之前的最大突发流量，即为令牌桶的容量（深度）。承诺突发尺寸必须大于报文的最大长度（最大时一个分组可以领取桶中的全部令牌）。CBS越大，表示所允许的突发量越大。</li>
<li>EBS（Extended burst size）：超额突发尺寸，用来定义在所有流量超过CIR之前的最大突发量。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/92.png"></p>
<blockquote>
<ul>
<li><p><strong>单速率令牌添加方式</strong></p>
<ul>
<li>单速率标记算法中，初始状态时两桶是满的。先往C桶中添加令牌，等C桶满了，再往E桶中添加令牌（E桶的令牌用做以后临时超过CIR的突发流量），当两桶都被填满时，新产生的令牌将会被丢弃。 </li>
</ul>
</li>
<li><p><strong>单速率流量评估规则</strong></p>
<ul>
<li><p>当报文到来后，直接与桶中的令牌数相比较，如果有足够的令牌就转发（通常用一个令牌关联一个比特的转发权限），如果没有足够的令牌则丢弃或缓存。</p>
</li>
<li><p>为方便用Tc和Te表示桶中的令牌数量，Tc和Te初始化等于CBS和EBS。</p>
</li>
<li><p>色盲模式下，在对到达报文（假设报文大小为B）进行评估时，遵循以下规则：</p>
</li>
<li><p>对于单速单桶：</p>
<ul>
<li>如果报文长度不超过C桶中的令牌数Tc，则报文被标记为绿色，且Tc=Tc-B，</li>
<li>如果报文长度超过C桶中的令牌数Tc，报文被标记为红色，Tc值不变。</li>
</ul>
</li>
<li><p>对于单速双桶：</p>
<ul>
<li>如果报文长度不超过C桶中的令牌数Tc，则报文被标记为绿色，且Tc=Tc-B，</li>
<li>如果报文长度超过C桶中的令牌数Tc但不超过E桶中的令牌数Te，则报文被标记为黄色，且Te=Te-B，</li>
<li>如果报文长度超过E桶中的令牌数Te，报文被标记为红色，但Tc和Te不变。</li>
</ul>
</li>
<li><p>色敏模式下，在对到达报文（假设报文大小为B）进行评估时，遵循以下规则：</p>
</li>
<li><p>对于单速单桶：</p>
<ul>
<li>如果报文已被标记为绿色但报文长度不超过C桶中的令牌数Tc，则报文被标记为绿色，且Tc=Tc-B；</li>
<li>如果报文已被标记为绿色且报文长度超过C桶中的令牌数Tc，则报文被标记为红色，Tc保持不变；</li>
<li>如果报文已被标记为黄色或红色，都直接将报文标记为红色，Tc保持不变。</li>
</ul>
</li>
<li><p>对于单速双桶：</p>
<ul>
<li>如果报文已被标记为绿色且报文长度不超过C桶中的令牌数Tc，则报文被标记为绿色，且Tc=Tc-B，</li>
<li>如果报文已被标记为绿色且报文长度超过C桶中的令牌数Tc但不超过E桶中的令牌数Te，则报文被标记为黄色，且Te=Te-B，</li>
<li>如果报文已被标记为黄色但报文长度不超过E桶中的令牌数Te，则报文被标记为黄色，且Te=Te-B，</li>
<li>如果报文已被标记为黄色且报文长度超过E桶中的令牌数Te，则报文被标记为红色，且Te保持不变，</li>
<li>如果报文已被标记为红色，直接将报文标记为红色，Tc和Te不变。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/93.png"></p>
<blockquote>
<ul>
<li>CIR（Committed Information Rate）：承诺信息速率，表示端口允许的信息流平均速率，单位是bit/s。</li>
<li>CBS（Committed Burst Size）：承诺突发尺寸，用来定义在部分流量超过CIR之前的最大突发流量，单位为bit。承诺突发尺寸必须不小于报文的最大长度。</li>
<li>PIR（Peak Information Rate）：表示峰值信息速率，表示端口允许的突发流量的最大速率，单位是bit/s。该值必须不小于CIR的设置值。</li>
<li>PBS（Peak Burst Size）：表示峰值突发尺寸，用来定义每次突发所允许的最大的流量尺寸。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/94.png"></p>
<blockquote>
<ul>
<li><p>双速率三色标记算法业界都使用两个令牌桶，但它关注的是速率的突发，所以不像单速率三色标记算法那样把第一个桶中未使用的令牌放到第二个桶中，而是使用两个独立的令牌桶，存在两个令牌填充速率。为方便将两个令牌桶称为C桶和P桶，C桶容量为CBS，令牌填充速率为CIR，P桶容量为PBS，令牌填充速率为PIR。</p>
</li>
<li><p>说明： “双速率”是指该算法中两个令牌桶中的令牌填充速率不同。</p>
</li>
<li><p><strong>双速率令牌添加方式</strong></p>
<ul>
<li>初始状态时两桶是满的。往C桶和P桶分别以CIR和PIR的速率填充令牌。因这两个令牌桶是相互独立的，当其中一个桶被填满时，这个桶新产生的令牌将会被丢弃，另一个桶继续填令牌。</li>
</ul>
</li>
<li><p><strong>双速率流量评估规则</strong></p>
<ul>
<li>双速率三色标记算法关注的是速率的突发，首先评估的是数据流的速率是否符合规定的突发要求，其规则是先比较P桶，再比较C桶。</li>
<li>双速率三色标记算法也有色盲模式和色敏模式两种。为方便用Tc和Tp表示桶中的令牌数量，Tc和Tp初始化等于CBS和PBS。</li>
<li>色盲模式下，在对到达报文（假设数据包大小为B）进行评估时，遵循以下规则：<ul>
<li>如果报文长度超过P桶中的令牌数Tp，则报文被标记为红色，且Tc和Tp保持不变，</li>
<li>如果报文长度不超过P桶中的令牌数Tp但超过C桶中的令牌数Tc，则报文被标记为黄色，且Tp=Tp-B，</li>
<li>如果报文长度不超过C桶中的令牌数Tc，报文被标记为绿色，且Tp=Tp-B，Tc=Tc-B。</li>
</ul>
</li>
<li>色敏模式下，在对到达报文（假设报文大小为B）进行评估时，遵循以下规则：<ul>
<li>如果报文已被标记为绿色且报文长度超过P桶中的令牌数Tp，则报文被标记为红色，且Tp和Tc不变。</li>
<li>如果报文已被标记为绿色且报文长度不超过P桶中的令牌数Tp但超过C桶中的令牌数Tc，则报文被标记为黄色，且Tp=Tp-B，Tc不变</li>
<li>如果报文已被标记为绿色且报文长度不超过C桶中的令牌数Tc，则报文被标记为绿色，且Tp=Tp-B，Tc=Tc-B。</li>
<li>如果报文已被标记为黄色，则只比较P桶，如果报文长度超过P桶中的令牌数Tp，则报文被标记为红色，且Tp和Tc不变。</li>
<li>如果报文已被标记为黄色，且报文长度不超过P桶的令牌数，则报文被标记为黄色，且Tp=Tp-B，Tc不变。</li>
<li>如果报文已被标记为红色，直接将报文标记为红色，Tc和Tp不变。</li>
</ul>
</li>
</ul>
</li>
<li><p>CIR PIR CBS PBS的单位 :</p>
<ul>
<li><strong>cir</strong> <em>cir-value</em> 指定承诺信息速率，即保证能够通过的速率。 整数形式，取值范围是0～4294967295，单位是kbit/s。</li>
<li><strong>pir</strong> <em>pir-value</em> 指定峰值速率，即最大能够通过的速率。 整数形式，取值范围是0～4294967295，单位是kbit/s。参数<em>pir*</em>-value<em>的值不应小于已经配置的</em>cir-value*的值。</li>
<li><strong>cbs</strong> <em>cbs-value</em> 指定承诺突发尺寸（Committed Burst Size），即瞬间能够通过的承诺流量，即第一个令牌桶的深度（假定该桶为C桶）。 整数形式，0～4294967295，单位是byte。 CBS的取值必须大于已经配置的CIR的值。缺省值与配置的<em>cir-value</em>有关。</li>
<li><strong>pbs</strong> <em>pbs-value</em> 指定超出突发尺寸（Peak Burst Size），即瞬间能够通过的峰值流量，即第二个令牌桶的深度（假定该桶为P桶）。 整数形式，0～4294967295单位是byte。 缺省值与<em>pir*</em>-value*有关</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/95.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/96.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/97.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/98.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/99.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/0.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/1.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/2.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/3.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/4.png"></p>
<blockquote>
<ul>
<li><p>传统的IP网络无区别地对待所有的报文，网络设备处理报文采用的策略是先入先出FIFO（First In First Out），它依照报文到达时间的先后顺序分配转发所需要的资源。所有报文共享网络和设备的带宽等资源，然而最终得到资源的多少完全取决于报文到达的时机。</p>
</li>
<li><p>FIFO尽最大的努力将报文送到目的地，但对报文的延迟、抖动、丢包率和可靠性等需求不提供任何承诺和保证，故对于一些关键业务（如语音、视频等）的通信质量无法进行保证。</p>
</li>
<li><p>那该如何提升端到端的通信质量呢？影响通信质量的因素都有哪些？</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/5.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/6.png"></p>
<blockquote>
<ul>
<li>我们已经知道影响端到端通信质量的因素，所以从这些因素入手就可以达到我们的目的。那这些因素各自都有什么特点呢？他们影响通信质量的具体表现是什么呢？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/7.png"></p>
<blockquote>
<ul>
<li><p>网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。</p>
</li>
<li><p>如图所示，尽管传输途径上的最大的一段链路带宽是1Gbps，但是数据从一个用户传到另一个用户的最大传输速率只能是256kbps，因为传输的最大带宽是由传输路径上的最小链路带宽决定的。正是因为这样，带宽小的链路是影响传输速率的关键。</p>
</li>
<li><p>如果网络上存在多个数据流，它们互相竞争带宽，可以通过增大带宽来获得更好的网络体验，但是提升了带宽之后又会催生新的应用，故不能无限地增加网络带宽，且增加带宽还需要提高成本，那么我们是否可以先保证重要业务的带宽呢？</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/8.png"></p>
<blockquote>
<ul>
<li><p>时延是指一个报文从一个网络的一端传送到另一端所需要的时间。</p>
</li>
<li><p>实时应用通信质量都比较关注时延大小，如语音、视频等。以语音传输为例，时延是指从说话者开始说话到对方听到所说内容的时间。若时延太大，会引起通话声音不清晰、不连贯或破碎。</p>
</li>
<li><p>单个网络设备的时延包括传输时延、串行化时延、处理时延、以及队列时延。</p>
<ul>
<li>传输时延：一个数据位从发送方到达接收方所需要的时间。该时延取决于传输距离和传输介质，与带宽无关。</li>
<li>串行化时延：指发送节点在传输链路上开始发送报文的第一个比特至发完该报文的最后一个比特所需的时间。该时延取决于链路带宽以及报文大小。</li>
<li>处理时延：指路由器把报文从入接口放到出接口队列需要的时间。它的大小跟路由器的处理性能有关。</li>
<li>队列时延：指报文在队列中等待的时间。它的大小跟队列中报文的大小和数量、带宽以及队列机制有关。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/9.png"></p>
<blockquote>
<ul>
<li>由于每个报文的端到端时延不一样，就会导致这些报文不能等间隔到达目的端，这种现象叫做抖动。一般来说，时延越小则时延抖动的范围越小。</li>
<li>某些业务类型（特别是语音和视频等实时业务）是极其不能容忍抖动的。报文到达时间的差异将在语音或视频中造成断续；另外，抖动也会影响一些网络协议的处理，有些协议是按固定的时间间隔发送交互性报文，抖动过大就会导致协议震荡，而实际上所有传输系统都有抖动，但只要抖动在规定容差之内就不会影响服务质量，另外，可利用缓存来克服过量的抖动，但这将会增加时延。</li>
<li>抖动的大小跟时延的大小直接相关，时延小则抖动的范围也小，时延大则可能抖动的范围也大。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/10.png"></p>
<blockquote>
<ul>
<li><p>丢包率是指在网络传输过程中丢失报文占传输报文的百分比。丢包可用于衡量网络的可靠性。</p>
</li>
<li><p>丢包（packet loss）可能在所有环节中发生，例如：</p>
<ul>
<li>处理过程：路由器在收到报文的时候可能由于CPU繁忙，无法处理报文而导致丢包；</li>
<li>排队过程：在把报文调度到队列的时候可能由于队列被装满而导致丢包；</li>
<li>传输过程：报文在链路上传输的过程中，可能由于种种原因（如链路故障等）导致的丢包。</li>
</ul>
</li>
<li><p>少量的丢包对业务的影响并不大，例如，在语音传输中，丢失一个比特或一个报文的信息，通话双方往往注意不到；在视频广播期间，丢失一个比特或一个报文可能造成屏幕上瞬间的波形干扰，但视频很快就会恢复正常。即使使用传输控制协议（TCP）传送数据也能处理少量的丢包，但大量的丢包就会严重影响到传输效率。</p>
</li>
<li><p>了解完这些影响通信质量因素的特点之后，请思考在进行实际网络部署时，具体该采用什么方法来提升通信质量呢？</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/11.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/12.png"></p>
<blockquote>
<ul>
<li><p>传统的先进先出转发即Best-Effort（尽力而为）服务模型：</p>
<ul>
<li>Best-Effort是一个单一的服务模型，也是最简单的服务模型。应用程序可以在任何时候，发出任意数量的报文，而且不需要事先获得批准，也不需要通知网络。</li>
<li>应用Best-Effort服务模型的网络尽最大的可能性来发送报文，但对时延、可靠性等性能不提供任何保证，但它适用于绝大多数网络应用，如FTP、E-Mail等。</li>
<li>Best-Effort服务是现在Internet的缺省服务模型，它是通过先入先出（FIFO）队列来实现的。</li>
</ul>
</li>
<li><p>在尽力而为的服务模型下，可通过增大网络带宽和升级网络设备来提高端到端通信质量：</p>
<ul>
<li>增大网络带宽：可以增大单位时间内传输的数据量，使其按照传统先进先出的方式在单位时间内传输更多的数据，改善网络拥塞问题。</li>
<li>升级网络设备：可以增大数据处理能力，使其按照传统先进先出的方式在单位时间内能够处理更多的数据，改善网络拥塞问题。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/13.png"></p>
<blockquote>
<ul>
<li>RSVP协议工作过程：在应用程序发送报文前，需要向网络申请特定的带宽和所需的特定服务质量的请求，等收到确认信息后才发送报文。</li>
<li>综合服务模型（Integrated Services Model）：<ul>
<li>IntServ是一种最为复杂的服务模型，它需要用到RSVP（Resource Reservation Protocol）协议。该服务模型在发送报文前，需要向网络申请特定的服务。这个请求是通过信令（signal）来完成的，应用程序首先通知网络它自己的流量参数和所需的特定服务质量的请求，包括带宽、时延等。应用程序一般在收到网络的确认信息后，即认为网络已经为这个应用程序的报文发送预留了资源，然后立即发送报文。</li>
<li>IntServ模型要求端到端网络的所有节点都支持RSVP协议，且每个节点都需要周期性地同相邻节点交换状态信息，这样就会加大协议报文导致的开销。更关键的是，所有网络节点都需要为每个数据流保存状态信息，而当前在Internet骨干网上有着成千上万条数据流，因此IntServ模型在Internet骨干网上无法得到广泛应用。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/14.png"></p>
<blockquote>
<ul>
<li>DiffServ区分服务工作过程：首先将网络中的流量分成多个类，然后为每个类定义相应的处理行为，使其拥有不同的优先转发、丢包率、时延等。</li>
<li>Diffserv服务模型概述：<ul>
<li>业务流分类和标记由边缘路由器来完成。边界路由器可以通过多种条件（比如报文的源地址和目的地址、ToS域中的优先级、协议类型等）灵活地对报文进行分类，然后对不同类型的报文设置不同的标记字段，而其他路由器只需要简单地识别报文中的这些标记，然后对其进行相应的资源分配和流量控制即可。因此，DiffServ是一种基于报文流的QoS模型。</li>
<li>它只包含有限数量的服务等级，少量的状态信息来提供有差别的流量控制和转发。</li>
<li>DS节点：实现DiffServ功能的网络节点称为DS节点。</li>
<li>DS边界节点：负责连接另一个DS域或者连接一个没有DS功能的域的节点。DS边界节点负责将进入此DS域的业务流进行分类和流量调整。</li>
<li>DS内部节点：用于在同一个DS域中连接DS边界节点和其他内部节点。DS内部节点仅需基于报文中的EXP、802.1p、IPP等字段值进行简单的流分类以及对相应的流进行流量控制。</li>
<li>DS域（DS Domain）：一组采用相同的服务提供策略和实现了相同PHB（Per Hop Behaviors）的相连DS节点组成。一个DS域由相同管理部门的一个或多个网络组成，如一个DS域可以是一个ISP，也可以是一个企业的内部网络。</li>
<li>DiffServ模型充分考虑了IP网络本身所具有的灵活性、可扩展性强等特点，将复杂的服务质量保证通过报文自身携带的信息转换为单跳行为，从而大大减少了信令的工作。该模型是目前应用最广的服务模型。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/15.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/16.png"></p>
<blockquote>
<p>1、答案：ABC。</p>
<p>2、答案：带宽、时延、抖动、丢包率。</p>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/17.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/18.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/19.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/20.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/21.png"></p>
<blockquote>
<ul>
<li>报文分类的依据都有哪些呢？先前我们学过利用ACL可以匹配五元组来进行分类，那QoS都支持哪些分类方式呢？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/22.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/23.png"></p>
<blockquote>
<ul>
<li>根据IEEE 802.1Q定义，VLAN TAG中的PRI字段用于标识QoS服务等级。</li>
<li>对于MPLS报文，通常将标签信息中的EXP域作为MPLS报文的CoS域，与IP网络的ToS域等效，用来区分数据流量的服务等级。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/24.png"></p>
<blockquote>
<ul>
<li><p>D bit代表延迟（Delay），T bit代表吞吐量（Throughput），R bit代表可靠性（Reliability）。</p>
</li>
<li><p>根据RFC791定义，IP报文头ToS（Type of Service）域中的Precedence字段标识了该报文的优先级。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/25.png"></p>
<blockquote>
<ul>
<li>在RFC2474中对IPv4报文头的ToS字段进行了重新定义，称为DS（Differentiated Services）字段。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/26.png"></p>
<blockquote>
<ul>
<li>AFxy中，x代表不同的类别，根据不同的分类后续可以定义进入相对应的队列，y代表当队列被装满的时候丢包的概率，例如AF1类中的报文，其中丢包概率由小到大排序为AF11&lt;AF12&lt;AF13。</li>
<li>不同关键字常用于标识不同报文（可自行定义）：<ul>
<li>CS6和CS7默认用于协议报文，而且是大多数厂商设备的硬件队列里最高优先级的报文，因为如果这些报文无法接收的话会引起协议中断。</li>
<li>EF常用于承载语音的流量，因为语音要求低延迟，低抖动，低丢包率，是仅次于协议报文的最重要的报文。</li>
<li>AF4用来承载语音的信令流量，这里大家可能会有疑问为什么这里语音要优先于信令呢？ 其实是这样的，这里的信令是电话的呼叫控制，你是可以忍受在接通的时候等待几秒钟的，但是绝对不能允许在通话的时候的中断。所以语音要优先于信令。</li>
<li>AF3可以用来承载IPTV的直播流量，直播的实时性很强，需要连续性和大吞吐量的保证。</li>
<li>AF2可以用来承载VOD（Video on Demand：视频点播）的流量，相对于直播流量来说，VOD对实时性要求没那么强烈，允许有时延或者缓冲。</li>
<li>AF1可以用来承载普通上网业务。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/27.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/28.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/29.png"></p>
<blockquote>
<ul>
<li>复杂流分类：<ul>
<li>复杂流分类是指根据五元组（源地址、目的地址、源端口号、目的端口号、协议号码）等报文信息对报文进行精细的分类（一般的分类依据都局限在封装报文的头部信息，使用报文内容作为分类的标准比较少见）。</li>
<li>缺省应用于网络的边缘位置。报文进入边缘节点时，网络管理者可以灵活配置分类规则。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/30.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/31.png"></p>
<blockquote>
<ul>
<li>一般在DS边界节点对报文进行分类（如图SWA、SWB）。</li>
<li>下游（downstream）设备可以选择接收上游（upstream）设备的分类结果，也可以按照自己的分类标准对报文进行重新分类。</li>
<li>端到端进行QoS部署时，如果需要每台设备都对报文进行分类，那么就会导致耗费大量地设备处理资源，为此提出了对报文进行标记的方法，这样下游设备只需要对标记进行识别即可提供差分服务。那标记是如何实现的呢？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/32.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/33.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/34.png"></p>
<blockquote>
<ul>
<li>一般在DS边界节点（如图SWA、SWB）对报文进行标记，DS节点对标记进行识别并提供差分服务即可。</li>
<li>像语音电话、视频终端等设备一般发送的报文都是携带设备默认标识的优先级值。若想通过自定义的值来提供差分服务，可以通过remark操作对报文进行重新标记。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/35.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/36.png"></p>
<blockquote>
<ul>
<li>在DS边界节点SWA上对报文重新进行remark，为DS域提供一个可信任的标记值。DS域内节点可根据此标记值进行QoS调度服务。</li>
<li>在此例中，边界节点SWA被称为可信任边界。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/37.png"></p>
<blockquote>
<p>1、答案：简单流分类和复杂流分类。</p>
<p>2、答案：端到端进行QoS部署时，就需要每台设备都对报文进行分类，这样就会导致耗费大量地设备处理资源，为此提出了对报文进行标记的方法，这样下游设备只需要对标记进行识别即可提供差分服务。</p>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/38.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/39.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/40.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/41.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/42.png"></p>
<blockquote>
<ul>
<li><p>拥塞发生的主要场景：</p>
<ul>
<li>速率不匹配：报文从高速链路进入设备，再由低速链路转发出去。</li>
<li>汇聚问题：报文从多个接口同时进入设备，由一个没有足够带宽的接口转发出去。</li>
</ul>
</li>
<li><p>拥塞可能会引发一系列的负面影响：</p>
<ul>
<li>增加了报文传输的时延和抖动。</li>
<li>过高的延迟会引起报文重传。</li>
<li>使网络的有效吞吐率降低，造成网络资源的损害。</li>
<li>加剧耗费大量的网络资源（特别是存储资源），不合理的资源分配甚至可能导致系统陷入资源死锁而崩溃。</li>
</ul>
</li>
</ul>
<p>由此可见，拥塞使流量不能及时获得资源，是造成服务性能下降的源头。然而在报文交换以及多用户业务并存的复杂环境下，拥塞又是常见的。因此采取有效的避免拥塞以及防止拥塞加剧的方法是必需的，那具体实现的方法是怎样的呢？</p>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/43.png"></p>
<blockquote>
<ul>
<li>LP（本地优先级，又称为内部优先级）：优先级映射实现从数据原始携带的QoS优先级到内部优先级或从内部优先级到QoS优先级的映射。<ul>
<li>对于进入设备的报文，设备将报文携带的优先级或者端口优先级映射为内部优先级，然后根据内部优先级与队列之间的映射关系确定报文进入的队列。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/44.png"></p>
<blockquote>
<ul>
<li>具体差分服务是如何通过队列调度来体现的呢？每种队列调度算法又是如何工作的？各自都有什么优缺点？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/45.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/46.png"></p>
<blockquote>
<ul>
<li>FIFO队列不对报文进行分类，当报文进入接口的速度大于出接口能发送的速度时，FIFO按报文到达接口的先后顺序让报文进入队列，同时，FIFO在队列的出口让报文按进队的顺序出队，先进的报文将先出队，后进的报文将后出队。</li>
<li>FIFO队列具有处理简单，开销小的优点。但FIFO不区分报文类型，采用尽力而为的服务模型，使得对时延敏感的实时应用的延迟得不到保证，关键业务的带宽也不能得到保证。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/47.png"></p>
<blockquote>
<ul>
<li>PQ队列是针对关键业务应用设计的，且关键业务有一个重要特点，就是需要在拥塞发生时要求优先获得服务以减少响应的延迟。</li>
<li>PQ调度机制：分为4个队列，分别为高优先队列、中优先队列、正常优先队列和低优先队列，它们的优先级依次降低。在报文出队的时候，PQ会首先让高优先队列中的报文出队并发送，直到高优先队列中的报文发送完，然后发送中优先队列中的报文，同样，直到发送完，然后是正常优先队列和低优先队列。如此的话，将关键业务的报文放入较高优先级的队列，将非关键业务（如E-Mail）的报文放入较低优先级的队列，可以保证关键业务的报文被优先传送，非关键业务的报文在处理关键业务数据的空闲间隙被传送。</li>
<li>如果高优先级队列中持续有报文等待被发送，那么后面较低优先级队列中的报文就迟迟不能得到发送，出现“饿死”现象。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/48.png"></p>
<blockquote>
<ul>
<li>WRR（Weight Round Robin）加权循环调度在RR（Round Robin）调度的基础上演变而来，根据每个队列的权重来轮流调度各队列中的报文流。实际上，RR调度相当于权值为1的WRR调度。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/49.png"></p>
<blockquote>
<ul>
<li>WFQ对报文按流特征进行分类，对于IP网络，相同源IP地址、目的IP地址、源端口号、目的端口号、协议号、ToS的报文属于同一个流，而对于MPLS网络，具有相同的标签和EXP域值的报文属于同一个流。每一个流被分配到一个队列，该过程称为散列，采用HASH算法来自动完成，这种方式会尽量将不同特征的流分入不同的队列中。WFQ允许的队列数目是有限的，用户可以根据需要配置该值。 </li>
<li>在出队的时候，WFQ按流的优先级来分配每个流应占有的出口带宽。优先级的数值越小，所得的带宽越少。优先级的数值越大，所得的带宽越多。这样就保证了相同优先级业务之间的公平，体现了不同优先级业务之间的权值。</li>
<li>WFQ优点在于配置简单，但由于流是自动分类，无法手工干预，故缺乏一定的灵活性；且受资源限制，当多个流进入同一个队列时无法提供精确服务，无法保证每个流获得的实际资源量。WFQ均衡各个流的延迟与抖动，同样也不适合延迟敏感的业务应用。 </li>
<li>通过以上分析，会发现如果所有队列都应用一种调度算法都存在各自的优缺点，且不能很好地满足业务需求，但通过分析会发现有些调度算法之间的优缺点正好是互补的，试想：是否可以设置不同的队列应用不同的调度算法，这样是否就能很大程度满足业务需求呢？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/50.png"></p>
<blockquote>
<ul>
<li><p>PQ+WFQ调度过程：</p>
<ul>
<li>如图，在进行调度时，首先按照PQ方式优先调度Queue7、Queue6和Queue5队列中的报文流，只有这些队列中的报文流全部调度完毕后，才开始以WFQ方式调度Queue4、Queue3、Queue2、Queue1和Queue0队列中的报文流。其中，Queue4、Queue3、Queue2、Queue1和Queue0队列包含自己的权值。</li>
<li>重要的协议报文以及有低时延需求的业务报文应放入PQ调度队列中，得到优先调度的机会，其他报文则可放入以WFQ方式调度的各队列中。</li>
</ul>
</li>
<li><p>PQ+WFQ优缺点：</p>
<ul>
<li>其集合了PQ调度和WFQ调度各自的优缺点。单纯采用PQ调度时，低优先级队列中的报文流可能会长期得不到带宽，而单纯采用WFQ调度时，低延时需求业务可能得不到及时调度，而如果将两种调度方式结合起来形成PQ+WFQ调度方式，其不仅能发挥两种调度的优势，而且能互补一些各自特有的缺点。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/51.png"></p>
<blockquote>
<ul>
<li>CBQ（Class-based Queueing）基于类的加权公平队列是对WFQ功能的扩展，为用户提供了自定义类的支持。CBQ首先根据IP优先级或者DSCP优先级、入接口、IP报文的五元组等规则来对报文进行分类，然后让不同类别的报文进入不同的队列。对于不匹配任何类别的报文，会送入系统定义的缺省类。</li>
<li>CBQ提供三类队列：<ul>
<li>EF队列：满足低时延业务。<ul>
<li>EF队列拥有绝对优先级，仅当EF队列中的报文调度完毕后，才会调度其他队列中的报文。 </li>
</ul>
</li>
<li>AF队列：满足需要带宽保证的关键数据业务。<ul>
<li>每个AF队列分别对应一类报文，用户可以设定每类报文占用的带宽。当系统调度报文出队的时候，会按用户为各类报文设定的带宽将报文进行出队发送，可实现各个类的队列的公平调度。</li>
</ul>
</li>
<li>BE队列：满足不需要严格QoS保证的尽力发送业务。<ul>
<li>当报文不匹配用户设定的所有类别时，报文会被送入系统定义的缺省BE（Best Effort，尽力传送）类。BE队列使用接口剩余带宽和WFQ调度方式进行发送。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/52.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/53.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/54.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/55.png"></p>
<blockquote>
<ul>
<li>此页配置参数与前文标题为“拥塞管理实现的第一步”的一页内容相对应。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/56.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/57.png"></p>
<blockquote>
<ul>
<li>思考：尾丢弃这种方式有什么利弊？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/58.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/59.png"></p>
<blockquote>
<ul>
<li>TCP全局同步：对于TCP报文，如果大量的报文被丢弃，将造成TCP超时，从而引发TCP慢启动，使得TCP减少报文的发送。当队列同时丢弃多个TCP连接的报文时，将造成多个TCP连接同时进入拥塞避免和慢启动状态以调整并降低流量，这就被称为TCP全局同步现象。这样多个TCP连接发往队列的报文将同时减少，而后又会在某个时间同时出现流量高峰，如此反复，使网络资源利用率低。</li>
<li>思考：该如何来避免TCP全局同步现象？问题的核心是什么？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/60.png"></p>
<blockquote>
<ul>
<li><p>为避免TCP全局同步现象，出现了RED（Random Early Detection）技术。RED通过随机地丢弃数据报文，让多个TCP连接不同时降低发送速度，从而避免了TCP的全局同步现象。使TCP速率及网络流量都趋于稳定。</p>
</li>
<li><p>RED为每个队列的长度都设定了阈值门限，并规定： </p>
<ul>
<li>当队列的长度小于低门限时，不丢弃报文。 </li>
<li>当队列的长度大于高门限时，丢弃所有收到的报文。 </li>
<li>当队列的长度在低门限和高门限之间时，开始随机丢弃到来的报文。方法是为每个到来的报文赋予一个随机数，并用该随机数与当前队列的丢弃概率比较，如果大于丢弃概率则报文被丢弃。队列越长，报文被丢弃的概率越高。</li>
</ul>
</li>
<li><p>思考：尾丢弃对于丢弃TCP报文造成全局同步现象，还会对其造成其他的影响么？</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/61.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/62.png"></p>
<blockquote>
<ul>
<li>RED技术是否可以解决尾丢弃的缺点二和三？为什么？</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/63.png"></p>
<blockquote>
<ul>
<li>基于RED技术，又实现了WRED（Weighted Random Early Detection）技术，可实现每一种优先级都能独立设置报文的丢包的高门限、低门限及丢包率，报文到达低门限时，开始丢包，到达高门限时丢弃所有的报文，随着门限的增高，丢包率不断增加，最高丢包率不超过设置的最大丢包率，直至到达高门限，报文全部丢弃。这样按照一定的丢弃概率主动丢弃队列中的报文，从一定程度上避免了尾丢弃带来的所有缺点。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/64.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/65.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/66.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/67.png"></p>
<blockquote>
<p>1、答案：拥塞管理机制的实现过程分为：</p>
<ul>
<li>第一步：将准备从一个接口发出的所有报文放入不同的队列中；</li>
<li>第二步：根据各队列间的调度机制实现不同报文的差分转发。</li>
</ul>
<p>2、答案：FIFO、PQ、WFQ、PQ+WFQ、CBQ等。</p>
<p>3、答案：A。</p>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/68.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/69.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/70.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/71.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/72.png"></p>
<blockquote>
<ul>
<li>流量监管功能可对接收或发送的流量进行限速控制，限制进入网络的突发流量，为网络提供了基本的QoS功能。</li>
<li>流量监管TP（Traffic Policing）的典型应用是监督进入网络的某一流量的规格，把它限制在一个合理的范围之内，并对超出部分的流量进行“惩罚”，以保护网络资源和运营商的利益。</li>
<li>流量监管通常使用承诺访问速率CAR（Committed Access Rate）来限制某类报文的流量。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/73.png"></p>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/74.png"></p>
<blockquote>
<ul>
<li>流量整形TS（Traffic Shaping）的典型作用是限制流出某一网络的某一连接的正常流量与突发流量，使这类报文以比较均匀的速度向外发送，是一种主动调整流量输出速率的措施，故只能对输出的流量进行速率控制。常用GTS（Generic Traffic Shaping）技术来限制某类流量。</li>
<li>应用场景：当网络中上下游的接口带宽不匹配，尤其是上游接口的带宽资源大于下游的带宽资源时，容易在下游网络形成拥塞。如果不希望下游网络因为上游发送数据流量过大造成拥塞，可在上游的出接口配置流量整形，使上游发送的流量与下游接收的能力相匹配。报文可以均匀向外发送，而且部分超出规格的报文不直接丢弃，而是进行缓存，等待链路空闲的时候再发送出去。</li>
</ul>
</blockquote>
<p><img src="/2021/08/31/IE-QoS%E6%8A%80%E6%9C%AF/75.png"></p>
<blockquote>
<p>1、答案：在进行报文流量控制时，流量监管是对超过流量限制的报文进行丢弃；而流量整形则将超过流量限制的报文缓存在队列中，等待链路空闲的时候再发送。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/" itemprop="url">IE-MPLS-BGP-VPN跨域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-23T10:20:47+08:00">
                2021-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/1.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/2.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/3.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/4.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/5.png"></p>
<blockquote>
<ul>
<li>引入：</li>
<li>随着MPLS VPN解决方案的广泛应用，大型企业不同的分支站点之间，或相互协作的企业网络之间都存在着跨越不同自治域的情况。</li>
<li>举例：</li>
<li>一般的MPLS VPN体系结构都是在一个自治系统内运行，任何VPN的路由信息都是只能在一个自治系统内按需扩散，没有提供自治系统内的VPN信息向其他自治系统扩散的功能。</li>
<li>如上图，基于MPLS的VPN可以将私有网络的不同Site连接起来，形成一个统一的网络，基于MPLS的VPN还支持对不同VPN间的互通控制。CE（Customer Edge）是用户边缘设备；PE（Provider Edge）是服务商边缘路由器，位于骨干网络；P（Provider），是服务提供商网络中的骨干路由器，不与CE直接相连。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/6.png"></p>
<blockquote>
<ul>
<li>如果同一VPN的两个站点位于不同的AS，那么普通的MPLS BGP VPN是否还合适于业务的部署？</li>
<li>答案是否定的。因为此时连接VPN的PE路由器已经无法简单地建立IBGP邻居关系了，或是与RR建立邻居关系。因此，需要一些手段通过建立EBGP邻居关系来传递VPNv4路由。</li>
<li>为了支持不同AS之间的VPN路由信息交换，就需要扩展现有的协议和修改MPLS VPN体系框架，提供一个不同于基本的MPLS VPN体系结构所提供的互连模型——跨域（Inter-AS）的MPLS VPN，以便可以穿过AS间的链路来发布路由前缀和标签信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/7.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/8.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/9.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/10.png"></p>
<blockquote>
<ul>
<li>在本方案中，ASBR-PE之间直接相连。两台ASBR-PE之间用多个接口(包括子接口)互连，每个接口关联一个VPN，每个ASBR-PE都把对端当成CE。因此，ASBR-PE相连的接口(包括子接口)需要绑定VRF，并通过eBGP邻居关系把VPNv4路由转变成普通IPv4路由从一个AS传递到另一个AS。因此，两个ASBR相连，但不需要启用MPLS。此方案在MPLS BGP VPN业务属性上没有做扩展。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/11.png"></p>
<blockquote>
<p>我们只通过单方向来解释控制平面的工作过程，同时假设在站点Site1有一VPN路由Client1连接，如上图，现在需要把Client1这条路由从CE1穿过AS100和AS200传递到CE2：</p>
<p>1.在AS100中，通过运行LDP协议，PE1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T1给P1。</p>
<p>2.在AS100中，通过运行LDP协议，P1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T2给ASBR-PE1。</p>
<p>3.在AS200中，同样通过运行LDP协议，ASBR-PE2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T3给P2。</p>
<p>4.在AS200中，通过运行LDP协议，P2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T4给PE2。</p>
<p>5.CE1 通告路由Client1给PE1，路由的下一跳为CE1的接口地址。</p>
<p>6.PE1将IPv4路由Client1通过MP-BGP重发布为VPNv4路由，并且下一跳改为PE1，分配一个VPN标签V1，然后通告给ASBR-PE1。</p>
<p>7.ASBR-PE1将VPNv4路由变为IPv4路由，把IPv4路由Client1通告给ASBR-PE2，并且下一跳指向ASBR-PE1。</p>
<p>8.ASBR-PE2将IPv4路由Client1通过MP-BGP重发布为VPNv4路由，并且下一跳为ASBR-PE2，为该路由分配一个VPN标签V2，将其通告给PE2。</p>
<p>9.PE2将VPNv4路由转变为IPv4路由Client1，把路由Client1通告给CE2，并且下一跳指向PE2。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/12.png"></p>
<blockquote>
<p>通过前文的过程分析，我们从反向来分析转发平面的工作过程，即CE2要发送一个目的地为Client1的IP报文给CE1，如上图所示：</p>
<p>1.CE2发送一个目的地为Client1的IP报文给PE2。</p>
<p>2.PE2收到IP报文后进行MPLS标签的封装，先封装VPN标签V2，再封装外层标签T4，然后将此报文发送给P2。</p>
<p>3.P2进行标签交换，把外层标签T4换成T3，然后将此报文发送给ASBR-PE2。</p>
<p>4.ASBR-PE2去掉所有标签，将报文(普通IP报文)转发给ASBR-PE1。</p>
<p>5.ASBR-PE1收到IP报文后进行MPLS标签的封装，先封装VPN标签V1，再封装外层标签T2，然后将此报文发送给P1。</p>
<p>6.P1进行标签交换，把外层标签T2换成T1，然后将此报文发送给PE1。</p>
<p>7.PE1收到后去掉所有标签，将报文(普通IP报文)转发给CE1。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/13.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/14.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/15.png"></p>
<blockquote>
<ul>
<li>此例中，为方便描述，采用不带RR的方式。带RR的实现方式可参考下文OptionB配置章节。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/16.png"></p>
<blockquote>
<ul>
<li>在此方案中，PE通过MP-iBGP将VPNv4路由通告给ASBR-PE或是VPN RR(其中ASBR-PE是其客户机)。ASBR-PE再通过MP-eBGP将VPNv4通告给另一个AS的ASBR-PE，再由这个ASBR-PE将VPNv4路由通告给该AS内的PE。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/17.png"></p>
<blockquote>
<p>我们只通过单方向来解释控制平面的工作过程，同时假设在站点Site1有一VPN路由Client1连接：</p>
<p>1、在AS100中，通过运行LDP协议，PE1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T1给P1</p>
<p>2、在AS100中，通过运行LDP协议，P1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T2给ASBR-PE1</p>
<p>3、在AS200中，同样通过运行LDP协议，ASBR-PE2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T3给P2</p>
<p>4、在AS200中，通过运行LDP协议，P2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T4给PE2</p>
<p>5、CE1 通告路由Client1给PE1，路由的下一跳为CE1的接口地址</p>
<p>6、PE1将IPv4路由Client1通过MP-IBGP重发布为VPNv4路由，并且下一跳改为PE1，分配一个VPN标签V1，然后通告给ASBR-PE1</p>
<p>7、ASBR-PE1通过MP-EBGP将Client1的VPNv4路由通告给ASBR-PE2，将下一跳改为ASBR-PE1，并重新分配一个VPN标签V2</p>
<p>8、ASBR-PE2将收到的Client1的VPNv4路由通过MP-IBGP通告给PE2，将下一跳指向自己，并重新分配一个VPN标签V3</p>
<p>9、PE2将Client1的VPNv4路由变为IPv4路由，把路由Client1通告给CE2，并且下一跳改为PE2</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/18.png"></p>
<blockquote>
<ul>
<li><p>当VPN实例数量较多时，可以部署专门的RR设备。如图，AS内的PE和ASBR设备只与RR设备建立MP-BGP邻居关系，由RR负责路由的反射传递，PE和ASBR之间无需建立BGP邻居。</p>
</li>
<li><p>RR只负责控制平面的VPNv4路由传递，数据转发时，流量不经过RR。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/19.png"></p>
<blockquote>
<p>通过上文的过程分析，我们从反向来分析转发平面的工作过程：</p>
<p>1.CE2发送一个目的地为Client1的IP报文给PE2。</p>
<p>2.PE2收到IP报文后进行MPLS标签的封装，先封装VPN标签V3，再封装外层标签T4，然后将此报文发送给P2。</p>
<p>3.P2进行标签交换，把外层标签T4换成T3，然后将此报文发送给ASBR-PE2。</p>
<p>4.ASBR-PE2去掉外层标签，将VPN标签V3交换为V2，再将其转发给ASBR-PE1（此时报文仅带有一层私网标签）。</p>
<p>5.ASBR-PE交换VPN标签V2成V1，再加一个外层标签T2，并将报文转发给P1。</p>
<p>6.P1进行标签交换，把外层标签T2换成T1，然后将此报文发送给PE1。</p>
<p>7.PE1收到后去掉所有标签，将报文(普通IP报文)转发给CE1。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/20.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/21.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/22.png"></p>
<blockquote>
<ul>
<li>此例中，为方便描述，采用不带RR的方式。带RR的实现方式可参考下文OptionC配置章节。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/23.png"></p>
<blockquote>
<ul>
<li>在此方案中，ASBR不再维护或是通告VPNv4路由（所以如上图，此处将ASBR-PE路由器改名为ASBR）。ASBR只需要维护所有去往PE的带标签路由，并通过EBGP通告给对端AS。在transit AS内的ASBR也同样需要使用EBGP通告这些带标签的IPv4路由。这样在不同AS的PE之间给会建立一条LSP，从而可以建立起PE之间的多跳MP-EBGP连接并进行VPNv4路由的通告。</li>
<li>如果每个AS的P路由器都能够知道去往其他AS的PE路由器的路由，那情况会比较简单。但是如果P不知道，那么当PE收到从CE收到VPN数据时，就要加上三层标签，底层标签是由对端PE分配的与VPN路由相关联的VPN标签，中间的标签是ASBR分配的与去往对端PE的路由相关联的标签，外层标签则是与去往下一跳ASBR的路由相关联的标签。</li>
<li>为了进一步扩展性能，多跳MP-EBGP会话可以建立在不同的AS的VPN RR之间。并且当这些VPN RR通告VPNv4路由时不改变下一跳信息。PE只与VPN RR建立MP-iBGP会话。</li>
<li>注意：为了方便，如上图，使用的是对称的LSP进行示意，但是实际上在控制平面和数据平面的工作过程上，两端AS的LSP结构是不对称的。下文将会详细讲解。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/24.png"></p>
<blockquote>
<ul>
<li>我们只通过单方向来解释控制平面的工作过程，同时假设在站点Site1有一VPN路由Client1连接，并且P1与P2路由器都没有去往另一个AS的PE的路由，以上图为例：<ul>
<li>在AS100中，通过运行LDP协议，PE1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T1给P1</li>
<li>在AS100中，通过运行LDP协议，P1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T2给ASBR-PE1</li>
<li>在AS200中，同样通过运行LDP协议，ASBR-PE2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T3给P2</li>
<li>在AS200中，通过运行LDP协议，P2分配一个与去往ASBR-PE2的路由相关联的隧道标签(外层标签)T4给PE2</li>
<li>ASBR1通过EBGP会话通告一条去往PE1的带标签的IPv4路由给ASBR2，其中下一跳为ASBR1，标签为BGP标签，值为B1</li>
<li>ASBR2通过BGP会话通告一条去往PE1的带标签的IPv4路由给PE2，其中下一跳为ASBR2，标签为BGP标签，值为B2。<ul>
<li>注意：这里假设PE2与ASBR1所在的AS已经为去往它们的路由分配了隧道标签(公网标签)，并且去往PE2的带标签路由也已经被通告。</li>
</ul>
</li>
<li>PE1与PE2建立起MP-EBGP会话</li>
<li>CE1 通告路由Client1给PE1，路由的下一跳为CE1的接口地址</li>
<li>PE1将IPv4路由Client1通过MP-EBGP重发布为VPNv4路由，并且下一跳改为PE1，分配一个VPN标签V1，将其通告给PE2</li>
<li>PE2将VPNv4路由变为IPv4路由，把IPv4路由Client1通告给CE2，并且下一跳改为PE2</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/25.png"></p>
<blockquote>
<ul>
<li><p>VPNv4邻居：</p>
<ul>
<li>本端PE只与本端RR建立VPNv4邻居，本端RR与对端RR建立VPNv4邻居，实现了跨域VPN路由的传递。</li>
</ul>
</li>
<li><p>ASBR,PE同RR建立BGP单播IPv4邻居：</p>
<ul>
<li>ASBR通过ipv4邻居学习将从对端ASBR学到的RR的loopback，传递给本端RR，用于本端RR与对端RR建立vpnv4邻居。</li>
<li>ASBR通过ipv4邻居学习将从对端ASBR学到的RR和PE的loopback，传递给本端RR，本端RR再将其反射给PE，用于跨域之间的PE建立BGP LSP。</li>
</ul>
</li>
<li><p>带RR场景中，RR负责控制平面IPv4的路由反射、VPNv4路由的传递，转发平面的流量不经过RR。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/26.png"></p>
<blockquote>
<p>通过上文的过程分析，我们从反向来分析转发平面的工作过程：</p>
<p>1.CE2发送一个目的地为Client1的IP报文给PE2。</p>
<p>2.PE2收到IP报文后进行MPLS标签的封装，先封装VPN标签V1，由于去往Client1的下一跳PE1不是直连邻居，通过查表发现去往PE1的BGP路由是带标签的路由，因此加上分配的BGP标签B2做为中间标签，最后，由于去往PE1的路由的下一跳ASBR2也不是直连邻居，通过查表发现去往ASBR2也有关联的标签T4，因此，封装上外层标签T4。</p>
<p>3.P2进行标签交换，把外层标签T4换成T3，然后将此报文发送给ASBR-PE2。</p>
<p>4.ASBR2去掉外层标签，将BGP标签B2交换为B1，再将其转发给ASBR1。</p>
<p>5.当ASBR1收到报文后，发现B1是它分配的，所以去掉B1进一步查表转发，发现此时去往PE1的路由有一个关联的标签T2，因此，ASBR1将其加在栈顶，并转发给P1。</p>
<p>6.P1进行标签交换，把外层标签T2换成T1，然后将此报文发送给PE1。</p>
<p>7.PE1收到后去掉所有标签，将报文(普通IP报文)转发给CE1。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/27.png"></p>
<blockquote>
<p>此例中，为方便描述，采用不带RR的方式。带RR的实现方式可参考下文OptionC配置章节。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/28.png"></p>
<blockquote>
<ul>
<li>在此方案中，ASBR不再维护或是通告VPNv4路由。ASBR只需要维护所有去往PE的带标签路由，并通过EBGP通告给对端ASBR。</li>
<li>对端ASBR收到带BGP标签路由后，MPLS LDP会触发为该BGP标签路由产生标签，并在AS内的LDP邻居间传递。因此，在PE上可以看到去往对端PE的LDP LSP。</li>
<li>为了进一步扩展性能，多跳MP-EBGP会话可以建立在不同的AS的VPN RR之间，本AS内的PE只需要与RR建立MP-IBGP即可。这些VPN RR通告VPNv4路由时不改变下一跳信息，进而当对端PE转发流量时，可以迭代至正确的隧道。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/29.png"></p>
<blockquote>
<p>我们只通过单方向来解释控制平面的工作过程，同时假设在站点Site1有一VPN路由Client1连接，并且P1与P2路由器都没有去往另一个AS的PE的路由，以上图为例：</p>
<p>1.在AS100中，通过运行LDP协议，PE1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T1给P1。</p>
<p>2.在AS100中，通过运行LDP协议，P1分配一个与去往PE1的路由相关联的隧道标签(外层标签)T2给ASBR1。</p>
<p>3.在AS200中，同样通过运行LDP协议，ASBR2分配一个与去往ASBR2的路由相关联的隧道标签(外层标签)T3给P2。</p>
<p>4.在AS200中，通过运行LDP协议，P2分配一个与去往ASBR2的路由相关联的隧道标签(外层标签)T4给PE2。</p>
<p>5.ASBR1通过EBGP会话通告一条去往PE1的带标签的IPv4路由给ASBR2，其中下一跳为ASBR1，标签为BGP标签，值为B1。</p>
<p>6.ASBR2为这条BGP标签路由触发建立LSP，分发LDP标签T5至P2，P2进而分发T6至PE2。</p>
<p>7.PE1与PE2建立起MP-EBGP会话。</p>
<p>8.CE1 通告路由Client1给PE1，路由的下一跳为CE1的接口地址。</p>
<p>9.PE1将IPv4路由Client1通过MP-EBGP重发布为VPNv4路由，并且下一跳改为PE1，分配一个VPN标签V1，将其通告给PE2。</p>
<p>10.PE2将VPNv4路由变为IPv4路由，把IPv4路由Client1通告给CE2，并且下一跳改为PE2。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/30.png"></p>
<blockquote>
<ul>
<li><p>VPNv4邻居：</p>
<ul>
<li>本端PE只与本端RR建立VPNv4邻居，本端RR与对端RR建立VPNv4邻居，实现了跨域VPN路由的传递。</li>
</ul>
</li>
<li><p>带RR场景中，RR只负责控制平面VPNv4路由的传递，转发平面的流量不经过RR。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/31.png"></p>
<blockquote>
<p>通过上文的过程分析，我们从反向来分析转发平面的工作过程：</p>
<p>1.CE2发送一个目的地为Client1的IP报文给PE2。</p>
<p>2.PE2收到IP报文后进行MPLS标签的封装，先封装VPN标签V1，由于去往Client1的下一跳PE1不是直连邻居，通过查表发现去往PE1的标签为T6，打上T6。</p>
<p>3.P2进行标签交换，把外层标签T6换成T5，然后将此报文发送给ASBR2。</p>
<p>4.ASBR2去掉外层标签，将T5交换为B1，再将其转发给ASBR1。</p>
<p>5.当ASBR1收到报文后，发现B1是它分配的，所以去掉B1进一步查转发表，发现此时去往PE1的路由有一个关联的标签T2，因此，ASBR1将其加在栈顶，并转发给P1。</p>
<p>6.P1进行标签交换，把外层标签T2换成T1，然后将此报文发送给PE1。</p>
<p>7.PE1收到后去掉所有标签，将报文(普通IP报文)转发给CE1。</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/32.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/33.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/34.png"></p>
<blockquote>
<ul>
<li>如上图所示，共分为4个AS，AS100和AS200作为ISP，PE1和ASBR1属于AS100，PE2和ASBR2属于AS200。CE1和CE2属于同一个VPN，CE1通过AS100的PE1接入，CE2通过AS200的PE2接入。</li>
<li>每台路由器的IP地址规划详见拓扑图。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/35.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/36.png"></p>
<blockquote>
<p>1.搭建拓扑，配置IP：按照拓扑要求搭建试验拓扑，并配置IP地址。</p>
<ul>
<li>CE1需要配置Loopback 0，GE0/0/1；</li>
<li>PE1需要配置Loopback 0，GE0/0/0；</li>
<li>P1需要配置Loopback 0，GE0/0/0，GE0/0/1；</li>
<li>ASBR1需要配置Loopback 0，GE0/0/1；</li>
<li>ASBR2需要配置Loopback 0，GE0/0/1；</li>
<li>P2需要配置Loopback 0，GE0/0/0，GE0/0/1；</li>
<li>PE2需要配置Loopback 0，GE0/0/0；</li>
<li>CE2需要配置：Loopback 0，GE0/0/1。</li>
</ul>
<p>2.配置OSPF路由协议：在PE1、P1和ASBR1，PE2、P2和ASBR2上配置OSPF协议</p>
<ul>
<li>在PE1上宣告网络1.1.1.1/32， 12.12.12.0/30；</li>
<li>在P1上宣告网络2.2.2.2/32，12.12.12.0/30，23.23.23.0/30；</li>
<li>在ASBR1上宣告网络3.3.3.3/32，23.23.23.0/30；</li>
<li>在ASBR2上宣告网络4.4.4.4/32，45.45.45.0/30；</li>
<li>在P2上宣告网络5.5.5.5/32，45.45.45.0/30，56.56.56.0/30；</li>
<li>在PE2上宣告网络6.6.6.6/32， 56.56.56.0/30。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/37.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/38.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/39.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/40.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/41.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/42.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/43.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/44.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/45.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/46.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/47.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/48.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/49.png"></p>
<blockquote>
<ul>
<li>本实例RR1和RR2分别作为AS100与200的RR，PE与ASBR与RR建立BGP邻居，由RR负责VPN路由的反射。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/50.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/51.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/52.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/53.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/54.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/55.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/56.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/57.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/58.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/59.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/60.png"></p>
<blockquote>
<ul>
<li>如上图所示，共分为4个AS，AS100和AS200作为ISP，PE1，P1，RR1和ASBR1属于AS100，PE2，P2，RR2和ASBR2属于AS200。CE1和CE2属于同一个VPN，CE1通过AS100的PE1接入，CE2通过AS200的PE2接入。</li>
<li>每台路由器的IP地址规划详见拓扑图。</li>
<li>本例为OptionC方式实现方案一，可以采用PE1与PE2直接建立MP-EBGP（不带RR）来传递跨域VPN路由，也可以采用RR1与RR2建立MP-EBGP邻居（PE1与RR1，PE2与RR2建立MP-IBGP邻居）传递跨域VPN路由，两者相似，本例采用RR方式实现OptionC方案一。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/61.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/62.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/63.png"></p>
<blockquote>
<ul>
<li>步骤4，RR2的配置参考RR1。PE，ASBR的配置参考普通BGP邻居配置。</li>
<li>步骤5，ASBR2的配置参考ASBR1。</li>
<li>ASBR之间建立单播EBGP邻居，并将本端RR和PE的loopback发布给对方。</li>
<li>ASBR在向对端ASBR发布RR ,PE的loopback时，为其分配MPLS标签；向本AS的RR传递的对端的RR和PE的loopback路由时，为其分配新的MPLS标签。</li>
<li>ASBR,PE同本端RR建立邻居时使能交换标签能力。</li>
<li>ASBR,P,PE同RR建立ipv4邻居：<ul>
<li>ASBR通过ipv4邻居学习将从对端ASBR学到的RR的loopback，传递给本端RR，用于本端RR与对端建立vpnv4邻居。</li>
<li>ASBR通过ipv4邻居学习将从对端ASBR学到的RR和PE的loopback，传递给本端RR，本端RR再将其反射给P，用于跨域bgp路由的递归查询。</li>
<li>ASBR通过ipv4邻居学习将从对端ASBR学到的RR和PE的loopback，传递给本端RR，本端RR再将其反射给PE，用于跨域之间的PE建立BGP LSP。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/64.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/65.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/66.png"></p>
<blockquote>
<ul>
<li>PE2与RR2的MP-IBGP配置参考PE1与RR1的配置。</li>
<li>配置“undo policy vpn-target”原理与Opiton B中相同，即RR上不用RT来过滤路由。</li>
<li>配置“peer X.X.X.X next-hop-invariable”，保证对端PE可以在流量传输时迭代到通往本端PE的BGP LSP。</li>
<li>RR之间建立vpnv4邻居，向对端传递路由时不改变下一跳。即对端PE学到的VPNv4路由的下一跳是本端PE。</li>
<li>RR与本端PE建立vpnv4邻居，RR向本端PE传递路由时不改变下一跳，即本端PE学到的VPNv4路由的下一跳是对端PE。</li>
<li>本端PE只与本端RR建立VPNv4邻居，本端RR与对端RR建立VPNv4邻居，实现了跨域VPN路由的传递。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/67.png"></p>
<blockquote>
<ul>
<li>PE2,RR2,ASBR2的配置分别参考PE1,RR1和ASBR1。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/68.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/69.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/70.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/71.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/72.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/73.png"></p>
<blockquote>
<ul>
<li>如上图所示，共分为4个AS，AS100和AS200作为ISP，PE1，P1，RR1和ASBR1属于AS100，PE2，P2，RR2和ASBR2属于AS200。CE1和CE2属于同一个VPN，CE1通过AS100的PE1接入，CE2通过AS200的PE2接入。</li>
<li>每台路由器的IP地址规划详见拓扑图。</li>
<li>本例为OptionC方式实现方案二。方案二的实现与方案一大致相似，主要区别在于，当本端ASBR收到对端ASBR传递来的labeled-IPv4-Route后，触发LDP为BGP标签路由分标签。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/74.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/75.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/76.png"></p>
<blockquote>
<ul>
<li>在OSPF进程中引入BGP路由，是为了让RR1与RR2能够顺利建立EBGP邻居关系，进而传递VPN路由。建议在OSPF中引入BGP路由时配置路由策略，做好精确的明细引入，减少不必要的路由进入IGP域。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/77.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/78.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/79.png"></p>
<blockquote>
<ul>
<li>PE2与RR2的MP-IBGP配置参考PE1与RR1的配置。</li>
<li>配置“undo policy vpn-target”原理与Opiton B中相同，即RR上不用RT来过滤路由。</li>
<li>配置“peer X.X.X.X next-hop-invariable”，保证对端PE可以在流量传输时迭代到通往本端PE的BGP LSP。</li>
<li>RR之间建立vpnv4邻居，向对端传递路由时不改变下一跳。即对端PE学到的VPNv4路由的下一跳是本端PE。</li>
<li>RR与本端PE建立vpnv4邻居，RR向本端PE传递路由时不改变下一跳，即本端PE学到的VPNv4路由的下一跳是对端PE。</li>
<li>本端PE只与本端RR建立VPNv4邻居，本端RR与对端RR建立VPNv4邻居，实现了跨域VPN路由的传递。</li>
</ul>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/80.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/81.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/82.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/83.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/84.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/85.png"></p>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/86.png"></p>
<blockquote>
<p>1.C</p>
<p>2.C</p>
</blockquote>
<p><img src="/2021/08/23/IE-MPLS-BGP-VPN%E8%B7%A8%E5%9F%9F/87.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/" itemprop="url">IE-PIM双栈原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:31+08:00">
                2021-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/2.png"></p>
<blockquote>
<ul>
<li><p>现代网络传输技术对以下两项目标给予更高的关注：</p>
<ul>
<li>资源发现</li>
<li>点对多点的IP传输</li>
</ul>
</li>
<li><p>实现这两项目标有三种解决方案：单播（Unicast）、广播（Broadcast）、组播（Multicast）</p>
</li>
<li><p>通过比较三种解决方案的数据传输方式，说明组播方式更适合点对多点的IP传输。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/3.png"></p>
<blockquote>
<ul>
<li>学习完此课程，您将会：了解组播与单播以及广播三种数据传输方式的区别。掌握组播的地址结构以及组播报文的转发流程。掌握组播技术中的相关概念，如源路径树、共享树等。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>组播协议包括用于主机注册的组播组管理协议，和用于组播选路转发的组播路由协议。各种组播协议在网络中的如图所示。</p>
</li>
<li><p>IGMP（Internet Group Management Protocol）在接收者主机和组播路由器之间运行，该协议定义了主机与路由器之间建立和维护组播成员关系的机制。</p>
</li>
<li><p>组播路由器之间运行组播路由协议，组播路由协议用于建立和维护组播路由，并正确、高效地转发组播数据包。</p>
</li>
<li><p>对于ASM模型，可以将组播路由分为域内和域间两大类。</p>
<ul>
<li>域内组播路由协议用来在自治系统AS（Autonomous System）内发现组播源并构建组播分发树，将信息传递到接收者。域内组播路由协议包括：DVRMP、MOSPF、PIM。<ul>
<li>DVRMP是距离矢量组播路由协议（Distance Vector Multicast Routing Protocol）是一种密集模式协议。该协议有跳数限制，最大跳数32跳。</li>
<li>MOSPF是OSPF路由协议的扩展协议。它通过定义新的LSA来支持组播。</li>
<li>PIM（Protocol Independent Multicast）是典型的域内组播路由协议，分为DM（Dense Mode）和SM（Sparse Mode）两种模型。当接收者在网络中的分布较为密集时，适用DM；较为稀疏时，适用SM。PIM必须和单播路由协议协同工作。</li>
</ul>
</li>
<li>域间组播路由协议用来实现组播信息在AS之间的传递。<ul>
<li>MSDP（Multicast Source Discovery Protocol）能够跨越AS传播组播源信息。</li>
<li>MPBGP （MultiProtocol Border Gateway Protocol）的组播扩展MBGP （Multicast BGP）能够跨越AS传播组播路由。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>对于SSM模型，没有域内和域间的划分。由于接收者预先知道组播源的具体位置，因此可以借助PIM SM的部分功能直接创建组播传输路径。</li>
<li>为了使不同的 PIM-SM 域之间组播数据能够互通，需要在域间部署 MSDP 协议。MSDP 通过在各个 PIM-SM 域之间建立 MSDP 对等体关系，对等体之间交互 SA 消息来传递组播信 息，从而实现接收者主机可以接收其他 PIM-SM 域的组播源数据。MSDP 仅用于 IPv4 网络， 只对 ASM 服务模型有意义。在单个 PIM 域内，使用 IGMP 管理组成员关系，使用 PIM-SM 建 立组播路由指导数据转发。 </li>
<li>由于 PIM 协议依赖于单播路由表，从而组播转发路径与单播转发路径是一致的。当组播源与接收者分布在不同的AS中时，需要跨AS建立组播转发树。此时可以部署MBGP 协议， 生成一张独立于单播路由的组播路由表，使组播数据通过组播路由表进行传输。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/7.png"></p>
<blockquote>
<ul>
<li><p>相对于PIM-DM的“推（Push）模式”，PIM-SM使用“拉（Pull）模式”转发组播报文。PIM-SM假设网络中的组成员分布非常稀疏，几乎所有网段均不存在组成员，直到某网段出现组成员时，才构建组播路由，向该网段转发组播数据。一般应用于组播组成员规模相对较大、相对稀疏的网络。</p>
</li>
<li><p>基于这一种稀疏的网络模型，它的实现方法是：</p>
<ul>
<li>在网络中维护一台重要的PIM路由器：汇聚点RP（Rendezvous Point），可以为随时出现的组成员或组播源服务。网络中所有PIM路由器都知道RP的位置。</li>
<li>当网络中出现组成员（用户主机通过IGMP加入某组播组G）时，最后一跳路由器向RP发送Join报文，逐跳创建（*，G）表项，生成一棵以RP为根的RPT。</li>
<li>当网络中出现活跃的组播源（信源向某组播组G发送第一个组播数据）时，第一跳路由器将组播数据封装在Register报文中单播发往RP，在RP上创建（S，G）表项，注册源信息。</li>
</ul>
</li>
<li><p>PIM-SM的关键机制包括邻居建立、DR竞选、RP发现、RPT构建、组播源注册、SPT切换、Assert；同时也可通过配置BSR（Bootstrap Router）管理域来实现单个PIM-SM域的精细化管理。PIM-SM中PIM邻居建立过程以及Assert机制与PIM-DM相同。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li>源路径树以组播源作为树根，将组播源到每一个接收者的最短路径结合起来构成的转发树。</li>
<li>源路径树使用的是从组播源到接收者的最短路径，也称为最短路径树（shortest path tree，SPT）。对于某个组，网络要为任何一个向该组发送报文的组播源建立一棵树。</li>
<li>本例中有两个组播源（源S1和源S2），接收者R1和RT2。所以本例中有两棵源路径树，分别是：</li>
<li>S1—A—C（R1）—–E（R2）</li>
<li>S2—F—-D—C（R1）——E（R2）</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li>共享树以某个路由器作为路由树的树根，该路由器称为汇集点（Rendezvous Point，RP），将 RP 到所有接收者的最短路径结合起来构成转发树。使用共享树时，对应某个组，网络中只有一棵树。所有的组播源和接收者都使用这棵树来收发报文，组播源先向树根发送数据报文，之后报文又向下转发到达所有的接收者。 </li>
<li>本例中两个源S1和S2共享一颗树 D（RP）—-C（R1）—-E（R2）</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/10.png"></p>
<blockquote>
<ul>
<li>PIM IPv6是与静态路由、RIPng、OSPFv3、IS-ISv6、BGP4+等IPv6单播路由协议类型无关的组播路由协议，其借助上述单播路由协议生成的路由项和RPF（Reverse Path Forwarding）机制创建组播路由表，实现组播报文转发。PIM IPv6域是指由支持PIM IPv6协议的组播路由器构成的网络。</li>
<li>目前，存在两种组播模型：任意源组播ASM（Any-Source Multicast）和指定源组播SSM（Source-Specific Multicast）。IPv6中，ASM模型包括IPv6 PIM-DM（Protocol Independent Multicast-Dense Mode）和IPv6 PIM-SM（Protocol Independent Multicast Sparse Mode）；SSM模型则使用MLDv2和IPv6 PIM-SM的部分机制来实现。</li>
<li>在组成员稀疏分布的大规模IPv6网络中，使用IPv6 PIM-SM，其主要特性是接收者需要显式加入。缺省情况下，IPv6 PIM-SM假设网络中的所有节点都不需要接收组播报文，上游节点只有接收到下游节点的加入消息后才进行组播数据的转发。</li>
<li>IPv6 PIM-SM中，汇集点RP（Rendezvous Point）只向拥有接收者的下游分枝转发组播信息。这样可以节省数据报文和控制报文占用的网络带宽，减少路由器的处理开销。</li>
<li>当主机希望从指定组播组接收数据时，与之相连的路由器向这个组的RP发送加入（Join）消息，沿途建立以RP为根节点的共享树RPT（Rendezvous Point Tree）。共享树的含义是不同组播源向相同组播组转发组播数据时，都使用此共享路径。</li>
<li>当组播源向组播组发送数据时，与源相连的DR把组播数据封装在注册消息中以单播方式向RP发送。注册消息到达RP后，由RP对组播数据解封装，再沿RPT向接收者发送。当以注册消息方式发送的组播数据达到一定速率后，RP向组播源发送加入消息，建立组播源与RP之间的组播分发树。然后，RP向组播源的DR发送注册停止消息，指示DR直接以非封装方式根据组播转发表发送组播数据。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li><p>借助Hello消息可以为共享网络（如Ethernet）选举DR（Designated Router），DR将作为本网段中组播信息的唯一转发者。无论是和组播源S连接的网络，还是和接收者连接的网络，只要网络为共享媒介则需要选举DR，接收者侧DR向RP发送Join加入消息；组播源侧DR向RP发送Register注册消息。</p>
</li>
<li><p>DR的选举过程如下所述：</p>
<ul>
<li>共享网段上的各路由器相互间发送带有DR优先级选项的Hello消息；</li>
<li>具有最高优先级的路由器被选举为此网段的DR。如果路由器具有相同的优先级，则IPv6地址最大的路由器被选举为DR。</li>
</ul>
</li>
<li><p>当DR出现异常，其他路由器将接收不到其发出的Hello消息。在此DR超时后，会触发共享网段上新一轮的DR选举。</p>
</li>
<li><p>如果网络中至少有一台路由器不支持在Hello报文中携带DR优先级，由IPv6链路本地地址最大的路由器充当DR。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/12.png"></p>
<blockquote>
<ul>
<li>如何发现RP？对于小规模的简单网络，一个RP用于全网转发信息就足够了，此RP的位置可通过静态指定，在DR和叶子路由器以及组播数据流将要经过的所有路由器上手工指定RP的IP地址。然而，在大多数应用中，IPv6 PIM-SM网络覆盖了很大的区域，需要通过RP转发大量的组播流量。因此，不同的组播组应该具有各自的RP。为了减少配置多个静态RP的工作量以及更好的适应网络的实时变化，采用自举（Bootstrap）机制来动态选举RP。</li>
<li>自举路由器BSR（BootStrap Router）是IPv6 PIM-SM网络的管理核心。BSR收集来自各候选RP即C-RP（Candidate-RP）的通告（Advertisement）消息，选择合适的C-RP来构成组播组的RP-Set信息。RP-Set是各组播组与对应C-RP的数据库。BSR通过自举消息向整个IPv6 PIM-SM网络通告RP-Set信息。包括DR在内的所有路由器学习到各组播组对应的C-RP后，根据哈希算法计算出各组播组对应的唯一RP。</li>
<li>一个网络（或一个管理域）只能有一个BSR，但可以有多个候选BSR即 C-BSR （Candidate-BSR）。一旦BSR发生故障后，可以通过自举机制从C-BSR中选举出新的BSR，从而避免业务的中断。IPv6 PIM-SM域中可以配置多个C-RP。BSR负责收集并发送各组播组的RP-Set信息。<ul>
<li>RP配置方式建议：<ul>
<li>中小型网络：建议选择静态RP方式，对设备要求低，也比较稳定。</li>
<li>如果网络中只有一个组播源，建议选择直连组播源的设备作为静态RP，这样可以省略源端DR向RP注册的过程。</li>
<li>采用静态RP方式要确保域内所有路由器（包括RP本身）的RP信息以及服务的组播组范围全网一致。</li>
<li>大型网络：可以采用动态RP方式，可靠性高，可维护性强。</li>
<li>如果网络中存在多个组播源，且分布密集，建议选择与组播源比较近的核心设备作为C-RP；如果网络中存在多个用户，且分布密集，建议选择与用户比较近的核心设备作为C-RP。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li>BootStrap router工作的原理和过程：首先要在网络中选择合适的路由器把它配置成候选BSR（C-BSR，Candidate BootStrap Router），每个C-BSR都有优先级，当它得知自己是C-BSR后，首先启动一个定时器（默认为150秒），监听网络中的 BootStrap Message。BootStrap Message 初始时通告发送路由器的优先级、BSR的IPv6地址，当C-BSR收到一个BootStrap Message后，它会把自己的优先级和报文里的优先级做比较，如果对方的优先级高，它就把自己的定时器重置，继续监听BootStrap Message；如果是自己的高，那么它就发送BootStrap Message声明自己是BSR，如果优先级相等，则比较IPv6地址，谁的IPv6地址大谁就是BSR。BSR消息发送的目的地址是FF02::13，所有的PIM IPv6路由器都能接收到这个报文，该报文TTL一般被置为1，但每个PIM IPv6路由器收到此报文后都是把它以泛洪的方式从自己所有的使能PIM IPv6的接口上发送出去，这就能保证网络中的每台PIM IPv6设备都能收到BootStrap Message。</li>
<li>RP就像C-BSR一样需要在设备上手工配置，首先配置C-RP（Candidate Rendezvous Point），包括RP IPv6地址、优先级和它所能服务的组。正如上文所述，一个RP可以给所有的IPv6组播组提供服务，也可以只给部分组提供服务。当C-RP收到BootStrap Message后，它可以从该message中得知网络中谁是BSR，然后C-RP通过Candidate-RP-Advertisement Message把自己所能服务的组单播给BSR，每个C-RP都这么做的话那么BSR就收集到了网络中所有C-RP的信息并把这些信息整理成一个集RP-Set。此后BSR通过BootStrap Message把RP-Set的信息通告给全网所有的路由器。</li>
<li>RP的选举规则：<ul>
<li>如果RP-Set对应该IPv6组地址的C-RP只有一个,那么DR就选该C-RP做RP；</li>
<li>如果对应该IPv6组地址的有多个C-RP，那么优先级最高的是RP（优先级数越小优先级越高）；</li>
<li>如果大家优先级相等，那么DR将开始Hash运算，把组地址、hash掩码、和C-RP的地址做为输入参数，输出是一些数字，数字高的C-RP将是该组的RP；</li>
<li>如果hash的结果大家也相等，那么IPv6地址最大的C-RP将成为该组的RP。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/14.png"></p>
<blockquote>
<ul>
<li><p>使能嵌入RP功能允许路由器从IPv6组播组地址中分析出RP的地址，从而取代静态配置RP或由BSR动态计算的RP。</p>
</li>
<li><p>使用嵌入式RP的组播组地址范围是FF7x::/16和FFFx::/16，x表示0～F的任意一个十六进制数。</p>
</li>
<li><p>在接收侧：</p>
<ul>
<li>接收者主机发布MLD报告消息，加入组播组；</li>
<li>接收侧的DR提取内嵌在组播组地址中的RP地址，向其发送IPv6 PIM-SM加入消息。</li>
</ul>
</li>
<li><p>在组播源侧：</p>
<ul>
<li>组播源知道组播地址后，向此组播组发送报文；</li>
<li>组播源侧的DR提取内嵌在组播地址中的RP地址，向其以单播方式发送IPv6 PIM-SM注册消息。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li>头8bits为FF说明是IPv6组播地址。</li>
<li>Flags字段的范围是7-F，说明是一个嵌入了RP地址的IPv6组播组地址。</li>
<li>RIID字段：RP Interface ID，抽取出来填充在RP地址的最后4bits。</li>
<li>Plen字段：RP地址的前缀长度，换算成十进制数后不能为0，也不能大于64。</li>
<li>Network Prefix字段：RP的地址前缀。</li>
<li>Group ID：组ID。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/16.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li>当接收者主机加入一个组播组G时，通过MLD报文知会与该主机直接相连的叶子路由器，叶子路由器掌握组播组G的接收者信息，然后朝着RP方向往上游节点发送加入组播组的Report消息。</li>
<li>从叶子路由器到RP之间途经的每个路由器都会在转发表中生成（<em>，G）表项，这些沿途经过的路由器就形成了RP共享树（RPT）的一个分支。其中（</em>，G）表示从任意源来的信息去往组播组G。RPT共享树以RP为根，以接收者为叶子。</li>
<li>当从组播源S来的发往组播组G的报文流经RP时，报文就会沿着已经建立好的RPT共享树路径到达叶子路由器，进而到达接收者主机。</li>
<li>当某接收者对组播信息不再感兴趣时，离该接收者最近的组播路由器会逆着RPT树朝RP方向逐跳发送Prune剪枝消息。第一个上游路由器接收到该剪枝消息，在接口列表中删除连接此下游路由器的接口，并检查自己是否拥有感兴趣的接收者，如果没有则继续向上游转发该剪枝消息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li><p>为了向RP通知组播源S的存在，当组播源S向组播组G发送了一个组播报文时，与组播源S直接相连的路由器接收到该组播报文后，就将该报文封装成IPv6 PIM Register注册报文，并单播发送给对应的RP。</p>
</li>
<li><p>当RP接收到来自组播源S的注册消息后，一方面解封装注册消息并将组播信息沿着RPT树转发到接收者，另一方面朝组播源S逐跳发送（S，G）加入消息，从而让RP和组播源S之间的所有路由器上都生成了（S，G）表项，这些沿途经过的路由器就形成了SPT树的一个分支。SPT源树以组播源S为根，以RP为目的地。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li>组播源S发出的组播信息沿着已经建立好的SPT树到达RP，然后由RP将信息沿着RPT共享树进行转发。当RP收到沿着SPT树转发的组播流量后，向与组播源S直连的路由器单播发送注册停止报文。组播源注册过程结束。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/20.png"></p>
<blockquote>
<ul>
<li>源数据流延源树（SPT）流向RP，从RP开始，数据流延共享树（RPT）流向接收者。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/21.png"></p>
<blockquote>
<ul>
<li><p>针对特定的源，PIM-SM通过指定一个利用带宽的SPT阈值可以实现将最后一跳路由器(即离接收者最近的DR)从RPT切换到SPT。当最后一跳路由器发现从RP发往组播组G的组播报文速率超过了该阈值时，就向单播路由表中到组播源S的下一跳路由器发送（S，G）加入消息，Join加入消息经过一个个路由器后到达第一跳路由器（即离组播源最近的DR），沿途经过的所有路由器都拥有了（S，G）表项，从而建立了SPT树分支。</p>
</li>
<li><p>用户端DR周期性检测组播报文的转发速率，一旦发现从RP发往组播组G的报文速率超过阈值，则触发SPT切换：</p>
<ul>
<li>用户端DR逐跳向源端DR发送（S，G）Join报文并创建（S，G）表项，建立源端DR到用户端DR的SPT。</li>
<li>SPT建立后，用户端DR会沿着RPT逐跳向RP发送剪枝报文，收到剪枝报文的路由器将（*，G）复制成相应的（S，G）,并将相应的下游接口置为剪枝状态。剪枝结束后，RP不再沿RPT转发组播报文到组成员端。</li>
<li>如果SPT不经过RP，RP会继续向源端DR逐跳发送剪枝报文，删除（S，G）表项中相应的下游接口。剪枝结束后，源端DR不再沿“源端DR-RP”的SPT转发组播报文到RP。</li>
</ul>
</li>
<li><p>在VRP中，缺省情况下连接接收者的路由器在探测到组播源之后（即接收到第一个数据报文），便立即加入最短路径树，即从RPT向SPT切换。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/22.png"></p>
<blockquote>
<ul>
<li>当路由器在不同接口接收到RPT和SPT两条路径上传输的相同组播数据时，丢弃沿RPT接收的数据，并向RP逐跳发送剪枝消息。RP接收到剪枝消息后，更新转发状态，并停止沿RPT转发（S, G）的组播流量；同时RP向组播源发送剪枝消息删除或更新相关的（S, G）转发项。通过这种方法，组播数据从RPT切换到SPT。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/24.png"></p>
<blockquote>
<ul>
<li>Host A和Host C分别是两个叶子网络中的组播信息接收者。这些接收者通过Router A、Router B、Router C和Router D连接到组播源。</li>
<li>配置思路：<ul>
<li>配置各路由器接口的IPv6地址和IPv6单播路由协议。<ul>
<li>配置各路由器接口的IPv6地址和掩码。</li>
<li>配置各路由器之间采用OSPFv3进行互连，进程号为1，区域号为0，确保网络中各路由器Router A、Router B、Router C和Router D之间能够在网络层互通。</li>
</ul>
</li>
<li>在各路由器上使能IPv6组播功能，在路由器各接口上使能IPv6 PIM-SM，主机侧接口上配置MLD，采用缺省版本2。</li>
<li>配置C-BSR和C-RP，充当C-BSR和C-RP的IPv6全球单播地址，此例中都为Router D上的2004::2。</li>
<li>检查配置结果。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/25.png"></p>
<blockquote>
<ul>
<li><p>进入系统视图</p>
<ul>
<li><strong>system-view</strong></li>
</ul>
</li>
<li><p>使能IPv6组播路由</p>
<ul>
<li><strong>multicast ipv6 routing-enable</strong></li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em></li>
</ul>
</li>
<li><p>使能IPv6 PIM-SM功能</p>
<ul>
<li><strong>pim</strong> <strong>ipv6</strong> <strong>sm</strong></li>
</ul>
</li>
<li><p>IPv6 PIM-SM只有在使能IPv6组播后才能配置。在接口上配置IPv6 PIM-SM后，路由器周期性发送Hello消息来发现PIM IPv6邻居，并处理邻居发来的报文。当路由器加入IPv6 PIM-SM域时，建议在非边界路由器的所有接口上使能IPv6 PIM-SM。</p>
</li>
<li><p>不能在一个接口上同时使能IPv6 PIM-SM和IPv6 PIM-DM。同一路由器上所有接口的PIM IPv6模式必须相同。</p>
</li>
<li><p>Router B、Router C和Router D上的配置过程与Router A上的配置相似。</p>
</li>
<li><p>与接受者相连的路由器上需要使能MLD。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/26.png"></p>
<blockquote>
<ul>
<li><p>在PIM域中可配置一个或多个C-BSR。从C-BSR选举出的BSR负责收集和通告C-RP信息。由于BSR和域中的其他设备需要交换大量信息，因此C-BSR与域中的其它设备之间应预留较大的带宽。所以由骨干网的路由器来充当C-BSR。</p>
</li>
<li><p>在指定本路由器的某接口地址作为C-BSR时，必须同时使能接口的IPv6 PIM-SM。C-BSR之间自动选举BSR的过程简要描述如下：</p>
<ul>
<li>初始时，每个C-BSR都认为自己是PIM-SM域内的BSR，使用自己接口的IPv6地址作为BSR地址来发送自举报文。</li>
<li>当C-BSR从其他路由器接收到自举报文时，把报文中的BSR地址与自己的BSR地址相比较。比较的标准包括优先级和BSR地址。如果优先级相同，优选BSR地址大的，即如果接收的自举报文中的BSR地址更高，则用此地址来代替自己的BSR地址，并不再认为自己是BSR；如果自举报文的BSR地址并不大于自己的BSR地址，则继续认为自己是BSR。</li>
</ul>
</li>
<li><p>进入PIM IPv6视图</p>
<ul>
<li><strong>pim-ipv6</strong></li>
</ul>
</li>
<li><p>配置自己的接口地址为C-BSR</p>
<ul>
<li>**c-**<strong>bsr</strong> <em>ipv6-address</em> [ <em>hash-length</em> ] [ <em>priority-value</em> ]</li>
</ul>
</li>
<li><p>配置C-RP</p>
<ul>
<li>**c-**<strong>rp</strong> <em>ipv6-address</em> [ <strong>priority</strong> <em>priority</em> ]</li>
</ul>
</li>
<li><p>配置静态RP</p>
<ul>
<li>**static-<em><strong><em>rp*</em> *rp</strong>-address</em> [ <em>basic-acl6-number</em> ] [ <strong>preferred</strong> ]</li>
</ul>
</li>
<li><p>配置嵌入式RP</p>
<ul>
<li>**embedded-**<strong>rp</strong> <strong>[</strong> <em>basic-acl6-number</em> <strong>]</strong></li>
</ul>
</li>
<li><p>**c-*<em><strong>bsr</strong>命令用来在希望自己成为BSR的路由器上配置自身某接口地址为C-BSR的地址。</em></p>
<ul>
<li>ipv6-address<em>：指定候选自举路由器C-BSR的IPv6全球单播地址。</em></li>
<li>hash-length*：指定计算RP的哈希函数的掩码长度。整数形式，取值范围是0～128。</li>
</ul>
</li>
<li><p><strong>pim</strong> <strong>ipv6</strong> <strong>bsr**</strong>-boundary<strong>命令用来设置作为BSR域边界的接口。在接口上配置此命令后，自举消息不能通过此接口，而其他PIM报文可以通过。</strong></p>
</li>
<li><p>c-rp**命令用来配置路由器向BSR通告自身是C-RP。配置成为C-RP的路由器和其他设备之间需要保留相对大的带宽。通过配置希望成为RP的接口地址，并选择合适的优先级。</p>
<ul>
<li><em>ipv6-address</em>：指定C-RP的IPv6全球单播地址。</li>
<li>如果网络中仅有一个动态RP，配置静态RP能避免由于单个RP发生故障引起的通信中断。使用静态RP转发组播数据时，应该在IPv6 PIM-SM域中所有路由器上配置完全相同的静态RP命令。</li>
</ul>
</li>
<li><p>**static-*<em><strong>rp</strong>命令用来配置静态RP。</em></p>
<ul>
<li>rp**-address*：指定静态RP地址。此地址必须是有效的IPv6全球单播地址。</li>
<li><em>basic-acl6-number</em>：指定用于控制静态RP服务的组播组范围的基本访问控制列表号。取值范围是2000～2999。</li>
<li><strong>preferred</strong>：表示配置的静态RP和由BSR机制选择的RP不同时，优先选择此静态RP。不指定此参数时，优先选择BSR机制选择的RP。</li>
</ul>
</li>
<li><p>嵌入式RP用于路由器从组播地址中获取RP地址，从而取代静态RP或从BSR机制选举的动态RP。使用嵌入式RP的组播地址范围是FF7x::/16～FFFx::/16，x表示0～F的任意一个十六进制数。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/28.png"></p>
<blockquote>
<ul>
<li><p>查看接口上的PIM IPv6信息 </p>
<ul>
<li><strong>display</strong> <strong>pim</strong> <strong>ipv6</strong> <strong>interface</strong> [ <em>interface-type interface-number</em> ]</li>
</ul>
</li>
<li><p>查看IPv6 PIM-SM域中BSR自举路由器的信息</p>
<ul>
<li><strong>display</strong> <strong>pim</strong> <strong>ipv6</strong> <strong>bsr**</strong>-info**</li>
<li>此网络中的BSR是Router D的POS2/0/0接口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/29.png"></p>
<blockquote>
<ul>
<li><p>查看IPv6 PIM-SM域中的RP信息</p>
<ul>
<li><strong>display</strong> <strong>pim</strong> <strong>ipv6</strong> <strong>rp**</strong>-info** [ <em>ipv6-group-address</em> ]</li>
</ul>
</li>
<li><p>此网络中的RP是Router D的POS2/0/0接口。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/30.png"></p>
<blockquote>
<ul>
<li>假设HostA加入组G（FF0E::1），RouterD和RouterB之间建立RPT树，在RPT路径上的路由器（RouterD和RouterB）生成（*, G）项。组播源S（2001::5）向组播组G发送组播报文后，在源树路径上的路由器（RouterA和RouterD）生成（S, G）项。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/31.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/33.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li>IPv6 PIM-SSM的实现可以概括成邻居发现、DR选举和SPT生成：<ul>
<li>邻居发现和DR选举过程与IPv6 PIM-SM中的描述相同，是通过在路由器间发送Hello消息来实现的；</li>
<li>由于PIM-SSM也使用PIM-SM协议，路由器生成RPT还是生成SPT的判决取决于组播地址是否在SSM组地址范围内。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/35.png"></p>
<blockquote>
<ul>
<li>SSM模型中，用信道（Channel）概念来表示（S, G）组合，用定制（Subscribed）消息概念来表示加入消息。</li>
<li>假定网络中的User A和User B需要接收组播源S的信息，就通过MLDv2向最近的查询器发送一个标为（include S, G）的报告信息。如果User A和User B不需要接收组播源S的信息，发送一个标为（exclude S, G）或包含其他组播源的报告消息。无论使用上述哪个报告消息，接收者是明确指定组播源S的。</li>
<li>接收到报告消息的查询器检查此消息的组播地址是否在SSM组地址的范围内。如果是，则路由器根据SSM模型建立组播分发树，随后向指定源逐跳发送定制消息（也称加入消息）。沿途上的所有路由器创建（S, G）项。以源S为根节点、接收者为叶子的SPT树就生成了。SSM模型使用此SPT树作为传输路径。</li>
<li>如果查询器发现组播地址在SSM组范围外，就在IPv6 PIM-SM基础上建立组播分发树。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>Host A和Host C分别是两个叶子网络中的组播信息接收者。这些接收者通过Router A、Router B、Router C和Router D连接到组播源。</li>
<li>Router B和N1、Router C和N2之间的主机侧接口必须运行MLDv2协议。</li>
<li>配置思路：<ul>
<li>配置各路由器接口的IPv6地址和IPv6单播路由协议。<ul>
<li>配置各路由器接口的IPv6地址和掩码。</li>
<li>配置各路由器之间采用OSPFv3进行互连，进程号为1，区域号为0，确保网络中各路由器Router A、Router B、Router C和Router D之间能够在网络层互通。</li>
</ul>
</li>
<li>在各路由器上使能IPv6组播功能，在路由器各接口上使能IPv6 PIM-SM。</li>
<li>在各路由器配置IPv6 PIM-SSM 组播组的地址范围。</li>
<li>在路由器的主机侧接口上配置MLDv2。</li>
<li>检查配置结果。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/37.png"></p>
<blockquote>
<ul>
<li><p>在Router A上配置IPv6 PIM-SSM组播组的地址范围是FF3E::1。</p>
</li>
<li><p>Router B、Router C和Router D上的配置过程与Router A上的配置相似。</p>
</li>
<li><p>SSM模型采用的是IPv6 PIM-SM的子集，所以必须先在网络中所有的路由器上使能IPv6 PIM-SM功能。同时，配置SSM组的地址范围。缺省情况下，采用IANA定义的SSM组范围。</p>
</li>
<li><p>如果用户希望从指定源S接收信息，或从指定源外的所有源S接收信息，必须发送含有信道（S, G）的MLDv2报告消息。接收侧的DR接收到此消息后，判断消息中的组播地址G是否在SSM组的地址范围内。如果是，DR向组播源S发送加入消息，并在沿途各路由器上创建（S, G）项，从而建立SPT树，SSM模型就此建立。如果组播地址G在SSM组地址范围外，或用户没有显式指定源地址S，DR触发建立IPv6 PIM-SM基础上的ASM模型。</p>
</li>
<li><p>SSM模型通过IPv6 PIM-SM的子集来实现。使能IPv6 PIM-SM的同时也就使路由器具有SSM处理能力。路由器周期性发送Hello报文来发现PIM IPv6邻居，并处理邻居发来的报文。当路由器加入IPv6 PIM-SSM时，建议在非边界路由器所有接口上使能IPv6 PIM-SSM。</p>
</li>
<li><p>组播源的信息通过IPv6 PIM-SSM模式还是IPv6 PIM-SM模式传递到接收者，取决于信道（S, G）的组播地址是否在SSM组地址范围内。因此，IPv6 PIM-SSM模式中，组地址信息十分重要。</p>
</li>
<li><p>如果没有指定SSM组地址范围，系统采用IANA为SSM保留的FF3x::/12网段作为缺省的地址范围。</p>
</li>
<li><p>进入系统视图</p>
<ul>
<li><strong>system-view</strong></li>
</ul>
</li>
<li><p>使能IPv6组播路由</p>
<ul>
<li><strong>multicast ipv6 routing-enable</strong></li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em> </li>
</ul>
</li>
<li><p>使能IPv6 PIM-SSM功能</p>
<ul>
<li><strong>pim</strong> <strong>ipv6</strong> <strong>sm</strong></li>
</ul>
</li>
<li><p>进入PIM IPv6视图</p>
<ul>
<li><strong>pim-ipv6</strong></li>
</ul>
</li>
<li><p>配置IPv6 PIM-SSM组播地址范围</p>
<ul>
<li><strong>ssm**</strong>-policy** <em>basic-acl6-number</em></li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/38.png"></p>
<blockquote>
<ul>
<li>如果Host A需要接收组播源S（2001::5）发给组G（FF3E::1）的信息，Router B建立到源的SPT。SPT路径上的Router A和Router B生成（S,G）项，SPT路径外的Router D不存在（S,G）项</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/39.png"></p>
<blockquote>
<ul>
<li>组播路由管理（Multicast Route Management）主要介绍如何创建或更改组播路由来控制组播报文的转发，以及组播转发路径的检测和维护。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/40.png"></p>
<blockquote>
<ul>
<li>组播路由和转发与单播路由和转发类似，首先每个组播路由协议都各自建立并维护了一张协议路由表。各组播路由协议的组播路由信息经过综合形成一个总的组播路由表（Multicast Routing-Table）。最后，路由器根据组播路由和转发策略，从组播路由表中选出最优的组播路由，并下发到组播转发表（Multicast Forwarding-Table），直接用于控制组播数据的转发。</li>
<li>通过组播转发表，整个网络建立了一条以组播源为根，组成员为叶子的一点到多点的转发路径。为了实现转发路径的控制与维护，组播路由管理提供了一系列特性。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li>(FC00::2, FFE3::1) (S, G)表项。 </li>
<li>Protocol: pim-sm 协议类型。第一个Protocol表示生成表项的协议类型，第二个Protocol表示生成下游接口的协议类型。</li>
<li>Flag: SPT LOC ACT PIM路由表项的标志。</li>
<li>UpTime: 00:04:24 存在时间。第一个UpTime表示表项已存在的时间，第二个UpTime表示下游接口已存在的时间。</li>
<li>Upstream interface: Vlanif20 上游接口。 </li>
<li>Upstream neighbor: FE80::A01:100:1 上游邻居。NULL表示不存在上游邻居。</li>
<li>RPF prime neighbor: FE80::A01:100:1 RPF邻居。NULL表示不存在RPF邻居。</li>
<li>Downstream interface(s) information: 下游接口信息。 </li>
<li>Total number of downstreams: 1 下游接口数量。 </li>
<li>Expires: 00:02:47 下游接口老化时间。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/42.png"></p>
<blockquote>
<ul>
<li>(FC00::2, FFE3::1) 第00001号表项，是(S, G)形式。 </li>
<li>Uptime: 00:00:14 组播路由表项更新时间。 </li>
<li>Upstream Interface: Vlanif10 上游接口。 </li>
<li>List of 1 downstream interface 下游接口列表。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/43.png"></p>
<blockquote>
<ul>
<li>(FC00:1::3, FF1E::1) 第00001号表项，是(S, G)形式。 </li>
<li>MID: 10 组播转发表项在MFIB表中的唯一标识，用于快速检索组播转发表。</li>
<li>Flags: ACT 组播转发表项的标志。 </li>
<li>UpTime: 02:54:43 组播转发表项已存在的时间。 </li>
<li>Timeout in: 00:03:26 组播转发表项超时时间。</li>
<li>Incoming interface: Vlanif10 表项入接口。 </li>
<li>List of 1 outgoing interfaces 表项出接口列表。</li>
<li>Activetime: 00:23:15 出接口已存在时间。 </li>
<li>Matched 38264 packets(1071392 bytes) 匹配该表项的报文数目。</li>
<li>Wrong If 0 packets 从错误接口进入的报文数目。</li>
<li>Forwarded 38264 packets(1071392 bytes) 已转发的报文数目。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/44.png"></p>
<blockquote>
<ul>
<li><p>RPF检查原理</p>
<ul>
<li>路由器收到一份组播报文后，会根据报文的源地址通过单播路由表查找到达“报文源”的路由，查看到“报文源”的路由表项的出接口是否与收到组播报文的入接口一致。如果一致，则认为该组播报文从正确的接口到达，从而保证了整个转发路径的正确性和唯一性。这个过程就被称为RPF检查。</li>
<li>如果这几条等价路由都是来自同一张路由表项，则选取下一跳地址最大的路由作为RPF路由。</li>
<li>RPF检验可以基于单播路由、MBGP路由和组播静态路由。他们之间的优先顺序为组播静态路由、MBGP路由、单播路由。</li>
</ul>
</li>
<li><p>拓扑描述</p>
</li>
<li><p>来自组播源FC00:0:0:2001::1/64的组播流从S1口到达路由器，路由器检查路由表，发现可以转发该组播流的端口为S0，RPF检查失败。因此达到S1口的数据流被丢弃。</p>
</li>
<li><p>来自组播源FC00:0:0:2001::1/64的组播流从S0口达到路由器，检查路由表发现入接口与接收该组播流的接口S0一致，RPF检查成功。因此组播流将被正确的转发。</p>
</li>
<li><p>组播路由协议通过已有的单播路由信息来确定上、下游邻居设备，创建组播路由表项。运用RPF检查机制，来确保组播数据流能够沿组播分发树（路径）正确的传输，同时可以避免转发路径上环路的产生。</p>
</li>
<li><p>在实际组播数据转发过程中，如果对每一份接收到的组播数据报文都通过单播路由表进行RPF检查，会给路由器带来很大负担。因此，路由器在收到一份来自源S发往组G的组播数据报文之后，首先会在组播转发表中查找有无相应的（S，G）组播转发表项：</p>
</li>
<li><p>如果不存在（S，G）转发表项，则对该报文执行RPF检查，将检查到的RPF接口作为入接口，创建组播路由表项，下发到组播转发表中。其中，对RPF检查结果的处理方式为：如果检查通过，表明接收接口为RPF接口，向转发表项的所有出接口转发；如果检查失败，表明报文来源路径错误，丢弃该报文。</p>
</li>
<li><p>如果存在（S，G）转发表项，并且接收该报文的接口与转发表项的入接口一致，则向所有的出接口转发该报文。</p>
</li>
<li><p>如果存在（S，G）转发表项，但是接收该报文的接口与转发表项的入接口不一致，则对此报文进行RPF检查。对RPF检查结果的处理方式为：</p>
<ul>
<li>若RPF检查选取出的RPF接口与转发表项的入接口一致，则说明（S，G）表项正确，报文来源路径错误，将其丢弃。</li>
<li>若RPF检查选取出的RPF接口与转发表项的入接口不符，则说明（S，G）表项已过时，于是把表项中的入接口更新为RPF接口。然后再根据RPF检查规则进行判断：如果接收该报文的接口正是其RPF接口，则向转发表项的所有出接口转发该报文，否则将其丢弃。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/46.png"></p>
<blockquote>
<ul>
<li>缺省情况下，组播报文转发过程中如果存在多条等价的最优转发路径，按照RPF检查对等价路由的处理规则，只会从IGP路由表中选取出下一跳地址最大的路由作为RPF路由。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/47.png"></p>
<blockquote>
<ul>
<li>组播源Source向组播组G发送组播流，路由器RouterA和RouterD之间运行某种IGP协议（如OSPF），RouterA→RouterB→RouterD和RouterA→RouterC→RouterD是2条等价转发路径。</li>
<li>缺省情况下，根据RPF检查规则，组播流会从Int1端口转发，因为Int1的IP地址比Int0地址大。配置组播负载分担之后，就不会根据下一跳地址来选取转发路径，RouterA→RouterB→RouterD和RouterA→RouterC→RouterD都会转发组播流。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/48.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/49.png"></p>
<blockquote>
<ul>
<li>如图所示，域内路由器运行PIM SM，和接收者相临的接口运行MLD v1，在IPv6组播中MLDv1协议等同于IPv4组播中的IGMPv2，用于获取组播组成员信息并通知上层协议。</li>
<li>区域内所有路由器通过RP的静态配置、BSR、或者自动发现方式得到RP信息。</li>
<li>和IPv6接收者相连的倒数第一跳路由器收到接收者发送的MLD report报文，沿RPF邻居向上游发送(*，G)加入消息，直到RP收到(*，G)加入消息，沿途路由器都创建(*，G)项，生成以RP为根的共享树。</li>
<li>组播源发出组播数据，第一跳路由器向RP发送PIM注册消息，RP收到后回应注册停止消息。</li>
<li>RP向通过RPF邻居向第一跳路由器发(S，G)加入消息，沿途路由器创建(S，G)项，生成以第一跳路由器为根的源路径树。</li>
<li>组播数据沿源路径树到达RP，并沿(*，G)转发，沿途路由器生成(S，G)项，组播数据到达接收者。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/50.png"></p>
<p><img src="/2021/08/18/IE-PIM%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/51.png"></p>
<blockquote>
<ul>
<li><p>IPv6 PIM-SM和IPv4 PIM-SM有哪些不同？</p>
<ul>
<li>地址不同，协议机制完全一样。</li>
</ul>
</li>
<li><p>IPv6 PIM-SSM的工作机制是怎样的？</p>
<ul>
<li>IPv6 PIM-SSM的实现可以概括成邻居发现、DR选举和SPT生成：<ul>
<li>邻居发现和DR选举过程与IPv6 PIM-SM中的描述相同，是通过在路由器间发送Hello消息来实现的；</li>
<li>由于PIM-SSM也使用PIM-SM协议，路由器生成RPT还是生成SPT的判决取决于组播地址是否在SSM组地址范围内。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/" itemprop="url">IE-MLD原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:11+08:00">
                2021-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li>组播侦听发现协议MLD（Multicast Listener Discovery）用于IPv6组播中的组成员管理，其基本原理和功能与IGMP相似。MLD的目的是使能每个IPv6路由器发现在其直连网络上的组播侦听者（即希望接收组播数据的节点）的存在，并且能明确发现这些邻居节点所感兴趣的组播地址。然后提供这些消息给路由器所使用的组播路由协议，以确保组播数据转发至存在接收者的所有链接。</li>
<li>MLD是非对称协议，明确了组播侦听者与路由器的不同行为。对路由器本身正在侦听的组播地址来说，路由器扮演协议的两种角色，包括对自己的消息作出回应。</li>
<li>如果路由器有不止一个接口在同一网络上，它只需要在其中一个接口上运行此协议。另一方面，对侦听者来说，则必须在所有接口运行此协议以便上层协议从接口接收所需要的组播数据。</li>
<li>所有MLD版本都支持ASM （Any-Source Multicast）模型。MLDv2可以直接应用于SSM （Source-Specific Multicast） 模型，而 MLDv1 则需要 SSM-Mapping 技术的支持。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>组播侦听者是希望接收组播数据的主机节点。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/7.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li><p>类型（Type）：MLD消息共有三种。</p>
<ul>
<li>组播侦听查询（类型值＝130），可分为两种子类型：<ul>
<li>普遍查询：用于获得在所连网络上具有侦听者的组播地址。</li>
<li>特定组播地址查询：用于获得在所连网络上对一特定组播地址是否存在侦听者。</li>
</ul>
</li>
</ul>
</li>
<li><p>组播侦听报告（类型值＝131）</p>
</li>
<li><p>组播侦听离开（ Multicast Listener Done）(类型值＝132)</p>
</li>
<li><p>代码（Code）</p>
<ul>
<li>发送时设置为1；接收时忽略。</li>
</ul>
</li>
<li><p>校验和（Checksum）</p>
<ul>
<li>标准的ICMPv6校验和，覆盖所有MLD消息以及IPv6首部区域中的伪首部。</li>
</ul>
</li>
<li><p>最大响应延迟（Maximum Response Delay）</p>
<ul>
<li>最大响应延迟值只在查询报文消息中有意义，它指定了发送响应报文的最大允许时间延迟，单位为毫秒。在其他报文消息中，发送时设置为零，接收时忽略。</li>
</ul>
</li>
<li><p>保留（Reserved）</p>
<ul>
<li>发送者设为零；接收者忽略。</li>
</ul>
</li>
<li><p>组播地址（Multicast Address）</p>
<ul>
<li>在查询报文中，当发送普遍查询时，组播地址值设为零；当发送特定组查询时，设为特定的IPv6组播地址。在报告或离开报文中，组播地址值分别设为报文发送者要侦听或者停止侦听的特定IPv6组播地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li><p>所有MLD路由器在初始时都认为自己是查询器，并向本地网段内的所有主机和路由器发送MLD普遍组查询（General Query）报文（目的地址为 FF02::1）。</p>
</li>
<li><p>本地网段中的其它MLD路由器在收到该报文后，将报文的源IPv6地址与自己的接口地址作比较。通过比较，IPv6地址最小的路由器将成为查询器，其它路由器成为非查询器（Non-Querier）。</p>
</li>
<li><p>所有非查询器上都会启动一个定时器（即其它查询器存在时间定时器 Other Querier Present Timer）。在定 时器超时前，如果收到了来自查询器的 MLD 查询报文，则重置该定时器；否则，就认为原查询器失效， 并发起新的查询器选举过程。 </p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/10.png"></p>
<blockquote>
<ul>
<li><p>VRP遵循RFC 2710来实现MLDv1。MLDv1基于查询/响应（Query/Response）机制完成组播组成员的管理。</p>
</li>
<li><p>MLDv1有两种类型的查询消息（Query Message）：</p>
<ul>
<li>普遍查询（General Query）：查询直连链路上是否有组播组的侦听者。</li>
<li>指定组播组查询（Multicast-address-specific Query）：查询直连链路上是否有某个指定组播地址的侦听者。</li>
</ul>
</li>
<li><p>如果共享网段上存在配置MLD的多个组播路由器，将触发查询路由器（Querier）选举机制，由网段上IPv6地址最小的路由器充当查询器（也称MLD查询器），其他路由器充当非查询器（Non-Querier）。</p>
</li>
<li><p>以普遍查询为例，主机加入组播组的基本过程是：</p>
<ul>
<li>1、MLD查询器周期性地向共享网段上的所有本地链路主机以组播方式（目的地址为FF02::1）发送普遍查询消息。</li>
<li>2、网段上的所有主机都接收到该普遍查询消息。如果主机Host B和Host C希望加入某组播组G1，则设置定时器延时来响应。</li>
<li>3、希望加入的主机在定时器超时后以组播方式向网段上的所有主机和路由器发送报告消息（Report Message）来响应查询，此消息包含组播组G1的地址信息。</li>
<li>4、网段上的所有主机和路由器接收到此报告消息后，也就获得了关于G1的组播信息。此时网段中其他也希望加入组播组G1的主机将不再发送相同的报告消息，如果主机Host A希望加入另一个组播组G2，就会发送包含组播组G2地址的报告消息以响应普遍查询消息来加入G2。</li>
<li>5、在查询/报告过程后，MLD查询器可以了解到在自己的直连网段上是否有组播组G1的接收者，生成形式为(<em>, G1)组播路由项，</em>表示任意的组播源。</li>
<li>6、通过组播路由机制，MLD查询器接收到组播源发来的组播信息。如果直连网段上有接收者，就在网段上转发此数据，加入组播组的主机接收该数据。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/11.png"></p>
<blockquote>
<ul>
<li>当主机想离开组播组，就以组播地址（目的地址是FF02::2）向链路上发送一个离开消息（Done Message），并且在其组播地址域携带要停止侦听的地址。</li>
<li>当查询器从链路上收到离开消息时，如果要离开的组播报文地址在此链路上查询器的侦听者地址列表中，查询器就会发送Last Listener Query Count次组播地址特定查询，每次间隔时间为Last Listener Query Interval。组播地址特定查询一般将Last Listener Query Interval设定为Maximum Response Delay，如果最后查询的响应延迟时间过后，没有此组播地址的报告在此链路上发送给查询器，因此此地址就从侦听者列表中删除。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/12.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/13.png"></p>
<blockquote>
<ul>
<li><p>头192bits部分是和MLDv1的消息格式相同的部分。</p>
</li>
<li><p>标志位S（Suppress Router-side Processing）：</p>
<ul>
<li>表示路由器接收到查询消息后是否对定时器更新进行抑制。</li>
</ul>
</li>
<li><p>查询器的健壮性变量 QRV（Querier’s Robustness Variable）：</p>
<ul>
<li>健壮性变量值QRV是最后侦听者查询次数的缺省值，也就是路由器在确定没有剩余侦听者存在之前而发送的特定组播地址查询的次数。</li>
</ul>
</li>
<li><p>查询器发送普遍查询消息的查询间隔 QQIC（Querier’s Query Interval Code）。</p>
</li>
<li><p>源数目（Number of Sources）：</p>
<ul>
<li>普遍查询或指定组播组查询中，此字段设置为0。</li>
<li>指定组播源-组查询中，此字段表示查询消息中包含的源地址个数。</li>
</ul>
</li>
<li><p>源地址（Source Address）：</p>
<ul>
<li>指定查询的组播源地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/14.png"></p>
<blockquote>
<ul>
<li><p>主机通过发送MLD报告消息来汇报当前的组播侦听状态。</p>
</li>
<li><p>类型（Type）：</p>
<ul>
<li>Type=143</li>
</ul>
</li>
<li><p>保留（Reserved）：</p>
<ul>
<li>发送时设置为0；接收时忽略。</li>
</ul>
</li>
<li><p>校验和（Checksum）：</p>
<ul>
<li>标准的ICMPv6校验和，覆盖所有MLD消息以及IPv6首部区域中的伪首部。</li>
</ul>
</li>
<li><p>组播地址记录的个数（ Number of Multicast Address Records ）</p>
</li>
<li><p>组播地址记录 （Multicast Address Records ）：</p>
<ul>
<li>表示主机在接口上侦听到的每个组播地址信息，包括记录类型、组播地址、源地址等。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/15.png"></p>
<blockquote>
<ul>
<li><p>MLDv2兼容MLDv1，原理与MLDv1相同。MLDv2支持源列表和过滤模式，可以指定源地址加入，用于实现SSM。</p>
</li>
<li><p>对 IPv6 组播源的过滤 ：MLDv2是在指定组播组查询的基础上增加关于组播源的过滤模式：Include或Exclude。</p>
<ul>
<li>如果主机加入组播组时，只要求接收某些指定源如S1、S2、……发来的组播组报文，MLD报告消息中可以设置为Include Sources (S1, S2, …)。</li>
<li>如果主机加入组播组时，拒绝接收某些指定源如S1、S2、……发来的组播报文，则可以设置从指定源外的源地址接收组播组报文，MLD报告消息中可以设置为Exclude Sources (S1, S2, …)。</li>
</ul>
</li>
<li><p>IPv6 组播组状态跟踪：运行MLDv2协议的组播路由器按每条直连链路上的组播地址（per multicast address per attached link）来保持组播组的状态。组播组状态包括：</p>
<ul>
<li>过滤模式：保持对Include或Exclude的状态跟踪。</li>
<li>源列表：保持对新增或删除组播源的跟踪。</li>
<li>定时器：例如表示组播地址超时后切换到Include模式的过滤定时器、关于源记录的源定时器等。</li>
</ul>
</li>
<li><p>接收者主机的状态侦听：运行MLDv2协议的组播路由器通过侦听接收者主机的状态，记录和维护网段上加入到源-组的主机的信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/16.png"></p>
<blockquote>
<ul>
<li>接收者通过组播方式接收视频点播信息，不同组织的接收者组成末梢网络，每个末梢网络中都存在一到多台接收者Host。</li>
<li>Host A和Host C为两个末梢网络中的组播信息接收者。PIM网络中的Router A通过GE1/0/0接口连接末梢网络N1，通过POS2/0/0接口连接PIM网络中的其它设备；Router B和Router C路由器通过各自的GE1/0/0接口连接末梢网络N2，分别通过POS2/0/0接口连接PIM网络中的其它设备。</li>
<li>Router A和末梢网络N1之间运行MLDv1。</li>
<li>Router B、Router C和末梢网络N2之间运行MLDv2。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/17.png"></p>
<blockquote>
<ul>
<li><p>进入系统视图</p>
<ul>
<li><strong>system-view</strong></li>
</ul>
</li>
<li><p>使能IP组播路由</p>
<ul>
<li><strong>multicast ipv6 routing-enable</strong></li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em></li>
</ul>
</li>
<li><p>使能MLD</p>
<ul>
<li><strong>mld</strong> <strong>enable</strong></li>
<li>配置了MLD的路由器必须在接口上使能MLD来侦听所有的IPv6组播地址。在需要建立和维持组播组成员关系的接口上使能MLD。</li>
<li>查询器在直连网段上周期性发送MLD查询消息来维持组播侦听者的信息。当接收到组成员报告消息时，组播路由器刷新相关的组成员信息。</li>
</ul>
</li>
<li><p>进入MLD视图</p>
<ul>
<li><strong>mld</strong></li>
</ul>
</li>
<li><p>配置全局性MLD版本</p>
<ul>
<li><strong>version</strong> { <strong>1</strong> | <strong>2</strong> } </li>
</ul>
</li>
<li><p>进入接口视图</p>
<ul>
<li><strong>interface</strong> <em>interface-type interface-number</em></li>
</ul>
</li>
<li><p>配置接口MLD版本</p>
<ul>
<li><strong>mld</strong> <strong>version</strong> { <strong>1</strong> | <strong>2</strong> } </li>
<li>MLD版本号的配置是可选的。缺省情况下，使用MLDv2版本。</li>
<li>当接口下没有配置新值时，缺省采用MLD视图下配置的值；假如接口下配置了新值，则接口视图下的取值优先被选择。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li>缺省情况下使用MLDv2。</li>
<li>Router C的配置与Router B类似。</li>
<li>在这样一个网络上需要选举查询器，那一台路由器将被选举成查询器呢？</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li>可以看到，Router B是查询器，这是因为同一网段上组播路由器Router B的GE1/0/0的IPv6地址较小。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/21.png"></p>
<blockquote>
<ul>
<li><p>配置完成后，当 RouterA 收到来自主机的 MLDv1 报告报文时，首先检查该报文中所携带的 IPv6 组播组地址 G， 然后根据检查结果的不同分别进行处理： </p>
<ul>
<li>如果 G 不在 IPv6 SSM 组地址范围内，则提供 ASM 组播服务。 </li>
<li>如果 G 在 IPv6 SSM 组地址范围内： </li>
<li>若 RouterA 上没有 G 对应的 MLD SSM Mapping 规则，则无法提供 SSM 组播服务，丢弃该报文； </li>
<li>若 RouterA 上有 G 对应的 MLD SSM Mapping 规则，则依据规则将报告报文中所包含的（*，G）信息 映射为（G，INCLUDE，（ S1，S2…））信息，可以提供 SSM 组播服务。SSM映射功能使采用MLDv1版本的主机无须升级MLD版本就能顺利接收SSM的数据报文。此功能不影响采用MLDv2的主机。</li>
</ul>
</li>
<li><p>映射策略可以多次配置，实现同一个组到多个源的映射。在一台路由器上，转发且仅转发映射表中的指定源-组报文。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/25.png"></p>
<blockquote>
<ul>
<li><p>MLD的主要功能是什么？</p>
<ul>
<li>组播侦听发现协议MLD（Multicast Listener Discovery）用于IPv6组播中的组成员管理，其基本原理和功能与IGMP相似。MLD的目的是使能每个IPv6路由器发现在其直连网络上的组播侦听者（即希望接收组播数据的节点）的存在，并且能明确发现这些邻居节点所感兴趣的组播地址。然后提供这些消息给路由器所使用的组播路由协议，以确保组播数据转发至存在接收者的所有链接。</li>
</ul>
</li>
<li><p>MLDv2和MLDv1有哪些主要区别？</p>
<ul>
<li>MLDv2兼容MLDv1，原理与MLDv1相同。MLDv2支持源列表和过滤模式，可以指定源地址加入，用于实现SSM。</li>
</ul>
</li>
<li><p>SSM Mapping的主要作用是什么？</p>
<ul>
<li>发送MLDv1格式的报告消息的主机，不能接收到SSM组范围内的数据报文。 SSM映射功能使采用MLDv1版本的主机无须升级MLD版本就能顺利接收SSM的数据报文。此功能不影响采用MLDv2的主机。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/08/18/IE-MLD%E5%8E%9F%E7%90%86/27.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/" itemprop="url">IE-路由import与Control</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:01+08:00">
                2021-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/1.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/2.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/3.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/4.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/5.png"></p>
<blockquote>
<ul>
<li><p>ACL访问控制类表</p>
<ul>
<li>ACL是由permit或deny语句组成的一系列有顺序规则的集合，它通过匹配报文的信息实现对报文的分类。路由器根据ACL定义的规则判断哪些报文可以接收，哪些报文需要拒绝，从而实现对报文的过滤。</li>
<li>ACL通过配置的一系列匹配规则对特定的数据包进行过滤，从而识别需要过滤的对象。然后，根据预先设定的策略允许或禁止相应的数据包通过。同时，ACL可以作为基础配置被其他功能模块引用。</li>
</ul>
</li>
<li><p>ip-prefix前缀类表</p>
<ul>
<li>ip-prefix将路由条目与前缀过滤列表的每一项进行匹配，然后根据定义的匹配模式进行过滤，达成路由筛选的目的。</li>
<li>ip-prefix不能用来过滤数据包，只能过滤路由信息。</li>
</ul>
</li>
<li><p>as-path-filter AS路径过滤器</p>
<ul>
<li>BGP的路由信息中，包含一个自治系统路径域。As-path-filter就是针对自治系统路径域指定匹配条件。AS路径过滤器仅应用于BGP协议。</li>
</ul>
</li>
<li><p>community-filter团体属性过滤器</p>
<ul>
<li>BGP的路由信息中，可以携带一个或多个团体属性，团体属性过滤器就针对团体属性域指定匹配条件。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/6.png"></p>
<blockquote>
<ul>
<li><p>ACL编号：用于标识ACL，表明该ACL是数字型ACL。</p>
<ul>
<li>根据ACL规则功能的不同，ACL被划分为基本ACL、高级ACL、二层ACL和用户ACL这几种类型，每类ACL编号的取值范围不同。</li>
<li>除了可以通过ACL编号标识ACL，设备还支持通过名称来标识ACL，就像用域名代替IP地址一样，更加方便记忆。这种ACL，称为命名型ACL。</li>
<li>命名型ACL实际上是“名字+数字”的形式，可以在定义命名型ACL时同时指定ACL编号。如果不指定编号，则由系统自动分配。</li>
</ul>
</li>
<li><p>规则：即描述报文匹配条件的判断语句。</p>
<ul>
<li>规则编号：用于标识ACL规则。可以自行配置规则编号，也可以由系统自动分配。ACL规则的编号范围是0～4294967294，所有规则均按照规则编号从小到大进行排序。所以，图1中的rule 5排在首位，而规则编号最大的rule15排在末位。系统按照规则编号从小到大的顺序，将规则依次与报文匹配，一旦匹配上一条规则即停止匹配。</li>
<li>动作：包括permit/deny两种动作，表示允许/拒绝。</li>
<li>匹配项：ACL定义了极其丰富的匹配项。除了图中的源地址和生效时间段，ACL还支持很多其他规则匹配项。例如，二层以太网帧头信息（如源MAC、目的MAC、以太帧协议类型）、三层报文信息（如目的地址、协议类型）以及四层报文信息（如TCP/UDP端口号）等。</li>
<li>如果规则存在，则系统会从ACL中编号最小的规则开始查找。如果匹配上了permit规则，则停止查找规则，并返回ACL匹配结果为：匹配（允许）。如果匹配上了deny规则，则停止查找规则，并返回ACL匹配结果为：匹配（拒绝）。如果未匹配上规则，则继续查找下一条规则，以此循环。如果一直查到最后一条规则，报文仍未匹配上，则返回ACL匹配结果为：不匹配。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/7.png"></p>
<blockquote>
<ul>
<li><p>基本ACL</p>
<ul>
<li>仅使用报文的源IP地址、分片信息和生效时间段信息来定义规则。</li>
</ul>
</li>
<li><p>高级ACL</p>
<ul>
<li>既可使用IPv4报文的源IP地址，也可使用目的IP地址、IP协议类型、ICMP类型、TCP源/目的端口、UDP源/目的端口号、生效时间段等来定义规则。</li>
</ul>
</li>
<li><p>二层ACL</p>
<ul>
<li>使用报文的以太网帧头信息来定义规则，如根据源MAC（Media Access Control）地址、目的MAC地址、二层协议类型等。</li>
</ul>
</li>
<li><p>用户ACL</p>
<ul>
<li>既可使用IPv4报文的源IP地址，也可使用目的IP地址、IP协议类型、ICMP类型、TCP源端口/目的端口、UDP源端口/目的端口号等来定义规则。</li>
</ul>
</li>
<li><p>除此之外，还有基于IPv6的ACL，基本ACL6和高级ACL6。</p>
<ul>
<li>基本ACL6：可使用IPv6报文的源IPv6地址、分片信息和生效时间段来定义规则。</li>
<li>高级ACL6：可以使用IPv6报文的源IPv6地址、目的IPv6地址、IPv6协议类型、ICMPv6类型、TCP源/目的端口、UDP源/目的端口号、生效时间段等来定义规则。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/8.png"></p>
<blockquote>
<ul>
<li><p>ACL的匹配顺序</p>
<ul>
<li>一个ACL 可以由多条“deny | permit”语句组成，每一条语句描述一条规则，这些规则可能存在重复或矛盾的地方（一条规则可以包含另一条规则，但两条规则不可能完全相同）。</li>
<li>设备支持两种匹配顺序，即配置顺序（config）和自动排序（auto）。当将一个数据包和访问控制列表的规则进行匹配的时候，由规则的匹配顺序决定规则的优先级，ACL通过设置规则的优先级来处理规则之间重复或矛盾的情形。缺省的ACL匹配顺序是config模式。</li>
</ul>
</li>
<li><p>配置顺序</p>
<ul>
<li>如果配置规则时指定了规则编号，则规则编号越小，规则插入位置越靠前，该规则越先被匹配。</li>
<li>如果配置规则时未指定规则编号，则由系统自动为其分配一个编号。该编号是一个大于当前ACL内最大规则编号且是步长整数倍的最小整数，因此该规则会被最后匹配。</li>
</ul>
</li>
<li><p>自动排序（auto）</p>
<ul>
<li>自动排序（auto）使用“深度优先”的原则进行匹配。</li>
<li>“深度优先”即根据规则的精确度排序，匹配条件（如协议类型、源和目的IP 地址范围等）限制越严格越精确。例如可以比较地址的反掩码，反掩码越小，则指定的主机的范围就越小，限制就越严格。</li>
<li>若“深度优先”的顺序相同，则匹配该规则时按rule-id从小到大排列。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/9.png"></p>
<blockquote>
<ul>
<li>ACL6和ACL命令行不同，而对应的编号可以相同，二者互不影响。</li>
<li>例如：<ul>
<li>[RouterA] acl ipv6 number 3001</li>
<li>[RouterA-acl6-adv-3001] rule deny ipv6 source 3001::2/64</li>
<li>[RouterA] acl 3001</li>
<li>[Router-acl-adv-3001] rule permit ip source 202.169.10.5 0.0.0.0</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/10.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/11.png"></p>
<blockquote>
<ul>
<li><p>ip-prefix</p>
<ul>
<li>每个地址前缀列表可以包含多个IP-Prefix条目，每个IP-Prefix条目对应一个索引号（index）。路由将按照索引号从小到大依次检查IP-Prefix列表，任意一个index匹配成功，将不再检查其余项。若所有index都匹配失败，路由信息将被过滤。</li>
<li>根据匹配的前缀不同，前缀过滤列表可以进行精确匹配，也可以进行在一定掩码长度范围内匹配。</li>
<li>前缀过滤列表可以进行精确匹配或者在一定掩码长度范围内匹配，可以通过配置关键字greater-equal和less-equal指定待匹配的前缀掩码长度范围。如果没有配置关键字greater-equal或less-equal，前缀过滤列表进行精确匹配，即只匹配掩码长度为前缀过滤列表掩码长度的相同IP地址路由；如果只配置了关键字greater-equal，则待匹配的掩码长度范围为从greater-equal指定值到32 位长度；如果只匹配了关键字less-equal，则待匹配的掩码长度范围为从指定的掩码到关键字less-equal指定值。</li>
<li>greater-equal-value与less-equal-value的取值限制：mask-length&lt;=greater-equal-value&lt;=less-equal-value&lt;=32。</li>
</ul>
</li>
<li><p>ip-prefix特点</p>
<ul>
<li>当所有前缀过滤列表均未匹配时，缺省情况下，存在最后一条默认匹配模式为deny。</li>
<li>当引用的前缀过滤列表不存在时，默认匹配模式为permit。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/12.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/13.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/14.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/15.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/16.png"></p>
<blockquote>
<ul>
<li>AS路径过滤器是将BGP中的AS_Path属性作为匹配条件的过滤器，只有BGP在收发路由的时候才能使用。</li>
<li>由于AS_Path属性记录AS号是将最后经历的AS号放在AS_Path记录中的最左侧，所以在配置as-path-filter时需要格外注意。<ul>
<li>如果一条路由起源于AS100，然后依次经过AS300, AS200, AS500，最后到达AS600。那么在AS600里，路由的AS-PATH属性表示为（500 200 300 100）。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/17.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/18.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/19.png"></p>
<blockquote>
<ul>
<li>团体属性过滤器是将BGP中的团体属性作为匹配条件的过滤器，只有BGP在收发路由的时候才能使用。</li>
<li>团体属性包括基本basic团体属性和extended团体属性<ul>
<li>自定义团体属性和公认团体属性均属于basic团体属性。</li>
<li>MPLS VPN中的RT和SOO均属于extended团体属性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/20.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/21.png"></p>
<blockquote>
<ul>
<li><p>路由策略主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。</p>
</li>
<li><p>路由策略常用于如下场景：</p>
<ul>
<li>控制路由的引入：<ul>
<li>在对路由做相互引入时，为了防止次优路径或者环路，可以使用路由策略加以解决。</li>
</ul>
</li>
<li>控制路由的接收和发布：<ul>
<li>根据网络需求，接收或者发布特定的路由。</li>
</ul>
</li>
<li>设置特定路由的属性：<ul>
<li>可以通过路由策略修改路由的属性，以对网络进行优化、调整。</li>
</ul>
</li>
</ul>
</li>
<li><p>路由策略原理</p>
<ul>
<li>一个Route-Policy由多个节点构成，路由进入路由策略后，按节点序号从小到大依次检查各个节点是否匹配。一个节点包括多个if-match和apply子句。if-match子句用来定义该节点的匹配条件，apply子句用来定义通过过滤的路由行为。if-match子句的过滤规则关系是“与”，即该节点的所有if-match子句都必须匹配。Route-Policy节点间的过滤关系是“或”，即只要通过了一个节点的过滤，就可通过该Route-Policy。如果没有通过任何一个节点的过滤，路由信息将无法通过该Route-Policy。</li>
<li>对于同一个Route-Policy节点，在匹配的过程中，各个if-match子句间是“与”的关系，即路由信息必须同时满足所有匹配条件，才可以执行apply子句的动作。但命令if-match route-type和if-match interface除外，这两个命令的各自if-match子句间是“或”的关系，与其它命令的if-match子句间仍是“与”的关系。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/22.png"></p>
<blockquote>
<ul>
<li>上面拓扑为双点双向重发布的示意图，如果不加控制，将会发生次优路由和环路等故障，产生故障的过程具体分析如下：<ul>
<li>在拓扑中，R1将网段10.0.0.0/24及2000::/64引入到OSPF。R2/R3分别将该路由引入ISIS，正常情况下，R2/R3将路由引入ISIS会有先后，假设R3先于R2将该路由引入到IS-IS。那么R2就会同时从OSPF和IS-IS学到10.0.0.0/24及2000::/64的路由。于是R2会根据路由协议的优先级优选通过IS-IS学到的路由（OSPF的外部路由优先级为150，IS-IS的路由优先级为15）。于是，当R2访问10.0.0.0/24及2000::/64网段时，会使用R4-R3-R1这条次优路径。为了避免出现这种情况，可以在路由器R2上使用route-policy修改OSPF ASE路由的优先级，使得OSPF ASE的路由优先于从IS-IS学到的路由，使得R2选择正确的路由。</li>
<li>当R1连接网络10.0.0.0/24及2000::/64的接口断掉之后，虽然该条外部LSA会在OSPF区域内老化，但是由于R2通过IS-IS已经学习到了10.0.0.0/24及2000::/64网络，所以R2会将该网络引入到OSPF，进而使R1和R3会通过R2学习到了网络10.0.0.0/24及2000::/64。当R2访问访问网络10.0.0.0/24及2000::/64时，流量会沿R4-R3-R1-R2的路径发送，从而引发环路。为避免这种情况，我们可以通过给路由条目添加标记tag标签，然后对特定标签进行过滤的方法来避免环路的发生。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/23.png"></p>
<blockquote>
<ul>
<li><p>控制路由的接收和发布</p>
<ul>
<li>只接收必要、合法的路由信息，以控制路由表的容量，提高网络的安全性。</li>
</ul>
</li>
<li><p>拓扑解释</p>
<ul>
<li>R4将网络10.0.X.0/24及2000::/64&amp;3000::/64引入到OSPF中。根据业务需要，R1只能接收网络10.0.0.0/24和2000::/64；而R2只能接收网络10.0.1.0/24和3000::/64。对于这种需求，可以通过filter-policy加以实现。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/24.png"></p>
<blockquote>
<ul>
<li>Filter-policy import命令用来按照过滤策略，设置OSPF对接收的路由进行过滤。</li>
<li>Filter-policy export命令用来按照过滤策略，设置对引入的路由在向外发布时进行过滤。<ul>
<li>通过指定protocol或process-id对特定的某一种协议或某一进程的路由进行过滤。如果没有指定protocol和process-id，则OSPF将对所有引入的路由信息进行过滤。</li>
<li>由于Type5、7 LSA是有ABSR产生的，因此，本命令仅在ASBR上配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/25.png"></p>
<blockquote>
<ul>
<li><p>Filter-policy import命令用来配置IS-IS路由加入IP路由表时的过滤策略。</p>
<ul>
<li>配置该命令后，不会影响本地设备的LSP的扩散和LSDB的同步，只会影响本地的IP路由表。</li>
</ul>
</li>
<li><p>Filter-policy export命令用来配置IS-IS对已引入的路由在向外发布时进行过滤的过滤策略。</p>
<ul>
<li>配置该命令后，不会影响本地设备的路由，只会将引入的部分外部路由发布给IS-IS邻居。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/26.png"></p>
<blockquote>
<ul>
<li>filter-policy import命令用来配置对接收的路由信息进行过滤。</li>
<li>filter-policy export命令用来配置对发布的路由进行过滤，只有通过过滤的路由才被BGP发布。<ul>
<li>如果指定protocol参数，将只对引入的这种协议产生的路由进行过滤，对引入的其他协议产生的路由不受影响。如果没有指定protocol参数，对引入的任何一个协议产生的路由都要进行过滤。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/27.png"></p>
<blockquote>
<ul>
<li>拓扑描述<ul>
<li>通过route-policy修改BGP中的Local_Pref属性，进而影响流量走向。R2将从EBGP学到的10.0.0.0/24和2000::/64路由的Local_Pref设为300，R3将从EBGP学到的该路由的Local_Pref设置为200，R1/R2/R3相互之间通过IBGP交互各自的路由，最终将选择以R2作为本AS去往网络10.0.0.0/24和2000::/64的出口。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/28.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/29.png"></p>
<blockquote>
<ul>
<li>策略路由与路由策略存在以下不同：<ul>
<li>策略路由的操作对象是数据包，在路由表已经产生的情况下，不按照路由表进行转发，而是根据需要，依照某种策略改变数据包转发路径。</li>
<li>路由策略的操作对象是路由信息。路由策略主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/30.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/31.png"></p>
<blockquote>
<ul>
<li><p>匹配顺序：</p>
<ul>
<li>如果找到了匹配的本地策略路由节点，则按照以下步骤发送报文：<ul>
<li>查看用户是否设置了报文的优先级: 如果用户设置了报文的优先级，首先根据用户设置的优先级设置报文的优先级，然后继续向下执行;如果用户未设置报文的优先级，则继续向下执行</li>
<li>查看用户是否设置了本地策略路由的出接口: 如果用户设置了出接口，则将报文从出接口发送出去，不再继续执行下面的步骤;如果用户未设置出接口，则继续向下执行</li>
<li>查看用户是否设置了本地策略路由的下一跳（用户可以设置两个下一跳以达到负载分担的目的）如果用户设置了策略路由的下一跳，则将报文发往下一跳，不再继续执行下面的步骤; 如果用户未设置下一跳，则按照正常流程根据报文的目的地址查找路由。如果没有查找到路由，则继续向下执行</li>
<li>查看用户是否设置了本地策略路由的缺省出接口: 如果用户设置了缺省出接口，则将报文从缺省出接口发送出去，不再继续执行下面的步骤;如果用户未设置缺省出接口，则继续执行</li>
<li>查看用户是否设置了本地策略路由的缺省下一跳:如果用户设置了缺省下一跳，则将报文发往缺省下一跳，不再继续执行下面的步骤;如果用户未设置缺省下一跳，则继续执行</li>
<li>丢弃报文，产生ICMP_UNREACH 消息</li>
</ul>
</li>
</ul>
</li>
<li><p>如果没有找到匹配的本地策略路由节点，按照发送IP报文的一般流程，根据目的地址查找路由</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/32.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/33.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/34.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/35.png"></p>
<blockquote>
<ul>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RTX与RTY互联，则互联地址为XY.1.1.X与XY.1.1.Y，掩码长度为24位。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/36.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>route-policy命令用来创建Route-Policy并进入该Route-Policy视图。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>route-policy route-policy-name { permit | deny } node node<ul>
<li>route-policy-name：指定Route-Policy名称。</li>
<li>permit：指定Route-Policy节点的匹配模式为允许。如果路由匹配所有的if-match子句，该路由可通过过滤并执行此节点apply命令中规定的一系列动作；否则，必须进行下一节点的测试。</li>
<li>deny：指定Route-Policy节点的匹配模式为拒绝。如果路由匹配所有的if-match子句，该路由不能通过过滤从而不能进入下一节点的测试。</li>
<li>node node：Route-Policy的节点索引。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>Route-Policy用于过滤路由信息以及为通过过滤的路由信息设置路由属性。一个Route-Policy由多个节点构成。一个节点包括多个if-match和apply子句。if-match子句用来定义该节点的匹配条件，apply子句用来定义通过过滤的路由行为。if-match子句的过滤规则关系是“与”，即该节点的所有if-match子句都必须匹配。Route-Policy节点间的过滤关系是“或”，即只要通过了一个节点的过滤，就可通过该Route-Policy。如果没有通过任何一个节点的过滤，路由信息将无法通过该Route-Policy。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/37.png"></p>
<blockquote>
<ul>
<li>此处的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
<li>对于该需求，主要考察对filter-policy和ACL的理解。所谓最优配置，实际上就是使用最少的命令达到要求的效果。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/38.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>filter-policy export命令用来按照过滤策略，设置对引入的路由在向外发布时进行过滤。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>filter-policy { acl-number | acl-name acl-name | ip-prefix ip-prefix-name } export [ protocol [ process-id ] ]<ul>
<li>acl-number：指定基本访问控制列表号。</li>
<li>acl-name acl-name：指定访问控制列表名称。</li>
<li>ip-prefix ip-prefix-name：指定地址前缀列表名称。</li>
<li>protocol：指定发布路由信息的协议。</li>
<li>process-id：当发布的路由协议为rip、isis、ospf时，可以指定进程号。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>OSPF通过命令import-route引入外部路由后，为了避免路由环路的产生，通过filter-policy export命令对引入的路由在发布时进行过滤，只将满足条件的外部路由转换为Type-5 LSA（AS-external-LSA）并发布出去。</li>
<li>通过指定protocol或process-id对特定的某一种协议或某一进程的路由进行过滤。如果没有指定protocol和process-id，则OSPF将对所有引入的路由信息进行过滤。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/39.png"></p>
<blockquote>
<ul>
<li>该案例拓扑和之前的拓扑一致。我们在完成需求后，要充分考虑到是否存在次优路由，是否发生了环路。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/40.png"></p>
<blockquote>
<ul>
<li>通过路由协议的相互引入之后，R4到达网络172.16.X.0/24出现次优路径。产生次优路径主要是因为R3将OSPF路由先行分发入ISIS协议域，于是R4从OSPF和ISIS同时学到了172.16.X.0/24的路由，因为OSPF的外部路由的preference值为150，而ISIS的preference值为15，所以R4选择了ISIS路由前往172.16.X.0/24网段，于是产生次优路由。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/41.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/42.png"></p>
<blockquote>
<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。<ul>
<li>需要修正R4访问172.16.X.0/24网段的路由，避免出现经过ISIS区域的次优路由。</li>
<li>可以通过Tag实现对双点双向路由引入的控制，从而避免环路。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/43.png"></p>
<blockquote>
<ul>
<li><p>如果在做路由互相引入的时候不做过滤，那么，在网络发生变化的时候，可能会在网络中导致环路。为避免环路就要保证路由协议间相互引入的时候只引入各路由域自身的路由。在上面的配置场景中，使用了tag来实现路由相互引入时的限制。使用tag的优势是不需要指定具体的路由条目，当路由域内具体的路由项有增减的时候，引入的路由条目的tag值会随之变化，不需要手工干预，具有很好的扩展性。</p>
</li>
<li><p>虽然上面的配置场景的路由策略能够很好地避免环路，但是并不能解决次优路由的问题。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/44.png"></p>
<blockquote>
<ul>
<li><p>次优路由主要是因为双点双向导入时，R3/R4中的某一台路由器会同时从两侧得到172.16.X.0/24路由，而因为OSPF的外部路由preference值大于ISIS的preference值（preference值越小越优先），导致R3/R4（其中一台）选择了次优路由。要解决此问题，需要修改OSPF外部路由条目的preference值，只要使OSPF_ASE路由的preference值小于ISIS路由的preference值就可以解决此问题。</p>
</li>
<li><p>考虑到合理性问题，不建议将OSPF_ASE路由的preference值设置成比OSPF内部路由的preference值（10）还小。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/45.png"></p>
<blockquote>
<ul>
<li>本案例中，是对原案例进行的扩展，在原案例的基础上进行配置。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/46.png"></p>
<blockquote>
<ul>
<li>当仅仅进行路由汇总，发现存在两个问题。第一个问题，R5学习到了该汇总路由；第二个问题，在R2 ping一个不存在的地址产生了环路。</li>
<li>第一个问题产生的原因，主要是由于R3和R4学习到对方产生的汇总路由后，再引入到ISIS域中产生的。此处，R3首先进行了OSPF汇聚配置，通过R2传递到R4。R4将该OSPF汇聚路由引入到ISIS，通告给R5。</li>
<li>第二个问题产生的原因，是因为R2上面有2条等价的10.0.0.0/16的路由，下一跳分别是R3和R4。当tracert的端口号变化时，tracert报文会被送给R3或R4。（1）tracert报文发给R4时： R4晚于R3进行OSPF路由汇聚，所以R4只有1条R3通告的OSPF聚合路由，所以R4对于10. 0.0.0/16，下一跳为R2。形成环路。（2）tracert报文发给R3时： R4生成OSPF汇聚路由后，通过R2通告给R3；R3生成OSPF汇聚路由后，通过R2传递给R4，R4将该OSPF汇聚路由引入到ISIS，通过R5通告给R3。所以R3会收到2条16位掩码的路由，通过比较协议优先级，R3会优选ISIS，下一跳为R5。R5的下一跳为R4。而R4晚于R3进行OSPF路由汇聚，所以R4有R3通告的OSPF聚合路由，所以R4对于10. 0.0.0/16，下一跳为R2。形成环路。</li>
<li>为了解决上面两个问题，我们需要保证R3和R4既不能学习到对方产生的汇总路由，又不能将该路由引入到ISIS路由域。所以，我们只需在R3和R4上将他们学习到的对方的汇总路由过滤即可。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/47.png"></p>
<blockquote>
<ul>
<li>在R3/R4上增加过滤策略，不从OSPF接收特定的汇聚路由。保证该汇聚路由不再重新导入到ISIS路由域。避免了环路。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/48.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/49.png"></p>
<blockquote>
<p>案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</p>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/50.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li>policy-based-route命令用来创建或修改策略路由和策略点。</li>
<li>ip local policy-based-route命令用来使能本地策略路由。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>policy-based-route policy-name { permit | deny } node node-id<ul>
<li>policy-name：指定策略名称。</li>
<li>permit：策略点的模式，表示对满足匹配条件的报文进行策略路由。</li>
<li>deny：策略点的模式，表示对满足匹配条件的报文不进行策略路由。</li>
<li>node-id：指定策略点的顺序号。</li>
</ul>
</li>
<li>ip local policy-based-route policy-name<ul>
<li>policy-name：指定策略路由的名称。 </li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在部署策略路由时，如果需要配置报文的出接口，则报文的出接口不能为以太接口等广播型接口。</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>在R5上指定不同的源地址对到达相同目的地的数据包进行跟踪，可以发现数据包选用了不同的路径。注意，ip local policy-based-route命令应用的策略只对路由器本地发起的数据包起作用。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/51.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/52.png"></p>
<blockquote>
<ul>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RTX与RTY互联，则互联地址为XY.1.1.X与XY.1.1.Y，掩码长度为24位。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/53.png"></p>
<blockquote>
<ul>
<li>该部分只需要注意R5在做路由引入时，需要精细匹配。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/54.png"></p>
<blockquote>
<ul>
<li>当tracert一个不存在的、但是在网络10.0.0.0/16内的地址时，会发生环路。该环路的产生主要是由于OSPF产生汇总路由时，不自动生成指向null0的路由所致。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/55.png"></p>
<blockquote>
<ul>
<li>在R5上通过命令配置指向null0的静态路由，即可破除环路。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/56.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/57.png"></p>
<blockquote>
<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RTX与RTY互联，则互联地址为XY.1.1.X与XY.1.1.Y,掩码长度为24位。</li>
<li>R1接口S1/0/0地址为12.1.1.1/24，R2接口S1/0/0地址为12.1.1.2/24；R1接口S1/0/1地址为21.1.1.1/24，R2接口S1/0/1地址为21.1.1.2/24。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/58.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/59.png"></p>
<blockquote>
<ul>
<li>通过filter-policy结合ACL，将需求中指定的两个网段导入到ISIS协议中，注意，当使用filter-policy过滤路由协议的导入的时候，使用export方向。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/60.png"></p>
<blockquote>
<ul>
<li>本案例中通过在导入路由的时候给路由条目加Tag的方法防止出现路由环路。ISIS路由协议如果需要支持Tag，必须要使用wide类型的开销，否则ISIS路由不能携带Tag标记。</li>
<li>使用Tag标签防止了路由回环，但是不能防止次优路由的产生。如果要避免次优路由，需要修改相应路由的preference值。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/61.png"></p>
<blockquote>
<ul>
<li>本例中的配置将避免路由10.0.0.0/16在R3/R4上出现次优路由。因为导入速度的不一致，总会导致R3/R4两台路由器中的一台会从ISIS和OSPF同时学到10.0.0.0/16，如果R3先行导入，那么R4就会同时从ISIS和OSPF学到10.0.0.0/16路由，而R4选择路由时会比较他们的preference，因OSPF外部路由的preference值为150，而isis的preference值为15，所以R4会选择到达经由IS-IS域到达网络10.0.0.0/16，该路径是次优路径。所以，通过在R4上，修改OSPF外部路由10.0.0.0/16的preference值，使其小于IS-IS的preference值，从而消除次优路径，考虑合理性，建议OSPF的外部路由preference值要大于OSPF的内部preference值（10）。</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/62.png"></p>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/63.png"></p>
<blockquote>
<ul>
<li>ABCD</li>
<li>D</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/64.png"></p>
<blockquote>
<ul>
<li>AB</li>
</ul>
</blockquote>
<p><img src="/2021/08/18/IE-%E8%B7%AF%E7%94%B1import%E4%B8%8EControl/65.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/" itemprop="url">IE-BGP双栈原理Advance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-09T15:31:25+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/1.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/2.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/3.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/4.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/5.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/6.png"></p>
<blockquote>
<ul>
<li>在大规模的网络中，BGP路由表十分庞大，给设备造成了很大的负担，同时使发生路由振荡的几率也大大增加，影响网络的稳定性。</li>
<li>路由聚合是将多条路由合并的机制，它通过只向对等体发送聚合后的路由而不发送所有的具体路由的方法，减小路由表的规模。并且被聚合的路由如果发生路由振荡，也不再对网络造成影响，从而提高了网络的稳定性。</li>
<li>路由聚合是会使用Aggregator属性（可选过渡属性），该属性标识发生聚合的节点，携带发生聚合节点的route-id和AS号。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/7.png"></p>
<blockquote>
<ul>
<li>自动聚合注意事项<ul>
<li>该命令对BGP引入的路由进行聚合，引入的路由可以是直连路由、静态路由、OSPF路由、IS-IS路由。配置聚合后，BGP将按照自然网段聚合路由，明细路由在BGP路由更新中被抑制。该命令对network命令引入的路由无效。</li>
<li>BGP只向对等体发送聚合后的路由；</li>
<li>缺省情况下BGP不启用自动聚合；</li>
<li>聚合之后的路由将带有atomic_aggregate和aggregator属性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/8.png"></p>
<blockquote>
<ul>
<li>手动聚合<ul>
<li>可通过命令决定是否抑制明细路由，抑制后该聚合后的路由会携带atomic_aggregate属性。</li>
<li>聚合路由不会携带成员明细路由的AS_PATH属性。</li>
<li>通过AS_SET属性来携带AS号，以避免环路。SET和SEQUENCE的不同之处在于，SET选项下的AS列表通常用于路由聚合，将来自不同AS的AS号无序排列在AS列表里；而SEQUENCE选项下的AS列表是有序的，每经过一个AS都会将其AS号排列在列表的前端。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/9.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/10.png"></p>
<blockquote>
<ul>
<li>对等体组（Peer Group）是一些具有某些相同策略的对等体的集合。当一个对等体加入对等体组中时，此对等体将获得与所在对等体组相同的配置。当对等体组的配置改变时，组内成员的配置也相应改变。</li>
<li>在大型BGP网络中，对等体的数量会很多，其中很多对等体具有相同的策略，在配置时会重复使用一些命令，利用对等体组可以简化配置。</li>
<li>对等体组中的单个对等体也可以配置自己的发布路由与接收路由的策略。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/11.png"></p>
<blockquote>
<ul>
<li><p>BGP按组打包</p>
<ul>
<li>缺省情况下，BGP会针对不同邻居（即使出口策略相同）单独打包路由。</li>
<li>应用按组打包功能后，每条待发送路由只被打包一次然后发给组内的所有邻居，使打包效率成倍提升。</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>一个反射器有3个客户机，有10万条路由需要反射。如果按照每个邻居分别打包的方式，反射器RR在向3个客户机发送路由的时候，所有路由被打包的总次数是10万×3。而按组打包技术将这个过程变为10 万×1，性能相当于提升了3倍。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/12.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/13.png"></p>
<blockquote>
<ul>
<li><p>团体属性是一组有相同特征的目的地址的集合。团体属性用一组以4字节为单位的列表来表示，设备中团体属性的格式是aa:nn或团体号。</p>
<ul>
<li>aa:nn：aa和nn的取值范围都是0～65535，管理员可根据实际情况设置具体数值。通常aa表示自治系统AS编号，nn是管理员定义的团体属性标识。例如，来自AS100的一条路由，管理员定义的团体属性标识是1，则该路由的团体属性格式是100:1。</li>
<li>团体号：团体号是0～4294967295的整数。RFC1997中定义，0（0x00000000）～65535（0x0000FFFF）和4294901760（0xFFFF0000）～4294967295（0xFFFFFFFF）是预留的。</li>
</ul>
</li>
<li><p>团体属性用来简化路由策略的应用和降低维护管理的难度，利用团体可以使多个AS中的一组BGP设备共享相同的策略。团体是一个路由属性，在BGP对等体之间传播，且不受AS的限制。BGP设备在将带有团体属性的路由发布给其它对等体之前，可以先改变此路由原有的团体属性。</p>
</li>
<li><p>公认团体属性</p>
<ul>
<li>Internet：缺省情况下，所有的路由都属于Internet团体。具有此属性的路由可以被通告给所有的BGP对等体。</li>
<li>No_Advertise：具有此属性的路由在收到后，不能被通告给任何其他的BGP对等体。</li>
<li>No_Export：具有此属性的路由在收到后，不能被发布到本地AS之外。如果使用了联盟，则不能被发布到联盟之外，但可以发布给联盟中的其他子AS。</li>
<li>No_Export_Subconfed：具有此属性的路由在收到后，不能被发布到本地AS之外，也不能发布到联盟中的其他子AS。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/14.png"></p>
<blockquote>
<ul>
<li>为保证IBGP对等体之间的连通性，需要在IBGP对等体之间建立全连接（Full-mesh）关系。假设在一个AS内部有n台路由器，那么应该建立的IBGP连接数就为n(n-1)/2。当IBGP对等体数目很多时，对网络资源和CPU资源的消耗都很大。利用路由反射可以解决这一问题。</li>
<li>在一个AS内，其中一台路由器作为路由反射器RR（Route Reflector），其它路由器作为客户机（Client）。客户机与路由反射器之间建立IBGP连接。路由反射器和它的客户机组成一个集群（Cluster）。路由反射器在客户机之间反射路由信息，客户机之间不需要建立BGP连接。</li>
<li>路由反射器概念<ul>
<li>路由反射器RR（Route Reflector）：允许把从IBGP 对等体学到的路由反射到其他IBGP对等体的BGP设备。</li>
<li>客户机（Client）：与RR形成反射邻居关系的IBGP设备。在AS内部客户机只需要与RR直连。</li>
<li>非客户机（Non-Client）：既不是RR也不是客户机的IBGP设备。在AS内部非客户机与RR之间，以及所有的非客户机之间仍然必须建立全连接关系。</li>
<li>始发者（Originator）：在AS内部始发路由的设备。Originator_ID属性用于防止集群内产生路由环路。</li>
<li>集群（Cluster）：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/15.png"></p>
<blockquote>
<ul>
<li><p>在向IBGP邻居发布学习到的路由信息时，RR按照以下规则发布路由</p>
<ul>
<li>从EBGP对等体学到的路由，发布给所有的非客户机和客户机。</li>
<li>从非客户机IBGP对等体学到的路由，发布给此RR的所有客户机。</li>
<li>从客户机学到的路由，发布给此RR的所有非客户机和客户机（发起此路由的客户机除外）。</li>
</ul>
</li>
<li><p>RR的配置方便，只需要对作为反射器的路由器进行配置，客户机并不需要知道自己是客户机。</p>
</li>
<li><p>在某些网络中，路由反射器的客户机之间已经建立了全连接，它们可以直接交换路由信息，此时客户机到客户机之间的路由反射是没有必要的，而且还占用带宽资源。VRP支持配置命令undo reflect between-clients来禁止RR将从客户机收到的路由再反射给其他客户机。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/16.png"></p>
<blockquote>
<ul>
<li><p>Originator ID由RR产生，使用的Router ID的值标识路由的发送者，用于防止集群内产生路由环路。</p>
<ul>
<li>当一条路由第一次被RR反射的时候，RR将Originator_ID属性加入这条路由，标识这条路由的发起设备。如果一条路由中已经存在了Originator_ID属性，则RR将不会创建新的Originator_ID属性。</li>
<li>当设备接收到这条路由的时候，将比较收到的Originator ID和本地的Router ID，如果两个ID相同，则不接收此路由。</li>
</ul>
</li>
<li><p>路由反射器和它的客户机组成一个集群（Cluster）。在一个AS内，每个路由反射器使用唯一的Cluster ID作为集群标识。</p>
<ul>
<li>为了防止集群间产生路由环路，路由反射器使用Cluster_List属性，记录路由经过的所有集群的Cluster ID。</li>
<li>当RR在它的客户机之间或客户机与非客户机之间反射路由时，RR会把本地Cluster_ID添加到Cluster_List的前面。如果Cluster_List为空，RR就创建一个。</li>
<li>当RR接收到一条更新路由时，RR会检查Cluster_List。如果Cluster_List中已经有本地Cluster_ID，丢弃该路由；如果没有本地Cluster_ID，将其加入Cluster_List，然后反射该更新路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/17.png"></p>
<blockquote>
<ul>
<li><p>备份RR主要是为了解决单点故障。</p>
</li>
<li><p>备份RR</p>
<ul>
<li>VRP需要使用命令reflector cluster-id给所有位于同一个集群内的路由反射器配置相同的Cluster_ID。</li>
<li>在冗余的环境里，客户机会收到不同反射器发来的到达同一目的地的多条路由，这时客户机应用BGP选择路由的策略来选择最佳路由。</li>
<li>Cluster_List的应用保证了同一AS内的不同RR之间不出现路由循环。</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>当客户机Client1从外部对等体接收到一条更新路由（10.0.0.0/24）后，它通过IBGP向RR1和RR2通告这条路由。</li>
<li>RR1接收到该更新路由后，它向其他的客户机（Client2、Client3）和非客户机（RR2）反射，同时将本地Cluster_ID添加到Cluster_List前面。</li>
<li>RR2接收到该反射路由后，检查Cluster_List，发现自己的Cluster_ID已经包含在Cluster_List中。因此，它丢弃该更新路由，不再向自己的客户机反射。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/18.png"></p>
<blockquote>
<ul>
<li>一个骨干网被分成多个反射集群，每个RR将其它的RR配置成非客户机，各RR之间建立全连接。每个客户机只与所在集群的RR建立IBGP连接。这样该自治系统内的所有BGP路由器都会收到反射路由信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/19.png"></p>
<blockquote>
<ul>
<li>Cluster1中部署了一个一级RR（RR-1），Cluster2和Cluster3中的RR(RR-2和RR-3)作为RR-1的客户端。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/20.png"></p>
<blockquote>
<ul>
<li>联盟<ul>
<li>联盟将一个AS划分为若干个子AS。每个子AS内部建立IBGP全连接关系，子AS之间建立联盟EBGP连接关系，但联盟外部AS仍认为联盟是一个AS。</li>
<li>配置联盟后，原AS号将作为每个路由器的联盟ID。</li>
<li>原有的IBGP 属性，包括Local Preference属性、MED属性和NEXT_HOP属性等；联盟相关的属性在传出联盟时会自动被删除，即管理员无需在联盟的出口处配置过滤子AS号等信息的操作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/21.png"></p>
<blockquote>
<ul>
<li><p>AS_PATH属性被定义为公认必遵属性，该属性由AS号所组成。AS_PATH包含4种不同类型</p>
<ul>
<li>AS_SET: 由一系列AS号无序地组成，包含在UPDATE消息里。当网络发生聚合时，可通过适当策略使AS_PATH使用类型AS_SET来避免路径信息丢失。</li>
<li>AS_SEQUENCE: 由一系列AS号顺序地组成，包含在UPDATE消息里。一般情况下，AS_PATH类型为AS_SEQUENCE。</li>
<li>AS_CONFED_SEQUENCE: 在本地联盟内由一系列成员AS号按顺序地组成，包含在UPDATE消息中，用法和AS_SEQUENCE相同，只能在本地联盟内传递。</li>
<li>AS_CONFED_SET: 在本地联盟内由一系列成员AS无序地组成，包含在UPDATE消息中，用法和AS_SET相同，只能在本地联盟内传递。</li>
</ul>
</li>
<li><p>联盟内部的成员AS号对于其他非联盟AS是不可见的，所以路由在从联盟内部发送到其他非联盟AS时，联盟成员AS号被剥离。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/22.png"></p>
<blockquote>
<ul>
<li>反射器和联盟的比较<ul>
<li>联盟需要重新划分区域，对现网改动较大。</li>
<li>反射器在配置时，只需要对RR进行配置，客户机不需要做任何其他的操作；联盟需要在所有路由器上进行配置。</li>
<li>RR与RR间需要IBGP全互联。</li>
<li>路由反射器应用较为广泛；联盟应用较少。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/23.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/24.png"></p>
<blockquote>
<ul>
<li><p>BGP安全特性：</p>
<ul>
<li>MD5：BGP使用TCP作为传输层协议，为提高BGP的安全性，可以在建立TCP连接时进行MD5认证。但BGP的MD5认证并不能对BGP报文认证，它只是为TCP连接设置MD5认证密码，由TCP完成认证。如果认证失败，则不建立TCP连接。</li>
<li>GTSM（Generalized TTL Security Mechanism）：GTSM通过检测IP报文头中的TTL值是否在一个预先定义好的特定范围内，对IP层以上业务进行保护，增强系统的安全性。使能BGP的GTSM策略后，接口板对所有BGP报文的TTL值进行检查。根据实际组网的需要，对于不符合TTL值范围的报文，GTSM可以设置为通过或丢弃。配置GTSM缺省动作为丢弃时，可以根据网络拓扑选择合适的TTL有限值范围，不符合TTL值范围的报文会被接口板直接丢弃，这样就避免了网络攻击者模拟的“合法”BGP报文占用CPU。该功能与EBGP多跳互斥。</li>
<li>限制从对等体接收的路由数量，防止资源耗尽性攻击。</li>
</ul>
</li>
<li><p>AS_Path长度保护。通过在入口和出口两个方向对AS_Path的长度进行限定，直接丢弃AS_Path超限的报文。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/25.png"></p>
<blockquote>
<ul>
<li>路由衰减（Route Dampening）用来解决路由不稳定的问题。多数情况下，BGP协议都应用于复杂的网络环境中，路由变化十分频繁。为了防止持续的路由振荡带来的不利影响，BGP使用路由衰减来抑制不稳定的路由。</li>
<li>BGP衰减使用惩罚值（Penalty Value）来衡量一条路由的稳定性，惩罚值越高则说明路由越不稳定。路由每发生一次振荡（路由从激活状态变为未激活状态，称为一次路由振荡），BGP便会给此路由增加一定的惩罚值（1000）。当惩罚值超过抑制阈值（Suppress Value）时，此路由被抑制，不加入到路由表中，也不再向其他BGP对等体发布更新报文。</li>
<li>当某条路由的惩罚值到达最大抑制值（Maximum Suppress Value）,便不会再增加，这样就可以确保某路由在非常短的时间内翻动十几次之后，不会将惩罚值累加到一个很高的、使路由始终保持被抑制状态的值。</li>
<li>被抑制的路由每经过一段时间，惩罚值便会减少一半，这个时间称为半衰期（Half-life）。当惩罚值降到再使用阈值（Reuse Value）时，此路由变为可用并被加入到路由表中，同时向其他BGP对等体发布更新报文。上文提到的惩罚值、抑制阈值和半衰期都可以手动配置。</li>
<li>路由衰减只适用于EBGP路由。对于从IBGP收来的路由不能进行衰减，因为IBGP路由经常含有本AS的路由，内部网络路由要求转发表尽可能一致，IGP快速收敛就是为了达到信息同步，转发一致。如果衰减对IBGP路由起作用，不同设备的衰减参数不一致时，会导致转发表不一致。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/26.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/27.png"></p>
<blockquote>
<ul>
<li>RFC5291、RFC5292规定了BGP基于前缀的ORF能力，能将本端设备配置的基于前缀的入口策略通过路由刷新报文发送给BGP邻居。BGP邻居根据这些策略构造出口策略，在路由发送时对路由条目进行过滤。这样不仅避免了本端设备接收大量无用的路由，降低了本端设备的CPU使用率，还有效减少了BGP邻居的配置工作，降低了链路带宽的占用率。</li>
<li>拓扑描述<ul>
<li>直连EBGP邻居中，Client1、R1协商基于前缀的ORF 能力后，Client1将本地配置的基于前缀的入口策略打包到Route-refresh报文中发送给R1。R1根据接收到的路由刷新报文构造出口策略，通过Route-refresh报文发送路由给Client1。Client1只收到它需要的路由，而R1不必维护路由策略，减少了配置工作。</li>
<li>Client1、Client2为RR的客户端，Client1与RR、Client2与RR，分别协商基于前缀的ORF 能力，Client1、Client2将本地配置的基于前缀的入口策略打包到Route-refresh 报文中发送给RR。RR 根据接收到的前缀信息构造出口策略，通过Route-refresh 报文将路由反射给Client1、Client2。Client1和Client2只收到需要的路由，RR不必维护路由策略，减少了配置工作。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/28.png"></p>
<blockquote>
<ul>
<li>Active-Route-Advertise<ul>
<li>默认情况下路由只需在BGP中优选即可向邻居发布。配置了此特性之后，路由必须同时满足在BGP协议层面优选与在路由管理层面活跃两个条件，才能向邻居发布。</li>
<li>与命令bgp-rib-only（用来禁止BGP路由下发到IP路由表）互斥。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/29.png"></p>
<blockquote>
<ul>
<li><p>4字节AS号定义的角色</p>
<ul>
<li>New Speaker：支持4字节AS号扩展能力的对等体。</li>
<li>Old Speaker：不支持4字节AS号扩展能力的对等体。</li>
<li>New Session：New Speaker之间建立的BGP连接。</li>
<li>Old Session：New Speaker和Old Speaker之间或者Old Speaker之间建立的BGP连接。</li>
</ul>
</li>
<li><p>协议扩展</p>
<ul>
<li>定义了2种新的可选过渡属性AS4_Path（属性码为0x11）和AS4_Aggregator属性（属性码为0x12）用于在Old Session上传递4字节AS信息。</li>
<li>如果New Speaker和Old Speaker建立连接，定义AS_TRANS（保留值为23456）用于衔接2字节AS和4字节AS。</li>
<li>新的AS号有三种写法：<ul>
<li>splain：就是一个十进制的数字</li>
<li>asdot+:写成（2字节）.（2字节）的形式，所以旧的2字节ASN123可以写成0.123，ASN65536是1.0；最大为65535.65535；</li>
<li>asdot：旧的2字节写法照旧，新的4字节写成asdot+的形式；（1－65535；1.0－65535.65535）</li>
<li>华为支持asdot写法。</li>
</ul>
</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>R2收到R1的一条四字节AS的路由,AS号码为10.1；</li>
<li>R2与R3建立邻居，需要令R3认为R2的AS号为AS_TRANS；</li>
<li>R2发送路由给R3的时候把AS_TRANS记录在AS_Path里面，把10.1与自己的AS号码20.1按照BGP要求的顺序记录在AS4_Path；</li>
<li>R3对于不识别的属性AS4_Path不作处理依然保留，它只按照BGP的规则来发送路由给RD。当然它认为R4的AS号码也是AS_TRANS；</li>
</ul>
</li>
<li><p>这样当R4收到从R3来的路由会把AS_PATH中的AS_TRANS按照顺序替换为AS4_Path里所记录的相应的地址，在R4上把AS_PATH属性还原为30 20.1 10.1。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/31.png"></p>
<blockquote>
<ul>
<li><p>按策略进行下一跳迭代</p>
<ul>
<li>BGP需要对非直连的下一跳进行路由迭代，但是如果不对迭代到的路由进行过滤的话，可能会迭代到一个错误的转发路径上。按策略进行下一跳迭代就是通过配置路由策略来限制迭代到的路由。如果路由不能通过路由策略，则该路由迭代失败。</li>
</ul>
</li>
<li><p>拓扑描述</p>
<ul>
<li>R1和R2、R3之间通过Loopback口建立IBGP邻居。R1从R2、R3分别收到了前缀为10.0.0.0/24的BGP路由。其中从R2收到的BGP路由的原始下一跳为2.2.2.2。另外，R1上Ethernet0/0/0的接口地址为2.2.2.100/24。</li>
<li>当R2正常运行时，R1收到从R2发来的前缀为10.0.0.0/24的路由会迭代到IGP路由2.2.2.2/32。但是当R2的IGP发生故障时，IGP路由2.2.2.2/32被撤销，这样就导致下一跳重新迭代。在R1上会用原始下一跳2.2.2.2在IP路由表中进行最长匹配迭代，结果会迭代到2.2.2.0/24的路由上。但此时用户期望的是，当到2.2.2.2的路由不可达时，可以重新选路优选到3.3.3.3的路由。实际上该故障主要是由于BGP收敛引起的，从而产生了路由的瞬时黑洞。</li>
<li>配置下一跳迭代策略，可以通过到BGP路由原始下一跳所依赖路由的掩码长度来过滤迭代路由。可以通过配置下一跳迭代策略，使到原始下一跳2.2.2.2只能依赖于2.2.2.2/32的IGP路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/32.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/33.png"></p>
<blockquote>
<ul>
<li><p>常见的企业网络拓扑类型</p>
<ul>
<li>单归属自治系统（一个出口设备且连接到一个ISP）</li>
<li>多归属到单自治系统（多个出口设备仅连接到一个ISP）</li>
<li>多归属到多自治系统（多个出口设备且连接到多个ISP）</li>
</ul>
</li>
<li><p>单归属自治系统：仅有一个出口设备且只连接到一个ISP。</p>
<ul>
<li>这种情况下，就可以不需要配置BGP协议。可在用户边界设备上添加一条默认路由，并宣告到用户自治系统内部。</li>
</ul>
</li>
<li><p>多归属到单自治系统：增加了对链路和网络设备的冗余性，一般这种情况下用户网络用的会是私有AS号。</p>
<ul>
<li>若两条链路采用主备的方式，那么也不需要采用BGP。两台出口设备分别向本自治系统内的设备宣告metric值不同的默认路由即可。（若采用OSPF为IGP，外部路由的cost应该采用E2方式，仅考虑外部开销（cost））</li>
<li>若两台路由器采用负载分担方式：<ul>
<li>方式一：两台路由器分别向自治系统内（IGP采用OSPF）宣告cost type为E1的默认路由，使得自治系统其他路由器选择距离自己最近的出口路由器到达外部网络。这种情况也可以不使用BGP。但是当两个出口路由器的物理间隔十分大，并且对时延有很高要求时，就可以考虑采取BGP来获取更精细的路由条目。</li>
<li>方式二：与ISP设备之间建立BGP连接，从BGP接收更为精细的路由条目，配合上路由策略工具的使用，来达到针对不同目的地址使用不同出口路由的目的。</li>
</ul>
</li>
</ul>
</li>
<li><p>多归属到多自治系统：不仅增加了对链路和网络设备的冗余性，同时使用了做到了ISP的冗余备份。</p>
<ul>
<li>对于这种自治系统，需要充分考虑到地址空间是否独立于运营商，是否拥有公有AS号等问题。</li>
<li>理想情况下，当用户网络拥有独立于ISP的地址空间和公有AS号时，有三种部署方式<ul>
<li>方式一：采取主备方式，出口路由器向内部宣告开销不一样的默认路由。</li>
<li>方式二：负载分担方式，出口路由器向内部宣告默认路由，仅使用IGP的开销计算机制，由IGP自行决定使用哪一台出口路由器。</li>
<li>方式三：部署BGP。考虑与ISP签署的合约，企业本身的业务流量特点等因素，使用各种路由策略工具，如有必要也可以使用默认路由宣告等方式。充分控制企业进和出方向的流量。</li>
</ul>
</li>
<li>一般情况下，多归属到多自治系统的网络会考虑部署BGP协议，因为前两种方法不利于路由的控制。但是不是绝对的，需要仔细权衡所得到的好处与增加路由复杂度所带来的代价。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/35.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/36.png"></p>
<blockquote>
<ul>
<li><p>BGP路由劫持</p>
<ul>
<li>产生原因：BGP协议里虽然有一些简单的安全认证的部分，但是对于两个已经成功建立BGP连接的AS来说，基本会无条件的相信对方AS所传来的信息，包括对方声称所拥有的IP地址范围。</li>
<li>潜在危害：若无条件相信对方发送过来的Update消息，不排除恶意的AS宣告不存在的IP网段，通过修改AS_Path等BGP属性，让其他AS认为这条路径才是到达这个目的网段的最短路径，那么该恶意的AS就能截获到数据流量。</li>
</ul>
</li>
<li><p>不对称路由</p>
<ul>
<li>产生原因：不恰当的属性使用或者是路由聚合不合理导致路由精准性不足，导致流量的出方向和入方向不同。</li>
<li>潜在危害：首先，不对称流量会使互联网络的流量模型变得难以预测，使得网络基准、容量规划、故障检测及排除变得困难；其次，不对称流量会使链路使用率出现不均衡，某些链路的带宽出现饱和，而其他链路的带宽却得不到有效利用；再次，不对称流量会使出流量和入流量的时延出现很大的差异，这种时延变化（即抖动）会对某些时延敏感型应用（如语音和直播视频）造成损害。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/37.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/38.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/39.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/40.png"></p>
<blockquote>
<ul>
<li><p>非BGP路由和BGP路由之间的交互</p>
<ul>
<li>一般情况下，IGP与BGP会有路由的引入。应采用合理的过滤策略，使合适的路由在IGP与BGP之间互相引入。</li>
</ul>
</li>
<li><p>默认路由的控制</p>
<ul>
<li>对于默认路由的发放，可以通过策略使默认路由根据某些具体条件来下发默认路由。</li>
</ul>
</li>
<li><p>策略路由</p>
<ul>
<li>通过策略路由来优化流量路径。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/41.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/42.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/43.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/44.png"></p>
<blockquote>
<ul>
<li><p>案例描述</p>
<ul>
<li>本案例中设备互联地址规则如下：<ul>
<li>如RX与RY互联，则互联地址为XY.1.1.X与XY.1.1.Y，掩码长度为24位。</li>
</ul>
</li>
<li>OSPF和OSPFv3已经运行正常，且设备互联地址和环回口地址已经宣告进了OSPF或OSPFv3。</li>
</ul>
</li>
<li><p>案例分析</p>
<ul>
<li>EBGP邻居之间使用环回口建立邻居关系。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/45.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>peer as-number命令用来配置指定对等体（组）的对端AS号。</li>
<li>peer connect-interface命令用来指定发送BGP报文的源接口，并可指定发起连接时使用的源地址。</li>
<li>peer next-hop-local命令用来设置向IBGP对等体（组）通告路由时，把下一跳属性设为自身的IP地址。</li>
<li>group命令可以用来创建对等体组。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>上述命令均为BGP进程视图下的命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address as-number as-number</li>
<li>ip-address：对等体的IPv4地址。</li>
<li>as-number：对等体的对端AS号。</li>
<li>peer ipv4-address connect-interface interface-type interface-number [ ipv4-source-address ]</li>
<li>ip-address：对等体的IPv4地址。</li>
<li>interface-type interface-number：接口类型和接口号。</li>
<li>ipv4-source-address：建立连接时的IPv4源地址。</li>
<li>peer ipv4-address next-hop-local</li>
<li>ip-address：对等体的IPv4地址。</li>
<li>group group-name [ external | internal ]<ul>
<li>group-name:对等体组的名称。</li>
<li>external:创建EBGP对等体组。</li>
<li>internal:创建IBGP对等体组。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在使用Loopback接口作为BGP报文的源接口时，必须注意以下事项：</li>
<li>确认BGP对等体的Loopback接口的地址是可达的。</li>
<li>如果是EBGP连接，还要配置peer ebgp-max-hop命令，允许EBGP通过非直连方式建立邻居关系。</li>
<li>peer next-hop-local和peer next-hop-invariable是两条互斥命令。</li>
<li>Display bgp peer中的Rec表示本端从对等体上收到路由前缀的数目。</li>
<li>IPv6的配置与IPv4配置一致。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/47.png"></p>
<blockquote>
<ul>
<li>案例描述<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
<li>需求2中，要求缺省路由的下发需要关联路由172.16.0.0/16，如果172.16.0.0/16消失，该缺省路由也消失。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/48.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>peer route-policy命令用来对来自对等体（组）的路由或向对等体（组）发布的路由指定Route-Policy，对接收或发布的路由进行控制。</li>
<li>peer default-route-advertise命令用来设置给对等体（组）发布缺省路由。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>peer route-policy命令为BGP视图命令</li>
<li>peer default-route-advertise命令BGP视图命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address route-policy route-policy-name { import | export }<ul>
<li>ipv4-address：对等体的IPv4地址。</li>
<li>route-policy-name：Route-Policy的名称。</li>
<li>import：对从对等体（组）来的路由应用Route-Policy。</li>
<li>export：对向对等体（组）发布的路由应用Route-Policy。</li>
</ul>
</li>
<li>peer { group-name | ipv4-address } default-route-advertise [ route-policy route-policy-name ] [ conditional-route-match-all{ ipv4-address1 { mask1 | mask-length1 } } &amp;&lt;1-4&gt; | conditional-route-match-any { ipv4-address2 { mask2 | mask-length2 } } &amp;&lt;1-4&gt; ]<ul>
<li>ipv4-address：对等体的IPv4地址。</li>
<li>route-policy route-policy-name：指定Route-Policy名称。</li>
<li>conditional-route-match-all ipv4-address1{ mask1 | mask-length1 }：指定条件路由的IPv4地址，以及掩码/掩码长度。匹配所有条件路由则发送缺省路由。</li>
<li>conditional-route-match-any ipv4-address2{ mask2 | mask-length2 }：指定条件路由的IPv4地址，以及掩码/掩码长度。匹配任一条件路由则发送缺省路由。</li>
</ul>
</li>
</ul>
</li>
<li><p>实验现象</p>
<ul>
<li>我们通过命令display ip routing-table命令用来显示路由表中包含的信息。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/50.png"></p>
<blockquote>
<ul>
<li>案例描述<ul>
<li>本案例中的需求是对之前案例的扩展，在原案例的基础上进行配置。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/51.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li>aggregate命令用来在BGP路由表中创建一条聚合路由。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>命令aggregate为BGP视图命令。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>aggregate ipv4-address { mask | mask-length } [ as-set | attribute-policy route-policy-name1 | detail-suppressed | origin-policy route-policy-name2 | suppress-policyroute-policy-name3 ] *<ul>
<li>ipv4-address：指定聚合路由的IPv4地址。</li>
<li> mask：仅IBGP路由参与负载a分担。</li>
<li>mask-length：指定聚合路由的网络掩码长度。</li>
<li>as-set：指定生成具有AS-SET的路由。</li>
<li>attribute-policy route-policy-name1：指定聚合后路由的属性策略名称。</li>
<li>detail-suppressed：指定仅通告聚合路由。</li>
<li>origin-policy route-policy-name2：指定允许生成聚合路由的策略名称。</li>
<li>suppress-policy route-policy-name3：指定抑制指定路由通告的策略名称。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>手工聚合和自动聚合本地均会产生指向NULL0的路由。</li>
<li>IPv6的配置与IPv4配置一致。</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>命令display ip routing-table protocol bgp可以查看BGP学到的路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/52.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/53.png"></p>
<blockquote>
<ul>
<li><p>路由器Rx和Ry（X&lt;Y）之间的接口网段为10.0.xy.0/24网段，Rx地址=10.0.xy.x  Ry地址=10.0.xy.y 。</p>
</li>
<li><p>所有接口地址均已经配置完成。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/54.png"></p>
<blockquote>
<ul>
<li>使用命令display bgp peer 可以查看是否已经建立BGP邻居关系。</li>
<li>使用命令display bgp routing-table 可以查看是否已经获取到路由信息。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/55.png"></p>
<blockquote>
<ul>
<li>路由器Rx和Ry（X&lt;Y）之间的接口网段为10.0.xy.0/24网段，Rx地址=10.0.xy.x  Ry地址=10.0.xy.y 。</li>
<li>所有接口地址均已经配置完成。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/56.png"></p>
<blockquote>
<ul>
<li>可以看到，因为AS_Set中包含本自治系统的AS号，所以导致无法接受这条聚合后的路由，可以考虑关闭明细抑制或取消AS_Set。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/57.png"></p>
<blockquote>
<ul>
<li>案例总结：<ul>
<li>配置路由聚合时需要谨慎，聚合配置不当会出现以下问题：<ul>
<li>无法学习到正确的路由；</li>
<li>可能导致环路的产生。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/58.png"></p>
<blockquote>
<ul>
<li>路由器Rx和Ry（X&lt;Y）之间的接口网段为10.0.xy.0/24网段，Rx地址=10.0.xy.x  Ry地址=10.0.xy.y 。</li>
<li>所有接口地址均已经配置完成。</li>
<li>R5是R3的client ， R6是R4的client 。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/59.png"></p>
<blockquote>
<ul>
<li>配置完成之后所有BGP邻居关系建立正常，且OSPF学习到的路由也都完整</li>
<li>R2与R1配置类似，R3与R4配置类似，R5与R6配置类似。</li>
<li>建立完成之后R1通告直连的192.168.1.0/24进入BGP，R7通告直连的192.168.2.0/24进入BGP。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/60.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/61.png"></p>
<blockquote>
<ul>
<li>配置完成之后所有BGP邻居关系建立正常，且OSPF学习到的路由也都完整。</li>
<li>R2与R1配置类似，R3与R4配置类似，R5与R6配置类似。</li>
<li>建立完成之后各路由器通告自己的loopback 0口的地址</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/62.png"></p>
<blockquote>
<ul>
<li>故障分析：<ul>
<li>R7向R5和R6发送192.168.2.0/24前缀。</li>
<li>R5,R6收到，分别向自己的IBGP邻居R3,R4发送。</li>
<li>这里分析R4的情况。R4收到后会有一个路径决策过程，这里R3也会向它发送192.168.2.0/24的前缀，根据BGP路径决策的13个原则，R4最总选择IGP度量值最小的，即选择R6作为下一跳。然后它将这个最佳路径发往R3和R1。</li>
<li>同理，R3最终选择的下一跳是R5。</li>
<li>关键在于R1和R2。因为R1只能收到R4发来的更新，所以，它去往192.168.2.0/24的下一跳也是R4；同理R2去往192.168.2.0/24的下一跳是R5。</li>
<li>经过IGP路由的递归查询，从192.168.1.1到192.168.2.1的数据包会在R1和R2之间来回转发，直到IP报文的TTL被减至0 。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/63.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/64.png"></p>
<blockquote>
<ul>
<li><p>参考答案：</p>
<p>1.A</p>
<p>2.路由聚合分为自动聚合和手工聚合</p>
<ul>
<li>自动聚合：只能聚合通过import命令引入的路由，只能按照自然掩码进行聚合，IPv6不支持自动聚合。</li>
<li>手工聚合：IPv4与IPv6路由均能聚合，可设置明细路由抑制，添加AS_set等功能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/65.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/66.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Advance/67.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/" itemprop="url">IE-BGP双栈原理Basic</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-09T15:29:54+08:00">
                2021-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/1.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/2.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/3.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/4.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/5.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/6.png"></p>
<blockquote>
<ul>
<li><p>BGP是一种用于自治系统（Autonomous System）之间的动态路由协议。早期发布的三个版本分别是BGP-1（RFC1105）、BGP-2（RFC1163）和BGP-3（RFC1267），主要用于交换AS之间的可达路由信息，构建AS域间的传播路径，防止路由环路的产生，并在AS级别应用一些路由策略。当前使用的版本是BGP-4（RFC4271）。</p>
</li>
<li><p>BGP作为事实上的Internet外部路由协议标准，被广泛应用于ISP之间。</p>
</li>
<li><p>BGP概述</p>
<ul>
<li>BGP是一种外部网关协议（EGP），与OSPF、RIP等内部网关协议（IGP）不同，其着眼点不在于自动发现网络拓扑，而在于在AS之间选择最佳路由和控制路由的传播。</li>
<li>BGP使用TCP作为其传输层协议（监听端口号为179），提高了协议的可靠性，且不需要专门的机制来确保连接的可控性。</li>
<li>BGP进行域间的路由选择，对协议的稳定性要求非常高。因此用TCP协议的高可靠性来保证BGP协议的稳定性。<ul>
<li>BGP的对等体之间必须在逻辑上连通，并进行TCP连接。目的端口号为179，本地端口号任意。</li>
<li>路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息。</li>
</ul>
</li>
<li>BGP从设计上避免了环路的发生。</li>
<li>AS之间：BGP通过携带AS路径信息来标记途经的AS，带有本地AS号的路由将被丢弃，从而避免了域间产生环路。</li>
<li>AS内部：BGP在AS内学到的路由不再通告给AS内的BGP邻居，避免了AS内产生环路。<ul>
<li>BGP提供了丰富的路由策略，能够对路由实现灵活的过滤和选择。</li>
<li>BGP提供了防止路由振荡的机制，有效提高了Internet网络的稳定性。</li>
<li>BGP易于扩展，能够适应网络新的发展。主要是通过TLV进行扩展。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/7.png"></p>
<blockquote>
<ul>
<li>BGP的运行是通过消息驱动的，共有Open、Update、Notification、Keepalive和Route-Refresh等5种消息类型。<ul>
<li>Open消息：是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系。对等体在接收到Open消息并协商成功后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-Refresh消息的交换。</li>
<li>Update消息：用于在对等体之间交换路由信息。一条Update消息可以发布多条属性相同的可达路由信息，也可以撤销多条不可达路由信息。<ul>
<li>一条Update消息可以发布多条具有相同路由属性的可达路由，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI（Network Layer Reachability Information）字段里的所有目的地（用IP前缀表示）。</li>
<li>一条Update消息可以撤销多条不可达路由。每一个路由通过目的地（用IP前缀表示），清楚的定义了BGP Speaker之间先前通告过的路由。</li>
<li>一条Update消息可以只用于撤销路由，这样就不需要包括路径属性或者NLRI。相反，也可以只用于通告可达路由，就不需要携带撤销路由信息了。</li>
</ul>
</li>
<li>Keepalive消息：BGP会周期性的向对等体发出Keepalive消息，用来保持连接的有效性。</li>
<li>Notification消息：当BGP检测到错误状态时，就向对等体发出Notification消息，之后BGP连接会立即中断。</li>
<li>Route-Refresh消息：通过OPEN消息告知BGP peer本地支持路由刷新能力（Route-Refresh capability）。在所有BGP路由器使能Route-Refresh能力的情况下，如果BGP的入口路由策略发生了变化，本地BGP路由器会向对等体发布Route-Refresh消息，收到此消息的对等体会将其路由信息重新发给本地BGP路由器。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。</li>
</ul>
</li>
</ul>
<ul>
<li>BGP报文应用：<ul>
<li>BGP使用TCP建立连接，本地监听端口为179。和TCP连接建立相同，BGP连接的建立也要经过一系列的对话和握手。TCP通过握手协商通告其端口等参数，BGP的握手协商的参数有：BGP版本、BGP连接保持时间、本地的路由器标识（Router ID）、授权信息等。这些信息都在Open消息中携带。</li>
<li>BGP连接建立后，如果有路由需要发送则发送Update消息通告对端。Update消息发布路由时，还要携带此路由的路由属性，用以帮助对端BGP协议选择最优路由。在本地BGP路由变化时，要通过Update消息来通知BGP对等体。</li>
<li>经过一段时间的路由信息交换后，本地BGP和对端BGP都无新路由通告，趋于稳定状态。此时要定时发送KEEPALIVE消息以保持BGP连接的有效性。对于本地BGP，如果在保持时间内，未收到任何对端发来的BGP消息，就认为此BGP连接已经中断，将断开此BGP连接，并删除所有从该对等体学来的BGP路由。</li>
<li>当本地BGP在运行中发现错误时（如对端BGP版本本地不支持、本地BGP收到了结构非法的Update消息等），要发送Notification消息通告BGP对等体。本地BGP退出BGP连接时，也需发送Notification报文。</li>
</ul>
</li>
</ul>
<ul>
<li>BGP报头<ul>
<li>Marker（标记）：16字节，固定为1。</li>
<li>Length（长度）：两字节无符号整数。指定了消息的全长，包括头部。</li>
<li>Type（类型）：1 字节，指示报文类型：<ul>
<li>Open</li>
<li>Update</li>
<li>Keepalive</li>
<li>Notification</li>
<li>Route-Refresh</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Open报文结构<ul>
<li>Version：BGP的版本号。对于BGPv4来说，其值为4。</li>
<li>My Autonomous System：本地AS编号。通过比较两端的AS编号可以确定是EBGP连接还是IBGP连接。</li>
<li>Hold Time：在建立对等体关系时两端要协商Hold time，并保持一致。如果两端所配置的Hold time时间不同，则BGP会选择较小的值作为协商的结果。如果在这个时间内未收到对端发来的Keepalive消息，则认为BGP连接中断。如果保持时间为0，则标识不发送Keepalive报文。</li>
<li>BGP Identifier：BGP路由器的Router ID，以IP地址的形式表示，用来识别BGP路由器。</li>
<li>Opt Parm Len（Optional Parameters Length）：可选参数的长度。如果为0则没有可选参数。</li>
<li>Optional Parameters：是一个可选参数用于BGP验证或多协议扩展（Multiprotocol Extensions）等功能。每一个参数为一个（Parameter Type-Parameter Length-Parameter Value）三元组。</li>
</ul>
</li>
</ul>
<ul>
<li>Update报文结构<ul>
<li>Withdrawn Routes Length ：（2字节无符号整数） 不可达路由长度，表示Withdrawn Routes字段的数据长度。如果Withdrawn Routes Length字段数值为0，则表示Withdrawn Routes字段没有任何数据，在UPDATE消息中不会被显示。</li>
<li>Withdrawn Routes ：（变长） 撤销路由。该字段包括一系列的IP地址前缀信息，以&lt;length, prefix&gt;的格式来表示，比如&lt;19,198.18.160.0&gt;表示一个198.18.160.0 255.255.224.0的网络。 </li>
<li>Path Attribute Length ：（2字节无符号整数） 路由属性长度，表示Path Attribute字段的数据长度。如果Path Attribute Length数值为0，则表示Path Attribute字段没有任何数据，在UPDATE消息中不会被显示。</li>
<li>Network Layer Reachability Information ：（变长） 网络可达信息。包括一系列的IP地址前缀。格式与撤消路由字段一样&lt;length, prefix&gt;。</li>
</ul>
</li>
</ul>
<ul>
<li>Keepalive报文结构<ul>
<li>KeepAlive 报文的组成只包括一个BGP数据报头。</li>
<li>缺省情况下，发送KeepAlive 的时间间隔为 60 秒，Hold Time是180秒。每次从邻居处接收到KeepAlive 报文将重置Hold Time定时器，如果Hold Time定时器超时，就认为对等体Down掉。</li>
</ul>
</li>
</ul>
<ul>
<li>Notification报文结构<ul>
<li>Errorcode：错误码。1字节长的字段。每个不同的错误都使用唯一的代码表示，而每一个错误码都可以拥有一个或多个错误子码，但如果某些错误码并不存在错误子码的话，则该错误子码字段以全0表示。</li>
<li>Errsubcode：错误子码。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/8.png"></p>
<blockquote>
<ul>
<li>BGP有限状态机共有六种状态，分别是Idle、Connect、Active、OpenSent、OpenConfirm和Established。<ul>
<li>Idle状态是BGP初始状态。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态。<ul>
<li>Start事件是由一个操作者配置一个BGP过程，或者重置一个已经存在的过程或者路由器软件重置BGP过程引起的。</li>
<li>任何状态中收到Notification报文或TCP拆除链路通知等Error事件后，BGP都会转至Idle状态。</li>
</ul>
</li>
<li>在Connect状态下，BGP启动连接重传定时器（Connect Retry，缺省为32秒），等待TCP完成连接。<ul>
<li>此阶段主动发起TCP连接；</li>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态；</li>
<li>如果TCP连接失败，那么BGP转至Active状态；</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态。</li>
<li>如果发生其他事件（由系统或者操作人员启动的），则退回到Idle状态。</li>
</ul>
</li>
<li>在Active状态下，BGP总是在试图建立TCP连接。<ul>
<li>此阶段等待对方发起TCP连接；</li>
<li>如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态；</li>
<li>如果TCP连接失败，那么BGP停留在Active状态；</li>
<li>如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。</li>
</ul>
</li>
<li>在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。<ul>
<li>如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态；</li>
<li>如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。</li>
</ul>
</li>
<li>在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。</li>
<li>在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。<ul>
<li>如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。</li>
<li>如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。</li>
<li>Route-refresh报文不会改变BGP状态。</li>
<li>如果收到Notification报文，那么BGP转至Idle状态。</li>
<li>如果收到TCP连接断开消息，那么BGP断开连接，转至Idle状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/9.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/10.png"></p>
<blockquote>
<ul>
<li>BGP路由信息处理：<ul>
<li>当从对等体接收到更新数据包时，路由器会把这些更新数据包存储到路由选择信息库(Routing Information Base, RIB)中，并指明是来自哪个对等体的(Adj-RIB-In)。这些更新数据包被输入策略引擎过滤后，路由器将会执行路径选择算法，来为每一条前缀确定最佳路径。</li>
<li>得出的最佳路径被存储到本地BGP RIB (Loc-RIB)中，然后被提交给本地IP路由选择表(IP-RIB)，以用作安装考虑。</li>
<li>除了从对等体接收来的最佳路径外，Loc-RIB也会包含当前路由器注入的(被称为本地发起的路由)，并被选择为最佳路径的BGP前缀。Loc-RIB中的内容在被通告给其他对等体之前，必须通过输出策略引擎。只有那些成功通过输出策略引擎的路由，才会被安装到输出RIB (Adj-RIB-Out)中。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/11.png"></p>
<blockquote>
<ul>
<li>BGP设备将最优路由加入BGP路由表，形成BGP路由。<ul>
<li>从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体</li>
<li>从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP和IBGP对等体</li>
<li>当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体</li>
<li>路由更新时，BGP设备只发送更新的BGP路由</li>
<li>从IBGP邻居学到的路由，只有当IGP中也存在相同的路由时才会宣告给EBGP对等体</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/12.png"></p>
<blockquote>
<ul>
<li>同步是指IBGP和IGP之间的同步，其目的是避免误导外部AS的路由器。</li>
</ul>
<ul>
<li><p>拓扑说明（在同步开启情况下）</p>
<ul>
<li>R4通过BGP学习到R1宣告的10.0.0.0/24网络。R4在将该网络通告给R5之前，会首先检查自己的IGP路由表是否已经存在10.0.0.0/24网络。如果R4本地IGP路由表项存在10.0.0.0/24网络，则将该网络通告给R5；如果R4本地IGP路由表项不存在10.0.0.0/24网络，则不能将该网络通告给R5。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>VRP平台缺省情况下BGP与IGP是取消同步机制的，并不可改变。但取消同步是有条件的，在以下两种情况下可以取消同步：</li>
<li>本AS不是过渡AS。</li>
<li>本AS内所有路由器建立IBGP全连接。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/13.png"></p>
<blockquote>
<ul>
<li><p>BGP路由属性是一套参数，它对特定的路由进一步的描述，使得BGP能够对路由进行过滤和选择。</p>
</li>
<li><p>常用的属性类别如下所示：</p>
<ul>
<li>Origin为公认必遵属性</li>
<li>AS_Path为公认必遵属性</li>
<li>Next_Hop为公认必遵属性</li>
<li>Local_Pref为公认任意属性</li>
<li>community为可选过渡属性</li>
<li>MED为可选非过渡属性</li>
<li>Originator_ID为可选非过渡属性</li>
<li>Cluster_List为可选非过渡属性</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/14.png"></p>
<blockquote>
<ul>
<li>Origin属性用来定义路径信息的来源，标记一条路由是怎么成为BGP路由的。它有以下3种类型：<ul>
<li>IGP：具有最高的优先级。通过路由始发AS的IGP得到的路由信息，比如通过network命令注入到BGP路由表的路由，其Origin属性为IGP。</li>
<li>EGP：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP。</li>
<li>Incomplete：优先级最低。通过其他方式学习到的路由信息。比如BGP通过import-route命令引入的路由，其Origin属性为Incomplete。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/15.png"></p>
<blockquote>
<ul>
<li>在BGP进行选路时会优先比较协议首选值。默认情况下均为0，该值越大越优先。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/16.png"></p>
<blockquote>
<ul>
<li><p>AS_Path属性可以当做BGP选路的参考属性之一，AS_Path长度越短越优先。此外，当BGP路由器从EBGP对等体接收路由时，如果发现AS_Path列表中有本AS号，则不接收该路由，从而避免了AS间的路由环路。</p>
<ul>
<li>当BGP Speaker本地通告一条路由时：<ul>
<li>当BGP Speaker将这条路由通告到其他AS时，便会将本地AS号添加在AS_Path列表中，并通过Update消息通告给邻居路由器。</li>
<li>当BGP Speaker将这条路由通告到本地AS时，便会在Update消息中创建一个空的AS_Path列表。</li>
</ul>
</li>
<li>当BGP Speaker传播从其他BGP Speaker的Update消息中学习到的路由时：<ul>
<li>当BGP Speaker将这条路由通告到其他AS时，便会把本地AS编号添加在AS_Path列表的最前面（最左面）。收到此路由的BGP路由器根据AS_Path属性就可以知道去目的地址所要经过的AS。离本地AS最近的相邻AS号排在前面，其他AS号按顺序依次排列。</li>
<li>当BGP Speaker将这条路由通告到本地AS时，不会改变这条路由相关的AS_Path属性。</li>
</ul>
</li>
</ul>
</li>
<li><p>拓扑描述：</p>
<ul>
<li>当R4将网段10.0.0.0/24通告给AS400和AS100时，会在AS_PATH中添加自己的AS号。当R5将网段10.0.0.0/24通告给AS100时，也会添加添加自己的AS号。当AS100内的R1、R3和R2之间将网段10.0.0.0/24相互通告时，AS_PATH属性不会改变，在其他BGP选路条件相同的前提下，BGP会选择AS_PATH路径最短的，即选择通过R3直达R4的路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/17.png"></p>
<blockquote>
<ul>
<li>Next_Hop属性记录了路由的下一跳信息。BGP的下一跳属性和IGP的有所不同，不一定就是邻居设备的IP地址。通常情况下，Next_Hop属性遵循下面的规则：<ul>
<li>BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。</li>
<li>BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/18.png"></p>
<blockquote>
<ul>
<li>Local_Pref属性<ul>
<li>该属性仅在IBGP对等体之间有效，不通告给其他AS。它表明路由器的BGP优先级。</li>
<li>当BGP路由器通过不同的IBGP对等体得到目的地址相同但下一跳不同的多条路由时，将优先选择Local_Pref属性值较高的路由，缺省情况下该值为100。</li>
</ul>
</li>
</ul>
<ul>
<li>拓扑描述<ul>
<li>AS100内，R1，R2和R3之间分别两两建立IBGP对等体关系，而R2和R3分别和位于AS200和AS300的路由器建立EBGP对等体关系。这样路由器R2和R3都会从自己的EBGP对等体收到10.0.0.0/24这条路由，为了让AS100内的三台路由器优选R2作为10.0.0.0/24这条路由在本AS的出口，我们只需要在R2和R3上适当的对该路由的Local Pref属性进行修改，就可以达到目的。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/19.png"></p>
<blockquote>
<ul>
<li>当一个运行BGP的设备通过不同的EBGP对等体（EBGP对等体需属于同一AS）得到目的地址相同但下一跳不同的多条路由时，在其它条件相同的情况下，将优先选择MED 值较小者作为最佳路由。</li>
<li>MED属性仅在相邻两个AS之间传递，收到此属性的AS一方不会再将其通告给任何其他第三方AS。MED属性可以手动配置，如果路由没有配置MED属性，BGP选路时将该路由的MED值按缺省值0来处理。</li>
<li>拓扑描述<ul>
<li>R1和R2将网段10.0.0.0/24传递给各自的EBGP邻居R3和R4，R3和R4在其他条件相同的情况下，优先选择MED值较低的路径，即均选择经由R1访问网络10.0.0.0/24。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/20.png"></p>
<blockquote>
<ul>
<li><p>BGP路径选择</p>
</li>
<li><p>下一跳地址必须可达。</p>
</li>
<li><p>协议首选值（PrefVal）是华为设备的特有属性，该属性仅在本地有效。</p>
</li>
<li><p>如果路由没有本地优先级，BGP选路时将该路由按缺省的本地优先级100来处理。通过执行default local-preference命令可以修改BGP路由的缺省本地优先级。</p>
</li>
<li><p>本地生成的路由包括通过network命令或import-route命令引入的路由、手动聚合路由和自动聚合路由。</p>
<ul>
<li>优选聚合路由（聚合路由优先级高于非聚合路由）。</li>
<li>通过aggregate命令生成的手动聚合路由的优先级高于通过summary automatic命令生成的自动聚合路由。</li>
<li>通过network命令引入的路由的优先级高于通过import-route命令引入的路由。</li>
</ul>
</li>
<li><p>优选AS路径（AS_Path）最短的路由。</p>
<ul>
<li>AS_Path的长度不包括AS_CONFED_SEQUENCE和AS_CONFED_SET。</li>
<li>AS_SET的长度为1，无论AS_SET中包括多少AS号。</li>
<li>执行bestroute as-path-ignore命令后，BGP选路时，忽略AS_Path的比较。</li>
</ul>
</li>
<li><p>优选MED值最低的路由。</p>
<ul>
<li>BGP只比较来自同一个AS（不包括联盟的子AS）的路由的MED值。即，只有两条路由的AS_SEQUENCE（不包括AS_CONFED_SEQUENCE）属性的第一个AS号相同时，BGP才会比较二者的MED值。</li>
<li>如果路由没有MED属性，BGP选路时将该路由的MED值按缺省值0来处理；执行bestroute med-none-as-maximum命令后，BGP选路时将该路由的MED值按最大值4294967295来处理。</li>
<li>执行compare-different-as-med命令后，BGP将强制比较来自不同自治系统中的邻居的路由的MED值。除非能够确认不同的自治系统采用了同样的IGP和路由选择方式，否则不要使用compare-different-as-med命令（可能产生环路）。</li>
<li>执行bestroute med-confederation命令后，只有当AS_Path中不包含外部AS号（不属于联盟的子AS），且AS_CONFED_SEQUENCE的第一个AS号相同时，才能比较MED值的大小。</li>
<li>执行deterministic-med命令后，将消除路由接收顺序对选路结果的影响。</li>
</ul>
</li>
<li><p>负载分担</p>
<ul>
<li>当到达同一目的地址存在多条等价路由时，可以通过BGP等价负载分担实现均衡流量的目的。</li>
<li>形成BGP等价负载分担的条件是：BGP选路规则中“到下一跳的IGP metric”这条规则之前所有需要比较的属性完全相同。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/21.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/22.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/23.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/24.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/25.png"></p>
<blockquote>
<ul>
<li><p>除了多地址族的能力协商外，还有</p>
<ul>
<li>4字节AS号能力</li>
<li>Route-Refresh支持能力</li>
<li>多层标签能力</li>
</ul>
<p>等能力都会在该字段列出来进行协商。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/26.png"></p>
<blockquote>
<ul>
<li>地址族信息（Address Family Information）域：由2字节的地址族标识AFI（Address Family Identifier）和1字节的子地址族标识SAFI（Subsequent Address Family Identifier）组成。</li>
<li>下一跳长度（Length of Next Hop Network Address）域：1字节长度，表示下一跳地址的长度，通常情况下为16</li>
<li>下一跳地址（Network Address of Next Hop）域：长度由上一个字段决定，一般情况下为全球单播地址。</li>
<li>保留字段（Reserved）域：一字节，必须为0 </li>
<li>网络层可达信息（Network Layer Reachability Information）域：表示含有匹配相同属性的路由信息。当此字段为0时，表示为缺省路由。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/27.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/28.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/29.png"></p>
<blockquote>
<ul>
<li><p>地址族信息（Address Family Information）域：由2字节的地址族标识AFI（Address Family Identifier）和1字节的子地址族标识SAFI（Subsequent Address Family Identifier）组成。</p>
</li>
<li><p>撤销路由（Withdrawn Routes）域：表示撤销的路由条目。格式为&lt;掩码长度，路由前缀&gt; ，当此掩码长度为0时，表示为缺省路由。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/30.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/31.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/32.png"></p>
<blockquote>
<ul>
<li><p>地址分配规则：</p>
<ul>
<li>Rx和Ry（X&lt;Y）直连接口的IPv4网段为：10.0.xy.0/24. Rx相应接口的地址为10.0.xy.x ，Ry为10.0.xy.y </li>
<li>Rx和Ry（X&lt;Y）直连接口的IPv6网段为：2000::xy00/120. Rx相应接口的地址为2000::xy0x ，Ry为2000::xy0y </li>
<li>各路由器的LoopBack 0 接口的地址已给出,各LoopBack 0接口的IPv6地址为2000::z(z为相应路由器的编号)</li>
</ul>
</li>
<li><p>提示：</p>
<ul>
<li>AS内可运行OSPF，ISIS等协议来实现互通</li>
<li>稳定的IBGP关系可通过loopback接口来建立</li>
<li>EBGP邻居关系直接用物理接口建立即可</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/33.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li>peer as-number命令用来配置指定对等体（组）的对端AS号。</li>
<li>peer connect-interface命令用来指定发送BGP报文的源接口，并可指定发起连接时使用的源地址。</li>
<li>peer next-hop-local命令用来设置向IBGP对等体（组）通告路由时，把下一跳属性设为自身的IP地址。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>上述命令均为BGP进程视图下的命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address as-number as-number<ul>
<li>ip-address：对等体的IPv4地址。</li>
<li>as-number：对等体的对端AS号。</li>
</ul>
</li>
<li>peer ipv4-address connect-interface interface-type interface-number [ ipv4-source-address ]<ul>
<li>ip-address：对等体的IPv4地址。</li>
<li>interface-type interface-number：接口类型和接口号。</li>
<li>ipv4-source-address：建立连接时的IPv4源地址。</li>
</ul>
</li>
<li>peer ipv4-address next-hop-local<ul>
<li>ip-address：对等体的IPv4地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>在使用Loopback接口作为BGP报文的源接口时，必须注意以下事项：<ul>
<li>确认BGP对等体的Loopback接口的地址是可达的。</li>
<li>如果是EBGP连接，还要配置peer ebgp-max-hop命令，允许EBGP通过非直连方式建立邻居关系。</li>
</ul>
</li>
</ul>
</li>
<li><p>peer next-hop-local和peer next-hop-invariable是两条互斥命令。</p>
</li>
<li><p>Display bgp peer中的PrefRcv表示本端从对等体上收到路由前缀的数目。</p>
</li>
<li><p>IPv6的配置与IPv4基本一致，但是在指定完peer地址和as-number之后，需手工进入ipv6-family unicast视图，执行peer peer-ip-address enable 命令来激活。</p>
</li>
<li><p>本页图中的互连接口IPv6地址，掩码位是120。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/34.png"></p>
<blockquote>
<ul>
<li>此拓扑与“基础配置”一致，已建立了BGP邻居关系</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/35.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li><strong>peer route-policy</strong>命令用来对来自对等体（组）的路由或向对等体（组）发布的路由指定Route-Policy，对接收或发布的路由进行控制。</li>
<li><strong>apply preferred-value</strong> preferred-value 命令用来在路由策略中配置改变BGP路由的首选值的动作。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>peer route-policy命令为BGP视图命令</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>peer ipv4-address route-policy route-policy-name { import | export }<ul>
<li>ipv4-address：对等体的IPv4地址。</li>
<li>route-policy-name：Route-Policy的名称。</li>
<li>import：对从对等体（组）来的路由应用Route-Policy。</li>
<li>export：对向对等体（组）发布的路由应用Route-Policy。</li>
<li>preferred-value：指定BGP的首选值。在选择路由时，协议优选首选值最高的BGP路由。整数形式，取值范围0～65535，默认为0</li>
</ul>
</li>
</ul>
</li>
<li><p>实验现象</p>
<ul>
<li>我们使用display bgp routing-table和display bgp ipv6 routing-table命令查看BGP路由表。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>Preferred-value是BGP协议的私有属性，该命令只对BGP路由生效。Preferred-value是BGP选路规则中的weight值，不是RFC规定的标准属性，所以该命令仅在本地生效，在BGP的出口策略中不生效。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/36.png"></p>
<blockquote>
<ul>
<li>沿用BGP“基础配置”拓扑，仅建立了BGP邻居关系。</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/37.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li><strong>apply local-preference</strong> preference  配置路由的本地优先级</li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>Preference 指定的BGP路由的本地优先级，整数形式，取值范围是0～4294967295，默认情况下为100</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>策略生效后，将影响BGP路由选路。</li>
<li>本地优先级仅用于同一个AS域内的选路，不向域外发布这个属性，所以用于配置EBGP邻居的export方向的策略时，apply local-preference命令的设置不生效。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/38.png"></p>
<blockquote>
<ul>
<li>保留上一步local-preference的配置，其他不变。</li>
<li>需要解决上一步出现的来回路径不一致的问题，可通过R2宣告更高MED属性的路由，使得R5选择R3宣告的路由。 </li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/39.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li><strong>apply</strong> <strong>cost</strong> [ <strong>+</strong> | <strong>-</strong> ]  cost命 令用来在路由策略中配置改变路由的开销值的动作。</li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>+：表示增加开销值。</li>
<li>-： 表示减少开销值。</li>
<li>cost ：指定路由的开销值。对路由的选路进行控制，需要将路由的开销设置为固定值时，可以通过调整开销值避免路由环路的产生。</li>
</ul>
</li>
<li><p>注意事项：</p>
</li>
<li><p>在缺省情况下，BGP只比较来自同一AS的路由的MED值。这里的AS不包括联盟的子AS。为了使BGP在联盟内选择最优路由时能够比较MED值，可以配置bestroute med-confederation命令。</p>
</li>
<li><p>配置bestroute med-confederation命令后，只有当AS_Path中不包含外部自治系统（不在联盟内的自治系统）号时才比较MED值的大小。如果AS_Path中包含外部自治系统号，则不进行比较。</p>
<ul>
<li>例如：自治系统65000、65001、65002和65004属于同一联盟。四条到达同一目的地址的待选路由如下所示：<ul>
<li>path1：AS_Path=65000 65004，med=2</li>
<li>path2：AS_Path=65001 65004，med=3</li>
<li>path3：AS_Path=65002 65004，med=4</li>
<li>path4：AS_Path=65003 65004，med=1</li>
</ul>
</li>
</ul>
</li>
<li><p>在配置bestroute med-confederation命令后，因为path1、path2和path3的AS_Path中不包含同一联盟外的自治系统，所以当BGP需要通过比较MED值来选择路由时，将只比较path1、path2和path3的MED值。而path4的AS_Path中包含同一联盟外的自治系统，因此不比较path4的MED值。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/40.png"></p>
<blockquote>
<ul>
<li>拓扑与配置采用“基础配置”的内容。仅有基本的BGP邻居配置</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/41.png"></p>
<blockquote>
<ul>
<li><p>命令含义</p>
<ul>
<li><strong>apply as-path</strong> { { as-number-plain | as-number-dot } &amp;&lt;1-10&gt; { additive } | none overwrite }</li>
</ul>
</li>
<li><p>参数含义</p>
<ul>
<li><em>as*</em>-number-plain*<em>：</em>指定要替换或增加的整数形式的AS号。在同一个命令行中最多可以同时指定10个AS号。</li>
<li><em>as*</em>-number-dot* <em>：指</em>定要替换或增加的点分形式的AS号。在同一个命令行中最多可以同时指定10个AS号。</li>
<li><strong>additive</strong> <strong>：</strong>在原有的AS_Path列表中追加指定的AS号。</li>
<li><strong>overwrite</strong> <strong>：</strong>用指定的AS号覆盖原有的AS_Path列表。</li>
<li><strong>None</strong> <strong>：</strong>清空原来的AS_Path列表。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>策略生效后，将会影响BGP路由选路。</li>
<li>配置该命令会直接影响网络流量所经过的途径，另外也可能造成环路和选路错误，<strong>请谨慎使用该命令</strong>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/42.png"></p>
<blockquote>
<ul>
<li>拓扑与配置采用“基础配置”的内容。仅有基本的BGP邻居配置</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/43.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li><strong>if-match as-path-filter</strong> { as-path-filter-number &amp;&lt;1-16&gt; | as-path-filter-name } </li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>as-path-filter-number ：指定AS路径过滤器号。在一个命令行中可以配置多个此参数，但最大不能超过16。 整数形式，取值范围1～256。</li>
<li><em>as-path-filter*</em>-name*指定AS路径过滤器名称。字符串形式，区分大小写，不支持空格，长度范围是1～51，且不能都是数字。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>在一个命令行中可以配置多个AS-Path-filter值，但最多不能超过16个。它们之间是“或”的关系，即通过其中某一个AS路径过滤器的过滤就可以通过该命令的过滤。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/44.png"></p>
<blockquote>
<ul>
<li><p><strong>命令含义：</strong></p>
<ul>
<li><em>ip*</em> <strong>as-path-filter</strong> { <em>as-path-filter-number</em> | <em>as-path-filter-name</em> } { <strong>deny</strong> | <strong>permit</strong> } <em>regular-expression</em>命令用来创建AS路径过滤器。</li>
</ul>
</li>
<li><p>参数含义：</p>
<ul>
<li>as-path-filter-number 指定的AS路径过滤器号。 整数形式，取值范围1～256。</li>
<li>as-path-filter-name 指定的AS路径过滤器名称。 字符串形式，区分大小写，不支持空格，长度范围是1～51，且不能都是数字。当输入的字符串两端使用双引号时，可在字符串中输入空格。</li>
<li>deny 指定AS路径过滤器的匹配模式为拒绝。</li>
<li>permit 指定AS路径过滤器的匹配模式为允许。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/45.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/46.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/47.png"></p>
<blockquote>
<ul>
<li>拓扑与配置采用“基础配置”的内容。仅有基本的BGP邻居配置</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/48.png"></p>
<blockquote>
<ul>
<li><p>命令含义：</p>
<ul>
<li><strong>maximum</strong> <strong>load-balancing</strong>命令用来设置等价路由的最大条数。</li>
</ul>
</li>
<li><p>具体用法</p>
<ul>
<li>命令maximum load-balancing为BGP视图命令。</li>
</ul>
</li>
<li><p>参数意义</p>
<ul>
<li>ebgp：仅EBGP路由参与负载分担。</li>
<li>ibgp：仅IBGP路由参与负载分担。</li>
<li>number：BGP路由表中最大等价路由条数。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>如果配置了maximum load-balancing number命令，那么再配置maximum load-balancing ebgp number或maximum load-balancing ibgpnumber命令都不会生效；如果配置了maximum load-balancing ebgp number或maximum load-balancing ibgp number命令，那么再配置maximum load-balancing number命令也不会生效。</li>
<li>AS_Path不仅需要长度相等，内容也必须一致才能形成负载分担。可在BGP进程视图下使用load-balancing as-path-ignore设置路由在形成负载分担时不比较路由的AS-Path属性。</li>
</ul>
</li>
<li><p>实验结果</p>
<ul>
<li>使用命令display ip routing-table protocol bgp可以查看到通过BGP学到的等价路由。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/49.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/50.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/51.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/52.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/53.png"></p>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/54.png"></p>
<blockquote>
<ul>
<li>参考答案：<ul>
<li>T，正确</li>
<li>F，AS_Path需要完全一样才能形成负载分担。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/09/IE-BGP%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86Basic/55.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mydog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zsy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/" itemprop="url">IE-ISIS双栈原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-06T11:00:29+08:00">
                2021-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/1.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/2.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/3.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/4.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/5.png"></p>
<blockquote>
<ul>
<li><p>IGP的收敛可以总体描述为如下状态D+O+F+SPT+RIB+DD</p>
<ul>
<li>D状态为从链路出现故障以后到路由器发现链路故障所用的时间。</li>
<li>O状态为生成LSP，用来描述新的网络拓扑结构所需要的时间。</li>
<li>F状态为从发现链路故障一直到向邻居发布FIB更新的时间。</li>
<li>SPT状态为运行SPF算法，计算最短路径树的时间。</li>
<li>RIB状态为用主CPU更新RIB表项和FIB表项的时间</li>
<li>DD状态为从主控板向线卡上发布更新路由信息的延迟</li>
</ul>
</li>
<li><p>RIB状态和DD状态一般与路由器的硬件有关，如主CPU、线卡CPU、内存、网络处理器有关，这两个状态人为无法对收敛时间做出很大的改变。所以本文基本上以讨论前四个状态为主。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/6.png"></p>
<blockquote>
<ul>
<li>现有的故障检测方法主要包括：<ul>
<li>硬件检测：例如通过SDH（Synchronous Digital Hierarchy，同步数字体系）告警检测链路故障。硬件检测的优点是可以很快发现故障，但并不是所有介质都能提供硬件检测。</li>
<li>慢Hello机制：通常是指路由协议的Hello机制。这种机制检测到故障所需时间为秒级。对于高速数据传输，例如吉比特速率级，超过1秒的检测时间将导致大量数据丢失；对于时延敏感的业务，例如语音业务，超过1秒的延迟也是不能接受的。并且，这种机制依赖于路由协议。IS-IS协议一般通过IIH报文，用来做邻居发现和失效性检测，这个检测的速度是秒级的。</li>
<li>其他检测机制：不同的协议或设备制造商有时会提供专用的检测机制，但在系统间互联互通时，这样的专用检测机制通常难以部署，如BFD</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/7.png"></p>
<blockquote>
<ul>
<li>在IS-IS协议中，当LSP生成定时器到期时，系统会根据当前拓扑重新生成一个自己的LSP。原有的实现机制是采用间隔时间定长的定时器，不能同时满足快速收敛和低CPU占用率的需要。</li>
<li>为了加快网络的收敛速度，同时又不影响系统性能，因此在产生LSP时使用了智能定时器，它可以根据路由信息的变化频率自动调整延迟时间。使其可以对于突发事件（如接口Up/Down）快速响应，加快网络的收敛速度。同时，当网络变化频繁时，智能定时器的间隔时间会自动延长，避免过度占用CPU资源。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/8.png"></p>
<blockquote>
<ul>
<li><p>用户可以指定每次扩散的LSP数量，这个数量是针对所有接口的。如果需要发送的LSP的数量大于这个数，则就发送<em>lsp*</em>-count*个LSP。如果配置了定时器，在路由计算之前如果这个定时器未超时，则立即扩散；否则在该定时器超时时发送。</p>
</li>
<li><p>如果命令中没有指定级别，则缺省同时在Level-1和Level-2中使能此功能。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/9.png"></p>
<blockquote>
<ul>
<li>通常情况下，一个正常运行的IS-IS网络是稳定的，发生大量的网络变动的几率很小，IS-IS路由器不会频繁的进行路由计算，所以第一次触发的时间可以设置的非常短（毫秒级）。如果拓扑变化比较频繁，智能定时器会随着计算次数的增加，间隔时间也会逐渐延长，避免占用大量的CPU资源。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/10.png"></p>
<blockquote>
<ul>
<li><p>在ISO-10589中定义使用Dijkstra算法进行路由计算。当网络拓扑中有一个节点发生变化时，这种算法需要重新计算网络中的所有节点，计算时间长，占用过多的CPU资源，影响整个网络的收敛速度。</p>
</li>
<li><p>I-SPF改进了这个算法，除了第一次计算时需要计算全部节点外，每次只计算影响的节点，而最后生成的最短路径树SPT与原来的算法所计算的结果相同，大大降低了CPU的占用率，提高了网络收敛速度。</p>
</li>
<li><p>在路由计算中，路由代表叶子，路由器则代表节点。如果I-SPF计算后的SPT改变，PRC会只处理那个变化的节点上的所有叶子；如果经过I-SPF计算后的SPT并没有变化，则PRC只处理变化的叶子信息。</p>
</li>
<li><p>比如一个IS接口，则整个网络拓扑的SPT是不变的，这时PRC只更新这个节点的接口路由，从而节省CPU占用率。</p>
</li>
<li><p>PRC和I-SPF节点使能一个IS-配合使用可以将网络的收敛性能进一步提高，它是原始SPF算法的改进，所以已经代替了原有的算法。</p>
</li>
<li><p>默认情况下华为路由器采用I-SPF和PRC进行计算，不需要命令配置。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/11.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/12.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/13.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/14.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/15.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/16.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/17.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/18.png"></p>
<blockquote>
<ul>
<li><p>当IS-IS要发布的链路状态协议数据报文PDU（Protocol Data Unit）中的信息量太大时，IS-IS路由器将会生成多个LSP分片，用来携带更多的IS-IS信息。</p>
</li>
<li><p>IS-IS LSP分片由LSP ID中的LSP Number字段进行标识，这个字段的长度是1字节。因此，一个IS-IS进程最多可产生256个LSP分片，携带的信息量有限。在RFC3786中规定，IS-IS可以配置虚拟的System ID ，并生成虚拟IS-IS的LSP报文来携带路由等信息。</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/19.png"></p>
<blockquote>
<ul>
<li>Mode-1应用场景：用于网络中的部分路由器不支持LSP分片扩展特性的情况。</li>
<li>Mode-1工作原理：虚拟系统参与路由SPF计算，初始系统发布的LSP中携带了到每个虚拟系统的链路信息。类似地，虚拟系统发布的LSP也包含到初始系统的链路信息。这样，在网络中虚拟系统看起来与初始系统相连的真实路由器是一样的。这种方式是为了兼容不支持分片扩展的老版本所做的一个过渡模式。在老版本中，IS-IS无法识别IS Alias ID TLV，所以虚拟系统的LSP必须表现的像一个普通IS-IS发出的报文。</li>
<li>Mode-2应用场景：用于网络中所有路由器都支持LSP分片扩展特性的情况。</li>
<li>Mode-2工作原理：虚拟系统不参与路由SPF计算，网络中所有路由器都知道虚拟系统生成的LSP实际属于初始系统。在该模式下工作的IS-IS，可以识别IS Alias ID TLV的内容，并作为计算树和路由的依据。</li>
<li>说明：无论在哪种方式下，初始系统和虚拟系统的LSP零分片中，都必须包含IS Alias ID TLV来表示初始系统是谁。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/20.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/21.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/22.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/23.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/24.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/25.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/26.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/27.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/28.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/29.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/30.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/31.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/32.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/33.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/34.png"></p>
<blockquote>
<ul>
<li>引入：<ul>
<li>Level-1 区域内的路由信息通过Level-1-2 路由器通报给Level-2 区域，因此，Level-1-2和Level-2 路由器知道整个IS-IS 路由域的路由信息。但是，在缺省情况下，Level-2 路由器并不将自己知道的其他Level-1 区域以及骨干区域的路由信息通报给Level-1 区域。这样，Level-1 路由器将不了解本区域以外的路由信息，可能导致对本区域之外的目的地址无法选择最佳的路由。</li>
<li>为解决上述问题，IS-IS 提供了路由渗透功能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/35.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/36.png"></p>
<blockquote>
<ul>
<li>注意Level 1路由器在收到两条相同的路由的时候，会优选本区域的路由，不会优选L2区域过来的路由，尽管L2的路由cost较小。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/37.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/38.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/39.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/40.png"></p>
<blockquote>
<ul>
<li><p>IETF的draft-ietf-isis-ipv6-05.txt中规定了IS-IS为支持IPv6所新增的内容。主要是新添加的支持IPv6路由信息的两个TLVs（Type-Length-Values）和一个新的NLPID（Network Layer Protocol Identifier）。</p>
</li>
<li><p>新增的两个TLV分别是：</p>
<ul>
<li>IPv6 Reachability：类型值为236（0xEC），通过前缀、度量、标记等来描述可达的IPv6前缀信息。在IPv4中有IPv4内部可达性TLV和IPv4外部可达性TLV，在IPv6的扩展当中使用一个“X”bit来区分“内部”和“外部”。</li>
<li>IPv6 Interface Address：类型值为232（0xE8），它相当于IPv4中的“IP Interface Address” TLV，只不过把原来的32比特的IPv4地址改为128比特的IPv6地址。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/41.png"></p>
<blockquote>
<ul>
<li>这个数据结构可能会重复多次（当有多个路由前缀的时候）。</li>
<li>Metric字段已经被重新定义了，MAX_PATH_METRIC (1023) 变成了 MAX_V6_PATH_METRIC (0xFE000000). 如果一个前缀的METRIC大于MAX_V6_PATH_METRIC ，那么它不是用来构建路由表的，而是用于一些特殊的目的。</li>
<li>TLV128：IP内部可达性信息；TLV130：IP外部可达性信息；在TLV236中，“外部”和“内部”用“X”比特表示。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/42.png"></p>
<blockquote>
<ul>
<li>注意：在hello PDU中，“接口地址TLV”只包含发送hello包的接口的Link-local地址；对于LSP，“接口地址TLV”只包含IS的non-link-local IPV6地址。</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/43.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/44.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/45.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/46.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/47.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/48.png"></p>
<blockquote>
<ul>
<li><p>新增四个TLV</p>
<ul>
<li>TLV 229 – Multi-Topology Identifier</li>
<li>TLV 222 – Multi-Topologies Intermediate System</li>
<li>TLV 235 – Multi-Topologies Reachable IPv4 Prefixes</li>
<li>TLV 237 – Multi-Topologies Reachable IPv6 Prefixes</li>
</ul>
</li>
<li><p>Reserved MT ID Values</p>
</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/49.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/50.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/51.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/52.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/53.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/54.png"></p>
<blockquote>
<ul>
<li>ISIS快速收敛特性建议全部部署</li>
</ul>
</blockquote>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/55.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/56.png"></p>
<p><img src="/2021/08/06/IE-ISIS%E5%8F%8C%E6%A0%88%E5%8E%9F%E7%90%86/57.png">****</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/mydog.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">81</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zsy9959" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zsy9959@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张思宇</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
